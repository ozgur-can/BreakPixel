var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/phaser/src/renderer/BlendModes.js
var require_BlendModes = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    SKIP_CHECK: -1,
    NORMAL: 0,
    ADD: 1,
    MULTIPLY: 2,
    SCREEN: 3,
    OVERLAY: 4,
    DARKEN: 5,
    LIGHTEN: 6,
    COLOR_DODGE: 7,
    COLOR_BURN: 8,
    HARD_LIGHT: 9,
    SOFT_LIGHT: 10,
    DIFFERENCE: 11,
    EXCLUSION: 12,
    HUE: 13,
    SATURATION: 14,
    COLOR: 15,
    LUMINOSITY: 16,
    ERASE: 17,
    SOURCE_IN: 18,
    SOURCE_OUT: 19,
    SOURCE_ATOP: 20,
    DESTINATION_OVER: 21,
    DESTINATION_IN: 22,
    DESTINATION_OUT: 23,
    DESTINATION_ATOP: 24,
    LIGHTER: 25,
    COPY: 26,
    XOR: 27
  };
});

// node_modules/phaser/src/renderer/ScaleModes.js
var require_ScaleModes = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ScaleModes = {
    DEFAULT: 0,
    LINEAR: 0,
    NEAREST: 1
  };
  module2.exports = ScaleModes;
});

// node_modules/phaser/src/const.js
var require_const = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = {
    VERSION: "3.55.2",
    BlendModes: require_BlendModes(),
    ScaleModes: require_ScaleModes(),
    AUTO: 0,
    CANVAS: 1,
    WEBGL: 2,
    HEADLESS: 3,
    FOREVER: -1,
    NONE: 4,
    UP: 5,
    DOWN: 6,
    LEFT: 7,
    RIGHT: 8
  };
  module2.exports = CONST;
});

// node_modules/phaser/src/utils/object/IsPlainObject.js
var require_IsPlainObject = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var IsPlainObject = function(obj) {
    if (typeof obj !== "object" || obj.nodeType || obj === obj.window) {
      return false;
    }
    try {
      if (obj.constructor && !{}.hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
    } catch (e) {
      return false;
    }
    return true;
  };
  module2.exports = IsPlainObject;
});

// node_modules/phaser/src/utils/object/Extend.js
var require_Extend = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var IsPlainObject = require_IsPlainObject();
  var Extend = function() {
    var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (length === i) {
      target = this;
      --i;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && Array.isArray(src) ? src : [];
            } else {
              clone = src && IsPlainObject(src) ? src : {};
            }
            target[name] = Extend(deep, clone, copy);
          } else if (copy !== void 0) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  module2.exports = Extend;
});

// node_modules/phaser/src/display/align/const.js
var require_const2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ALIGN_CONST = {
    TOP_LEFT: 0,
    TOP_CENTER: 1,
    TOP_RIGHT: 2,
    LEFT_TOP: 3,
    LEFT_CENTER: 4,
    LEFT_BOTTOM: 5,
    CENTER: 6,
    RIGHT_TOP: 7,
    RIGHT_CENTER: 8,
    RIGHT_BOTTOM: 9,
    BOTTOM_LEFT: 10,
    BOTTOM_CENTER: 11,
    BOTTOM_RIGHT: 12
  };
  module2.exports = ALIGN_CONST;
});

// node_modules/phaser/src/display/bounds/GetBottom.js
var require_GetBottom = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetBottom = function(gameObject) {
    return gameObject.y + gameObject.height - gameObject.height * gameObject.originY;
  };
  module2.exports = GetBottom;
});

// node_modules/phaser/src/display/bounds/GetCenterX.js
var require_GetCenterX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCenterX = function(gameObject) {
    return gameObject.x - gameObject.width * gameObject.originX + gameObject.width * 0.5;
  };
  module2.exports = GetCenterX;
});

// node_modules/phaser/src/display/bounds/SetCenterX.js
var require_SetCenterX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetCenterX = function(gameObject, x) {
    var offsetX = gameObject.width * gameObject.originX;
    gameObject.x = x + offsetX - gameObject.width * 0.5;
    return gameObject;
  };
  module2.exports = SetCenterX;
});

// node_modules/phaser/src/display/bounds/SetTop.js
var require_SetTop = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetTop = function(gameObject, value) {
    gameObject.y = value + gameObject.height * gameObject.originY;
    return gameObject;
  };
  module2.exports = SetTop;
});

// node_modules/phaser/src/display/align/to/BottomCenter.js
var require_BottomCenter = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetBottom = require_GetBottom();
  var GetCenterX = require_GetCenterX();
  var SetCenterX = require_SetCenterX();
  var SetTop = require_SetTop();
  var BottomCenter = function(gameObject, alignTo, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
    SetTop(gameObject, GetBottom(alignTo) + offsetY);
    return gameObject;
  };
  module2.exports = BottomCenter;
});

// node_modules/phaser/src/display/bounds/GetLeft.js
var require_GetLeft = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetLeft = function(gameObject) {
    return gameObject.x - gameObject.width * gameObject.originX;
  };
  module2.exports = GetLeft;
});

// node_modules/phaser/src/display/bounds/SetLeft.js
var require_SetLeft = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetLeft = function(gameObject, value) {
    gameObject.x = value + gameObject.width * gameObject.originX;
    return gameObject;
  };
  module2.exports = SetLeft;
});

// node_modules/phaser/src/display/align/to/BottomLeft.js
var require_BottomLeft = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetBottom = require_GetBottom();
  var GetLeft = require_GetLeft();
  var SetLeft = require_SetLeft();
  var SetTop = require_SetTop();
  var BottomLeft = function(gameObject, alignTo, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetLeft(gameObject, GetLeft(alignTo) - offsetX);
    SetTop(gameObject, GetBottom(alignTo) + offsetY);
    return gameObject;
  };
  module2.exports = BottomLeft;
});

// node_modules/phaser/src/display/bounds/GetRight.js
var require_GetRight = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetRight = function(gameObject) {
    return gameObject.x + gameObject.width - gameObject.width * gameObject.originX;
  };
  module2.exports = GetRight;
});

// node_modules/phaser/src/display/bounds/SetRight.js
var require_SetRight = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetRight = function(gameObject, value) {
    gameObject.x = value - gameObject.width + gameObject.width * gameObject.originX;
    return gameObject;
  };
  module2.exports = SetRight;
});

// node_modules/phaser/src/display/align/to/BottomRight.js
var require_BottomRight = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetBottom = require_GetBottom();
  var GetRight = require_GetRight();
  var SetRight = require_SetRight();
  var SetTop = require_SetTop();
  var BottomRight = function(gameObject, alignTo, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetRight(gameObject, GetRight(alignTo) + offsetX);
    SetTop(gameObject, GetBottom(alignTo) + offsetY);
    return gameObject;
  };
  module2.exports = BottomRight;
});

// node_modules/phaser/src/display/bounds/SetBottom.js
var require_SetBottom = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetBottom = function(gameObject, value) {
    gameObject.y = value - gameObject.height + gameObject.height * gameObject.originY;
    return gameObject;
  };
  module2.exports = SetBottom;
});

// node_modules/phaser/src/display/align/to/LeftBottom.js
var require_LeftBottom = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetBottom = require_GetBottom();
  var GetLeft = require_GetLeft();
  var SetBottom = require_SetBottom();
  var SetRight = require_SetRight();
  var LeftBottom = function(gameObject, alignTo, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetRight(gameObject, GetLeft(alignTo) - offsetX);
    SetBottom(gameObject, GetBottom(alignTo) + offsetY);
    return gameObject;
  };
  module2.exports = LeftBottom;
});

// node_modules/phaser/src/display/bounds/GetCenterY.js
var require_GetCenterY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCenterY = function(gameObject) {
    return gameObject.y - gameObject.height * gameObject.originY + gameObject.height * 0.5;
  };
  module2.exports = GetCenterY;
});

// node_modules/phaser/src/display/bounds/SetCenterY.js
var require_SetCenterY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetCenterY = function(gameObject, y) {
    var offsetY = gameObject.height * gameObject.originY;
    gameObject.y = y + offsetY - gameObject.height * 0.5;
    return gameObject;
  };
  module2.exports = SetCenterY;
});

// node_modules/phaser/src/display/align/to/LeftCenter.js
var require_LeftCenter = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCenterY = require_GetCenterY();
  var GetLeft = require_GetLeft();
  var SetCenterY = require_SetCenterY();
  var SetRight = require_SetRight();
  var LeftCenter = function(gameObject, alignTo, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetRight(gameObject, GetLeft(alignTo) - offsetX);
    SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);
    return gameObject;
  };
  module2.exports = LeftCenter;
});

// node_modules/phaser/src/display/bounds/GetTop.js
var require_GetTop = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTop = function(gameObject) {
    return gameObject.y - gameObject.height * gameObject.originY;
  };
  module2.exports = GetTop;
});

// node_modules/phaser/src/display/align/to/LeftTop.js
var require_LeftTop = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetLeft = require_GetLeft();
  var GetTop = require_GetTop();
  var SetRight = require_SetRight();
  var SetTop = require_SetTop();
  var LeftTop = function(gameObject, alignTo, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetRight(gameObject, GetLeft(alignTo) - offsetX);
    SetTop(gameObject, GetTop(alignTo) - offsetY);
    return gameObject;
  };
  module2.exports = LeftTop;
});

// node_modules/phaser/src/display/align/to/RightBottom.js
var require_RightBottom = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetBottom = require_GetBottom();
  var GetRight = require_GetRight();
  var SetBottom = require_SetBottom();
  var SetLeft = require_SetLeft();
  var RightBottom = function(gameObject, alignTo, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetLeft(gameObject, GetRight(alignTo) + offsetX);
    SetBottom(gameObject, GetBottom(alignTo) + offsetY);
    return gameObject;
  };
  module2.exports = RightBottom;
});

// node_modules/phaser/src/display/align/to/RightCenter.js
var require_RightCenter = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCenterY = require_GetCenterY();
  var GetRight = require_GetRight();
  var SetCenterY = require_SetCenterY();
  var SetLeft = require_SetLeft();
  var RightCenter = function(gameObject, alignTo, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetLeft(gameObject, GetRight(alignTo) + offsetX);
    SetCenterY(gameObject, GetCenterY(alignTo) + offsetY);
    return gameObject;
  };
  module2.exports = RightCenter;
});

// node_modules/phaser/src/display/align/to/RightTop.js
var require_RightTop = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetRight = require_GetRight();
  var GetTop = require_GetTop();
  var SetLeft = require_SetLeft();
  var SetTop = require_SetTop();
  var RightTop = function(gameObject, alignTo, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetLeft(gameObject, GetRight(alignTo) + offsetX);
    SetTop(gameObject, GetTop(alignTo) - offsetY);
    return gameObject;
  };
  module2.exports = RightTop;
});

// node_modules/phaser/src/display/align/to/TopCenter.js
var require_TopCenter = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCenterX = require_GetCenterX();
  var GetTop = require_GetTop();
  var SetBottom = require_SetBottom();
  var SetCenterX = require_SetCenterX();
  var TopCenter = function(gameObject, alignTo, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetCenterX(gameObject, GetCenterX(alignTo) + offsetX);
    SetBottom(gameObject, GetTop(alignTo) - offsetY);
    return gameObject;
  };
  module2.exports = TopCenter;
});

// node_modules/phaser/src/display/align/to/TopLeft.js
var require_TopLeft = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetLeft = require_GetLeft();
  var GetTop = require_GetTop();
  var SetBottom = require_SetBottom();
  var SetLeft = require_SetLeft();
  var TopLeft = function(gameObject, alignTo, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetLeft(gameObject, GetLeft(alignTo) - offsetX);
    SetBottom(gameObject, GetTop(alignTo) - offsetY);
    return gameObject;
  };
  module2.exports = TopLeft;
});

// node_modules/phaser/src/display/align/to/TopRight.js
var require_TopRight = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetRight = require_GetRight();
  var GetTop = require_GetTop();
  var SetBottom = require_SetBottom();
  var SetRight = require_SetRight();
  var TopRight = function(gameObject, alignTo, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetRight(gameObject, GetRight(alignTo) + offsetX);
    SetBottom(gameObject, GetTop(alignTo) - offsetY);
    return gameObject;
  };
  module2.exports = TopRight;
});

// node_modules/phaser/src/display/align/to/QuickSet.js
var require_QuickSet = __commonJS((exports2, module2) => {
  /**
   * @author       samme
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ALIGN_CONST = require_const2();
  var AlignToMap = [];
  AlignToMap[ALIGN_CONST.BOTTOM_CENTER] = require_BottomCenter();
  AlignToMap[ALIGN_CONST.BOTTOM_LEFT] = require_BottomLeft();
  AlignToMap[ALIGN_CONST.BOTTOM_RIGHT] = require_BottomRight();
  AlignToMap[ALIGN_CONST.LEFT_BOTTOM] = require_LeftBottom();
  AlignToMap[ALIGN_CONST.LEFT_CENTER] = require_LeftCenter();
  AlignToMap[ALIGN_CONST.LEFT_TOP] = require_LeftTop();
  AlignToMap[ALIGN_CONST.RIGHT_BOTTOM] = require_RightBottom();
  AlignToMap[ALIGN_CONST.RIGHT_CENTER] = require_RightCenter();
  AlignToMap[ALIGN_CONST.RIGHT_TOP] = require_RightTop();
  AlignToMap[ALIGN_CONST.TOP_CENTER] = require_TopCenter();
  AlignToMap[ALIGN_CONST.TOP_LEFT] = require_TopLeft();
  AlignToMap[ALIGN_CONST.TOP_RIGHT] = require_TopRight();
  var QuickSet = function(child, alignTo, position, offsetX, offsetY) {
    return AlignToMap[position](child, alignTo, offsetX, offsetY);
  };
  module2.exports = QuickSet;
});

// node_modules/phaser/src/actions/AlignTo.js
var require_AlignTo = __commonJS((exports2, module2) => {
  /**
   * @author       samme
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var QuickSet = require_QuickSet();
  var AlignTo = function(items, position, offsetX, offsetY) {
    var target = items[0];
    for (var i = 1; i < items.length; i++) {
      var item = items[i];
      QuickSet(item, target, position, offsetX, offsetY);
      target = item;
    }
    return items;
  };
  module2.exports = AlignTo;
});

// node_modules/phaser/src/actions/PropertyValueInc.js
var require_PropertyValueInc = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueInc = function(items, key, value, step, index, direction) {
    if (step === void 0) {
      step = 0;
    }
    if (index === void 0) {
      index = 0;
    }
    if (direction === void 0) {
      direction = 1;
    }
    var i;
    var t = 0;
    var end = items.length;
    if (direction === 1) {
      for (i = index; i < end; i++) {
        items[i][key] += value + t * step;
        t++;
      }
    } else {
      for (i = index; i >= 0; i--) {
        items[i][key] += value + t * step;
        t++;
      }
    }
    return items;
  };
  module2.exports = PropertyValueInc;
});

// node_modules/phaser/src/actions/Angle.js
var require_Angle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueInc = require_PropertyValueInc();
  var Angle = function(items, value, step, index, direction) {
    return PropertyValueInc(items, "angle", value, step, index, direction);
  };
  module2.exports = Angle;
});

// node_modules/phaser/src/actions/Call.js
var require_Call = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Call = function(items, callback, context) {
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      callback.call(context, item);
    }
    return items;
  };
  module2.exports = Call;
});

// node_modules/phaser/src/actions/GetFirst.js
var require_GetFirst = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetFirst = function(items, compare, index) {
    if (index === void 0) {
      index = 0;
    }
    for (var i = index; i < items.length; i++) {
      var item = items[i];
      var match = true;
      for (var property in compare) {
        if (item[property] !== compare[property]) {
          match = false;
        }
      }
      if (match) {
        return item;
      }
    }
    return null;
  };
  module2.exports = GetFirst;
});

// node_modules/phaser/src/actions/GetLast.js
var require_GetLast = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetLast = function(items, compare, index) {
    if (index === void 0) {
      index = 0;
    }
    for (var i = index; i < items.length; i++) {
      var item = items[i];
      var match = true;
      for (var property in compare) {
        if (item[property] !== compare[property]) {
          match = false;
        }
      }
      if (match) {
        return item;
      }
    }
    return null;
  };
  module2.exports = GetLast;
});

// node_modules/phaser/src/display/align/in/BottomCenter.js
var require_BottomCenter2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetBottom = require_GetBottom();
  var GetCenterX = require_GetCenterX();
  var SetBottom = require_SetBottom();
  var SetCenterX = require_SetCenterX();
  var BottomCenter = function(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
    SetBottom(gameObject, GetBottom(alignIn) + offsetY);
    return gameObject;
  };
  module2.exports = BottomCenter;
});

// node_modules/phaser/src/display/align/in/BottomLeft.js
var require_BottomLeft2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetBottom = require_GetBottom();
  var GetLeft = require_GetLeft();
  var SetBottom = require_SetBottom();
  var SetLeft = require_SetLeft();
  var BottomLeft = function(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
    SetBottom(gameObject, GetBottom(alignIn) + offsetY);
    return gameObject;
  };
  module2.exports = BottomLeft;
});

// node_modules/phaser/src/display/align/in/BottomRight.js
var require_BottomRight2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetBottom = require_GetBottom();
  var GetRight = require_GetRight();
  var SetBottom = require_SetBottom();
  var SetRight = require_SetRight();
  var BottomRight = function(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetRight(gameObject, GetRight(alignIn) + offsetX);
    SetBottom(gameObject, GetBottom(alignIn) + offsetY);
    return gameObject;
  };
  module2.exports = BottomRight;
});

// node_modules/phaser/src/display/bounds/CenterOn.js
var require_CenterOn = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetCenterX = require_SetCenterX();
  var SetCenterY = require_SetCenterY();
  var CenterOn = function(gameObject, x, y) {
    SetCenterX(gameObject, x);
    return SetCenterY(gameObject, y);
  };
  module2.exports = CenterOn;
});

// node_modules/phaser/src/display/align/in/Center.js
var require_Center = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CenterOn = require_CenterOn();
  var GetCenterX = require_GetCenterX();
  var GetCenterY = require_GetCenterY();
  var Center = function(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);
    return gameObject;
  };
  module2.exports = Center;
});

// node_modules/phaser/src/display/align/in/LeftCenter.js
var require_LeftCenter2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCenterY = require_GetCenterY();
  var GetLeft = require_GetLeft();
  var SetCenterY = require_SetCenterY();
  var SetLeft = require_SetLeft();
  var LeftCenter = function(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
    SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
    return gameObject;
  };
  module2.exports = LeftCenter;
});

// node_modules/phaser/src/display/align/in/RightCenter.js
var require_RightCenter2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCenterY = require_GetCenterY();
  var GetRight = require_GetRight();
  var SetCenterY = require_SetCenterY();
  var SetRight = require_SetRight();
  var RightCenter = function(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetRight(gameObject, GetRight(alignIn) + offsetX);
    SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
    return gameObject;
  };
  module2.exports = RightCenter;
});

// node_modules/phaser/src/display/align/in/TopCenter.js
var require_TopCenter2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCenterX = require_GetCenterX();
  var GetTop = require_GetTop();
  var SetCenterX = require_SetCenterX();
  var SetTop = require_SetTop();
  var TopCenter = function(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
    SetTop(gameObject, GetTop(alignIn) - offsetY);
    return gameObject;
  };
  module2.exports = TopCenter;
});

// node_modules/phaser/src/display/align/in/TopLeft.js
var require_TopLeft2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetLeft = require_GetLeft();
  var GetTop = require_GetTop();
  var SetLeft = require_SetLeft();
  var SetTop = require_SetTop();
  var TopLeft = function(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
    SetTop(gameObject, GetTop(alignIn) - offsetY);
    return gameObject;
  };
  module2.exports = TopLeft;
});

// node_modules/phaser/src/display/align/in/TopRight.js
var require_TopRight2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetRight = require_GetRight();
  var GetTop = require_GetTop();
  var SetRight = require_SetRight();
  var SetTop = require_SetTop();
  var TopRight = function(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    SetRight(gameObject, GetRight(alignIn) + offsetX);
    SetTop(gameObject, GetTop(alignIn) - offsetY);
    return gameObject;
  };
  module2.exports = TopRight;
});

// node_modules/phaser/src/display/align/in/QuickSet.js
var require_QuickSet2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ALIGN_CONST = require_const2();
  var AlignInMap = [];
  AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = require_BottomCenter2();
  AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = require_BottomLeft2();
  AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = require_BottomRight2();
  AlignInMap[ALIGN_CONST.CENTER] = require_Center();
  AlignInMap[ALIGN_CONST.LEFT_CENTER] = require_LeftCenter2();
  AlignInMap[ALIGN_CONST.RIGHT_CENTER] = require_RightCenter2();
  AlignInMap[ALIGN_CONST.TOP_CENTER] = require_TopCenter2();
  AlignInMap[ALIGN_CONST.TOP_LEFT] = require_TopLeft2();
  AlignInMap[ALIGN_CONST.TOP_RIGHT] = require_TopRight2();
  AlignInMap[ALIGN_CONST.LEFT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_LEFT];
  AlignInMap[ALIGN_CONST.LEFT_TOP] = AlignInMap[ALIGN_CONST.TOP_LEFT];
  AlignInMap[ALIGN_CONST.RIGHT_BOTTOM] = AlignInMap[ALIGN_CONST.BOTTOM_RIGHT];
  AlignInMap[ALIGN_CONST.RIGHT_TOP] = AlignInMap[ALIGN_CONST.TOP_RIGHT];
  var QuickSet = function(child, alignIn, position, offsetX, offsetY) {
    return AlignInMap[position](child, alignIn, offsetX, offsetY);
  };
  module2.exports = QuickSet;
});

// node_modules/phaser/src/utils/object/GetFastValue.js
var require_GetFastValue = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetFastValue = function(source, key, defaultValue) {
    var t = typeof source;
    if (!source || t === "number" || t === "string") {
      return defaultValue;
    } else if (source.hasOwnProperty(key) && source[key] !== void 0) {
      return source[key];
    } else {
      return defaultValue;
    }
  };
  module2.exports = GetFastValue;
});

// node_modules/phaser/src/utils/NOOP.js
var require_NOOP = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var NOOP = function() {
  };
  module2.exports = NOOP;
});

// node_modules/phaser/src/utils/Class.js
var require_Class = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  function hasGetterOrSetter(def) {
    return !!def.get && typeof def.get === "function" || !!def.set && typeof def.set === "function";
  }
  function getProperty(definition, k, isClassDescriptor) {
    var def = isClassDescriptor ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);
    if (!isClassDescriptor && def.value && typeof def.value === "object") {
      def = def.value;
    }
    if (def && hasGetterOrSetter(def)) {
      if (typeof def.enumerable === "undefined") {
        def.enumerable = true;
      }
      if (typeof def.configurable === "undefined") {
        def.configurable = true;
      }
      return def;
    } else {
      return false;
    }
  }
  function hasNonConfigurable(obj, k) {
    var prop = Object.getOwnPropertyDescriptor(obj, k);
    if (!prop) {
      return false;
    }
    if (prop.value && typeof prop.value === "object") {
      prop = prop.value;
    }
    if (prop.configurable === false) {
      return true;
    }
    return false;
  }
  function extend(ctor, definition, isClassDescriptor, extend2) {
    for (var k in definition) {
      if (!definition.hasOwnProperty(k)) {
        continue;
      }
      var def = getProperty(definition, k, isClassDescriptor);
      if (def !== false) {
        var parent = extend2 || ctor;
        if (hasNonConfigurable(parent.prototype, k)) {
          if (Class.ignoreFinals) {
            continue;
          }
          throw new Error("cannot override final property '" + k + "', set Class.ignoreFinals = true to skip");
        }
        Object.defineProperty(ctor.prototype, k, def);
      } else {
        ctor.prototype[k] = definition[k];
      }
    }
  }
  function mixin(myClass, mixins) {
    if (!mixins) {
      return;
    }
    if (!Array.isArray(mixins)) {
      mixins = [mixins];
    }
    for (var i = 0; i < mixins.length; i++) {
      extend(myClass, mixins[i].prototype || mixins[i]);
    }
  }
  function Class(definition) {
    if (!definition) {
      definition = {};
    }
    var initialize;
    var Extends;
    if (definition.initialize) {
      if (typeof definition.initialize !== "function") {
        throw new Error("initialize must be a function");
      }
      initialize = definition.initialize;
      delete definition.initialize;
    } else if (definition.Extends) {
      var base = definition.Extends;
      initialize = function() {
        base.apply(this, arguments);
      };
    } else {
      initialize = function() {
      };
    }
    if (definition.Extends) {
      initialize.prototype = Object.create(definition.Extends.prototype);
      initialize.prototype.constructor = initialize;
      Extends = definition.Extends;
      delete definition.Extends;
    } else {
      initialize.prototype.constructor = initialize;
    }
    var mixins = null;
    if (definition.Mixins) {
      mixins = definition.Mixins;
      delete definition.Mixins;
    }
    mixin(initialize, mixins);
    extend(initialize, definition, true, Extends);
    return initialize;
  }
  Class.extend = extend;
  Class.mixin = mixin;
  Class.ignoreFinals = false;
  module2.exports = Class;
});

// node_modules/phaser/src/geom/circle/Contains.js
var require_Contains = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = function(circle, x, y) {
    if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom) {
      var dx = (circle.x - x) * (circle.x - x);
      var dy = (circle.y - y) * (circle.y - y);
      return dx + dy <= circle.radius * circle.radius;
    } else {
      return false;
    }
  };
  module2.exports = Contains;
});

// node_modules/phaser/src/geom/const.js
var require_const3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GEOM_CONST = {
    CIRCLE: 0,
    ELLIPSE: 1,
    LINE: 2,
    POINT: 3,
    POLYGON: 4,
    RECTANGLE: 5,
    TRIANGLE: 6
  };
  module2.exports = GEOM_CONST;
});

// node_modules/phaser/src/geom/point/Point.js
var require_Point = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GEOM_CONST = require_const3();
  var Point = new Class({
    initialize: function Point2(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = x;
      }
      this.type = GEOM_CONST.POINT;
      this.x = x;
      this.y = y;
    },
    setTo: function(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = x;
      }
      this.x = x;
      this.y = y;
      return this;
    }
  });
  module2.exports = Point;
});

// node_modules/phaser/src/geom/circle/CircumferencePoint.js
var require_CircumferencePoint = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var CircumferencePoint = function(circle, angle, out) {
    if (out === void 0) {
      out = new Point();
    }
    out.x = circle.x + circle.radius * Math.cos(angle);
    out.y = circle.y + circle.radius * Math.sin(angle);
    return out;
  };
  module2.exports = CircumferencePoint;
});

// node_modules/phaser/src/math/Clamp.js
var require_Clamp = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = function(value, min, max) {
    return Math.max(min, Math.min(max, value));
  };
  module2.exports = Clamp;
});

// node_modules/phaser/src/math/FromPercent.js
var require_FromPercent = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = require_Clamp();
  var FromPercent = function(percent, min, max) {
    percent = Clamp(percent, 0, 1);
    return (max - min) * percent + min;
  };
  module2.exports = FromPercent;
});

// node_modules/phaser/src/math/const.js
var require_const4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MATH_CONST = {
    PI2: Math.PI * 2,
    TAU: Math.PI * 0.5,
    EPSILON: 1e-6,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,
    RND: null,
    MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,
    MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991
  };
  module2.exports = MATH_CONST;
});

// node_modules/phaser/src/geom/circle/GetPoint.js
var require_GetPoint = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CircumferencePoint = require_CircumferencePoint();
  var FromPercent = require_FromPercent();
  var MATH_CONST = require_const4();
  var Point = require_Point();
  var GetPoint = function(circle, position, out) {
    if (out === void 0) {
      out = new Point();
    }
    var angle = FromPercent(position, 0, MATH_CONST.PI2);
    return CircumferencePoint(circle, angle, out);
  };
  module2.exports = GetPoint;
});

// node_modules/phaser/src/geom/circle/Circumference.js
var require_Circumference = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Circumference = function(circle) {
    return 2 * (Math.PI * circle.radius);
  };
  module2.exports = Circumference;
});

// node_modules/phaser/src/geom/circle/GetPoints.js
var require_GetPoints = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Circumference = require_Circumference();
  var CircumferencePoint = require_CircumferencePoint();
  var FromPercent = require_FromPercent();
  var MATH_CONST = require_const4();
  var GetPoints = function(circle, quantity, stepRate, out) {
    if (out === void 0) {
      out = [];
    }
    if (!quantity && stepRate > 0) {
      quantity = Circumference(circle) / stepRate;
    }
    for (var i = 0; i < quantity; i++) {
      var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);
      out.push(CircumferencePoint(circle, angle));
    }
    return out;
  };
  module2.exports = GetPoints;
});

// node_modules/phaser/src/geom/circle/Random.js
var require_Random = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var Random = function(circle, out) {
    if (out === void 0) {
      out = new Point();
    }
    var t = 2 * Math.PI * Math.random();
    var u = Math.random() + Math.random();
    var r = u > 1 ? 2 - u : u;
    var x = r * Math.cos(t);
    var y = r * Math.sin(t);
    out.x = circle.x + x * circle.radius;
    out.y = circle.y + y * circle.radius;
    return out;
  };
  module2.exports = Random;
});

// node_modules/phaser/src/geom/circle/Circle.js
var require_Circle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Contains = require_Contains();
  var GetPoint = require_GetPoint();
  var GetPoints = require_GetPoints();
  var GEOM_CONST = require_const3();
  var Random = require_Random();
  var Circle = new Class({
    initialize: function Circle2(x, y, radius) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (radius === void 0) {
        radius = 0;
      }
      this.type = GEOM_CONST.CIRCLE;
      this.x = x;
      this.y = y;
      this._radius = radius;
      this._diameter = radius * 2;
    },
    contains: function(x, y) {
      return Contains(this, x, y);
    },
    getPoint: function(position, point) {
      return GetPoint(this, position, point);
    },
    getPoints: function(quantity, stepRate, output) {
      return GetPoints(this, quantity, stepRate, output);
    },
    getRandomPoint: function(point) {
      return Random(this, point);
    },
    setTo: function(x, y, radius) {
      this.x = x;
      this.y = y;
      this._radius = radius;
      this._diameter = radius * 2;
      return this;
    },
    setEmpty: function() {
      this._radius = 0;
      this._diameter = 0;
      return this;
    },
    setPosition: function(x, y) {
      if (y === void 0) {
        y = x;
      }
      this.x = x;
      this.y = y;
      return this;
    },
    isEmpty: function() {
      return this._radius <= 0;
    },
    radius: {
      get: function() {
        return this._radius;
      },
      set: function(value) {
        this._radius = value;
        this._diameter = value * 2;
      }
    },
    diameter: {
      get: function() {
        return this._diameter;
      },
      set: function(value) {
        this._diameter = value;
        this._radius = value * 0.5;
      }
    },
    left: {
      get: function() {
        return this.x - this._radius;
      },
      set: function(value) {
        this.x = value + this._radius;
      }
    },
    right: {
      get: function() {
        return this.x + this._radius;
      },
      set: function(value) {
        this.x = value - this._radius;
      }
    },
    top: {
      get: function() {
        return this.y - this._radius;
      },
      set: function(value) {
        this.y = value + this._radius;
      }
    },
    bottom: {
      get: function() {
        return this.y + this._radius;
      },
      set: function(value) {
        this.y = value - this._radius;
      }
    }
  });
  module2.exports = Circle;
});

// node_modules/phaser/src/gameobjects/components/Alpha.js
var require_Alpha = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = require_Clamp();
  var _FLAG = 2;
  var Alpha = {
    _alpha: 1,
    _alphaTL: 1,
    _alphaTR: 1,
    _alphaBL: 1,
    _alphaBR: 1,
    clearAlpha: function() {
      return this.setAlpha(1);
    },
    setAlpha: function(topLeft, topRight, bottomLeft, bottomRight) {
      if (topLeft === void 0) {
        topLeft = 1;
      }
      if (topRight === void 0) {
        this.alpha = topLeft;
      } else {
        this._alphaTL = Clamp(topLeft, 0, 1);
        this._alphaTR = Clamp(topRight, 0, 1);
        this._alphaBL = Clamp(bottomLeft, 0, 1);
        this._alphaBR = Clamp(bottomRight, 0, 1);
      }
      return this;
    },
    alpha: {
      get: function() {
        return this._alpha;
      },
      set: function(value) {
        var v = Clamp(value, 0, 1);
        this._alpha = v;
        this._alphaTL = v;
        this._alphaTR = v;
        this._alphaBL = v;
        this._alphaBR = v;
        if (v === 0) {
          this.renderFlags &= ~_FLAG;
        } else {
          this.renderFlags |= _FLAG;
        }
      }
    },
    alphaTopLeft: {
      get: function() {
        return this._alphaTL;
      },
      set: function(value) {
        var v = Clamp(value, 0, 1);
        this._alphaTL = v;
        if (v !== 0) {
          this.renderFlags |= _FLAG;
        }
      }
    },
    alphaTopRight: {
      get: function() {
        return this._alphaTR;
      },
      set: function(value) {
        var v = Clamp(value, 0, 1);
        this._alphaTR = v;
        if (v !== 0) {
          this.renderFlags |= _FLAG;
        }
      }
    },
    alphaBottomLeft: {
      get: function() {
        return this._alphaBL;
      },
      set: function(value) {
        var v = Clamp(value, 0, 1);
        this._alphaBL = v;
        if (v !== 0) {
          this.renderFlags |= _FLAG;
        }
      }
    },
    alphaBottomRight: {
      get: function() {
        return this._alphaBR;
      },
      set: function(value) {
        var v = Clamp(value, 0, 1);
        this._alphaBR = v;
        if (v !== 0) {
          this.renderFlags |= _FLAG;
        }
      }
    }
  };
  module2.exports = Alpha;
});

// node_modules/phaser/src/gameobjects/components/AlphaSingle.js
var require_AlphaSingle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = require_Clamp();
  var _FLAG = 2;
  var AlphaSingle = {
    _alpha: 1,
    clearAlpha: function() {
      return this.setAlpha(1);
    },
    setAlpha: function(value) {
      if (value === void 0) {
        value = 1;
      }
      this.alpha = value;
      return this;
    },
    alpha: {
      get: function() {
        return this._alpha;
      },
      set: function(value) {
        var v = Clamp(value, 0, 1);
        this._alpha = v;
        if (v === 0) {
          this.renderFlags &= ~_FLAG;
        } else {
          this.renderFlags |= _FLAG;
        }
      }
    }
  };
  module2.exports = AlphaSingle;
});

// node_modules/phaser/src/gameobjects/components/BlendMode.js
var require_BlendMode = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BlendModes = require_BlendModes();
  var BlendMode = {
    _blendMode: BlendModes.NORMAL,
    blendMode: {
      get: function() {
        return this._blendMode;
      },
      set: function(value) {
        if (typeof value === "string") {
          value = BlendModes[value];
        }
        value |= 0;
        if (value >= -1) {
          this._blendMode = value;
        }
      }
    },
    setBlendMode: function(value) {
      this.blendMode = value;
      return this;
    }
  };
  module2.exports = BlendMode;
});

// node_modules/phaser/src/gameobjects/components/ComputedSize.js
var require_ComputedSize = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ComputedSize = {
    width: 0,
    height: 0,
    displayWidth: {
      get: function() {
        return this.scaleX * this.width;
      },
      set: function(value) {
        this.scaleX = value / this.width;
      }
    },
    displayHeight: {
      get: function() {
        return this.scaleY * this.height;
      },
      set: function(value) {
        this.scaleY = value / this.height;
      }
    },
    setSize: function(width, height) {
      this.width = width;
      this.height = height;
      return this;
    },
    setDisplaySize: function(width, height) {
      this.displayWidth = width;
      this.displayHeight = height;
      return this;
    }
  };
  module2.exports = ComputedSize;
});

// node_modules/phaser/src/gameobjects/components/Crop.js
var require_Crop = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Crop = {
    texture: null,
    frame: null,
    isCropped: false,
    setCrop: function(x, y, width, height) {
      if (x === void 0) {
        this.isCropped = false;
      } else if (this.frame) {
        if (typeof x === "number") {
          this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
        } else {
          var rect = x;
          this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
        }
        this.isCropped = true;
      }
      return this;
    },
    resetCropObject: function() {
      return {u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0};
    }
  };
  module2.exports = Crop;
});

// node_modules/phaser/src/gameobjects/components/Depth.js
var require_Depth = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Depth = {
    _depth: 0,
    depth: {
      get: function() {
        return this._depth;
      },
      set: function(value) {
        if (this.displayList) {
          this.displayList.queueDepthSort();
        }
        this._depth = value;
      }
    },
    setDepth: function(value) {
      if (value === void 0) {
        value = 0;
      }
      this.depth = value;
      return this;
    }
  };
  module2.exports = Depth;
});

// node_modules/phaser/src/gameobjects/components/Flip.js
var require_Flip = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Flip = {
    flipX: false,
    flipY: false,
    toggleFlipX: function() {
      this.flipX = !this.flipX;
      return this;
    },
    toggleFlipY: function() {
      this.flipY = !this.flipY;
      return this;
    },
    setFlipX: function(value) {
      this.flipX = value;
      return this;
    },
    setFlipY: function(value) {
      this.flipY = value;
      return this;
    },
    setFlip: function(x, y) {
      this.flipX = x;
      this.flipY = y;
      return this;
    },
    resetFlip: function() {
      this.flipX = false;
      this.flipY = false;
      return this;
    }
  };
  module2.exports = Flip;
});

// node_modules/phaser/src/geom/rectangle/Contains.js
var require_Contains2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = function(rect, x, y) {
    if (rect.width <= 0 || rect.height <= 0) {
      return false;
    }
    return rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y;
  };
  module2.exports = Contains;
});

// node_modules/phaser/src/geom/rectangle/Perimeter.js
var require_Perimeter = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Perimeter = function(rect) {
    return 2 * (rect.width + rect.height);
  };
  module2.exports = Perimeter;
});

// node_modules/phaser/src/geom/rectangle/GetPoint.js
var require_GetPoint2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Perimeter = require_Perimeter();
  var Point = require_Point();
  var GetPoint = function(rectangle, position, out) {
    if (out === void 0) {
      out = new Point();
    }
    if (position <= 0 || position >= 1) {
      out.x = rectangle.x;
      out.y = rectangle.y;
      return out;
    }
    var p = Perimeter(rectangle) * position;
    if (position > 0.5) {
      p -= rectangle.width + rectangle.height;
      if (p <= rectangle.width) {
        out.x = rectangle.right - p;
        out.y = rectangle.bottom;
      } else {
        out.x = rectangle.x;
        out.y = rectangle.bottom - (p - rectangle.width);
      }
    } else if (p <= rectangle.width) {
      out.x = rectangle.x + p;
      out.y = rectangle.y;
    } else {
      out.x = rectangle.right;
      out.y = rectangle.y + (p - rectangle.width);
    }
    return out;
  };
  module2.exports = GetPoint;
});

// node_modules/phaser/src/geom/rectangle/GetPoints.js
var require_GetPoints2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetPoint = require_GetPoint2();
  var Perimeter = require_Perimeter();
  var GetPoints = function(rectangle, quantity, stepRate, out) {
    if (out === void 0) {
      out = [];
    }
    if (!quantity && stepRate > 0) {
      quantity = Perimeter(rectangle) / stepRate;
    }
    for (var i = 0; i < quantity; i++) {
      var position = i / quantity;
      out.push(GetPoint(rectangle, position));
    }
    return out;
  };
  module2.exports = GetPoints;
});

// node_modules/phaser/src/geom/line/GetPoint.js
var require_GetPoint3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var GetPoint = function(line, position, out) {
    if (out === void 0) {
      out = new Point();
    }
    out.x = line.x1 + (line.x2 - line.x1) * position;
    out.y = line.y1 + (line.y2 - line.y1) * position;
    return out;
  };
  module2.exports = GetPoint;
});

// node_modules/phaser/src/geom/line/Length.js
var require_Length = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Length = function(line) {
    return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));
  };
  module2.exports = Length;
});

// node_modules/phaser/src/geom/line/GetPoints.js
var require_GetPoints3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Length = require_Length();
  var Point = require_Point();
  var GetPoints = function(line, quantity, stepRate, out) {
    if (out === void 0) {
      out = [];
    }
    if (!quantity && stepRate > 0) {
      quantity = Length(line) / stepRate;
    }
    var x1 = line.x1;
    var y1 = line.y1;
    var x2 = line.x2;
    var y2 = line.y2;
    for (var i = 0; i < quantity; i++) {
      var position = i / quantity;
      var x = x1 + (x2 - x1) * position;
      var y = y1 + (y2 - y1) * position;
      out.push(new Point(x, y));
    }
    return out;
  };
  module2.exports = GetPoints;
});

// node_modules/phaser/src/geom/line/Random.js
var require_Random2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var Random = function(line, out) {
    if (out === void 0) {
      out = new Point();
    }
    var t = Math.random();
    out.x = line.x1 + t * (line.x2 - line.x1);
    out.y = line.y1 + t * (line.y2 - line.y1);
    return out;
  };
  module2.exports = Random;
});

// node_modules/phaser/src/math/fuzzy/Equal.js
var require_Equal = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Equal = function(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = 1e-4;
    }
    return Math.abs(a - b) < epsilon;
  };
  module2.exports = Equal;
});

// node_modules/phaser/src/math/Vector2.js
var require_Vector2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FuzzyEqual = require_Equal();
  var Vector2 = new Class({
    initialize: function Vector22(x, y) {
      this.x = 0;
      this.y = 0;
      if (typeof x === "object") {
        this.x = x.x || 0;
        this.y = x.y || 0;
      } else {
        if (y === void 0) {
          y = x;
        }
        this.x = x || 0;
        this.y = y || 0;
      }
    },
    clone: function() {
      return new Vector2(this.x, this.y);
    },
    copy: function(src) {
      this.x = src.x || 0;
      this.y = src.y || 0;
      return this;
    },
    setFromObject: function(obj) {
      this.x = obj.x || 0;
      this.y = obj.y || 0;
      return this;
    },
    set: function(x, y) {
      if (y === void 0) {
        y = x;
      }
      this.x = x;
      this.y = y;
      return this;
    },
    setTo: function(x, y) {
      return this.set(x, y);
    },
    setToPolar: function(azimuth, radius) {
      if (radius == null) {
        radius = 1;
      }
      this.x = Math.cos(azimuth) * radius;
      this.y = Math.sin(azimuth) * radius;
      return this;
    },
    equals: function(v) {
      return this.x === v.x && this.y === v.y;
    },
    fuzzyEquals: function(v, epsilon) {
      return FuzzyEqual(this.x, v.x, epsilon) && FuzzyEqual(this.y, v.y, epsilon);
    },
    angle: function() {
      var angle = Math.atan2(this.y, this.x);
      if (angle < 0) {
        angle += 2 * Math.PI;
      }
      return angle;
    },
    setAngle: function(angle) {
      return this.setToPolar(angle, this.length());
    },
    add: function(src) {
      this.x += src.x;
      this.y += src.y;
      return this;
    },
    subtract: function(src) {
      this.x -= src.x;
      this.y -= src.y;
      return this;
    },
    multiply: function(src) {
      this.x *= src.x;
      this.y *= src.y;
      return this;
    },
    scale: function(value) {
      if (isFinite(value)) {
        this.x *= value;
        this.y *= value;
      } else {
        this.x = 0;
        this.y = 0;
      }
      return this;
    },
    divide: function(src) {
      this.x /= src.x;
      this.y /= src.y;
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    },
    distance: function(src) {
      var dx = src.x - this.x;
      var dy = src.y - this.y;
      return Math.sqrt(dx * dx + dy * dy);
    },
    distanceSq: function(src) {
      var dx = src.x - this.x;
      var dy = src.y - this.y;
      return dx * dx + dy * dy;
    },
    length: function() {
      var x = this.x;
      var y = this.y;
      return Math.sqrt(x * x + y * y);
    },
    setLength: function(length) {
      return this.normalize().scale(length);
    },
    lengthSq: function() {
      var x = this.x;
      var y = this.y;
      return x * x + y * y;
    },
    normalize: function() {
      var x = this.x;
      var y = this.y;
      var len = x * x + y * y;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
        this.x = x * len;
        this.y = y * len;
      }
      return this;
    },
    normalizeRightHand: function() {
      var x = this.x;
      this.x = this.y * -1;
      this.y = x;
      return this;
    },
    normalizeLeftHand: function() {
      var x = this.x;
      this.x = this.y;
      this.y = x * -1;
      return this;
    },
    dot: function(src) {
      return this.x * src.x + this.y * src.y;
    },
    cross: function(src) {
      return this.x * src.y - this.y * src.x;
    },
    lerp: function(src, t) {
      if (t === void 0) {
        t = 0;
      }
      var ax = this.x;
      var ay = this.y;
      this.x = ax + t * (src.x - ax);
      this.y = ay + t * (src.y - ay);
      return this;
    },
    transformMat3: function(mat) {
      var x = this.x;
      var y = this.y;
      var m = mat.val;
      this.x = m[0] * x + m[3] * y + m[6];
      this.y = m[1] * x + m[4] * y + m[7];
      return this;
    },
    transformMat4: function(mat) {
      var x = this.x;
      var y = this.y;
      var m = mat.val;
      this.x = m[0] * x + m[4] * y + m[12];
      this.y = m[1] * x + m[5] * y + m[13];
      return this;
    },
    reset: function() {
      this.x = 0;
      this.y = 0;
      return this;
    },
    limit: function(max) {
      var len = this.length();
      if (len && len > max) {
        this.scale(max / len);
      }
      return this;
    },
    reflect: function(normal) {
      normal = normal.clone().normalize();
      return this.subtract(normal.scale(2 * this.dot(normal)));
    },
    mirror: function(axis) {
      return this.reflect(axis).negate();
    },
    rotate: function(delta) {
      var cos = Math.cos(delta);
      var sin = Math.sin(delta);
      return this.set(cos * this.x - sin * this.y, sin * this.x + cos * this.y);
    }
  });
  Vector2.ZERO = new Vector2();
  Vector2.RIGHT = new Vector2(1, 0);
  Vector2.LEFT = new Vector2(-1, 0);
  Vector2.UP = new Vector2(0, -1);
  Vector2.DOWN = new Vector2(0, 1);
  Vector2.ONE = new Vector2(1, 1);
  module2.exports = Vector2;
});

// node_modules/phaser/src/geom/line/Line.js
var require_Line = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetPoint = require_GetPoint3();
  var GetPoints = require_GetPoints3();
  var GEOM_CONST = require_const3();
  var Random = require_Random2();
  var Vector2 = require_Vector2();
  var Line = new Class({
    initialize: function Line2(x1, y1, x2, y2) {
      if (x1 === void 0) {
        x1 = 0;
      }
      if (y1 === void 0) {
        y1 = 0;
      }
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      this.type = GEOM_CONST.LINE;
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
    },
    getPoint: function(position, output) {
      return GetPoint(this, position, output);
    },
    getPoints: function(quantity, stepRate, output) {
      return GetPoints(this, quantity, stepRate, output);
    },
    getRandomPoint: function(point) {
      return Random(this, point);
    },
    setTo: function(x1, y1, x2, y2) {
      if (x1 === void 0) {
        x1 = 0;
      }
      if (y1 === void 0) {
        y1 = 0;
      }
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      return this;
    },
    getPointA: function(vec2) {
      if (vec2 === void 0) {
        vec2 = new Vector2();
      }
      vec2.set(this.x1, this.y1);
      return vec2;
    },
    getPointB: function(vec2) {
      if (vec2 === void 0) {
        vec2 = new Vector2();
      }
      vec2.set(this.x2, this.y2);
      return vec2;
    },
    left: {
      get: function() {
        return Math.min(this.x1, this.x2);
      },
      set: function(value) {
        if (this.x1 <= this.x2) {
          this.x1 = value;
        } else {
          this.x2 = value;
        }
      }
    },
    right: {
      get: function() {
        return Math.max(this.x1, this.x2);
      },
      set: function(value) {
        if (this.x1 > this.x2) {
          this.x1 = value;
        } else {
          this.x2 = value;
        }
      }
    },
    top: {
      get: function() {
        return Math.min(this.y1, this.y2);
      },
      set: function(value) {
        if (this.y1 <= this.y2) {
          this.y1 = value;
        } else {
          this.y2 = value;
        }
      }
    },
    bottom: {
      get: function() {
        return Math.max(this.y1, this.y2);
      },
      set: function(value) {
        if (this.y1 > this.y2) {
          this.y1 = value;
        } else {
          this.y2 = value;
        }
      }
    }
  });
  module2.exports = Line;
});

// node_modules/phaser/src/geom/rectangle/Random.js
var require_Random3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var Random = function(rect, out) {
    if (out === void 0) {
      out = new Point();
    }
    out.x = rect.x + Math.random() * rect.width;
    out.y = rect.y + Math.random() * rect.height;
    return out;
  };
  module2.exports = Random;
});

// node_modules/phaser/src/geom/rectangle/Rectangle.js
var require_Rectangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Contains = require_Contains2();
  var GetPoint = require_GetPoint2();
  var GetPoints = require_GetPoints2();
  var GEOM_CONST = require_const3();
  var Line = require_Line();
  var Random = require_Random3();
  var Rectangle = new Class({
    initialize: function Rectangle2(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.type = GEOM_CONST.RECTANGLE;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    },
    contains: function(x, y) {
      return Contains(this, x, y);
    },
    getPoint: function(position, output) {
      return GetPoint(this, position, output);
    },
    getPoints: function(quantity, stepRate, output) {
      return GetPoints(this, quantity, stepRate, output);
    },
    getRandomPoint: function(point) {
      return Random(this, point);
    },
    setTo: function(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      return this;
    },
    setEmpty: function() {
      return this.setTo(0, 0, 0, 0);
    },
    setPosition: function(x, y) {
      if (y === void 0) {
        y = x;
      }
      this.x = x;
      this.y = y;
      return this;
    },
    setSize: function(width, height) {
      if (height === void 0) {
        height = width;
      }
      this.width = width;
      this.height = height;
      return this;
    },
    isEmpty: function() {
      return this.width <= 0 || this.height <= 0;
    },
    getLineA: function(line) {
      if (line === void 0) {
        line = new Line();
      }
      line.setTo(this.x, this.y, this.right, this.y);
      return line;
    },
    getLineB: function(line) {
      if (line === void 0) {
        line = new Line();
      }
      line.setTo(this.right, this.y, this.right, this.bottom);
      return line;
    },
    getLineC: function(line) {
      if (line === void 0) {
        line = new Line();
      }
      line.setTo(this.right, this.bottom, this.x, this.bottom);
      return line;
    },
    getLineD: function(line) {
      if (line === void 0) {
        line = new Line();
      }
      line.setTo(this.x, this.bottom, this.x, this.y);
      return line;
    },
    left: {
      get: function() {
        return this.x;
      },
      set: function(value) {
        if (value >= this.right) {
          this.width = 0;
        } else {
          this.width = this.right - value;
        }
        this.x = value;
      }
    },
    right: {
      get: function() {
        return this.x + this.width;
      },
      set: function(value) {
        if (value <= this.x) {
          this.width = 0;
        } else {
          this.width = value - this.x;
        }
      }
    },
    top: {
      get: function() {
        return this.y;
      },
      set: function(value) {
        if (value >= this.bottom) {
          this.height = 0;
        } else {
          this.height = this.bottom - value;
        }
        this.y = value;
      }
    },
    bottom: {
      get: function() {
        return this.y + this.height;
      },
      set: function(value) {
        if (value <= this.y) {
          this.height = 0;
        } else {
          this.height = value - this.y;
        }
      }
    },
    centerX: {
      get: function() {
        return this.x + this.width / 2;
      },
      set: function(value) {
        this.x = value - this.width / 2;
      }
    },
    centerY: {
      get: function() {
        return this.y + this.height / 2;
      },
      set: function(value) {
        this.y = value - this.height / 2;
      }
    }
  });
  module2.exports = Rectangle;
});

// node_modules/phaser/src/math/RotateAround.js
var require_RotateAround = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateAround = function(point, x, y, angle) {
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var tx = point.x - x;
    var ty = point.y - y;
    point.x = tx * c - ty * s + x;
    point.y = tx * s + ty * c + y;
    return point;
  };
  module2.exports = RotateAround;
});

// node_modules/phaser/src/gameobjects/components/GetBounds.js
var require_GetBounds = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  var RotateAround = require_RotateAround();
  var Vector2 = require_Vector2();
  var GetBounds = {
    prepareBoundsOutput: function(output, includeParent) {
      if (includeParent === void 0) {
        includeParent = false;
      }
      if (this.rotation !== 0) {
        RotateAround(output, this.x, this.y, this.rotation);
      }
      if (includeParent && this.parentContainer) {
        var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
        parentMatrix.transformPoint(output.x, output.y, output);
      }
      return output;
    },
    getCenter: function(output) {
      if (output === void 0) {
        output = new Vector2();
      }
      output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
      output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
      return output;
    },
    getTopLeft: function(output, includeParent) {
      if (!output) {
        output = new Vector2();
      }
      output.x = this.x - this.displayWidth * this.originX;
      output.y = this.y - this.displayHeight * this.originY;
      return this.prepareBoundsOutput(output, includeParent);
    },
    getTopCenter: function(output, includeParent) {
      if (!output) {
        output = new Vector2();
      }
      output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
      output.y = this.y - this.displayHeight * this.originY;
      return this.prepareBoundsOutput(output, includeParent);
    },
    getTopRight: function(output, includeParent) {
      if (!output) {
        output = new Vector2();
      }
      output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
      output.y = this.y - this.displayHeight * this.originY;
      return this.prepareBoundsOutput(output, includeParent);
    },
    getLeftCenter: function(output, includeParent) {
      if (!output) {
        output = new Vector2();
      }
      output.x = this.x - this.displayWidth * this.originX;
      output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
      return this.prepareBoundsOutput(output, includeParent);
    },
    getRightCenter: function(output, includeParent) {
      if (!output) {
        output = new Vector2();
      }
      output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
      output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;
      return this.prepareBoundsOutput(output, includeParent);
    },
    getBottomLeft: function(output, includeParent) {
      if (!output) {
        output = new Vector2();
      }
      output.x = this.x - this.displayWidth * this.originX;
      output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
      return this.prepareBoundsOutput(output, includeParent);
    },
    getBottomCenter: function(output, includeParent) {
      if (!output) {
        output = new Vector2();
      }
      output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;
      output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
      return this.prepareBoundsOutput(output, includeParent);
    },
    getBottomRight: function(output, includeParent) {
      if (!output) {
        output = new Vector2();
      }
      output.x = this.x - this.displayWidth * this.originX + this.displayWidth;
      output.y = this.y - this.displayHeight * this.originY + this.displayHeight;
      return this.prepareBoundsOutput(output, includeParent);
    },
    getBounds: function(output) {
      if (output === void 0) {
        output = new Rectangle();
      }
      var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;
      if (this.parentContainer) {
        var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
        this.getTopLeft(output);
        parentMatrix.transformPoint(output.x, output.y, output);
        TLx = output.x;
        TLy = output.y;
        this.getTopRight(output);
        parentMatrix.transformPoint(output.x, output.y, output);
        TRx = output.x;
        TRy = output.y;
        this.getBottomLeft(output);
        parentMatrix.transformPoint(output.x, output.y, output);
        BLx = output.x;
        BLy = output.y;
        this.getBottomRight(output);
        parentMatrix.transformPoint(output.x, output.y, output);
        BRx = output.x;
        BRy = output.y;
      } else {
        this.getTopLeft(output);
        TLx = output.x;
        TLy = output.y;
        this.getTopRight(output);
        TRx = output.x;
        TRy = output.y;
        this.getBottomLeft(output);
        BLx = output.x;
        BLy = output.y;
        this.getBottomRight(output);
        BRx = output.x;
        BRy = output.y;
      }
      output.x = Math.min(TLx, TRx, BLx, BRx);
      output.y = Math.min(TLy, TRy, BLy, BRy);
      output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
      output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;
      return output;
    }
  };
  module2.exports = GetBounds;
});

// node_modules/phaser/src/core/events/BLUR_EVENT.js
var require_BLUR_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "blur";
});

// node_modules/phaser/src/core/events/BOOT_EVENT.js
var require_BOOT_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "boot";
});

// node_modules/phaser/src/core/events/CONTEXT_LOST_EVENT.js
var require_CONTEXT_LOST_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "contextlost";
});

// node_modules/phaser/src/core/events/CONTEXT_RESTORED_EVENT.js
var require_CONTEXT_RESTORED_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "contextrestored";
});

// node_modules/phaser/src/core/events/DESTROY_EVENT.js
var require_DESTROY_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "destroy";
});

// node_modules/phaser/src/core/events/FOCUS_EVENT.js
var require_FOCUS_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "focus";
});

// node_modules/phaser/src/core/events/HIDDEN_EVENT.js
var require_HIDDEN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "hidden";
});

// node_modules/phaser/src/core/events/PAUSE_EVENT.js
var require_PAUSE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pause";
});

// node_modules/phaser/src/core/events/POST_RENDER_EVENT.js
var require_POST_RENDER_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "postrender";
});

// node_modules/phaser/src/core/events/POST_STEP_EVENT.js
var require_POST_STEP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "poststep";
});

// node_modules/phaser/src/core/events/PRE_RENDER_EVENT.js
var require_PRE_RENDER_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "prerender";
});

// node_modules/phaser/src/core/events/PRE_STEP_EVENT.js
var require_PRE_STEP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "prestep";
});

// node_modules/phaser/src/core/events/READY_EVENT.js
var require_READY_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "ready";
});

// node_modules/phaser/src/core/events/RESUME_EVENT.js
var require_RESUME_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "resume";
});

// node_modules/phaser/src/core/events/STEP_EVENT.js
var require_STEP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "step";
});

// node_modules/phaser/src/core/events/VISIBLE_EVENT.js
var require_VISIBLE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "visible";
});

// node_modules/phaser/src/core/events/index.js
var require_events = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    BLUR: require_BLUR_EVENT(),
    BOOT: require_BOOT_EVENT(),
    CONTEXT_LOST: require_CONTEXT_LOST_EVENT(),
    CONTEXT_RESTORED: require_CONTEXT_RESTORED_EVENT(),
    DESTROY: require_DESTROY_EVENT(),
    FOCUS: require_FOCUS_EVENT(),
    HIDDEN: require_HIDDEN_EVENT(),
    PAUSE: require_PAUSE_EVENT(),
    POST_RENDER: require_POST_RENDER_EVENT(),
    POST_STEP: require_POST_STEP_EVENT(),
    PRE_RENDER: require_PRE_RENDER_EVENT(),
    PRE_STEP: require_PRE_STEP_EVENT(),
    READY: require_READY_EVENT(),
    RESUME: require_RESUME_EVENT(),
    STEP: require_STEP_EVENT(),
    VISIBLE: require_VISIBLE_EVENT()
  };
});

// node_modules/phaser/src/renderer/events/POST_RENDER_EVENT.js
var require_POST_RENDER_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "postrender";
});

// node_modules/phaser/src/renderer/events/PRE_RENDER_EVENT.js
var require_PRE_RENDER_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "prerender";
});

// node_modules/phaser/src/renderer/events/RENDER_EVENT.js
var require_RENDER_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "render";
});

// node_modules/phaser/src/renderer/events/RESIZE_EVENT.js
var require_RESIZE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "resize";
});

// node_modules/phaser/src/renderer/events/index.js
var require_events2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    POST_RENDER: require_POST_RENDER_EVENT2(),
    PRE_RENDER: require_PRE_RENDER_EVENT2(),
    RENDER: require_RENDER_EVENT(),
    RESIZE: require_RESIZE_EVENT()
  };
});

// node_modules/phaser/src/display/mask/BitmapMask.js
var require_BitmapMask = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GameEvents = require_events();
  var RenderEvents = require_events2();
  var BitmapMask = new Class({
    initialize: function BitmapMask2(scene, renderable) {
      var renderer = scene.sys.renderer;
      this.renderer = renderer;
      this.bitmapMask = renderable;
      this.maskTexture = null;
      this.mainTexture = null;
      this.dirty = true;
      this.mainFramebuffer = null;
      this.maskFramebuffer = null;
      this.invertAlpha = false;
      this.isStencil = false;
      this.createMask();
      scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, this.createMask, this);
      if (renderer) {
        renderer.on(RenderEvents.RESIZE, this.createMask, this);
      }
    },
    createMask: function() {
      var renderer = this.renderer;
      if (!renderer || !renderer.gl) {
        return;
      }
      if (this.mainTexture) {
        this.clearMask();
      }
      var width = renderer.width;
      var height = renderer.height;
      var pot = (width & width - 1) === 0 && (height & height - 1) === 0;
      var gl = renderer.gl;
      var wrap = pot ? gl.REPEAT : gl.CLAMP_TO_EDGE;
      var filter = gl.LINEAR;
      this.mainTexture = renderer.createTexture2D(0, filter, filter, wrap, wrap, gl.RGBA, null, width, height);
      this.maskTexture = renderer.createTexture2D(0, filter, filter, wrap, wrap, gl.RGBA, null, width, height);
      this.mainFramebuffer = renderer.createFramebuffer(width, height, this.mainTexture, true);
      this.maskFramebuffer = renderer.createFramebuffer(width, height, this.maskTexture, true);
    },
    clearMask: function() {
      var renderer = this.renderer;
      if (!renderer || !renderer.gl || !this.mainTexture) {
        return;
      }
      renderer.deleteTexture(this.mainTexture);
      renderer.deleteTexture(this.maskTexture);
      renderer.deleteFramebuffer(this.mainFramebuffer);
      renderer.deleteFramebuffer(this.maskFramebuffer);
      this.mainTexture = null;
      this.maskTexture = null;
      this.mainFramebuffer = null;
      this.maskFramebuffer = null;
    },
    setBitmap: function(renderable) {
      this.bitmapMask = renderable;
    },
    preRenderWebGL: function(renderer, maskedObject, camera) {
      renderer.pipelines.BITMAPMASK_PIPELINE.beginMask(this, maskedObject, camera);
    },
    postRenderWebGL: function(renderer, camera) {
      renderer.pipelines.BITMAPMASK_PIPELINE.endMask(this, camera);
    },
    preRenderCanvas: function() {
    },
    postRenderCanvas: function() {
    },
    destroy: function() {
      this.clearMask();
      if (this.renderer) {
        this.renderer.off(RenderEvents.RESIZE, this.createMask, this);
      }
      this.bitmapMask = null;
      this.prevFramebuffer = null;
      this.renderer = null;
    }
  });
  module2.exports = BitmapMask;
});

// node_modules/phaser/src/display/mask/GeometryMask.js
var require_GeometryMask = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GeometryMask = new Class({
    initialize: function GeometryMask2(scene, graphicsGeometry) {
      this.geometryMask = graphicsGeometry;
      this.invertAlpha = false;
      this.isStencil = true;
      this.level = 0;
    },
    setShape: function(graphicsGeometry) {
      this.geometryMask = graphicsGeometry;
      return this;
    },
    setInvertAlpha: function(value) {
      if (value === void 0) {
        value = true;
      }
      this.invertAlpha = value;
      return this;
    },
    preRenderWebGL: function(renderer, child, camera) {
      var gl = renderer.gl;
      renderer.flush();
      if (renderer.maskStack.length === 0) {
        gl.enable(gl.STENCIL_TEST);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        renderer.maskCount = 0;
      }
      if (renderer.currentCameraMask.mask !== this) {
        renderer.currentMask.mask = this;
      }
      renderer.maskStack.push({mask: this, camera});
      this.applyStencil(renderer, camera, true);
      renderer.maskCount++;
    },
    applyStencil: function(renderer, camera, inc) {
      var gl = renderer.gl;
      var geometryMask = this.geometryMask;
      var level = renderer.maskCount;
      gl.colorMask(false, false, false, false);
      if (inc) {
        gl.stencilFunc(gl.EQUAL, level, 255);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
      } else {
        gl.stencilFunc(gl.EQUAL, level + 1, 255);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
      }
      geometryMask.renderWebGL(renderer, geometryMask, camera);
      renderer.flush();
      gl.colorMask(true, true, true, true);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      if (inc) {
        if (this.invertAlpha) {
          gl.stencilFunc(gl.NOTEQUAL, level + 1, 255);
        } else {
          gl.stencilFunc(gl.EQUAL, level + 1, 255);
        }
      } else if (this.invertAlpha) {
        gl.stencilFunc(gl.NOTEQUAL, level, 255);
      } else {
        gl.stencilFunc(gl.EQUAL, level, 255);
      }
    },
    postRenderWebGL: function(renderer) {
      var gl = renderer.gl;
      renderer.maskStack.pop();
      renderer.maskCount--;
      renderer.flush();
      var current = renderer.currentMask;
      if (renderer.maskStack.length === 0) {
        current.mask = null;
        gl.disable(gl.STENCIL_TEST);
      } else {
        var prev = renderer.maskStack[renderer.maskStack.length - 1];
        prev.mask.applyStencil(renderer, prev.camera, false);
        if (renderer.currentCameraMask.mask !== prev.mask) {
          current.mask = prev.mask;
          current.camera = prev.camera;
        } else {
          current.mask = null;
        }
      }
    },
    preRenderCanvas: function(renderer, mask, camera) {
      var geometryMask = this.geometryMask;
      renderer.currentContext.save();
      geometryMask.renderCanvas(renderer, geometryMask, camera, null, null, true);
      renderer.currentContext.clip();
    },
    postRenderCanvas: function(renderer) {
      renderer.currentContext.restore();
    },
    destroy: function() {
      this.geometryMask = null;
    }
  });
  module2.exports = GeometryMask;
});

// node_modules/phaser/src/gameobjects/components/Mask.js
var require_Mask = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BitmapMask = require_BitmapMask();
  var GeometryMask = require_GeometryMask();
  var Mask = {
    mask: null,
    setMask: function(mask) {
      this.mask = mask;
      return this;
    },
    clearMask: function(destroyMask) {
      if (destroyMask === void 0) {
        destroyMask = false;
      }
      if (destroyMask && this.mask) {
        this.mask.destroy();
      }
      this.mask = null;
      return this;
    },
    createBitmapMask: function(renderable) {
      if (renderable === void 0 && (this.texture || this.shader)) {
        renderable = this;
      }
      return new BitmapMask(this.scene, renderable);
    },
    createGeometryMask: function(graphics) {
      if (graphics === void 0 && this.type === "Graphics") {
        graphics = this;
      }
      return new GeometryMask(this.scene, graphics);
    }
  };
  module2.exports = Mask;
});

// node_modules/phaser/src/gameobjects/components/Origin.js
var require_Origin = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Origin = {
    _originComponent: true,
    originX: 0.5,
    originY: 0.5,
    _displayOriginX: 0,
    _displayOriginY: 0,
    displayOriginX: {
      get: function() {
        return this._displayOriginX;
      },
      set: function(value) {
        this._displayOriginX = value;
        this.originX = value / this.width;
      }
    },
    displayOriginY: {
      get: function() {
        return this._displayOriginY;
      },
      set: function(value) {
        this._displayOriginY = value;
        this.originY = value / this.height;
      }
    },
    setOrigin: function(x, y) {
      if (x === void 0) {
        x = 0.5;
      }
      if (y === void 0) {
        y = x;
      }
      this.originX = x;
      this.originY = y;
      return this.updateDisplayOrigin();
    },
    setOriginFromFrame: function() {
      if (!this.frame || !this.frame.customPivot) {
        return this.setOrigin();
      } else {
        this.originX = this.frame.pivotX;
        this.originY = this.frame.pivotY;
      }
      return this.updateDisplayOrigin();
    },
    setDisplayOrigin: function(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = x;
      }
      this.displayOriginX = x;
      this.displayOriginY = y;
      return this;
    },
    updateDisplayOrigin: function() {
      this._displayOriginX = this.originX * this.width;
      this._displayOriginY = this.originY * this.height;
      return this;
    }
  };
  module2.exports = Origin;
});

// node_modules/phaser/src/math/DegToRad.js
var require_DegToRad = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const4();
  var DegToRad = function(degrees) {
    return degrees * CONST.DEG_TO_RAD;
  };
  module2.exports = DegToRad;
});

// node_modules/phaser/src/tweens/builders/GetBoolean.js
var require_GetBoolean = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetBoolean = function(source, key, defaultValue) {
    if (!source) {
      return defaultValue;
    } else if (source.hasOwnProperty(key)) {
      return source[key];
    } else {
      return defaultValue;
    }
  };
  module2.exports = GetBoolean;
});

// node_modules/phaser/src/utils/object/GetValue.js
var require_GetValue = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetValue = function(source, key, defaultValue) {
    if (!source || typeof source === "number") {
      return defaultValue;
    } else if (source.hasOwnProperty(key)) {
      return source[key];
    } else if (key.indexOf(".") !== -1) {
      var keys = key.split(".");
      var parent = source;
      var value = defaultValue;
      for (var i = 0; i < keys.length; i++) {
        if (parent.hasOwnProperty(keys[i])) {
          value = parent[keys[i]];
          parent = parent[keys[i]];
        } else {
          value = defaultValue;
          break;
        }
      }
      return value;
    } else {
      return defaultValue;
    }
  };
  module2.exports = GetValue;
});

// node_modules/phaser/src/tweens/tween/const.js
var require_const5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TWEEN_CONST = {
    CREATED: 0,
    INIT: 1,
    DELAY: 2,
    OFFSET_DELAY: 3,
    PENDING_RENDER: 4,
    PLAYING_FORWARD: 5,
    PLAYING_BACKWARD: 6,
    HOLD_DELAY: 7,
    REPEAT_DELAY: 8,
    COMPLETE: 9,
    PENDING_ADD: 20,
    PAUSED: 21,
    LOOP_DELAY: 22,
    ACTIVE: 23,
    COMPLETE_DELAY: 24,
    PENDING_REMOVE: 25,
    REMOVED: 26
  };
  module2.exports = TWEEN_CONST;
});

// node_modules/phaser/src/gameobjects/components/PathFollower.js
var require_PathFollower = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DegToRad = require_DegToRad();
  var GetBoolean = require_GetBoolean();
  var GetValue = require_GetValue();
  var TWEEN_CONST = require_const5();
  var Vector2 = require_Vector2();
  var PathFollower = {
    path: null,
    rotateToPath: false,
    pathRotationOffset: 0,
    pathOffset: null,
    pathVector: null,
    pathDelta: null,
    pathTween: null,
    pathConfig: null,
    _prevDirection: TWEEN_CONST.PLAYING_FORWARD,
    setPath: function(path, config2) {
      if (config2 === void 0) {
        config2 = this.pathConfig;
      }
      var tween = this.pathTween;
      if (tween && tween.isPlaying()) {
        tween.stop();
      }
      this.path = path;
      if (config2) {
        this.startFollow(config2);
      }
      return this;
    },
    setRotateToPath: function(value, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      this.rotateToPath = value;
      this.pathRotationOffset = offset;
      return this;
    },
    isFollowing: function() {
      var tween = this.pathTween;
      return tween && tween.isPlaying();
    },
    startFollow: function(config2, startAt) {
      if (config2 === void 0) {
        config2 = {};
      }
      if (startAt === void 0) {
        startAt = 0;
      }
      var tween = this.pathTween;
      if (tween && tween.isPlaying()) {
        tween.stop();
      }
      if (typeof config2 === "number") {
        config2 = {duration: config2};
      }
      config2.from = GetValue(config2, "from", 0);
      config2.to = GetValue(config2, "to", 1);
      var positionOnPath = GetBoolean(config2, "positionOnPath", false);
      this.rotateToPath = GetBoolean(config2, "rotateToPath", false);
      this.pathRotationOffset = GetValue(config2, "rotationOffset", 0);
      var seek = GetValue(config2, "startAt", startAt);
      if (seek) {
        config2.onStart = function(tween2) {
          var tweenData = tween2.data[0];
          tweenData.progress = seek;
          tweenData.elapsed = tweenData.duration * seek;
          var v = tweenData.ease(tweenData.progress);
          tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v;
          tweenData.target[tweenData.key] = tweenData.current;
        };
      }
      if (!this.pathOffset) {
        this.pathOffset = new Vector2(this.x, this.y);
      }
      if (!this.pathVector) {
        this.pathVector = new Vector2();
      }
      if (!this.pathDelta) {
        this.pathDelta = new Vector2();
      }
      this.pathDelta.reset();
      this.pathTween = this.scene.sys.tweens.addCounter(config2);
      this.path.getStartPoint(this.pathOffset);
      if (positionOnPath) {
        this.x = this.pathOffset.x;
        this.y = this.pathOffset.y;
      }
      this.pathOffset.x = this.x - this.pathOffset.x;
      this.pathOffset.y = this.y - this.pathOffset.y;
      this._prevDirection = TWEEN_CONST.PLAYING_FORWARD;
      if (this.rotateToPath) {
        var nextPoint = this.path.getPoint(0.1);
        this.rotation = Math.atan2(nextPoint.y - this.y, nextPoint.x - this.x) + DegToRad(this.pathRotationOffset);
      }
      this.pathConfig = config2;
      return this;
    },
    pauseFollow: function() {
      var tween = this.pathTween;
      if (tween && tween.isPlaying()) {
        tween.pause();
      }
      return this;
    },
    resumeFollow: function() {
      var tween = this.pathTween;
      if (tween && tween.isPaused()) {
        tween.resume();
      }
      return this;
    },
    stopFollow: function() {
      var tween = this.pathTween;
      if (tween && tween.isPlaying()) {
        tween.stop();
      }
      return this;
    },
    pathUpdate: function() {
      var tween = this.pathTween;
      if (tween) {
        var tweenData = tween.data[0];
        var pathDelta = this.pathDelta;
        var pathVector = this.pathVector;
        pathDelta.copy(pathVector).negate();
        if (tweenData.state === TWEEN_CONST.COMPLETE) {
          this.path.getPoint(1, pathVector);
          pathDelta.add(pathVector);
          pathVector.add(this.pathOffset);
          this.setPosition(pathVector.x, pathVector.y);
          return;
        } else if (tweenData.state !== TWEEN_CONST.PLAYING_FORWARD && tweenData.state !== TWEEN_CONST.PLAYING_BACKWARD) {
          return;
        }
        this.path.getPoint(tween.getValue(), pathVector);
        pathDelta.add(pathVector);
        pathVector.add(this.pathOffset);
        var oldX = this.x;
        var oldY = this.y;
        this.setPosition(pathVector.x, pathVector.y);
        var speedX = this.x - oldX;
        var speedY = this.y - oldY;
        if (speedX === 0 && speedY === 0) {
          return;
        }
        if (tweenData.state !== this._prevDirection) {
          this._prevDirection = tweenData.state;
          return;
        }
        if (this.rotateToPath) {
          this.rotation = Math.atan2(speedY, speedX) + DegToRad(this.pathRotationOffset);
        }
      }
    }
  };
  module2.exports = PathFollower;
});

// node_modules/phaser/src/utils/object/DeepCopy.js
var require_DeepCopy = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DeepCopy = function(inObject) {
    var outObject;
    var value;
    var key;
    if (typeof inObject !== "object" || inObject === null) {
      return inObject;
    }
    outObject = Array.isArray(inObject) ? [] : {};
    for (key in inObject) {
      value = inObject[key];
      outObject[key] = DeepCopy(value);
    }
    return outObject;
  };
  module2.exports = DeepCopy;
});

// node_modules/phaser/src/renderer/webgl/pipelines/const.js
var require_const6 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PIPELINE_CONST = {
    BITMAPMASK_PIPELINE: "BitmapMaskPipeline",
    LIGHT_PIPELINE: "Light2D",
    POINTLIGHT_PIPELINE: "PointLightPipeline",
    SINGLE_PIPELINE: "SinglePipeline",
    MULTI_PIPELINE: "MultiPipeline",
    ROPE_PIPELINE: "RopePipeline",
    GRAPHICS_PIPELINE: "GraphicsPipeline",
    POSTFX_PIPELINE: "PostFXPipeline",
    UTILITY_PIPELINE: "UtilityPipeline"
  };
  module2.exports = PIPELINE_CONST;
});

// node_modules/phaser/src/utils/array/SpliceOne.js
var require_SpliceOne = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SpliceOne = function(array, index) {
    if (index >= array.length) {
      return;
    }
    var len = array.length - 1;
    var item = array[index];
    for (var i = index; i < len; i++) {
      array[i] = array[i + 1];
    }
    array.length = len;
    return item;
  };
  module2.exports = SpliceOne;
});

// node_modules/phaser/src/gameobjects/components/Pipeline.js
var require_Pipeline = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DeepCopy = require_DeepCopy();
  var PIPELINE_CONST = require_const6();
  var SpliceOne = require_SpliceOne();
  var Pipeline = {
    defaultPipeline: null,
    pipeline: null,
    hasPostPipeline: false,
    postPipelines: null,
    pipelineData: null,
    initPipeline: function(pipeline) {
      if (pipeline === void 0) {
        pipeline = PIPELINE_CONST.MULTI_PIPELINE;
      }
      var renderer = this.scene.sys.renderer;
      if (!renderer) {
        return false;
      }
      var pipelines = renderer.pipelines;
      this.postPipelines = [];
      this.pipelineData = {};
      if (pipelines) {
        var instance = pipelines.get(pipeline);
        if (instance) {
          this.defaultPipeline = instance;
          this.pipeline = instance;
          return true;
        }
      }
      return false;
    },
    setPipeline: function(pipeline, pipelineData, copyData) {
      var renderer = this.scene.sys.renderer;
      if (!renderer) {
        return this;
      }
      var pipelines = renderer.pipelines;
      if (pipelines) {
        var instance = pipelines.get(pipeline);
        if (instance) {
          this.pipeline = instance;
        }
        if (pipelineData) {
          this.pipelineData = copyData ? DeepCopy(pipelineData) : pipelineData;
        }
      }
      return this;
    },
    setPostPipeline: function(pipelines, pipelineData, copyData) {
      var renderer = this.scene.sys.renderer;
      if (!renderer) {
        return this;
      }
      var pipelineManager = renderer.pipelines;
      if (pipelineManager) {
        if (!Array.isArray(pipelines)) {
          pipelines = [pipelines];
        }
        for (var i = 0; i < pipelines.length; i++) {
          var instance = pipelineManager.getPostPipeline(pipelines[i], this);
          if (instance) {
            this.postPipelines.push(instance);
          }
        }
        if (pipelineData) {
          this.pipelineData = copyData ? DeepCopy(pipelineData) : pipelineData;
        }
      }
      this.hasPostPipeline = this.postPipelines.length > 0;
      return this;
    },
    setPipelineData: function(key, value) {
      var data = this.pipelineData;
      if (value === void 0) {
        delete data[key];
      } else {
        data[key] = value;
      }
      return this;
    },
    getPostPipeline: function(pipeline) {
      var pipelines = this.postPipelines;
      var results = [];
      for (var i = 0; i < pipelines.length; i++) {
        var instance = pipelines[i];
        if (typeof pipeline === "string" && instance.name === pipeline || instance instanceof pipeline) {
          results.push(instance);
        }
      }
      return results.length === 1 ? results[0] : results;
    },
    resetPipeline: function(resetPostPipelines, resetData) {
      if (resetPostPipelines === void 0) {
        resetPostPipelines = false;
      }
      if (resetData === void 0) {
        resetData = false;
      }
      this.pipeline = this.defaultPipeline;
      if (resetPostPipelines) {
        this.postPipelines = [];
        this.hasPostPipeline = false;
      }
      if (resetData) {
        this.pipelineData = {};
      }
      return this.pipeline !== null;
    },
    resetPostPipeline: function(resetData) {
      if (resetData === void 0) {
        resetData = false;
      }
      var pipelines = this.postPipelines;
      for (var i = 0; i < pipelines.length; i++) {
        pipelines[i].destroy();
      }
      this.postPipelines = [];
      this.hasPostPipeline = false;
      if (resetData) {
        this.pipelineData = {};
      }
    },
    removePostPipeline: function(pipeline) {
      var pipelines = this.postPipelines;
      for (var i = pipelines.length - 1; i >= 0; i--) {
        var instance = pipelines[i];
        if (typeof pipeline === "string" && instance.name === pipeline || typeof pipeline !== "string" && instance instanceof pipeline) {
          instance.destroy();
          SpliceOne(pipelines, i);
        }
      }
      this.hasPostPipeline = this.postPipelines.length > 0;
      return this;
    },
    getPipelineName: function() {
      return this.pipeline.name;
    }
  };
  module2.exports = Pipeline;
});

// node_modules/phaser/src/gameobjects/components/ScrollFactor.js
var require_ScrollFactor = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ScrollFactor = {
    scrollFactorX: 1,
    scrollFactorY: 1,
    setScrollFactor: function(x, y) {
      if (y === void 0) {
        y = x;
      }
      this.scrollFactorX = x;
      this.scrollFactorY = y;
      return this;
    }
  };
  module2.exports = ScrollFactor;
});

// node_modules/phaser/src/gameobjects/components/Size.js
var require_Size = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Size = {
    _sizeComponent: true,
    width: 0,
    height: 0,
    displayWidth: {
      get: function() {
        return Math.abs(this.scaleX * this.frame.realWidth);
      },
      set: function(value) {
        this.scaleX = value / this.frame.realWidth;
      }
    },
    displayHeight: {
      get: function() {
        return Math.abs(this.scaleY * this.frame.realHeight);
      },
      set: function(value) {
        this.scaleY = value / this.frame.realHeight;
      }
    },
    setSizeToFrame: function(frame) {
      if (frame === void 0) {
        frame = this.frame;
      }
      this.width = frame.realWidth;
      this.height = frame.realHeight;
      return this;
    },
    setSize: function(width, height) {
      this.width = width;
      this.height = height;
      return this;
    },
    setDisplaySize: function(width, height) {
      this.displayWidth = width;
      this.displayHeight = height;
      return this;
    }
  };
  module2.exports = Size;
});

// node_modules/phaser/src/gameobjects/components/Texture.js
var require_Texture = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var _FLAG = 8;
  var Texture = {
    texture: null,
    frame: null,
    isCropped: false,
    setTexture: function(key, frame) {
      this.texture = this.scene.sys.textures.get(key);
      return this.setFrame(frame);
    },
    setFrame: function(frame, updateSize, updateOrigin) {
      if (updateSize === void 0) {
        updateSize = true;
      }
      if (updateOrigin === void 0) {
        updateOrigin = true;
      }
      this.frame = this.texture.get(frame);
      if (!this.frame.cutWidth || !this.frame.cutHeight) {
        this.renderFlags &= ~_FLAG;
      } else {
        this.renderFlags |= _FLAG;
      }
      if (this._sizeComponent && updateSize) {
        this.setSizeToFrame();
      }
      if (this._originComponent && updateOrigin) {
        if (this.frame.customPivot) {
          this.setOrigin(this.frame.pivotX, this.frame.pivotY);
        } else {
          this.updateDisplayOrigin();
        }
      }
      return this;
    }
  };
  module2.exports = Texture;
});

// node_modules/phaser/src/gameobjects/components/TextureCrop.js
var require_TextureCrop = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var _FLAG = 8;
  var TextureCrop = {
    texture: null,
    frame: null,
    isCropped: false,
    setCrop: function(x, y, width, height) {
      if (x === void 0) {
        this.isCropped = false;
      } else if (this.frame) {
        if (typeof x === "number") {
          this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
        } else {
          var rect = x;
          this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);
        }
        this.isCropped = true;
      }
      return this;
    },
    setTexture: function(key, frame) {
      this.texture = this.scene.sys.textures.get(key);
      return this.setFrame(frame);
    },
    setFrame: function(frame, updateSize, updateOrigin) {
      if (updateSize === void 0) {
        updateSize = true;
      }
      if (updateOrigin === void 0) {
        updateOrigin = true;
      }
      this.frame = this.texture.get(frame);
      if (!this.frame.cutWidth || !this.frame.cutHeight) {
        this.renderFlags &= ~_FLAG;
      } else {
        this.renderFlags |= _FLAG;
      }
      if (this._sizeComponent && updateSize) {
        this.setSizeToFrame();
      }
      if (this._originComponent && updateOrigin) {
        if (this.frame.customPivot) {
          this.setOrigin(this.frame.pivotX, this.frame.pivotY);
        } else {
          this.updateDisplayOrigin();
        }
      }
      if (this.isCropped) {
        this.frame.updateCropUVs(this._crop, this.flipX, this.flipY);
      }
      return this;
    },
    resetCropObject: function() {
      return {u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0};
    }
  };
  module2.exports = TextureCrop;
});

// node_modules/phaser/src/gameobjects/components/Tint.js
var require_Tint = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Tint = {
    tintTopLeft: 16777215,
    tintTopRight: 16777215,
    tintBottomLeft: 16777215,
    tintBottomRight: 16777215,
    tintFill: false,
    clearTint: function() {
      this.setTint(16777215);
      return this;
    },
    setTint: function(topLeft, topRight, bottomLeft, bottomRight) {
      if (topLeft === void 0) {
        topLeft = 16777215;
      }
      if (topRight === void 0) {
        topRight = topLeft;
        bottomLeft = topLeft;
        bottomRight = topLeft;
      }
      this.tintTopLeft = topLeft;
      this.tintTopRight = topRight;
      this.tintBottomLeft = bottomLeft;
      this.tintBottomRight = bottomRight;
      this.tintFill = false;
      return this;
    },
    setTintFill: function(topLeft, topRight, bottomLeft, bottomRight) {
      this.setTint(topLeft, topRight, bottomLeft, bottomRight);
      this.tintFill = true;
      return this;
    },
    tint: {
      set: function(value) {
        this.setTint(value, value, value, value);
      }
    },
    isTinted: {
      get: function() {
        var white = 16777215;
        return this.tintFill || this.tintTopLeft !== white || this.tintTopRight !== white || this.tintBottomLeft !== white || this.tintBottomRight !== white;
      }
    }
  };
  module2.exports = Tint;
});

// node_modules/phaser/src/gameobjects/components/ToJSON.js
var require_ToJSON = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ToJSON = function(gameObject) {
    var out = {
      name: gameObject.name,
      type: gameObject.type,
      x: gameObject.x,
      y: gameObject.y,
      depth: gameObject.depth,
      scale: {
        x: gameObject.scaleX,
        y: gameObject.scaleY
      },
      origin: {
        x: gameObject.originX,
        y: gameObject.originY
      },
      flipX: gameObject.flipX,
      flipY: gameObject.flipY,
      rotation: gameObject.rotation,
      alpha: gameObject.alpha,
      visible: gameObject.visible,
      blendMode: gameObject.blendMode,
      textureKey: "",
      frameKey: "",
      data: {}
    };
    if (gameObject.texture) {
      out.textureKey = gameObject.texture.key;
      out.frameKey = gameObject.frame.name;
    }
    return out;
  };
  module2.exports = ToJSON;
});

// node_modules/phaser/src/gameobjects/components/TransformMatrix.js
var require_TransformMatrix = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var MATH_CONST = require_const4();
  var Vector2 = require_Vector2();
  var TransformMatrix = new Class({
    initialize: function TransformMatrix2(a, b, c, d, tx, ty) {
      if (a === void 0) {
        a = 1;
      }
      if (b === void 0) {
        b = 0;
      }
      if (c === void 0) {
        c = 0;
      }
      if (d === void 0) {
        d = 1;
      }
      if (tx === void 0) {
        tx = 0;
      }
      if (ty === void 0) {
        ty = 0;
      }
      this.matrix = new Float32Array([a, b, c, d, tx, ty, 0, 0, 1]);
      this.decomposedMatrix = {
        translateX: 0,
        translateY: 0,
        scaleX: 1,
        scaleY: 1,
        rotation: 0
      };
    },
    a: {
      get: function() {
        return this.matrix[0];
      },
      set: function(value) {
        this.matrix[0] = value;
      }
    },
    b: {
      get: function() {
        return this.matrix[1];
      },
      set: function(value) {
        this.matrix[1] = value;
      }
    },
    c: {
      get: function() {
        return this.matrix[2];
      },
      set: function(value) {
        this.matrix[2] = value;
      }
    },
    d: {
      get: function() {
        return this.matrix[3];
      },
      set: function(value) {
        this.matrix[3] = value;
      }
    },
    e: {
      get: function() {
        return this.matrix[4];
      },
      set: function(value) {
        this.matrix[4] = value;
      }
    },
    f: {
      get: function() {
        return this.matrix[5];
      },
      set: function(value) {
        this.matrix[5] = value;
      }
    },
    tx: {
      get: function() {
        return this.matrix[4];
      },
      set: function(value) {
        this.matrix[4] = value;
      }
    },
    ty: {
      get: function() {
        return this.matrix[5];
      },
      set: function(value) {
        this.matrix[5] = value;
      }
    },
    rotation: {
      get: function() {
        return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1);
      }
    },
    rotationNormalized: {
      get: function() {
        var matrix = this.matrix;
        var a = matrix[0];
        var b = matrix[1];
        var c = matrix[2];
        var d = matrix[3];
        if (a || b) {
          return b > 0 ? Math.acos(a / this.scaleX) : -Math.acos(a / this.scaleX);
        } else if (c || d) {
          return MATH_CONST.TAU - (d > 0 ? Math.acos(-c / this.scaleY) : -Math.acos(c / this.scaleY));
        } else {
          return 0;
        }
      }
    },
    scaleX: {
      get: function() {
        return Math.sqrt(this.a * this.a + this.b * this.b);
      }
    },
    scaleY: {
      get: function() {
        return Math.sqrt(this.c * this.c + this.d * this.d);
      }
    },
    loadIdentity: function() {
      var matrix = this.matrix;
      matrix[0] = 1;
      matrix[1] = 0;
      matrix[2] = 0;
      matrix[3] = 1;
      matrix[4] = 0;
      matrix[5] = 0;
      return this;
    },
    translate: function(x, y) {
      var matrix = this.matrix;
      matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];
      matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];
      return this;
    },
    scale: function(x, y) {
      var matrix = this.matrix;
      matrix[0] *= x;
      matrix[1] *= x;
      matrix[2] *= y;
      matrix[3] *= y;
      return this;
    },
    rotate: function(angle) {
      var sin = Math.sin(angle);
      var cos = Math.cos(angle);
      var matrix = this.matrix;
      var a = matrix[0];
      var b = matrix[1];
      var c = matrix[2];
      var d = matrix[3];
      matrix[0] = a * cos + c * sin;
      matrix[1] = b * cos + d * sin;
      matrix[2] = a * -sin + c * cos;
      matrix[3] = b * -sin + d * cos;
      return this;
    },
    multiply: function(rhs, out) {
      var matrix = this.matrix;
      var source = rhs.matrix;
      var localA = matrix[0];
      var localB = matrix[1];
      var localC = matrix[2];
      var localD = matrix[3];
      var localE = matrix[4];
      var localF = matrix[5];
      var sourceA = source[0];
      var sourceB = source[1];
      var sourceC = source[2];
      var sourceD = source[3];
      var sourceE = source[4];
      var sourceF = source[5];
      var destinationMatrix = out === void 0 ? this : out;
      destinationMatrix.a = sourceA * localA + sourceB * localC;
      destinationMatrix.b = sourceA * localB + sourceB * localD;
      destinationMatrix.c = sourceC * localA + sourceD * localC;
      destinationMatrix.d = sourceC * localB + sourceD * localD;
      destinationMatrix.e = sourceE * localA + sourceF * localC + localE;
      destinationMatrix.f = sourceE * localB + sourceF * localD + localF;
      return destinationMatrix;
    },
    multiplyWithOffset: function(src, offsetX, offsetY) {
      var matrix = this.matrix;
      var otherMatrix = src.matrix;
      var a0 = matrix[0];
      var b0 = matrix[1];
      var c0 = matrix[2];
      var d0 = matrix[3];
      var tx0 = matrix[4];
      var ty0 = matrix[5];
      var pse = offsetX * a0 + offsetY * c0 + tx0;
      var psf = offsetX * b0 + offsetY * d0 + ty0;
      var a1 = otherMatrix[0];
      var b1 = otherMatrix[1];
      var c1 = otherMatrix[2];
      var d1 = otherMatrix[3];
      var tx1 = otherMatrix[4];
      var ty1 = otherMatrix[5];
      matrix[0] = a1 * a0 + b1 * c0;
      matrix[1] = a1 * b0 + b1 * d0;
      matrix[2] = c1 * a0 + d1 * c0;
      matrix[3] = c1 * b0 + d1 * d0;
      matrix[4] = tx1 * a0 + ty1 * c0 + pse;
      matrix[5] = tx1 * b0 + ty1 * d0 + psf;
      return this;
    },
    transform: function(a, b, c, d, tx, ty) {
      var matrix = this.matrix;
      var a0 = matrix[0];
      var b0 = matrix[1];
      var c0 = matrix[2];
      var d0 = matrix[3];
      var tx0 = matrix[4];
      var ty0 = matrix[5];
      matrix[0] = a * a0 + b * c0;
      matrix[1] = a * b0 + b * d0;
      matrix[2] = c * a0 + d * c0;
      matrix[3] = c * b0 + d * d0;
      matrix[4] = tx * a0 + ty * c0 + tx0;
      matrix[5] = tx * b0 + ty * d0 + ty0;
      return this;
    },
    transformPoint: function(x, y, point) {
      if (point === void 0) {
        point = {x: 0, y: 0};
      }
      var matrix = this.matrix;
      var a = matrix[0];
      var b = matrix[1];
      var c = matrix[2];
      var d = matrix[3];
      var tx = matrix[4];
      var ty = matrix[5];
      point.x = x * a + y * c + tx;
      point.y = x * b + y * d + ty;
      return point;
    },
    invert: function() {
      var matrix = this.matrix;
      var a = matrix[0];
      var b = matrix[1];
      var c = matrix[2];
      var d = matrix[3];
      var tx = matrix[4];
      var ty = matrix[5];
      var n = a * d - b * c;
      matrix[0] = d / n;
      matrix[1] = -b / n;
      matrix[2] = -c / n;
      matrix[3] = a / n;
      matrix[4] = (c * ty - d * tx) / n;
      matrix[5] = -(a * ty - b * tx) / n;
      return this;
    },
    copyFrom: function(src) {
      var matrix = this.matrix;
      matrix[0] = src.a;
      matrix[1] = src.b;
      matrix[2] = src.c;
      matrix[3] = src.d;
      matrix[4] = src.e;
      matrix[5] = src.f;
      return this;
    },
    copyFromArray: function(src) {
      var matrix = this.matrix;
      matrix[0] = src[0];
      matrix[1] = src[1];
      matrix[2] = src[2];
      matrix[3] = src[3];
      matrix[4] = src[4];
      matrix[5] = src[5];
      return this;
    },
    copyToContext: function(ctx) {
      var matrix = this.matrix;
      ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
      return ctx;
    },
    setToContext: function(ctx) {
      var matrix = this.matrix;
      ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
      return ctx;
    },
    copyToArray: function(out) {
      var matrix = this.matrix;
      if (out === void 0) {
        out = [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]];
      } else {
        out[0] = matrix[0];
        out[1] = matrix[1];
        out[2] = matrix[2];
        out[3] = matrix[3];
        out[4] = matrix[4];
        out[5] = matrix[5];
      }
      return out;
    },
    setTransform: function(a, b, c, d, tx, ty) {
      var matrix = this.matrix;
      matrix[0] = a;
      matrix[1] = b;
      matrix[2] = c;
      matrix[3] = d;
      matrix[4] = tx;
      matrix[5] = ty;
      return this;
    },
    decomposeMatrix: function() {
      var decomposedMatrix = this.decomposedMatrix;
      var matrix = this.matrix;
      var a = matrix[0];
      var b = matrix[1];
      var c = matrix[2];
      var d = matrix[3];
      var determ = a * d - b * c;
      decomposedMatrix.translateX = matrix[4];
      decomposedMatrix.translateY = matrix[5];
      if (a || b) {
        var r = Math.sqrt(a * a + b * b);
        decomposedMatrix.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
        decomposedMatrix.scaleX = r;
        decomposedMatrix.scaleY = determ / r;
      } else if (c || d) {
        var s = Math.sqrt(c * c + d * d);
        decomposedMatrix.rotation = Math.PI * 0.5 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
        decomposedMatrix.scaleX = determ / s;
        decomposedMatrix.scaleY = s;
      } else {
        decomposedMatrix.rotation = 0;
        decomposedMatrix.scaleX = 0;
        decomposedMatrix.scaleY = 0;
      }
      return decomposedMatrix;
    },
    applyITRS: function(x, y, rotation, scaleX, scaleY) {
      var matrix = this.matrix;
      var radianSin = Math.sin(rotation);
      var radianCos = Math.cos(rotation);
      matrix[4] = x;
      matrix[5] = y;
      matrix[0] = radianCos * scaleX;
      matrix[1] = radianSin * scaleX;
      matrix[2] = -radianSin * scaleY;
      matrix[3] = radianCos * scaleY;
      return this;
    },
    applyInverse: function(x, y, output) {
      if (output === void 0) {
        output = new Vector2();
      }
      var matrix = this.matrix;
      var a = matrix[0];
      var b = matrix[1];
      var c = matrix[2];
      var d = matrix[3];
      var tx = matrix[4];
      var ty = matrix[5];
      var id = 1 / (a * d + c * -b);
      output.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;
      output.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;
      return output;
    },
    getX: function(x, y) {
      return x * this.a + y * this.c + this.e;
    },
    getY: function(x, y) {
      return x * this.b + y * this.d + this.f;
    },
    getXRound: function(x, y, round) {
      var v = this.getX(x, y);
      if (round) {
        v = Math.round(v);
      }
      return v;
    },
    getYRound: function(x, y, round) {
      var v = this.getY(x, y);
      if (round) {
        v = Math.round(v);
      }
      return v;
    },
    getCSSMatrix: function() {
      var m = this.matrix;
      return "matrix(" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + "," + m[4] + "," + m[5] + ")";
    },
    destroy: function() {
      this.matrix = null;
      this.decomposedMatrix = null;
    }
  });
  module2.exports = TransformMatrix;
});

// node_modules/phaser/src/math/TransformXY.js
var require_TransformXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector2 = require_Vector2();
  var TransformXY = function(x, y, positionX, positionY, rotation, scaleX, scaleY, output) {
    if (output === void 0) {
      output = new Vector2();
    }
    var radianSin = Math.sin(rotation);
    var radianCos = Math.cos(rotation);
    var a = radianCos * scaleX;
    var b = radianSin * scaleX;
    var c = -radianSin * scaleY;
    var d = radianCos * scaleY;
    var id = 1 / (a * d + c * -b);
    output.x = d * id * x + -c * id * y + (positionY * c - positionX * d) * id;
    output.y = a * id * y + -b * id * x + (-positionY * a + positionX * b) * id;
    return output;
  };
  module2.exports = TransformXY;
});

// node_modules/phaser/src/math/Wrap.js
var require_Wrap = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Wrap = function(value, min, max) {
    var range = max - min;
    return min + ((value - min) % range + range) % range;
  };
  module2.exports = Wrap;
});

// node_modules/phaser/src/math/angle/Wrap.js
var require_Wrap2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MathWrap = require_Wrap();
  var Wrap = function(angle) {
    return MathWrap(angle, -Math.PI, Math.PI);
  };
  module2.exports = Wrap;
});

// node_modules/phaser/src/math/angle/WrapDegrees.js
var require_WrapDegrees = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Wrap = require_Wrap();
  var WrapDegrees = function(angle) {
    return Wrap(angle, -180, 180);
  };
  module2.exports = WrapDegrees;
});

// node_modules/phaser/src/gameobjects/components/Transform.js
var require_Transform = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MATH_CONST = require_const4();
  var TransformMatrix = require_TransformMatrix();
  var TransformXY = require_TransformXY();
  var WrapAngle = require_Wrap2();
  var WrapAngleDegrees = require_WrapDegrees();
  var Vector2 = require_Vector2();
  var _FLAG = 4;
  var Transform = {
    _scaleX: 1,
    _scaleY: 1,
    _rotation: 0,
    x: 0,
    y: 0,
    z: 0,
    w: 0,
    scale: {
      get: function() {
        return (this._scaleX + this._scaleY) / 2;
      },
      set: function(value) {
        this._scaleX = value;
        this._scaleY = value;
        if (value === 0) {
          this.renderFlags &= ~_FLAG;
        } else {
          this.renderFlags |= _FLAG;
        }
      }
    },
    scaleX: {
      get: function() {
        return this._scaleX;
      },
      set: function(value) {
        this._scaleX = value;
        if (value === 0) {
          this.renderFlags &= ~_FLAG;
        } else {
          this.renderFlags |= _FLAG;
        }
      }
    },
    scaleY: {
      get: function() {
        return this._scaleY;
      },
      set: function(value) {
        this._scaleY = value;
        if (value === 0) {
          this.renderFlags &= ~_FLAG;
        } else {
          this.renderFlags |= _FLAG;
        }
      }
    },
    angle: {
      get: function() {
        return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);
      },
      set: function(value) {
        this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
      }
    },
    rotation: {
      get: function() {
        return this._rotation;
      },
      set: function(value) {
        this._rotation = WrapAngle(value);
      }
    },
    setPosition: function(x, y, z, w) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = x;
      }
      if (z === void 0) {
        z = 0;
      }
      if (w === void 0) {
        w = 0;
      }
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    },
    copyPosition: function(source) {
      if (source.x !== void 0) {
        this.x = source.x;
      }
      if (source.y !== void 0) {
        this.y = source.y;
      }
      if (source.z !== void 0) {
        this.z = source.z;
      }
      if (source.w !== void 0) {
        this.w = source.w;
      }
      return this;
    },
    setRandomPosition: function(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = this.scene.sys.scale.width;
      }
      if (height === void 0) {
        height = this.scene.sys.scale.height;
      }
      this.x = x + Math.random() * width;
      this.y = y + Math.random() * height;
      return this;
    },
    setRotation: function(radians) {
      if (radians === void 0) {
        radians = 0;
      }
      this.rotation = radians;
      return this;
    },
    setAngle: function(degrees) {
      if (degrees === void 0) {
        degrees = 0;
      }
      this.angle = degrees;
      return this;
    },
    setScale: function(x, y) {
      if (x === void 0) {
        x = 1;
      }
      if (y === void 0) {
        y = x;
      }
      this.scaleX = x;
      this.scaleY = y;
      return this;
    },
    setX: function(value) {
      if (value === void 0) {
        value = 0;
      }
      this.x = value;
      return this;
    },
    setY: function(value) {
      if (value === void 0) {
        value = 0;
      }
      this.y = value;
      return this;
    },
    setZ: function(value) {
      if (value === void 0) {
        value = 0;
      }
      this.z = value;
      return this;
    },
    setW: function(value) {
      if (value === void 0) {
        value = 0;
      }
      this.w = value;
      return this;
    },
    getLocalTransformMatrix: function(tempMatrix) {
      if (tempMatrix === void 0) {
        tempMatrix = new TransformMatrix();
      }
      return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
    },
    getWorldTransformMatrix: function(tempMatrix, parentMatrix) {
      if (tempMatrix === void 0) {
        tempMatrix = new TransformMatrix();
      }
      if (parentMatrix === void 0) {
        parentMatrix = new TransformMatrix();
      }
      var parent = this.parentContainer;
      if (!parent) {
        return this.getLocalTransformMatrix(tempMatrix);
      }
      tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
      while (parent) {
        parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);
        parentMatrix.multiply(tempMatrix, tempMatrix);
        parent = parent.parentContainer;
      }
      return tempMatrix;
    },
    getLocalPoint: function(x, y, point, camera) {
      if (!point) {
        point = new Vector2();
      }
      if (!camera) {
        camera = this.scene.sys.cameras.main;
      }
      var csx = camera.scrollX;
      var csy = camera.scrollY;
      var px = x + csx * this.scrollFactorX - csx;
      var py = y + csy * this.scrollFactorY - csy;
      if (this.parentContainer) {
        this.getWorldTransformMatrix().applyInverse(px, py, point);
      } else {
        TransformXY(px, py, this.x, this.y, this.rotation, this.scaleX, this.scaleY, point);
      }
      if (this._originComponent) {
        point.x += this._displayOriginX;
        point.y += this._displayOriginY;
      }
      return point;
    },
    getParentRotation: function() {
      var rotation = 0;
      var parent = this.parentContainer;
      while (parent) {
        rotation += parent.rotation;
        parent = parent.parentContainer;
      }
      return rotation;
    }
  };
  module2.exports = Transform;
});

// node_modules/phaser/src/gameobjects/components/Visible.js
var require_Visible = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var _FLAG = 1;
  var Visible = {
    _visible: true,
    visible: {
      get: function() {
        return this._visible;
      },
      set: function(value) {
        if (value) {
          this._visible = true;
          this.renderFlags |= _FLAG;
        } else {
          this._visible = false;
          this.renderFlags &= ~_FLAG;
        }
      }
    },
    setVisible: function(value) {
      this.visible = value;
      return this;
    }
  };
  module2.exports = Visible;
});

// node_modules/phaser/src/gameobjects/components/index.js
var require_components = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Alpha: require_Alpha(),
    AlphaSingle: require_AlphaSingle(),
    BlendMode: require_BlendMode(),
    ComputedSize: require_ComputedSize(),
    Crop: require_Crop(),
    Depth: require_Depth(),
    Flip: require_Flip(),
    GetBounds: require_GetBounds(),
    Mask: require_Mask(),
    Origin: require_Origin(),
    PathFollower: require_PathFollower(),
    Pipeline: require_Pipeline(),
    ScrollFactor: require_ScrollFactor(),
    Size: require_Size(),
    Texture: require_Texture(),
    TextureCrop: require_TextureCrop(),
    Tint: require_Tint(),
    ToJSON: require_ToJSON(),
    Transform: require_Transform(),
    TransformMatrix: require_TransformMatrix(),
    Visible: require_Visible()
  };
});

// node_modules/phaser/src/data/events/CHANGE_DATA_EVENT.js
var require_CHANGE_DATA_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "changedata";
});

// node_modules/phaser/src/data/events/CHANGE_DATA_KEY_EVENT.js
var require_CHANGE_DATA_KEY_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "changedata-";
});

// node_modules/phaser/src/data/events/DESTROY_EVENT.js
var require_DESTROY_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "destroy";
});

// node_modules/phaser/src/data/events/REMOVE_DATA_EVENT.js
var require_REMOVE_DATA_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "removedata";
});

// node_modules/phaser/src/data/events/SET_DATA_EVENT.js
var require_SET_DATA_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "setdata";
});

// node_modules/phaser/src/data/events/index.js
var require_events3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    CHANGE_DATA: require_CHANGE_DATA_EVENT(),
    CHANGE_DATA_KEY: require_CHANGE_DATA_KEY_EVENT(),
    DESTROY: require_DESTROY_EVENT2(),
    REMOVE_DATA: require_REMOVE_DATA_EVENT(),
    SET_DATA: require_SET_DATA_EVENT()
  };
});

// node_modules/phaser/src/data/DataManager.js
var require_DataManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Events = require_events3();
  var DataManager = new Class({
    initialize: function DataManager2(parent, eventEmitter) {
      this.parent = parent;
      this.events = eventEmitter;
      if (!eventEmitter) {
        this.events = parent.events ? parent.events : parent;
      }
      this.list = {};
      this.values = {};
      this._frozen = false;
      if (!parent.hasOwnProperty("sys") && this.events) {
        this.events.once(Events.DESTROY, this.destroy, this);
      }
    },
    get: function(key) {
      var list = this.list;
      if (Array.isArray(key)) {
        var output = [];
        for (var i = 0; i < key.length; i++) {
          output.push(list[key[i]]);
        }
        return output;
      } else {
        return list[key];
      }
    },
    getAll: function() {
      var results = {};
      for (var key in this.list) {
        if (this.list.hasOwnProperty(key)) {
          results[key] = this.list[key];
        }
      }
      return results;
    },
    query: function(search) {
      var results = {};
      for (var key in this.list) {
        if (this.list.hasOwnProperty(key) && key.match(search)) {
          results[key] = this.list[key];
        }
      }
      return results;
    },
    set: function(key, data) {
      if (this._frozen) {
        return this;
      }
      if (typeof key === "string") {
        return this.setValue(key, data);
      } else {
        for (var entry in key) {
          this.setValue(entry, key[entry]);
        }
      }
      return this;
    },
    inc: function(key, data) {
      if (this._frozen) {
        return this;
      }
      if (data === void 0) {
        data = 1;
      }
      var value = this.get(key);
      if (value === void 0) {
        value = 0;
      }
      this.set(key, value + data);
      return this;
    },
    toggle: function(key) {
      if (this._frozen) {
        return this;
      }
      this.set(key, !this.get(key));
      return this;
    },
    setValue: function(key, data) {
      if (this._frozen) {
        return this;
      }
      if (this.has(key)) {
        this.values[key] = data;
      } else {
        var _this = this;
        var list = this.list;
        var events = this.events;
        var parent = this.parent;
        Object.defineProperty(this.values, key, {
          enumerable: true,
          configurable: true,
          get: function() {
            return list[key];
          },
          set: function(value) {
            if (!_this._frozen) {
              var previousValue = list[key];
              list[key] = value;
              events.emit(Events.CHANGE_DATA, parent, key, value, previousValue);
              events.emit(Events.CHANGE_DATA_KEY + key, parent, value, previousValue);
            }
          }
        });
        list[key] = data;
        events.emit(Events.SET_DATA, parent, key, data);
      }
      return this;
    },
    each: function(callback, context) {
      var args = [this.parent, null, void 0];
      for (var i = 1; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      for (var key in this.list) {
        args[1] = key;
        args[2] = this.list[key];
        callback.apply(context, args);
      }
      return this;
    },
    merge: function(data, overwrite) {
      if (overwrite === void 0) {
        overwrite = true;
      }
      for (var key in data) {
        if (data.hasOwnProperty(key) && (overwrite || !overwrite && !this.has(key))) {
          this.setValue(key, data[key]);
        }
      }
      return this;
    },
    remove: function(key) {
      if (this._frozen) {
        return this;
      }
      if (Array.isArray(key)) {
        for (var i = 0; i < key.length; i++) {
          this.removeValue(key[i]);
        }
      } else {
        return this.removeValue(key);
      }
      return this;
    },
    removeValue: function(key) {
      if (this.has(key)) {
        var data = this.list[key];
        delete this.list[key];
        delete this.values[key];
        this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
      }
      return this;
    },
    pop: function(key) {
      var data = void 0;
      if (!this._frozen && this.has(key)) {
        data = this.list[key];
        delete this.list[key];
        delete this.values[key];
        this.events.emit(Events.REMOVE_DATA, this.parent, key, data);
      }
      return data;
    },
    has: function(key) {
      return this.list.hasOwnProperty(key);
    },
    setFreeze: function(value) {
      this._frozen = value;
      return this;
    },
    reset: function() {
      for (var key in this.list) {
        delete this.list[key];
        delete this.values[key];
      }
      this._frozen = false;
      return this;
    },
    destroy: function() {
      this.reset();
      this.events.off(Events.CHANGE_DATA);
      this.events.off(Events.SET_DATA);
      this.events.off(Events.REMOVE_DATA);
      this.parent = null;
    },
    freeze: {
      get: function() {
        return this._frozen;
      },
      set: function(value) {
        this._frozen = value ? true : false;
      }
    },
    count: {
      get: function() {
        var i = 0;
        for (var key in this.list) {
          if (this.list[key] !== void 0) {
            i++;
          }
        }
        return i;
      }
    }
  });
  module2.exports = DataManager;
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports2, module2) => {
  "use strict";
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module2 !== "undefined") {
    module2.exports = EventEmitter;
  }
});

// node_modules/phaser/src/gameobjects/events/ADDED_TO_SCENE_EVENT.js
var require_ADDED_TO_SCENE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "addedtoscene";
});

// node_modules/phaser/src/gameobjects/events/DESTROY_EVENT.js
var require_DESTROY_EVENT3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "destroy";
});

// node_modules/phaser/src/gameobjects/events/REMOVED_FROM_SCENE_EVENT.js
var require_REMOVED_FROM_SCENE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "removedfromscene";
});

// node_modules/phaser/src/gameobjects/events/VIDEO_COMPLETE_EVENT.js
var require_VIDEO_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "complete";
});

// node_modules/phaser/src/gameobjects/events/VIDEO_CREATED_EVENT.js
var require_VIDEO_CREATED_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "created";
});

// node_modules/phaser/src/gameobjects/events/VIDEO_ERROR_EVENT.js
var require_VIDEO_ERROR_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "error";
});

// node_modules/phaser/src/gameobjects/events/VIDEO_LOOP_EVENT.js
var require_VIDEO_LOOP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "loop";
});

// node_modules/phaser/src/gameobjects/events/VIDEO_PLAY_EVENT.js
var require_VIDEO_PLAY_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "play";
});

// node_modules/phaser/src/gameobjects/events/VIDEO_SEEKED_EVENT.js
var require_VIDEO_SEEKED_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "seeked";
});

// node_modules/phaser/src/gameobjects/events/VIDEO_SEEKING_EVENT.js
var require_VIDEO_SEEKING_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "seeking";
});

// node_modules/phaser/src/gameobjects/events/VIDEO_STOP_EVENT.js
var require_VIDEO_STOP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "stop";
});

// node_modules/phaser/src/gameobjects/events/VIDEO_TIMEOUT_EVENT.js
var require_VIDEO_TIMEOUT_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "timeout";
});

// node_modules/phaser/src/gameobjects/events/VIDEO_UNLOCKED_EVENT.js
var require_VIDEO_UNLOCKED_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "unlocked";
});

// node_modules/phaser/src/gameobjects/events/index.js
var require_events4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ADDED_TO_SCENE: require_ADDED_TO_SCENE_EVENT(),
    DESTROY: require_DESTROY_EVENT3(),
    REMOVED_FROM_SCENE: require_REMOVED_FROM_SCENE_EVENT(),
    VIDEO_COMPLETE: require_VIDEO_COMPLETE_EVENT(),
    VIDEO_CREATED: require_VIDEO_CREATED_EVENT(),
    VIDEO_ERROR: require_VIDEO_ERROR_EVENT(),
    VIDEO_LOOP: require_VIDEO_LOOP_EVENT(),
    VIDEO_PLAY: require_VIDEO_PLAY_EVENT(),
    VIDEO_SEEKED: require_VIDEO_SEEKED_EVENT(),
    VIDEO_SEEKING: require_VIDEO_SEEKING_EVENT(),
    VIDEO_STOP: require_VIDEO_STOP_EVENT(),
    VIDEO_TIMEOUT: require_VIDEO_TIMEOUT_EVENT(),
    VIDEO_UNLOCKED: require_VIDEO_UNLOCKED_EVENT()
  };
});

// node_modules/phaser/src/scene/events/ADDED_TO_SCENE_EVENT.js
var require_ADDED_TO_SCENE_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "addedtoscene";
});

// node_modules/phaser/src/scene/events/BOOT_EVENT.js
var require_BOOT_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "boot";
});

// node_modules/phaser/src/scene/events/CREATE_EVENT.js
var require_CREATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "create";
});

// node_modules/phaser/src/scene/events/DESTROY_EVENT.js
var require_DESTROY_EVENT4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "destroy";
});

// node_modules/phaser/src/scene/events/PAUSE_EVENT.js
var require_PAUSE_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pause";
});

// node_modules/phaser/src/scene/events/POST_UPDATE_EVENT.js
var require_POST_UPDATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "postupdate";
});

// node_modules/phaser/src/scene/events/PRE_RENDER_EVENT.js
var require_PRE_RENDER_EVENT3 = __commonJS((exports2, module2) => {
  /**
   * @author       samme
   * @copyright    2021 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "prerender";
});

// node_modules/phaser/src/scene/events/PRE_UPDATE_EVENT.js
var require_PRE_UPDATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "preupdate";
});

// node_modules/phaser/src/scene/events/READY_EVENT.js
var require_READY_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "ready";
});

// node_modules/phaser/src/scene/events/REMOVED_FROM_SCENE_EVENT.js
var require_REMOVED_FROM_SCENE_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "removedfromscene";
});

// node_modules/phaser/src/scene/events/RENDER_EVENT.js
var require_RENDER_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "render";
});

// node_modules/phaser/src/scene/events/RESUME_EVENT.js
var require_RESUME_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "resume";
});

// node_modules/phaser/src/scene/events/SHUTDOWN_EVENT.js
var require_SHUTDOWN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "shutdown";
});

// node_modules/phaser/src/scene/events/SLEEP_EVENT.js
var require_SLEEP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "sleep";
});

// node_modules/phaser/src/scene/events/START_EVENT.js
var require_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "start";
});

// node_modules/phaser/src/scene/events/TRANSITION_COMPLETE_EVENT.js
var require_TRANSITION_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "transitioncomplete";
});

// node_modules/phaser/src/scene/events/TRANSITION_INIT_EVENT.js
var require_TRANSITION_INIT_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "transitioninit";
});

// node_modules/phaser/src/scene/events/TRANSITION_OUT_EVENT.js
var require_TRANSITION_OUT_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "transitionout";
});

// node_modules/phaser/src/scene/events/TRANSITION_START_EVENT.js
var require_TRANSITION_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "transitionstart";
});

// node_modules/phaser/src/scene/events/TRANSITION_WAKE_EVENT.js
var require_TRANSITION_WAKE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "transitionwake";
});

// node_modules/phaser/src/scene/events/UPDATE_EVENT.js
var require_UPDATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "update";
});

// node_modules/phaser/src/scene/events/WAKE_EVENT.js
var require_WAKE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "wake";
});

// node_modules/phaser/src/scene/events/index.js
var require_events5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ADDED_TO_SCENE: require_ADDED_TO_SCENE_EVENT2(),
    BOOT: require_BOOT_EVENT2(),
    CREATE: require_CREATE_EVENT(),
    DESTROY: require_DESTROY_EVENT4(),
    PAUSE: require_PAUSE_EVENT2(),
    POST_UPDATE: require_POST_UPDATE_EVENT(),
    PRE_RENDER: require_PRE_RENDER_EVENT3(),
    PRE_UPDATE: require_PRE_UPDATE_EVENT(),
    READY: require_READY_EVENT2(),
    REMOVED_FROM_SCENE: require_REMOVED_FROM_SCENE_EVENT2(),
    RENDER: require_RENDER_EVENT2(),
    RESUME: require_RESUME_EVENT2(),
    SHUTDOWN: require_SHUTDOWN_EVENT(),
    SLEEP: require_SLEEP_EVENT(),
    START: require_START_EVENT(),
    TRANSITION_COMPLETE: require_TRANSITION_COMPLETE_EVENT(),
    TRANSITION_INIT: require_TRANSITION_INIT_EVENT(),
    TRANSITION_OUT: require_TRANSITION_OUT_EVENT(),
    TRANSITION_START: require_TRANSITION_START_EVENT(),
    TRANSITION_WAKE: require_TRANSITION_WAKE_EVENT(),
    UPDATE: require_UPDATE_EVENT(),
    WAKE: require_WAKE_EVENT()
  };
});

// node_modules/phaser/src/gameobjects/GameObject.js
var require_GameObject = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var ComponentsToJSON = require_ToJSON();
  var DataManager = require_DataManager();
  var EventEmitter = require_eventemitter3();
  var Events = require_events4();
  var SceneEvents = require_events5();
  var GameObject = new Class({
    Extends: EventEmitter,
    initialize: function GameObject2(scene, type) {
      EventEmitter.call(this);
      this.scene = scene;
      this.displayList = null;
      this.type = type;
      this.state = 0;
      this.parentContainer = null;
      this.name = "";
      this.active = true;
      this.tabIndex = -1;
      this.data = null;
      this.renderFlags = 15;
      this.cameraFilter = 0;
      this.input = null;
      this.body = null;
      this.ignoreDestroy = false;
      this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
      this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
      scene.sys.queueDepthSort();
    },
    setActive: function(value) {
      this.active = value;
      return this;
    },
    setName: function(value) {
      this.name = value;
      return this;
    },
    setState: function(value) {
      this.state = value;
      return this;
    },
    setDataEnabled: function() {
      if (!this.data) {
        this.data = new DataManager(this);
      }
      return this;
    },
    setData: function(key, value) {
      if (!this.data) {
        this.data = new DataManager(this);
      }
      this.data.set(key, value);
      return this;
    },
    incData: function(key, value) {
      if (!this.data) {
        this.data = new DataManager(this);
      }
      this.data.inc(key, value);
      return this;
    },
    toggleData: function(key) {
      if (!this.data) {
        this.data = new DataManager(this);
      }
      this.data.toggle(key);
      return this;
    },
    getData: function(key) {
      if (!this.data) {
        this.data = new DataManager(this);
      }
      return this.data.get(key);
    },
    setInteractive: function(hitArea, hitAreaCallback, dropZone) {
      this.scene.sys.input.enable(this, hitArea, hitAreaCallback, dropZone);
      return this;
    },
    disableInteractive: function() {
      if (this.input) {
        this.input.enabled = false;
      }
      return this;
    },
    removeInteractive: function() {
      this.scene.sys.input.clear(this);
      this.input = void 0;
      return this;
    },
    addedToScene: function() {
    },
    removedFromScene: function() {
    },
    update: function() {
    },
    toJSON: function() {
      return ComponentsToJSON(this);
    },
    willRender: function(camera) {
      return !(GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
    },
    getIndexList: function() {
      var child = this;
      var parent = this.parentContainer;
      var indexes = [];
      while (parent) {
        indexes.unshift(parent.getIndex(child));
        child = parent;
        if (!parent.parentContainer) {
          break;
        } else {
          parent = parent.parentContainer;
        }
      }
      if (this.displayList) {
        indexes.unshift(this.displayList.getIndex(child));
      } else {
        indexes.unshift(this.scene.sys.displayList.getIndex(child));
      }
      return indexes;
    },
    addToDisplayList: function(displayList) {
      if (displayList === void 0) {
        displayList = this.scene.sys.displayList;
      }
      if (this.displayList && this.displayList !== displayList) {
        this.removeFromDisplayList();
      }
      if (!displayList.exists(this)) {
        this.displayList = displayList;
        displayList.add(this, true);
        displayList.queueDepthSort();
        this.emit(Events.ADDED_TO_SCENE, this, this.scene);
        displayList.events.emit(SceneEvents.ADDED_TO_SCENE, this, this.scene);
      }
      return this;
    },
    addToUpdateList: function() {
      if (this.scene && this.preUpdate) {
        this.scene.sys.updateList.add(this);
      }
      return this;
    },
    removeFromDisplayList: function() {
      var displayList = this.displayList || this.scene.sys.displayList;
      if (displayList.exists(this)) {
        displayList.remove(this, true);
        displayList.queueDepthSort();
        this.displayList = null;
        this.emit(Events.REMOVED_FROM_SCENE, this, this.scene);
        displayList.events.emit(SceneEvents.REMOVED_FROM_SCENE, this, this.scene);
      }
      return this;
    },
    removeFromUpdateList: function() {
      if (this.scene && this.preUpdate) {
        this.scene.sys.updateList.remove(this);
      }
      return this;
    },
    destroy: function(fromScene) {
      if (!this.scene || this.ignoreDestroy) {
        return;
      }
      if (fromScene === void 0) {
        fromScene = false;
      }
      if (this.preDestroy) {
        this.preDestroy.call(this);
      }
      this.emit(Events.DESTROY, this, fromScene);
      this.removeAllListeners();
      if (this.postPipelines) {
        this.resetPostPipeline(true);
      }
      this.removeFromDisplayList();
      this.removeFromUpdateList();
      if (this.input) {
        this.scene.sys.input.clear(this);
        this.input = void 0;
      }
      if (this.data) {
        this.data.destroy();
        this.data = void 0;
      }
      if (this.body) {
        this.body.destroy();
        this.body = void 0;
      }
      this.active = false;
      this.visible = false;
      this.scene = void 0;
      this.parentContainer = void 0;
    }
  });
  GameObject.RENDER_MASK = 15;
  module2.exports = GameObject;
});

// node_modules/phaser/src/gameobjects/zone/Zone.js
var require_Zone = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BlendModes = require_BlendModes();
  var Circle = require_Circle();
  var CircleContains = require_Contains();
  var Class = require_Class();
  var Components = require_components();
  var GameObject = require_GameObject();
  var Rectangle = require_Rectangle();
  var RectangleContains = require_Contains2();
  var Zone = new Class({
    Extends: GameObject,
    Mixins: [
      Components.Depth,
      Components.GetBounds,
      Components.Origin,
      Components.Transform,
      Components.ScrollFactor,
      Components.Visible
    ],
    initialize: function Zone2(scene, x, y, width, height) {
      if (width === void 0) {
        width = 1;
      }
      if (height === void 0) {
        height = width;
      }
      GameObject.call(this, scene, "Zone");
      this.setPosition(x, y);
      this.width = width;
      this.height = height;
      this.blendMode = BlendModes.NORMAL;
      this.updateDisplayOrigin();
    },
    displayWidth: {
      get: function() {
        return this.scaleX * this.width;
      },
      set: function(value) {
        this.scaleX = value / this.width;
      }
    },
    displayHeight: {
      get: function() {
        return this.scaleY * this.height;
      },
      set: function(value) {
        this.scaleY = value / this.height;
      }
    },
    setSize: function(width, height, resizeInput) {
      if (resizeInput === void 0) {
        resizeInput = true;
      }
      this.width = width;
      this.height = height;
      this.updateDisplayOrigin();
      var input = this.input;
      if (resizeInput && input && !input.customHitArea) {
        input.hitArea.width = width;
        input.hitArea.height = height;
      }
      return this;
    },
    setDisplaySize: function(width, height) {
      this.displayWidth = width;
      this.displayHeight = height;
      return this;
    },
    setCircleDropZone: function(radius) {
      return this.setDropZone(new Circle(0, 0, radius), CircleContains);
    },
    setRectangleDropZone: function(width, height) {
      return this.setDropZone(new Rectangle(0, 0, width, height), RectangleContains);
    },
    setDropZone: function(hitArea, hitAreaCallback) {
      if (hitArea === void 0) {
        this.setRectangleDropZone(this.width, this.height);
      } else if (!this.input) {
        this.setInteractive(hitArea, hitAreaCallback, true);
      }
      return this;
    },
    setAlpha: function() {
    },
    setBlendMode: function() {
    },
    renderCanvas: function(renderer, src, camera) {
      camera.addToRenderList(src);
    },
    renderWebGL: function(renderer, src, camera) {
      camera.addToRenderList(src);
    }
  });
  module2.exports = Zone;
});

// node_modules/phaser/src/actions/GridAlign.js
var require_GridAlign = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AlignIn = require_QuickSet2();
  var CONST = require_const2();
  var GetFastValue = require_GetFastValue();
  var NOOP = require_NOOP();
  var Zone = require_Zone();
  var tempZone = new Zone({sys: {queueDepthSort: NOOP, events: {once: NOOP}}}, 0, 0, 1, 1);
  var GridAlign = function(items, options) {
    if (options === void 0) {
      options = {};
    }
    var widthSet = options.hasOwnProperty("width");
    var heightSet = options.hasOwnProperty("height");
    var width = GetFastValue(options, "width", -1);
    var height = GetFastValue(options, "height", -1);
    var cellWidth = GetFastValue(options, "cellWidth", 1);
    var cellHeight = GetFastValue(options, "cellHeight", cellWidth);
    var position = GetFastValue(options, "position", CONST.TOP_LEFT);
    var x = GetFastValue(options, "x", 0);
    var y = GetFastValue(options, "y", 0);
    var cx = 0;
    var cy = 0;
    var w = width * cellWidth;
    var h = height * cellHeight;
    tempZone.setPosition(x, y);
    tempZone.setSize(cellWidth, cellHeight);
    for (var i = 0; i < items.length; i++) {
      AlignIn(items[i], tempZone, position);
      if (widthSet && width === -1) {
        tempZone.x += cellWidth;
      } else if (heightSet && height === -1) {
        tempZone.y += cellHeight;
      } else if (heightSet && !widthSet) {
        cy += cellHeight;
        tempZone.y += cellHeight;
        if (cy === h) {
          cy = 0;
          cx += cellWidth;
          tempZone.y = y;
          tempZone.x += cellWidth;
          if (cx === w) {
            break;
          }
        }
      } else {
        cx += cellWidth;
        tempZone.x += cellWidth;
        if (cx === w) {
          cx = 0;
          cy += cellHeight;
          tempZone.x = x;
          tempZone.y += cellHeight;
          if (cy === h) {
            break;
          }
        }
      }
    }
    return items;
  };
  module2.exports = GridAlign;
});

// node_modules/phaser/src/actions/IncAlpha.js
var require_IncAlpha = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueInc = require_PropertyValueInc();
  var IncAlpha = function(items, value, step, index, direction) {
    return PropertyValueInc(items, "alpha", value, step, index, direction);
  };
  module2.exports = IncAlpha;
});

// node_modules/phaser/src/actions/IncX.js
var require_IncX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueInc = require_PropertyValueInc();
  var IncX = function(items, value, step, index, direction) {
    return PropertyValueInc(items, "x", value, step, index, direction);
  };
  module2.exports = IncX;
});

// node_modules/phaser/src/actions/IncXY.js
var require_IncXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueInc = require_PropertyValueInc();
  var IncXY = function(items, x, y, stepX, stepY, index, direction) {
    if (y === void 0 || y === null) {
      y = x;
    }
    PropertyValueInc(items, "x", x, stepX, index, direction);
    return PropertyValueInc(items, "y", y, stepY, index, direction);
  };
  module2.exports = IncXY;
});

// node_modules/phaser/src/actions/IncY.js
var require_IncY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueInc = require_PropertyValueInc();
  var IncY = function(items, value, step, index, direction) {
    return PropertyValueInc(items, "y", value, step, index, direction);
  };
  module2.exports = IncY;
});

// node_modules/phaser/src/actions/PlaceOnCircle.js
var require_PlaceOnCircle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PlaceOnCircle = function(items, circle, startAngle, endAngle) {
    if (startAngle === void 0) {
      startAngle = 0;
    }
    if (endAngle === void 0) {
      endAngle = 6.28;
    }
    var angle = startAngle;
    var angleStep = (endAngle - startAngle) / items.length;
    for (var i = 0; i < items.length; i++) {
      items[i].x = circle.x + circle.radius * Math.cos(angle);
      items[i].y = circle.y + circle.radius * Math.sin(angle);
      angle += angleStep;
    }
    return items;
  };
  module2.exports = PlaceOnCircle;
});

// node_modules/phaser/src/actions/PlaceOnEllipse.js
var require_PlaceOnEllipse = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PlaceOnEllipse = function(items, ellipse, startAngle, endAngle) {
    if (startAngle === void 0) {
      startAngle = 0;
    }
    if (endAngle === void 0) {
      endAngle = 6.28;
    }
    var angle = startAngle;
    var angleStep = (endAngle - startAngle) / items.length;
    var a = ellipse.width / 2;
    var b = ellipse.height / 2;
    for (var i = 0; i < items.length; i++) {
      items[i].x = ellipse.x + a * Math.cos(angle);
      items[i].y = ellipse.y + b * Math.sin(angle);
      angle += angleStep;
    }
    return items;
  };
  module2.exports = PlaceOnEllipse;
});

// node_modules/phaser/src/actions/PlaceOnLine.js
var require_PlaceOnLine = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetPoints = require_GetPoints3();
  var PlaceOnLine = function(items, line) {
    var points = GetPoints(line, items.length);
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var point = points[i];
      item.x = point.x;
      item.y = point.y;
    }
    return items;
  };
  module2.exports = PlaceOnLine;
});

// node_modules/phaser/src/geom/rectangle/MarchingAnts.js
var require_MarchingAnts = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Perimeter = require_Perimeter();
  var Point = require_Point();
  var MarchingAnts = function(rect, step, quantity, out) {
    if (out === void 0) {
      out = [];
    }
    if (!step && !quantity) {
      return out;
    }
    if (!step) {
      step = Perimeter(rect) / quantity;
    } else {
      quantity = Math.round(Perimeter(rect) / step);
    }
    var x = rect.x;
    var y = rect.y;
    var face = 0;
    for (var i = 0; i < quantity; i++) {
      out.push(new Point(x, y));
      switch (face) {
        case 0:
          x += step;
          if (x >= rect.right) {
            face = 1;
            y += x - rect.right;
            x = rect.right;
          }
          break;
        case 1:
          y += step;
          if (y >= rect.bottom) {
            face = 2;
            x -= y - rect.bottom;
            y = rect.bottom;
          }
          break;
        case 2:
          x -= step;
          if (x <= rect.left) {
            face = 3;
            y -= rect.left - x;
            x = rect.left;
          }
          break;
        case 3:
          y -= step;
          if (y <= rect.top) {
            face = 0;
            y = rect.top;
          }
          break;
      }
    }
    return out;
  };
  module2.exports = MarchingAnts;
});

// node_modules/phaser/src/utils/array/RotateLeft.js
var require_RotateLeft = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateLeft = function(array, total) {
    if (total === void 0) {
      total = 1;
    }
    var element = null;
    for (var i = 0; i < total; i++) {
      element = array.shift();
      array.push(element);
    }
    return element;
  };
  module2.exports = RotateLeft;
});

// node_modules/phaser/src/utils/array/RotateRight.js
var require_RotateRight = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateRight = function(array, total) {
    if (total === void 0) {
      total = 1;
    }
    var element = null;
    for (var i = 0; i < total; i++) {
      element = array.pop();
      array.unshift(element);
    }
    return element;
  };
  module2.exports = RotateRight;
});

// node_modules/phaser/src/actions/PlaceOnRectangle.js
var require_PlaceOnRectangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MarchingAnts = require_MarchingAnts();
  var RotateLeft = require_RotateLeft();
  var RotateRight = require_RotateRight();
  var PlaceOnRectangle = function(items, rect, shift) {
    if (shift === void 0) {
      shift = 0;
    }
    var points = MarchingAnts(rect, false, items.length);
    if (shift > 0) {
      RotateLeft(points, shift);
    } else if (shift < 0) {
      RotateRight(points, Math.abs(shift));
    }
    for (var i = 0; i < items.length; i++) {
      items[i].x = points[i].x;
      items[i].y = points[i].y;
    }
    return items;
  };
  module2.exports = PlaceOnRectangle;
});

// node_modules/phaser/src/geom/line/BresenhamPoints.js
var require_BresenhamPoints = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BresenhamPoints = function(line, stepRate, results) {
    if (stepRate === void 0) {
      stepRate = 1;
    }
    if (results === void 0) {
      results = [];
    }
    var x1 = Math.round(line.x1);
    var y1 = Math.round(line.y1);
    var x2 = Math.round(line.x2);
    var y2 = Math.round(line.y2);
    var dx = Math.abs(x2 - x1);
    var dy = Math.abs(y2 - y1);
    var sx = x1 < x2 ? 1 : -1;
    var sy = y1 < y2 ? 1 : -1;
    var err = dx - dy;
    results.push({x: x1, y: y1});
    var i = 1;
    while (!(x1 === x2 && y1 === y2)) {
      var e2 = err << 1;
      if (e2 > -dy) {
        err -= dy;
        x1 += sx;
      }
      if (e2 < dx) {
        err += dx;
        y1 += sy;
      }
      if (i % stepRate === 0) {
        results.push({x: x1, y: y1});
      }
      i++;
    }
    return results;
  };
  module2.exports = BresenhamPoints;
});

// node_modules/phaser/src/actions/PlaceOnTriangle.js
var require_PlaceOnTriangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BresenhamPoints = require_BresenhamPoints();
  var PlaceOnTriangle = function(items, triangle, stepRate) {
    var p1 = BresenhamPoints({x1: triangle.x1, y1: triangle.y1, x2: triangle.x2, y2: triangle.y2}, stepRate);
    var p2 = BresenhamPoints({x1: triangle.x2, y1: triangle.y2, x2: triangle.x3, y2: triangle.y3}, stepRate);
    var p3 = BresenhamPoints({x1: triangle.x3, y1: triangle.y3, x2: triangle.x1, y2: triangle.y1}, stepRate);
    p1.pop();
    p2.pop();
    p3.pop();
    p1 = p1.concat(p2, p3);
    var step = p1.length / items.length;
    var p = 0;
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var point = p1[Math.floor(p)];
      item.x = point.x;
      item.y = point.y;
      p += step;
    }
    return items;
  };
  module2.exports = PlaceOnTriangle;
});

// node_modules/phaser/src/actions/PlayAnimation.js
var require_PlayAnimation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PlayAnimation = function(items, key, ignoreIfPlaying) {
    for (var i = 0; i < items.length; i++) {
      var gameObject = items[i];
      if (gameObject.anims) {
        gameObject.anims.play(key, ignoreIfPlaying);
      }
    }
    return items;
  };
  module2.exports = PlayAnimation;
});

// node_modules/phaser/src/actions/PropertyValueSet.js
var require_PropertyValueSet = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = function(items, key, value, step, index, direction) {
    if (step === void 0) {
      step = 0;
    }
    if (index === void 0) {
      index = 0;
    }
    if (direction === void 0) {
      direction = 1;
    }
    var i;
    var t = 0;
    var end = items.length;
    if (direction === 1) {
      for (i = index; i < end; i++) {
        items[i][key] = value + t * step;
        t++;
      }
    } else {
      for (i = index; i >= 0; i--) {
        items[i][key] = value + t * step;
        t++;
      }
    }
    return items;
  };
  module2.exports = PropertyValueSet;
});

// node_modules/phaser/src/actions/RandomCircle.js
var require_RandomCircle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Random = require_Random();
  var RandomCircle = function(items, circle) {
    for (var i = 0; i < items.length; i++) {
      Random(circle, items[i]);
    }
    return items;
  };
  module2.exports = RandomCircle;
});

// node_modules/phaser/src/geom/ellipse/Random.js
var require_Random4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var Random = function(ellipse, out) {
    if (out === void 0) {
      out = new Point();
    }
    var p = Math.random() * Math.PI * 2;
    var s = Math.sqrt(Math.random());
    out.x = ellipse.x + s * Math.cos(p) * ellipse.width / 2;
    out.y = ellipse.y + s * Math.sin(p) * ellipse.height / 2;
    return out;
  };
  module2.exports = Random;
});

// node_modules/phaser/src/actions/RandomEllipse.js
var require_RandomEllipse = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Random = require_Random4();
  var RandomEllipse = function(items, ellipse) {
    for (var i = 0; i < items.length; i++) {
      Random(ellipse, items[i]);
    }
    return items;
  };
  module2.exports = RandomEllipse;
});

// node_modules/phaser/src/actions/RandomLine.js
var require_RandomLine = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Random = require_Random2();
  var RandomLine = function(items, line) {
    for (var i = 0; i < items.length; i++) {
      Random(line, items[i]);
    }
    return items;
  };
  module2.exports = RandomLine;
});

// node_modules/phaser/src/actions/RandomRectangle.js
var require_RandomRectangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Random = require_Random3();
  var RandomRectangle = function(items, rect) {
    for (var i = 0; i < items.length; i++) {
      Random(rect, items[i]);
    }
    return items;
  };
  module2.exports = RandomRectangle;
});

// node_modules/phaser/src/geom/triangle/Random.js
var require_Random5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var Random = function(triangle, out) {
    if (out === void 0) {
      out = new Point();
    }
    var ux = triangle.x2 - triangle.x1;
    var uy = triangle.y2 - triangle.y1;
    var vx = triangle.x3 - triangle.x1;
    var vy = triangle.y3 - triangle.y1;
    var r = Math.random();
    var s = Math.random();
    if (r + s >= 1) {
      r = 1 - r;
      s = 1 - s;
    }
    out.x = triangle.x1 + (ux * r + vx * s);
    out.y = triangle.y1 + (uy * r + vy * s);
    return out;
  };
  module2.exports = Random;
});

// node_modules/phaser/src/actions/RandomTriangle.js
var require_RandomTriangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Random = require_Random5();
  var RandomTriangle = function(items, triangle) {
    for (var i = 0; i < items.length; i++) {
      Random(triangle, items[i]);
    }
    return items;
  };
  module2.exports = RandomTriangle;
});

// node_modules/phaser/src/actions/Rotate.js
var require_Rotate = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueInc = require_PropertyValueInc();
  var Rotate = function(items, value, step, index, direction) {
    return PropertyValueInc(items, "rotation", value, step, index, direction);
  };
  module2.exports = Rotate;
});

// node_modules/phaser/src/math/RotateAroundDistance.js
var require_RotateAroundDistance = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateAroundDistance = function(point, x, y, angle, distance) {
    var t = angle + Math.atan2(point.y - y, point.x - x);
    point.x = x + distance * Math.cos(t);
    point.y = y + distance * Math.sin(t);
    return point;
  };
  module2.exports = RotateAroundDistance;
});

// node_modules/phaser/src/math/distance/DistanceBetween.js
var require_DistanceBetween = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DistanceBetween = function(x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  };
  module2.exports = DistanceBetween;
});

// node_modules/phaser/src/actions/RotateAround.js
var require_RotateAround2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateAroundDistance = require_RotateAroundDistance();
  var DistanceBetween = require_DistanceBetween();
  var RotateAround = function(items, point, angle) {
    var x = point.x;
    var y = point.y;
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      RotateAroundDistance(item, x, y, angle, Math.max(1, DistanceBetween(item.x, item.y, x, y)));
    }
    return items;
  };
  module2.exports = RotateAround;
});

// node_modules/phaser/src/actions/RotateAroundDistance.js
var require_RotateAroundDistance2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MathRotateAroundDistance = require_RotateAroundDistance();
  var RotateAroundDistance = function(items, point, angle, distance) {
    var x = point.x;
    var y = point.y;
    if (distance === 0) {
      return items;
    }
    for (var i = 0; i < items.length; i++) {
      MathRotateAroundDistance(items[i], x, y, angle, distance);
    }
    return items;
  };
  module2.exports = RotateAroundDistance;
});

// node_modules/phaser/src/actions/ScaleX.js
var require_ScaleX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueInc = require_PropertyValueInc();
  var ScaleX = function(items, value, step, index, direction) {
    return PropertyValueInc(items, "scaleX", value, step, index, direction);
  };
  module2.exports = ScaleX;
});

// node_modules/phaser/src/actions/ScaleXY.js
var require_ScaleXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueInc = require_PropertyValueInc();
  var ScaleXY = function(items, scaleX, scaleY, stepX, stepY, index, direction) {
    if (scaleY === void 0 || scaleY === null) {
      scaleY = scaleX;
    }
    PropertyValueInc(items, "scaleX", scaleX, stepX, index, direction);
    return PropertyValueInc(items, "scaleY", scaleY, stepY, index, direction);
  };
  module2.exports = ScaleXY;
});

// node_modules/phaser/src/actions/ScaleY.js
var require_ScaleY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueInc = require_PropertyValueInc();
  var ScaleY = function(items, value, step, index, direction) {
    return PropertyValueInc(items, "scaleY", value, step, index, direction);
  };
  module2.exports = ScaleY;
});

// node_modules/phaser/src/actions/SetAlpha.js
var require_SetAlpha = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetAlpha = function(items, value, step, index, direction) {
    return PropertyValueSet(items, "alpha", value, step, index, direction);
  };
  module2.exports = SetAlpha;
});

// node_modules/phaser/src/actions/SetBlendMode.js
var require_SetBlendMode = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetBlendMode = function(items, value, index, direction) {
    return PropertyValueSet(items, "blendMode", value, 0, index, direction);
  };
  module2.exports = SetBlendMode;
});

// node_modules/phaser/src/actions/SetDepth.js
var require_SetDepth = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetDepth = function(items, value, step, index, direction) {
    return PropertyValueSet(items, "depth", value, step, index, direction);
  };
  module2.exports = SetDepth;
});

// node_modules/phaser/src/actions/SetHitArea.js
var require_SetHitArea = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetHitArea = function(items, hitArea, hitAreaCallback) {
    for (var i = 0; i < items.length; i++) {
      items[i].setInteractive(hitArea, hitAreaCallback);
    }
    return items;
  };
  module2.exports = SetHitArea;
});

// node_modules/phaser/src/actions/SetOrigin.js
var require_SetOrigin = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetOrigin = function(items, originX, originY, stepX, stepY, index, direction) {
    if (originY === void 0 || originY === null) {
      originY = originX;
    }
    PropertyValueSet(items, "originX", originX, stepX, index, direction);
    PropertyValueSet(items, "originY", originY, stepY, index, direction);
    items.forEach(function(item) {
      item.updateDisplayOrigin();
    });
    return items;
  };
  module2.exports = SetOrigin;
});

// node_modules/phaser/src/actions/SetRotation.js
var require_SetRotation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetRotation = function(items, value, step, index, direction) {
    return PropertyValueSet(items, "rotation", value, step, index, direction);
  };
  module2.exports = SetRotation;
});

// node_modules/phaser/src/actions/SetScale.js
var require_SetScale = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetScale = function(items, scaleX, scaleY, stepX, stepY, index, direction) {
    if (scaleY === void 0 || scaleY === null) {
      scaleY = scaleX;
    }
    PropertyValueSet(items, "scaleX", scaleX, stepX, index, direction);
    return PropertyValueSet(items, "scaleY", scaleY, stepY, index, direction);
  };
  module2.exports = SetScale;
});

// node_modules/phaser/src/actions/SetScaleX.js
var require_SetScaleX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetScaleX = function(items, value, step, index, direction) {
    return PropertyValueSet(items, "scaleX", value, step, index, direction);
  };
  module2.exports = SetScaleX;
});

// node_modules/phaser/src/actions/SetScaleY.js
var require_SetScaleY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetScaleY = function(items, value, step, index, direction) {
    return PropertyValueSet(items, "scaleY", value, step, index, direction);
  };
  module2.exports = SetScaleY;
});

// node_modules/phaser/src/actions/SetScrollFactor.js
var require_SetScrollFactor = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetScrollFactor = function(items, scrollFactorX, scrollFactorY, stepX, stepY, index, direction) {
    if (scrollFactorY === void 0 || scrollFactorY === null) {
      scrollFactorY = scrollFactorX;
    }
    PropertyValueSet(items, "scrollFactorX", scrollFactorX, stepX, index, direction);
    return PropertyValueSet(items, "scrollFactorY", scrollFactorY, stepY, index, direction);
  };
  module2.exports = SetScrollFactor;
});

// node_modules/phaser/src/actions/SetScrollFactorX.js
var require_SetScrollFactorX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetScrollFactorX = function(items, value, step, index, direction) {
    return PropertyValueSet(items, "scrollFactorX", value, step, index, direction);
  };
  module2.exports = SetScrollFactorX;
});

// node_modules/phaser/src/actions/SetScrollFactorY.js
var require_SetScrollFactorY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetScrollFactorY = function(items, value, step, index, direction) {
    return PropertyValueSet(items, "scrollFactorY", value, step, index, direction);
  };
  module2.exports = SetScrollFactorY;
});

// node_modules/phaser/src/actions/SetTint.js
var require_SetTint = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetTint = function(items, topLeft, topRight, bottomLeft, bottomRight) {
    for (var i = 0; i < items.length; i++) {
      items[i].setTint(topLeft, topRight, bottomLeft, bottomRight);
    }
    return items;
  };
  module2.exports = SetTint;
});

// node_modules/phaser/src/actions/SetVisible.js
var require_SetVisible = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetVisible = function(items, value, index, direction) {
    return PropertyValueSet(items, "visible", value, 0, index, direction);
  };
  module2.exports = SetVisible;
});

// node_modules/phaser/src/actions/SetX.js
var require_SetX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetX = function(items, value, step, index, direction) {
    return PropertyValueSet(items, "x", value, step, index, direction);
  };
  module2.exports = SetX;
});

// node_modules/phaser/src/actions/SetXY.js
var require_SetXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetXY = function(items, x, y, stepX, stepY, index, direction) {
    if (y === void 0 || y === null) {
      y = x;
    }
    PropertyValueSet(items, "x", x, stepX, index, direction);
    return PropertyValueSet(items, "y", y, stepY, index, direction);
  };
  module2.exports = SetXY;
});

// node_modules/phaser/src/actions/SetY.js
var require_SetY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PropertyValueSet = require_PropertyValueSet();
  var SetY = function(items, value, step, index, direction) {
    return PropertyValueSet(items, "y", value, step, index, direction);
  };
  module2.exports = SetY;
});

// node_modules/phaser/src/actions/ShiftPosition.js
var require_ShiftPosition = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector2 = require_Vector2();
  var ShiftPosition = function(items, x, y, direction, output) {
    if (direction === void 0) {
      direction = 0;
    }
    if (output === void 0) {
      output = new Vector2();
    }
    var px;
    var py;
    if (items.length > 1) {
      var i;
      var cx;
      var cy;
      var cur;
      if (direction === 0) {
        var len = items.length - 1;
        px = items[len].x;
        py = items[len].y;
        for (i = len - 1; i >= 0; i--) {
          cur = items[i];
          cx = cur.x;
          cy = cur.y;
          cur.x = px;
          cur.y = py;
          px = cx;
          py = cy;
        }
        items[len].x = x;
        items[len].y = y;
      } else {
        px = items[0].x;
        py = items[0].y;
        for (i = 1; i < items.length; i++) {
          cur = items[i];
          cx = cur.x;
          cy = cur.y;
          cur.x = px;
          cur.y = py;
          px = cx;
          py = cy;
        }
        items[0].x = x;
        items[0].y = y;
      }
    } else {
      px = items[0].x;
      py = items[0].y;
      items[0].x = x;
      items[0].y = y;
    }
    output.x = px;
    output.y = py;
    return output;
  };
  module2.exports = ShiftPosition;
});

// node_modules/phaser/src/utils/array/Shuffle.js
var require_Shuffle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Shuffle = function(array) {
    for (var i = array.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
    return array;
  };
  module2.exports = Shuffle;
});

// node_modules/phaser/src/actions/Shuffle.js
var require_Shuffle2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ArrayShuffle = require_Shuffle();
  var Shuffle = function(items) {
    return ArrayShuffle(items);
  };
  module2.exports = Shuffle;
});

// node_modules/phaser/src/math/SmootherStep.js
var require_SmootherStep = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SmootherStep = function(x, min, max) {
    x = Math.max(0, Math.min(1, (x - min) / (max - min)));
    return x * x * x * (x * (x * 6 - 15) + 10);
  };
  module2.exports = SmootherStep;
});

// node_modules/phaser/src/actions/SmootherStep.js
var require_SmootherStep2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MathSmootherStep = require_SmootherStep();
  var SmootherStep = function(items, property, min, max, inc) {
    if (inc === void 0) {
      inc = false;
    }
    var step = Math.abs(max - min) / items.length;
    var i;
    if (inc) {
      for (i = 0; i < items.length; i++) {
        items[i][property] += MathSmootherStep(i * step, min, max);
      }
    } else {
      for (i = 0; i < items.length; i++) {
        items[i][property] = MathSmootherStep(i * step, min, max);
      }
    }
    return items;
  };
  module2.exports = SmootherStep;
});

// node_modules/phaser/src/math/SmoothStep.js
var require_SmoothStep = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SmoothStep = function(x, min, max) {
    if (x <= min) {
      return 0;
    }
    if (x >= max) {
      return 1;
    }
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  };
  module2.exports = SmoothStep;
});

// node_modules/phaser/src/actions/SmoothStep.js
var require_SmoothStep2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MathSmoothStep = require_SmoothStep();
  var SmoothStep = function(items, property, min, max, inc) {
    if (inc === void 0) {
      inc = false;
    }
    var step = Math.abs(max - min) / items.length;
    var i;
    if (inc) {
      for (i = 0; i < items.length; i++) {
        items[i][property] += MathSmoothStep(i * step, min, max);
      }
    } else {
      for (i = 0; i < items.length; i++) {
        items[i][property] = MathSmoothStep(i * step, min, max);
      }
    }
    return items;
  };
  module2.exports = SmoothStep;
});

// node_modules/phaser/src/actions/Spread.js
var require_Spread = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Spread = function(items, property, min, max, inc) {
    if (inc === void 0) {
      inc = false;
    }
    var step = Math.abs(max - min) / items.length;
    var i;
    if (inc) {
      for (i = 0; i < items.length; i++) {
        items[i][property] += i * step + min;
      }
    } else {
      for (i = 0; i < items.length; i++) {
        items[i][property] = i * step + min;
      }
    }
    return items;
  };
  module2.exports = Spread;
});

// node_modules/phaser/src/actions/ToggleVisible.js
var require_ToggleVisible = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ToggleVisible = function(items) {
    for (var i = 0; i < items.length; i++) {
      items[i].visible = !items[i].visible;
    }
    return items;
  };
  module2.exports = ToggleVisible;
});

// node_modules/phaser/src/actions/WrapInRectangle.js
var require_WrapInRectangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       samme <samme.npm@gmail.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Wrap = require_Wrap();
  var WrapInRectangle = function(items, rect, padding) {
    if (padding === void 0) {
      padding = 0;
    }
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      item.x = Wrap(item.x, rect.left - padding, rect.right + padding);
      item.y = Wrap(item.y, rect.top - padding, rect.bottom + padding);
    }
    return items;
  };
  module2.exports = WrapInRectangle;
});

// node_modules/phaser/src/actions/index.js
var require_actions = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    AlignTo: require_AlignTo(),
    Angle: require_Angle(),
    Call: require_Call(),
    GetFirst: require_GetFirst(),
    GetLast: require_GetLast(),
    GridAlign: require_GridAlign(),
    IncAlpha: require_IncAlpha(),
    IncX: require_IncX(),
    IncXY: require_IncXY(),
    IncY: require_IncY(),
    PlaceOnCircle: require_PlaceOnCircle(),
    PlaceOnEllipse: require_PlaceOnEllipse(),
    PlaceOnLine: require_PlaceOnLine(),
    PlaceOnRectangle: require_PlaceOnRectangle(),
    PlaceOnTriangle: require_PlaceOnTriangle(),
    PlayAnimation: require_PlayAnimation(),
    PropertyValueInc: require_PropertyValueInc(),
    PropertyValueSet: require_PropertyValueSet(),
    RandomCircle: require_RandomCircle(),
    RandomEllipse: require_RandomEllipse(),
    RandomLine: require_RandomLine(),
    RandomRectangle: require_RandomRectangle(),
    RandomTriangle: require_RandomTriangle(),
    Rotate: require_Rotate(),
    RotateAround: require_RotateAround2(),
    RotateAroundDistance: require_RotateAroundDistance2(),
    ScaleX: require_ScaleX(),
    ScaleXY: require_ScaleXY(),
    ScaleY: require_ScaleY(),
    SetAlpha: require_SetAlpha(),
    SetBlendMode: require_SetBlendMode(),
    SetDepth: require_SetDepth(),
    SetHitArea: require_SetHitArea(),
    SetOrigin: require_SetOrigin(),
    SetRotation: require_SetRotation(),
    SetScale: require_SetScale(),
    SetScaleX: require_SetScaleX(),
    SetScaleY: require_SetScaleY(),
    SetScrollFactor: require_SetScrollFactor(),
    SetScrollFactorX: require_SetScrollFactorX(),
    SetScrollFactorY: require_SetScrollFactorY(),
    SetTint: require_SetTint(),
    SetVisible: require_SetVisible(),
    SetX: require_SetX(),
    SetXY: require_SetXY(),
    SetY: require_SetY(),
    ShiftPosition: require_ShiftPosition(),
    Shuffle: require_Shuffle2(),
    SmootherStep: require_SmootherStep2(),
    SmoothStep: require_SmoothStep2(),
    Spread: require_Spread(),
    ToggleVisible: require_ToggleVisible(),
    WrapInRectangle: require_WrapInRectangle()
  };
});

// node_modules/phaser/src/animations/events/ADD_ANIMATION_EVENT.js
var require_ADD_ANIMATION_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "add";
});

// node_modules/phaser/src/animations/events/ANIMATION_COMPLETE_EVENT.js
var require_ANIMATION_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "animationcomplete";
});

// node_modules/phaser/src/animations/events/ANIMATION_COMPLETE_KEY_EVENT.js
var require_ANIMATION_COMPLETE_KEY_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "animationcomplete-";
});

// node_modules/phaser/src/animations/events/ANIMATION_REPEAT_EVENT.js
var require_ANIMATION_REPEAT_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "animationrepeat";
});

// node_modules/phaser/src/animations/events/ANIMATION_RESTART_EVENT.js
var require_ANIMATION_RESTART_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "animationrestart";
});

// node_modules/phaser/src/animations/events/ANIMATION_START_EVENT.js
var require_ANIMATION_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "animationstart";
});

// node_modules/phaser/src/animations/events/ANIMATION_STOP_EVENT.js
var require_ANIMATION_STOP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "animationstop";
});

// node_modules/phaser/src/animations/events/ANIMATION_UPDATE_EVENT.js
var require_ANIMATION_UPDATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "animationupdate";
});

// node_modules/phaser/src/animations/events/PAUSE_ALL_EVENT.js
var require_PAUSE_ALL_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pauseall";
});

// node_modules/phaser/src/animations/events/REMOVE_ANIMATION_EVENT.js
var require_REMOVE_ANIMATION_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "remove";
});

// node_modules/phaser/src/animations/events/RESUME_ALL_EVENT.js
var require_RESUME_ALL_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "resumeall";
});

// node_modules/phaser/src/animations/events/index.js
var require_events6 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ADD_ANIMATION: require_ADD_ANIMATION_EVENT(),
    ANIMATION_COMPLETE: require_ANIMATION_COMPLETE_EVENT(),
    ANIMATION_COMPLETE_KEY: require_ANIMATION_COMPLETE_KEY_EVENT(),
    ANIMATION_REPEAT: require_ANIMATION_REPEAT_EVENT(),
    ANIMATION_RESTART: require_ANIMATION_RESTART_EVENT(),
    ANIMATION_START: require_ANIMATION_START_EVENT(),
    ANIMATION_STOP: require_ANIMATION_STOP_EVENT(),
    ANIMATION_UPDATE: require_ANIMATION_UPDATE_EVENT(),
    PAUSE_ALL: require_PAUSE_ALL_EVENT(),
    REMOVE_ANIMATION: require_REMOVE_ANIMATION_EVENT(),
    RESUME_ALL: require_RESUME_ALL_EVENT()
  };
});

// node_modules/phaser/src/utils/array/FindClosestInSorted.js
var require_FindClosestInSorted = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FindClosestInSorted = function(value, array, key) {
    if (!array.length) {
      return NaN;
    } else if (array.length === 1) {
      return array[0];
    }
    var i = 1;
    var low;
    var high;
    if (key) {
      if (value < array[0][key]) {
        return array[0];
      }
      while (array[i][key] < value) {
        i++;
      }
    } else {
      while (array[i] < value) {
        i++;
      }
    }
    if (i > array.length) {
      i = array.length;
    }
    if (key) {
      low = array[i - 1][key];
      high = array[i][key];
      return high - value <= value - low ? array[i] : array[i - 1];
    } else {
      low = array[i - 1];
      high = array[i];
      return high - value <= value - low ? high : low;
    }
  };
  module2.exports = FindClosestInSorted;
});

// node_modules/phaser/src/animations/AnimationFrame.js
var require_AnimationFrame = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var AnimationFrame = new Class({
    initialize: function AnimationFrame2(textureKey, textureFrame, index, frame, isKeyFrame) {
      if (isKeyFrame === void 0) {
        isKeyFrame = false;
      }
      this.textureKey = textureKey;
      this.textureFrame = textureFrame;
      this.index = index;
      this.frame = frame;
      this.isFirst = false;
      this.isLast = false;
      this.prevFrame = null;
      this.nextFrame = null;
      this.duration = 0;
      this.progress = 0;
      this.isKeyFrame = isKeyFrame;
    },
    toJSON: function() {
      return {
        key: this.textureKey,
        frame: this.textureFrame,
        duration: this.duration,
        keyframe: this.isKeyFrame
      };
    },
    destroy: function() {
      this.frame = void 0;
    }
  });
  module2.exports = AnimationFrame;
});

// node_modules/phaser/src/utils/array/SortByDigits.js
var require_SortByDigits = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SortByDigits = function(array) {
    var re = /\D/g;
    array.sort(function(a, b) {
      return parseInt(a.replace(re, ""), 10) - parseInt(b.replace(re, ""), 10);
    });
    return array;
  };
  module2.exports = SortByDigits;
});

// node_modules/phaser/src/animations/Animation.js
var require_Animation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = require_Clamp();
  var Class = require_Class();
  var Events = require_events6();
  var FindClosestInSorted = require_FindClosestInSorted();
  var Frame = require_AnimationFrame();
  var GetValue = require_GetValue();
  var SortByDigits = require_SortByDigits();
  var Animation = new Class({
    initialize: function Animation2(manager, key, config2) {
      this.manager = manager;
      this.key = key;
      this.type = "frame";
      this.frames = this.getFrames(manager.textureManager, GetValue(config2, "frames", []), GetValue(config2, "defaultTextureKey", null), GetValue(config2, "sortFrames", true));
      this.frameRate = GetValue(config2, "frameRate", null);
      this.duration = GetValue(config2, "duration", null);
      this.msPerFrame;
      this.skipMissedFrames = GetValue(config2, "skipMissedFrames", true);
      this.delay = GetValue(config2, "delay", 0);
      this.repeat = GetValue(config2, "repeat", 0);
      this.repeatDelay = GetValue(config2, "repeatDelay", 0);
      this.yoyo = GetValue(config2, "yoyo", false);
      this.showOnStart = GetValue(config2, "showOnStart", false);
      this.hideOnComplete = GetValue(config2, "hideOnComplete", false);
      this.paused = false;
      this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate);
      if (this.manager.on) {
        this.manager.on(Events.PAUSE_ALL, this.pause, this);
        this.manager.on(Events.RESUME_ALL, this.resume, this);
      }
    },
    getTotalFrames: function() {
      return this.frames.length;
    },
    calculateDuration: function(target, totalFrames, duration, frameRate) {
      if (duration === null && frameRate === null) {
        target.frameRate = 24;
        target.duration = 24 / totalFrames * 1e3;
      } else if (duration && frameRate === null) {
        target.duration = duration;
        target.frameRate = totalFrames / (duration / 1e3);
      } else {
        target.frameRate = frameRate;
        target.duration = totalFrames / frameRate * 1e3;
      }
      target.msPerFrame = 1e3 / target.frameRate;
    },
    addFrame: function(config2) {
      return this.addFrameAt(this.frames.length, config2);
    },
    addFrameAt: function(index, config2) {
      var newFrames = this.getFrames(this.manager.textureManager, config2);
      if (newFrames.length > 0) {
        if (index === 0) {
          this.frames = newFrames.concat(this.frames);
        } else if (index === this.frames.length) {
          this.frames = this.frames.concat(newFrames);
        } else {
          var pre = this.frames.slice(0, index);
          var post = this.frames.slice(index);
          this.frames = pre.concat(newFrames, post);
        }
        this.updateFrameSequence();
      }
      return this;
    },
    checkFrame: function(index) {
      return index >= 0 && index < this.frames.length;
    },
    getFirstTick: function(state) {
      state.accumulator = 0;
      state.nextTick = state.msPerFrame + state.currentFrame.duration;
    },
    getFrameAt: function(index) {
      return this.frames[index];
    },
    getFrames: function(textureManager, frames, defaultTextureKey, sortFrames) {
      if (sortFrames === void 0) {
        sortFrames = true;
      }
      var out = [];
      var prev;
      var animationFrame;
      var index = 1;
      var i;
      var textureKey;
      if (typeof frames === "string") {
        textureKey = frames;
        var texture = textureManager.get(textureKey);
        var frameKeys = texture.getFrameNames();
        if (sortFrames) {
          SortByDigits(frameKeys);
        }
        frames = [];
        frameKeys.forEach(function(value) {
          frames.push({key: textureKey, frame: value});
        });
      }
      if (!Array.isArray(frames) || frames.length === 0) {
        return out;
      }
      for (i = 0; i < frames.length; i++) {
        var item = frames[i];
        var key = GetValue(item, "key", defaultTextureKey);
        if (!key) {
          continue;
        }
        var frame = GetValue(item, "frame", 0);
        var textureFrame = textureManager.getFrame(key, frame);
        animationFrame = new Frame(key, frame, index, textureFrame);
        animationFrame.duration = GetValue(item, "duration", 0);
        animationFrame.isFirst = !prev;
        if (prev) {
          prev.nextFrame = animationFrame;
          animationFrame.prevFrame = prev;
        }
        out.push(animationFrame);
        prev = animationFrame;
        index++;
      }
      if (out.length > 0) {
        animationFrame.isLast = true;
        animationFrame.nextFrame = out[0];
        out[0].prevFrame = animationFrame;
        var slice = 1 / (out.length - 1);
        for (i = 0; i < out.length; i++) {
          out[i].progress = i * slice;
        }
      }
      return out;
    },
    getNextTick: function(state) {
      state.accumulator -= state.nextTick;
      state.nextTick = state.msPerFrame + state.currentFrame.duration;
    },
    getFrameByProgress: function(value) {
      value = Clamp(value, 0, 1);
      return FindClosestInSorted(value, this.frames, "progress");
    },
    nextFrame: function(state) {
      var frame = state.currentFrame;
      if (frame.isLast) {
        if (state.yoyo) {
          this.handleYoyoFrame(state, false);
        } else if (state.repeatCounter > 0) {
          if (state.inReverse && state.forward) {
            state.forward = false;
          } else {
            this.repeatAnimation(state);
          }
        } else {
          state.complete();
        }
      } else {
        this.updateAndGetNextTick(state, frame.nextFrame);
      }
    },
    handleYoyoFrame: function(state, isReverse) {
      if (!isReverse) {
        isReverse = false;
      }
      if (state.inReverse === !isReverse && state.repeatCounter > 0) {
        if (state.repeatDelay === 0 || state.pendingRepeat) {
          state.forward = isReverse;
        }
        this.repeatAnimation(state);
        return;
      }
      if (state.inReverse !== isReverse && state.repeatCounter === 0) {
        state.complete();
        return;
      }
      state.forward = isReverse;
      var frame = isReverse ? state.currentFrame.nextFrame : state.currentFrame.prevFrame;
      this.updateAndGetNextTick(state, frame);
    },
    getLastFrame: function() {
      return this.frames[this.frames.length - 1];
    },
    previousFrame: function(state) {
      var frame = state.currentFrame;
      if (frame.isFirst) {
        if (state.yoyo) {
          this.handleYoyoFrame(state, true);
        } else if (state.repeatCounter > 0) {
          if (state.inReverse && !state.forward) {
            this.repeatAnimation(state);
          } else {
            state.forward = true;
            this.repeatAnimation(state);
          }
        } else {
          state.complete();
        }
      } else {
        this.updateAndGetNextTick(state, frame.prevFrame);
      }
    },
    updateAndGetNextTick: function(state, frame) {
      state.setCurrentFrame(frame);
      this.getNextTick(state);
    },
    removeFrame: function(frame) {
      var index = this.frames.indexOf(frame);
      if (index !== -1) {
        this.removeFrameAt(index);
      }
      return this;
    },
    removeFrameAt: function(index) {
      this.frames.splice(index, 1);
      this.updateFrameSequence();
      return this;
    },
    repeatAnimation: function(state) {
      if (state._pendingStop === 2) {
        if (state._pendingStopValue === 0) {
          return state.stop();
        } else {
          state._pendingStopValue--;
        }
      }
      if (state.repeatDelay > 0 && !state.pendingRepeat) {
        state.pendingRepeat = true;
        state.accumulator -= state.nextTick;
        state.nextTick += state.repeatDelay;
      } else {
        state.repeatCounter--;
        if (state.forward) {
          state.setCurrentFrame(state.currentFrame.nextFrame);
        } else {
          state.setCurrentFrame(state.currentFrame.prevFrame);
        }
        if (state.isPlaying) {
          this.getNextTick(state);
          state.handleRepeat();
        }
      }
    },
    toJSON: function() {
      var output = {
        key: this.key,
        type: this.type,
        frames: [],
        frameRate: this.frameRate,
        duration: this.duration,
        skipMissedFrames: this.skipMissedFrames,
        delay: this.delay,
        repeat: this.repeat,
        repeatDelay: this.repeatDelay,
        yoyo: this.yoyo,
        showOnStart: this.showOnStart,
        hideOnComplete: this.hideOnComplete
      };
      this.frames.forEach(function(frame) {
        output.frames.push(frame.toJSON());
      });
      return output;
    },
    updateFrameSequence: function() {
      var len = this.frames.length;
      var slice = 1 / (len - 1);
      var frame;
      for (var i = 0; i < len; i++) {
        frame = this.frames[i];
        frame.index = i + 1;
        frame.isFirst = false;
        frame.isLast = false;
        frame.progress = i * slice;
        if (i === 0) {
          frame.isFirst = true;
          if (len === 1) {
            frame.isLast = true;
            frame.nextFrame = frame;
            frame.prevFrame = frame;
          } else {
            frame.isLast = false;
            frame.prevFrame = this.frames[len - 1];
            frame.nextFrame = this.frames[i + 1];
          }
        } else if (i === len - 1 && len > 1) {
          frame.isLast = true;
          frame.prevFrame = this.frames[len - 2];
          frame.nextFrame = this.frames[0];
        } else if (len > 1) {
          frame.prevFrame = this.frames[i - 1];
          frame.nextFrame = this.frames[i + 1];
        }
      }
      return this;
    },
    pause: function() {
      this.paused = true;
      return this;
    },
    resume: function() {
      this.paused = false;
      return this;
    },
    destroy: function() {
      if (this.manager.off) {
        this.manager.off(Events.PAUSE_ALL, this.pause, this);
        this.manager.off(Events.RESUME_ALL, this.resume, this);
      }
      this.manager.remove(this.key);
      for (var i = 0; i < this.frames.length; i++) {
        this.frames[i].destroy();
      }
      this.frames = [];
      this.manager = null;
    }
  });
  module2.exports = Animation;
});

// node_modules/phaser/src/structs/Map.js
var require_Map = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Map = new Class({
    initialize: function Map2(elements) {
      this.entries = {};
      this.size = 0;
      if (Array.isArray(elements)) {
        for (var i = 0; i < elements.length; i++) {
          this.set(elements[i][0], elements[i][1]);
        }
      }
    },
    set: function(key, value) {
      if (!this.has(key)) {
        this.size++;
      }
      this.entries[key] = value;
      return this;
    },
    get: function(key) {
      if (this.has(key)) {
        return this.entries[key];
      }
    },
    getArray: function() {
      var output = [];
      var entries = this.entries;
      for (var key in entries) {
        output.push(entries[key]);
      }
      return output;
    },
    has: function(key) {
      return this.entries.hasOwnProperty(key);
    },
    delete: function(key) {
      if (this.has(key)) {
        delete this.entries[key];
        this.size--;
      }
      return this;
    },
    clear: function() {
      Object.keys(this.entries).forEach(function(prop) {
        delete this.entries[prop];
      }, this);
      this.size = 0;
      return this;
    },
    keys: function() {
      return Object.keys(this.entries);
    },
    values: function() {
      var output = [];
      var entries = this.entries;
      for (var key in entries) {
        output.push(entries[key]);
      }
      return output;
    },
    dump: function() {
      var entries = this.entries;
      console.group("Map");
      for (var key in entries) {
        console.log(key, entries[key]);
      }
      console.groupEnd();
    },
    each: function(callback) {
      var entries = this.entries;
      for (var key in entries) {
        if (callback(key, entries[key]) === false) {
          break;
        }
      }
      return this;
    },
    contains: function(value) {
      var entries = this.entries;
      for (var key in entries) {
        if (entries[key] === value) {
          return true;
        }
      }
      return false;
    },
    merge: function(map, override) {
      if (override === void 0) {
        override = false;
      }
      var local = this.entries;
      var source = map.entries;
      for (var key in source) {
        if (local.hasOwnProperty(key) && override) {
          local[key] = source[key];
        } else {
          this.set(key, source[key]);
        }
      }
      return this;
    }
  });
  module2.exports = Map;
});

// node_modules/phaser/src/utils/string/Pad.js
var require_Pad = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Pad = function(str, len, pad, dir) {
    if (len === void 0) {
      len = 0;
    }
    if (pad === void 0) {
      pad = " ";
    }
    if (dir === void 0) {
      dir = 3;
    }
    str = str.toString();
    var padlen = 0;
    if (len + 1 >= str.length) {
      switch (dir) {
        case 1:
          str = new Array(len + 1 - str.length).join(pad) + str;
          break;
        case 3:
          var right = Math.ceil((padlen = len - str.length) / 2);
          var left = padlen - right;
          str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
          break;
        default:
          str = str + new Array(len + 1 - str.length).join(pad);
          break;
      }
    }
    return str;
  };
  module2.exports = Pad;
});

// node_modules/phaser/src/utils/array/NumberArray.js
var require_NumberArray = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var NumberArray = function(start, end, prefix, suffix) {
    var result = [];
    var i;
    var asString = false;
    if (prefix || suffix) {
      asString = true;
      if (!prefix) {
        prefix = "";
      }
      if (!suffix) {
        suffix = "";
      }
    }
    if (end < start) {
      for (i = start; i >= end; i--) {
        if (asString) {
          result.push(prefix + i.toString() + suffix);
        } else {
          result.push(i);
        }
      }
    } else {
      for (i = start; i <= end; i++) {
        if (asString) {
          result.push(prefix + i.toString() + suffix);
        } else {
          result.push(i);
        }
      }
    }
    return result;
  };
  module2.exports = NumberArray;
});

// node_modules/phaser/src/animations/AnimationManager.js
var require_AnimationManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Animation = require_Animation();
  var Class = require_Class();
  var CustomMap = require_Map();
  var EventEmitter = require_eventemitter3();
  var Events = require_events6();
  var GameEvents = require_events();
  var GetFastValue = require_GetFastValue();
  var GetValue = require_GetValue();
  var Pad = require_Pad();
  var NumberArray = require_NumberArray();
  var AnimationManager = new Class({
    Extends: EventEmitter,
    initialize: function AnimationManager2(game2) {
      EventEmitter.call(this);
      this.game = game2;
      this.textureManager = null;
      this.globalTimeScale = 1;
      this.anims = new CustomMap();
      this.mixes = new CustomMap();
      this.paused = false;
      this.name = "AnimationManager";
      game2.events.once(GameEvents.BOOT, this.boot, this);
    },
    boot: function() {
      this.textureManager = this.game.textures;
      this.game.events.once(GameEvents.DESTROY, this.destroy, this);
    },
    addMix: function(animA, animB, delay) {
      var anims = this.anims;
      var mixes = this.mixes;
      var keyA = typeof animA === "string" ? animA : animA.key;
      var keyB = typeof animB === "string" ? animB : animB.key;
      if (anims.has(keyA) && anims.has(keyB)) {
        var mixObj = mixes.get(keyA);
        if (!mixObj) {
          mixObj = {};
        }
        mixObj[keyB] = delay;
        mixes.set(keyA, mixObj);
      }
      return this;
    },
    removeMix: function(animA, animB) {
      var mixes = this.mixes;
      var keyA = typeof animA === "string" ? animA : animA.key;
      var mixObj = mixes.get(keyA);
      if (mixObj) {
        if (animB) {
          var keyB = typeof animB === "string" ? animB : animB.key;
          if (mixObj.hasOwnProperty(keyB)) {
            delete mixObj[keyB];
          }
        } else if (!animB) {
          mixes.delete(keyA);
        }
      }
      return this;
    },
    getMix: function(animA, animB) {
      var mixes = this.mixes;
      var keyA = typeof animA === "string" ? animA : animA.key;
      var keyB = typeof animB === "string" ? animB : animB.key;
      var mixObj = mixes.get(keyA);
      if (mixObj && mixObj.hasOwnProperty(keyB)) {
        return mixObj[keyB];
      } else {
        return 0;
      }
    },
    add: function(key, animation) {
      if (this.anims.has(key)) {
        console.warn("Animation key exists: " + key);
        return this;
      }
      animation.key = key;
      this.anims.set(key, animation);
      this.emit(Events.ADD_ANIMATION, key, animation);
      return this;
    },
    exists: function(key) {
      return this.anims.has(key);
    },
    createFromAseprite: function(key, tags) {
      var output = [];
      var data = this.game.cache.json.get(key);
      if (!data) {
        return output;
      }
      var _this = this;
      var meta = GetValue(data, "meta", null);
      var frames = GetValue(data, "frames", null);
      if (meta && frames) {
        var frameTags = GetValue(meta, "frameTags", []);
        frameTags.forEach(function(tag) {
          var animFrames = [];
          var name = GetFastValue(tag, "name", null);
          var from = GetFastValue(tag, "from", 0);
          var to = GetFastValue(tag, "to", 0);
          var direction = GetFastValue(tag, "direction", "forward");
          if (!name) {
            return;
          }
          if (!tags || tags && tags.indexOf(name) > -1) {
            var tempFrames = [];
            var minDuration = Number.MAX_SAFE_INTEGER;
            for (var i = from; i <= to; i++) {
              var frameKey = i.toString();
              var frame = frames[frameKey];
              if (frame) {
                var frameDuration = GetFastValue(frame, "duration", Number.MAX_SAFE_INTEGER);
                if (frameDuration < minDuration) {
                  minDuration = frameDuration;
                }
                tempFrames.push({frame: frameKey, duration: frameDuration});
              }
            }
            tempFrames.forEach(function(entry) {
              animFrames.push({
                key,
                frame: entry.frame,
                duration: minDuration - entry.duration
              });
            });
            var totalDuration = minDuration * animFrames.length;
            if (direction === "reverse") {
              animFrames = animFrames.reverse();
            }
            var createConfig = {
              key: name,
              frames: animFrames,
              duration: totalDuration,
              yoyo: direction === "pingpong"
            };
            var result = _this.create(createConfig);
            if (result) {
              output.push(result);
            }
          }
        });
      }
      return output;
    },
    create: function(config2) {
      var key = config2.key;
      var anim = false;
      if (key) {
        anim = this.get(key);
        if (!anim) {
          anim = new Animation(this, key, config2);
          this.anims.set(key, anim);
          this.emit(Events.ADD_ANIMATION, key, anim);
        }
      }
      return anim;
    },
    fromJSON: function(data, clearCurrentAnimations) {
      if (clearCurrentAnimations === void 0) {
        clearCurrentAnimations = false;
      }
      if (clearCurrentAnimations) {
        this.anims.clear();
      }
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      var output = [];
      if (data.hasOwnProperty("anims") && Array.isArray(data.anims)) {
        for (var i = 0; i < data.anims.length; i++) {
          output.push(this.create(data.anims[i]));
        }
        if (data.hasOwnProperty("globalTimeScale")) {
          this.globalTimeScale = data.globalTimeScale;
        }
      } else if (data.hasOwnProperty("key") && data.type === "frame") {
        output.push(this.create(data));
      }
      return output;
    },
    generateFrameNames: function(key, config2) {
      var prefix = GetValue(config2, "prefix", "");
      var start = GetValue(config2, "start", 0);
      var end = GetValue(config2, "end", 0);
      var suffix = GetValue(config2, "suffix", "");
      var zeroPad = GetValue(config2, "zeroPad", 0);
      var out = GetValue(config2, "outputArray", []);
      var frames = GetValue(config2, "frames", false);
      var texture = this.textureManager.get(key);
      if (!texture) {
        return out;
      }
      var i;
      if (!config2) {
        frames = texture.getFrameNames();
        for (i = 0; i < frames.length; i++) {
          out.push({key, frame: frames[i]});
        }
      } else {
        if (!frames) {
          frames = NumberArray(start, end);
        }
        for (i = 0; i < frames.length; i++) {
          var frame = prefix + Pad(frames[i], zeroPad, "0", 1) + suffix;
          if (texture.has(frame)) {
            out.push({key, frame});
          } else {
            console.warn("generateFrameNames: Frame missing: " + frame + " from texture: " + key);
          }
        }
      }
      return out;
    },
    generateFrameNumbers: function(key, config2) {
      var start = GetValue(config2, "start", 0);
      var end = GetValue(config2, "end", -1);
      var first = GetValue(config2, "first", false);
      var out = GetValue(config2, "outputArray", []);
      var frames = GetValue(config2, "frames", false);
      var texture = this.textureManager.get(key);
      if (!texture) {
        return out;
      }
      if (first && texture.has(first)) {
        out.push({key, frame: first});
      }
      if (!frames) {
        if (end === -1) {
          end = texture.frameTotal - 2;
        }
        frames = NumberArray(start, end);
      }
      for (var i = 0; i < frames.length; i++) {
        if (texture.has(frames[i])) {
          out.push({key, frame: frames[i]});
        } else {
          console.warn("generateFrameNumbers: Frame " + i + " missing from texture: " + key);
        }
      }
      return out;
    },
    get: function(key) {
      return this.anims.get(key);
    },
    pauseAll: function() {
      if (!this.paused) {
        this.paused = true;
        this.emit(Events.PAUSE_ALL);
      }
      return this;
    },
    play: function(key, children) {
      if (!Array.isArray(children)) {
        children = [children];
      }
      for (var i = 0; i < children.length; i++) {
        children[i].anims.play(key);
      }
      return this;
    },
    staggerPlay: function(key, children, stagger, staggerFirst) {
      if (stagger === void 0) {
        stagger = 0;
      }
      if (staggerFirst === void 0) {
        staggerFirst = true;
      }
      if (!Array.isArray(children)) {
        children = [children];
      }
      var len = children.length;
      if (!staggerFirst) {
        len--;
      }
      for (var i = 0; i < children.length; i++) {
        var time = stagger < 0 ? Math.abs(stagger) * (len - i) : stagger * i;
        children[i].anims.playAfterDelay(key, time);
      }
      return this;
    },
    remove: function(key) {
      var anim = this.get(key);
      if (anim) {
        this.emit(Events.REMOVE_ANIMATION, key, anim);
        this.anims.delete(key);
        this.removeMix(key);
      }
      return anim;
    },
    resumeAll: function() {
      if (this.paused) {
        this.paused = false;
        this.emit(Events.RESUME_ALL);
      }
      return this;
    },
    toJSON: function(key) {
      var output = {
        anims: [],
        globalTimeScale: this.globalTimeScale
      };
      if (key !== void 0 && key !== "") {
        output.anims.push(this.anims.get(key).toJSON());
      } else {
        this.anims.each(function(animationKey, animation) {
          output.anims.push(animation.toJSON());
        });
      }
      return output;
    },
    destroy: function() {
      this.anims.clear();
      this.mixes.clear();
      this.textureManager = null;
      this.game = null;
    }
  });
  module2.exports = AnimationManager;
});

// node_modules/phaser/src/animations/AnimationState.js
var require_AnimationState = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CustomMap = require_Map();
  var GetFastValue = require_GetFastValue();
  var Events = require_events6();
  var Animation = require_Animation();
  var AnimationState = new Class({
    initialize: function AnimationState2(parent) {
      this.parent = parent;
      this.animationManager = parent.scene.sys.anims;
      this.animationManager.on(Events.REMOVE_ANIMATION, this.globalRemove, this);
      this.textureManager = this.animationManager.textureManager;
      this.anims = null;
      this.isPlaying = false;
      this.hasStarted = false;
      this.currentAnim = null;
      this.currentFrame = null;
      this.nextAnim = null;
      this.nextAnimsQueue = [];
      this.timeScale = 1;
      this.frameRate = 0;
      this.duration = 0;
      this.msPerFrame = 0;
      this.skipMissedFrames = true;
      this.delay = 0;
      this.repeat = 0;
      this.repeatDelay = 0;
      this.yoyo = false;
      this.showOnStart = false;
      this.hideOnComplete = false;
      this.forward = true;
      this.inReverse = false;
      this.accumulator = 0;
      this.nextTick = 0;
      this.delayCounter = 0;
      this.repeatCounter = 0;
      this.pendingRepeat = false;
      this._paused = false;
      this._wasPlaying = false;
      this._pendingStop = 0;
      this._pendingStopValue;
    },
    chain: function(key) {
      var parent = this.parent;
      if (key === void 0) {
        this.nextAnimsQueue.length = 0;
        this.nextAnim = null;
        return parent;
      }
      if (!Array.isArray(key)) {
        key = [key];
      }
      for (var i = 0; i < key.length; i++) {
        var anim = key[i];
        if (this.nextAnim === null) {
          this.nextAnim = anim;
        } else {
          this.nextAnimsQueue.push(anim);
        }
      }
      return this.parent;
    },
    getName: function() {
      return this.currentAnim ? this.currentAnim.key : "";
    },
    getFrameName: function() {
      return this.currentFrame ? this.currentFrame.textureFrame : "";
    },
    load: function(key) {
      if (this.isPlaying) {
        this.stop();
      }
      var manager = this.animationManager;
      var animKey = typeof key === "string" ? key : GetFastValue(key, "key", null);
      var anim = this.exists(animKey) ? this.get(animKey) : manager.get(animKey);
      if (!anim) {
        console.warn("Missing animation: " + animKey);
      } else {
        this.currentAnim = anim;
        var totalFrames = anim.getTotalFrames();
        var frameRate = GetFastValue(key, "frameRate", anim.frameRate);
        var duration = GetFastValue(key, "duration", anim.duration);
        anim.calculateDuration(this, totalFrames, duration, frameRate);
        this.delay = GetFastValue(key, "delay", anim.delay);
        this.repeat = GetFastValue(key, "repeat", anim.repeat);
        this.repeatDelay = GetFastValue(key, "repeatDelay", anim.repeatDelay);
        this.yoyo = GetFastValue(key, "yoyo", anim.yoyo);
        this.showOnStart = GetFastValue(key, "showOnStart", anim.showOnStart);
        this.hideOnComplete = GetFastValue(key, "hideOnComplete", anim.hideOnComplete);
        this.skipMissedFrames = GetFastValue(key, "skipMissedFrames", anim.skipMissedFrames);
        this.timeScale = GetFastValue(key, "timeScale", this.timeScale);
        var startFrame = GetFastValue(key, "startFrame", 0);
        if (startFrame > anim.getTotalFrames()) {
          startFrame = 0;
        }
        var frame = anim.frames[startFrame];
        if (startFrame === 0 && !this.forward) {
          frame = anim.getLastFrame();
        }
        this.currentFrame = frame;
      }
      return this.parent;
    },
    pause: function(atFrame) {
      if (!this._paused) {
        this._paused = true;
        this._wasPlaying = this.isPlaying;
        this.isPlaying = false;
      }
      if (atFrame !== void 0) {
        this.setCurrentFrame(atFrame);
      }
      return this.parent;
    },
    resume: function(fromFrame) {
      if (this._paused) {
        this._paused = false;
        this.isPlaying = this._wasPlaying;
      }
      if (fromFrame !== void 0) {
        this.setCurrentFrame(fromFrame);
      }
      return this.parent;
    },
    playAfterDelay: function(key, delay) {
      if (!this.isPlaying) {
        this.delayCounter = delay;
        this.play(key, true);
      } else {
        var nextAnim = this.nextAnim;
        var queue = this.nextAnimsQueue;
        if (nextAnim) {
          queue.unshift(nextAnim);
        }
        this.nextAnim = key;
        this._pendingStop = 1;
        this._pendingStopValue = delay;
      }
      return this.parent;
    },
    playAfterRepeat: function(key, repeatCount) {
      if (repeatCount === void 0) {
        repeatCount = 1;
      }
      if (!this.isPlaying) {
        this.play(key);
      } else {
        var nextAnim = this.nextAnim;
        var queue = this.nextAnimsQueue;
        if (nextAnim) {
          queue.unshift(nextAnim);
        }
        if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter) {
          repeatCount = this.repeatCounter;
        }
        this.nextAnim = key;
        this._pendingStop = 2;
        this._pendingStopValue = repeatCount;
      }
      return this.parent;
    },
    play: function(key, ignoreIfPlaying) {
      if (ignoreIfPlaying === void 0) {
        ignoreIfPlaying = false;
      }
      var currentAnim = this.currentAnim;
      var parent = this.parent;
      var animKey = typeof key === "string" ? key : key.key;
      if (ignoreIfPlaying && this.isPlaying && currentAnim.key === animKey) {
        return parent;
      }
      if (currentAnim && this.isPlaying) {
        var mix = this.animationManager.getMix(currentAnim.key, key);
        if (mix > 0) {
          return this.playAfterDelay(key, mix);
        }
      }
      this.forward = true;
      this.inReverse = false;
      this._paused = false;
      this._wasPlaying = true;
      return this.startAnimation(key);
    },
    playReverse: function(key, ignoreIfPlaying) {
      if (ignoreIfPlaying === void 0) {
        ignoreIfPlaying = false;
      }
      var animKey = typeof key === "string" ? key : key.key;
      if (ignoreIfPlaying && this.isPlaying && this.currentAnim.key === animKey) {
        return this.parent;
      }
      this.forward = false;
      this.inReverse = true;
      this._paused = false;
      this._wasPlaying = true;
      return this.startAnimation(key);
    },
    startAnimation: function(key) {
      this.load(key);
      var anim = this.currentAnim;
      var gameObject = this.parent;
      if (!anim) {
        return gameObject;
      }
      this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
      anim.getFirstTick(this);
      this.isPlaying = true;
      this.pendingRepeat = false;
      this.hasStarted = false;
      this._pendingStop = 0;
      this._pendingStopValue = 0;
      this._paused = false;
      this.delayCounter += this.delay;
      if (this.delayCounter === 0) {
        this.handleStart();
      }
      return gameObject;
    },
    handleStart: function() {
      if (this.showOnStart) {
        this.parent.setVisible(true);
      }
      this.setCurrentFrame(this.currentFrame);
      this.hasStarted = true;
      this.emitEvents(Events.ANIMATION_START);
    },
    handleRepeat: function() {
      this.pendingRepeat = false;
      this.emitEvents(Events.ANIMATION_REPEAT);
    },
    handleStop: function() {
      this._pendingStop = 0;
      this.isPlaying = false;
      this.emitEvents(Events.ANIMATION_STOP);
    },
    handleComplete: function() {
      this._pendingStop = 0;
      this.isPlaying = false;
      if (this.hideOnComplete) {
        this.parent.setVisible(false);
      }
      this.emitEvents(Events.ANIMATION_COMPLETE, Events.ANIMATION_COMPLETE_KEY);
    },
    emitEvents: function(event, keyEvent) {
      var anim = this.currentAnim;
      var frame = this.currentFrame;
      var gameObject = this.parent;
      var frameKey = frame.textureFrame;
      gameObject.emit(event, anim, frame, gameObject, frameKey);
      if (keyEvent) {
        gameObject.emit(keyEvent + anim.key, anim, frame, gameObject, frameKey);
      }
    },
    reverse: function() {
      if (this.isPlaying) {
        this.inReverse = !this.inReverse;
        this.forward = !this.forward;
      }
      return this.parent;
    },
    getProgress: function() {
      var frame = this.currentFrame;
      if (!frame) {
        return 0;
      }
      var p = frame.progress;
      if (this.inReverse) {
        p *= -1;
      }
      return p;
    },
    setProgress: function(value) {
      if (!this.forward) {
        value = 1 - value;
      }
      this.setCurrentFrame(this.currentAnim.getFrameByProgress(value));
      return this.parent;
    },
    setRepeat: function(value) {
      this.repeatCounter = value === -1 ? Number.MAX_VALUE : value;
      return this.parent;
    },
    globalRemove: function(key, animation) {
      if (animation === void 0) {
        animation = this.currentAnim;
      }
      if (this.isPlaying && animation.key === this.currentAnim.key) {
        this.stop();
        this.setCurrentFrame(this.currentAnim.frames[0]);
      }
    },
    restart: function(includeDelay, resetRepeats) {
      if (includeDelay === void 0) {
        includeDelay = false;
      }
      if (resetRepeats === void 0) {
        resetRepeats = false;
      }
      var anim = this.currentAnim;
      var gameObject = this.parent;
      if (!anim) {
        return gameObject;
      }
      if (resetRepeats) {
        this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
      }
      anim.getFirstTick(this);
      this.emitEvents(Events.ANIMATION_RESTART);
      this.isPlaying = true;
      this.pendingRepeat = false;
      this.hasStarted = !includeDelay;
      this._pendingStop = 0;
      this._pendingStopValue = 0;
      this._paused = false;
      this.setCurrentFrame(anim.frames[0]);
      return this.parent;
    },
    complete: function() {
      this._pendingStop = 0;
      this.isPlaying = false;
      if (this.currentAnim) {
        this.handleComplete();
      }
      if (this.nextAnim) {
        var key = this.nextAnim;
        this.nextAnim = this.nextAnimsQueue.length > 0 ? this.nextAnimsQueue.shift() : null;
        this.play(key);
      }
      return this.parent;
    },
    stop: function() {
      this._pendingStop = 0;
      this.isPlaying = false;
      if (this.currentAnim) {
        this.handleStop();
      }
      if (this.nextAnim) {
        var key = this.nextAnim;
        this.nextAnim = this.nextAnimsQueue.shift();
        this.play(key);
      }
      return this.parent;
    },
    stopAfterDelay: function(delay) {
      this._pendingStop = 1;
      this._pendingStopValue = delay;
      return this.parent;
    },
    stopAfterRepeat: function(repeatCount) {
      if (repeatCount === void 0) {
        repeatCount = 1;
      }
      if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter) {
        repeatCount = this.repeatCounter;
      }
      this._pendingStop = 2;
      this._pendingStopValue = repeatCount;
      return this.parent;
    },
    stopOnFrame: function(frame) {
      this._pendingStop = 3;
      this._pendingStopValue = frame;
      return this.parent;
    },
    getTotalFrames: function() {
      return this.currentAnim ? this.currentAnim.getTotalFrames() : 0;
    },
    update: function(time, delta) {
      var anim = this.currentAnim;
      if (!this.isPlaying || !anim || anim.paused) {
        return;
      }
      this.accumulator += delta * this.timeScale;
      if (this._pendingStop === 1) {
        this._pendingStopValue -= delta;
        if (this._pendingStopValue <= 0) {
          return this.stop();
        }
      }
      if (!this.hasStarted) {
        if (this.accumulator >= this.delayCounter) {
          this.accumulator -= this.delayCounter;
          this.handleStart();
        }
      } else if (this.accumulator >= this.nextTick) {
        if (this.forward) {
          anim.nextFrame(this);
        } else {
          anim.previousFrame(this);
        }
        if (this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator > this.nextTick) {
          var safetyNet = 0;
          do {
            if (this.forward) {
              anim.nextFrame(this);
            } else {
              anim.previousFrame(this);
            }
            safetyNet++;
          } while (this.isPlaying && this.accumulator > this.nextTick && safetyNet < 60);
        }
      }
    },
    setCurrentFrame: function(animationFrame) {
      var gameObject = this.parent;
      this.currentFrame = animationFrame;
      gameObject.texture = animationFrame.frame.texture;
      gameObject.frame = animationFrame.frame;
      if (gameObject.isCropped) {
        gameObject.frame.updateCropUVs(gameObject._crop, gameObject.flipX, gameObject.flipY);
      }
      if (animationFrame.setAlpha) {
        gameObject.alpha = animationFrame.alpha;
      }
      gameObject.setSizeToFrame();
      if (gameObject._originComponent) {
        if (animationFrame.frame.customPivot) {
          gameObject.setOrigin(animationFrame.frame.pivotX, animationFrame.frame.pivotY);
        } else {
          gameObject.updateDisplayOrigin();
        }
      }
      if (this.isPlaying && this.hasStarted) {
        this.emitEvents(Events.ANIMATION_UPDATE);
        if (this._pendingStop === 3 && this._pendingStopValue === animationFrame) {
          this.stop();
        }
      }
      return gameObject;
    },
    nextFrame: function() {
      if (this.currentAnim) {
        this.currentAnim.nextFrame(this);
      }
      return this.parent;
    },
    previousFrame: function() {
      if (this.currentAnim) {
        this.currentAnim.previousFrame(this);
      }
      return this.parent;
    },
    get: function(key) {
      return this.anims ? this.anims.get(key) : null;
    },
    exists: function(key) {
      return this.anims ? this.anims.has(key) : false;
    },
    create: function(config2) {
      var key = config2.key;
      var anim = false;
      if (key) {
        anim = this.get(key);
        if (!anim) {
          anim = new Animation(this, key, config2);
          if (!this.anims) {
            this.anims = new CustomMap();
          }
          this.anims.set(key, anim);
        }
      }
      return anim;
    },
    generateFrameNames: function(key, config2) {
      return this.animationManager.generateFrameNames(key, config2);
    },
    generateFrameNumbers: function(key, config2) {
      return this.animationManager.generateFrameNumbers(key, config2);
    },
    remove: function(key) {
      var anim = this.get(key);
      if (anim) {
        if (this.currentAnim === anim) {
          this.stop();
        }
        this.anims.delete(key);
      }
      return anim;
    },
    destroy: function() {
      this.animationManager.off(Events.REMOVE_ANIMATION, this.globalRemove, this);
      if (this.anims) {
        this.anims.clear();
      }
      this.animationManager = null;
      this.parent = null;
      this.nextAnim = null;
      this.nextAnimsQueue.length = 0;
      this.currentAnim = null;
      this.currentFrame = null;
    },
    isPaused: {
      get: function() {
        return this._paused;
      }
    }
  });
  module2.exports = AnimationState;
});

// node_modules/phaser/src/animations/index.js
var require_animations = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Animation: require_Animation(),
    AnimationFrame: require_AnimationFrame(),
    AnimationManager: require_AnimationManager(),
    AnimationState: require_AnimationState(),
    Events: require_events6()
  };
});

// node_modules/phaser/src/cache/events/ADD_EVENT.js
var require_ADD_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "add";
});

// node_modules/phaser/src/cache/events/REMOVE_EVENT.js
var require_REMOVE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "remove";
});

// node_modules/phaser/src/cache/events/index.js
var require_events7 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ADD: require_ADD_EVENT(),
    REMOVE: require_REMOVE_EVENT()
  };
});

// node_modules/phaser/src/cache/BaseCache.js
var require_BaseCache = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CustomMap = require_Map();
  var EventEmitter = require_eventemitter3();
  var Events = require_events7();
  var BaseCache = new Class({
    initialize: function BaseCache2() {
      this.entries = new CustomMap();
      this.events = new EventEmitter();
    },
    add: function(key, data) {
      this.entries.set(key, data);
      this.events.emit(Events.ADD, this, key, data);
      return this;
    },
    has: function(key) {
      return this.entries.has(key);
    },
    exists: function(key) {
      return this.entries.has(key);
    },
    get: function(key) {
      return this.entries.get(key);
    },
    remove: function(key) {
      var entry = this.get(key);
      if (entry) {
        this.entries.delete(key);
        this.events.emit(Events.REMOVE, this, key, entry.data);
      }
      return this;
    },
    getKeys: function() {
      return this.entries.keys();
    },
    destroy: function() {
      this.entries.clear();
      this.events.removeAllListeners();
      this.entries = null;
      this.events = null;
    }
  });
  module2.exports = BaseCache;
});

// node_modules/phaser/src/cache/CacheManager.js
var require_CacheManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BaseCache = require_BaseCache();
  var Class = require_Class();
  var GameEvents = require_events();
  var CacheManager = new Class({
    initialize: function CacheManager2(game2) {
      this.game = game2;
      this.binary = new BaseCache();
      this.bitmapFont = new BaseCache();
      this.json = new BaseCache();
      this.physics = new BaseCache();
      this.shader = new BaseCache();
      this.audio = new BaseCache();
      this.video = new BaseCache();
      this.text = new BaseCache();
      this.html = new BaseCache();
      this.obj = new BaseCache();
      this.tilemap = new BaseCache();
      this.xml = new BaseCache();
      this.custom = {};
      this.game.events.once(GameEvents.DESTROY, this.destroy, this);
    },
    addCustom: function(key) {
      if (!this.custom.hasOwnProperty(key)) {
        this.custom[key] = new BaseCache();
      }
      return this.custom[key];
    },
    destroy: function() {
      var keys = [
        "binary",
        "bitmapFont",
        "json",
        "physics",
        "shader",
        "audio",
        "video",
        "text",
        "html",
        "obj",
        "tilemap",
        "xml"
      ];
      for (var i = 0; i < keys.length; i++) {
        this[keys[i]].destroy();
        this[keys[i]] = null;
      }
      for (var key in this.custom) {
        this.custom[key].destroy();
      }
      this.custom = null;
      this.game = null;
    }
  });
  module2.exports = CacheManager;
});

// node_modules/phaser/src/cache/index.js
var require_cache = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    BaseCache: require_BaseCache(),
    CacheManager: require_CacheManager(),
    Events: require_events7()
  };
});

// node_modules/phaser/src/cameras/controls/FixedKeyControl.js
var require_FixedKeyControl = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetValue = require_GetValue();
  var FixedKeyControl = new Class({
    initialize: function FixedKeyControl2(config2) {
      this.camera = GetValue(config2, "camera", null);
      this.left = GetValue(config2, "left", null);
      this.right = GetValue(config2, "right", null);
      this.up = GetValue(config2, "up", null);
      this.down = GetValue(config2, "down", null);
      this.zoomIn = GetValue(config2, "zoomIn", null);
      this.zoomOut = GetValue(config2, "zoomOut", null);
      this.zoomSpeed = GetValue(config2, "zoomSpeed", 0.01);
      this.minZoom = GetValue(config2, "minZoom", 1e-3);
      this.maxZoom = GetValue(config2, "maxZoom", 1e3);
      this.speedX = 0;
      this.speedY = 0;
      var speed = GetValue(config2, "speed", null);
      if (typeof speed === "number") {
        this.speedX = speed;
        this.speedY = speed;
      } else {
        this.speedX = GetValue(config2, "speed.x", 0);
        this.speedY = GetValue(config2, "speed.y", 0);
      }
      this._zoom = 0;
      this.active = this.camera !== null;
    },
    start: function() {
      this.active = this.camera !== null;
      return this;
    },
    stop: function() {
      this.active = false;
      return this;
    },
    setCamera: function(camera) {
      this.camera = camera;
      return this;
    },
    update: function(delta) {
      if (!this.active) {
        return;
      }
      if (delta === void 0) {
        delta = 1;
      }
      var cam = this.camera;
      if (this.up && this.up.isDown) {
        cam.scrollY -= this.speedY * delta | 0;
      } else if (this.down && this.down.isDown) {
        cam.scrollY += this.speedY * delta | 0;
      }
      if (this.left && this.left.isDown) {
        cam.scrollX -= this.speedX * delta | 0;
      } else if (this.right && this.right.isDown) {
        cam.scrollX += this.speedX * delta | 0;
      }
      if (this.zoomIn && this.zoomIn.isDown) {
        cam.zoom -= this.zoomSpeed;
        if (cam.zoom < this.minZoom) {
          cam.zoom = this.minZoom;
        }
      } else if (this.zoomOut && this.zoomOut.isDown) {
        cam.zoom += this.zoomSpeed;
        if (cam.zoom > this.maxZoom) {
          cam.zoom = this.maxZoom;
        }
      }
    },
    destroy: function() {
      this.camera = null;
      this.left = null;
      this.right = null;
      this.up = null;
      this.down = null;
      this.zoomIn = null;
      this.zoomOut = null;
    }
  });
  module2.exports = FixedKeyControl;
});

// node_modules/phaser/src/cameras/controls/SmoothedKeyControl.js
var require_SmoothedKeyControl = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetValue = require_GetValue();
  var SmoothedKeyControl = new Class({
    initialize: function SmoothedKeyControl2(config2) {
      this.camera = GetValue(config2, "camera", null);
      this.left = GetValue(config2, "left", null);
      this.right = GetValue(config2, "right", null);
      this.up = GetValue(config2, "up", null);
      this.down = GetValue(config2, "down", null);
      this.zoomIn = GetValue(config2, "zoomIn", null);
      this.zoomOut = GetValue(config2, "zoomOut", null);
      this.zoomSpeed = GetValue(config2, "zoomSpeed", 0.01);
      this.minZoom = GetValue(config2, "minZoom", 1e-3);
      this.maxZoom = GetValue(config2, "maxZoom", 1e3);
      this.accelX = 0;
      this.accelY = 0;
      var accel = GetValue(config2, "acceleration", null);
      if (typeof accel === "number") {
        this.accelX = accel;
        this.accelY = accel;
      } else {
        this.accelX = GetValue(config2, "acceleration.x", 0);
        this.accelY = GetValue(config2, "acceleration.y", 0);
      }
      this.dragX = 0;
      this.dragY = 0;
      var drag = GetValue(config2, "drag", null);
      if (typeof drag === "number") {
        this.dragX = drag;
        this.dragY = drag;
      } else {
        this.dragX = GetValue(config2, "drag.x", 0);
        this.dragY = GetValue(config2, "drag.y", 0);
      }
      this.maxSpeedX = 0;
      this.maxSpeedY = 0;
      var maxSpeed = GetValue(config2, "maxSpeed", null);
      if (typeof maxSpeed === "number") {
        this.maxSpeedX = maxSpeed;
        this.maxSpeedY = maxSpeed;
      } else {
        this.maxSpeedX = GetValue(config2, "maxSpeed.x", 0);
        this.maxSpeedY = GetValue(config2, "maxSpeed.y", 0);
      }
      this._speedX = 0;
      this._speedY = 0;
      this._zoom = 0;
      this.active = this.camera !== null;
    },
    start: function() {
      this.active = this.camera !== null;
      return this;
    },
    stop: function() {
      this.active = false;
      return this;
    },
    setCamera: function(camera) {
      this.camera = camera;
      return this;
    },
    update: function(delta) {
      if (!this.active) {
        return;
      }
      if (delta === void 0) {
        delta = 1;
      }
      var cam = this.camera;
      if (this._speedX > 0) {
        this._speedX -= this.dragX * delta;
        if (this._speedX < 0) {
          this._speedX = 0;
        }
      } else if (this._speedX < 0) {
        this._speedX += this.dragX * delta;
        if (this._speedX > 0) {
          this._speedX = 0;
        }
      }
      if (this._speedY > 0) {
        this._speedY -= this.dragY * delta;
        if (this._speedY < 0) {
          this._speedY = 0;
        }
      } else if (this._speedY < 0) {
        this._speedY += this.dragY * delta;
        if (this._speedY > 0) {
          this._speedY = 0;
        }
      }
      if (this.up && this.up.isDown) {
        this._speedY += this.accelY;
        if (this._speedY > this.maxSpeedY) {
          this._speedY = this.maxSpeedY;
        }
      } else if (this.down && this.down.isDown) {
        this._speedY -= this.accelY;
        if (this._speedY < -this.maxSpeedY) {
          this._speedY = -this.maxSpeedY;
        }
      }
      if (this.left && this.left.isDown) {
        this._speedX += this.accelX;
        if (this._speedX > this.maxSpeedX) {
          this._speedX = this.maxSpeedX;
        }
      } else if (this.right && this.right.isDown) {
        this._speedX -= this.accelX;
        if (this._speedX < -this.maxSpeedX) {
          this._speedX = -this.maxSpeedX;
        }
      }
      if (this.zoomIn && this.zoomIn.isDown) {
        this._zoom = -this.zoomSpeed;
      } else if (this.zoomOut && this.zoomOut.isDown) {
        this._zoom = this.zoomSpeed;
      } else {
        this._zoom = 0;
      }
      if (this._speedX !== 0) {
        cam.scrollX -= this._speedX * delta | 0;
      }
      if (this._speedY !== 0) {
        cam.scrollY -= this._speedY * delta | 0;
      }
      if (this._zoom !== 0) {
        cam.zoom += this._zoom;
        if (cam.zoom < this.minZoom) {
          cam.zoom = this.minZoom;
        } else if (cam.zoom > this.maxZoom) {
          cam.zoom = this.maxZoom;
        }
      }
    },
    destroy: function() {
      this.camera = null;
      this.left = null;
      this.right = null;
      this.up = null;
      this.down = null;
      this.zoomIn = null;
      this.zoomOut = null;
    }
  });
  module2.exports = SmoothedKeyControl;
});

// node_modules/phaser/src/cameras/controls/index.js
var require_controls = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    FixedKeyControl: require_FixedKeyControl(),
    SmoothedKeyControl: require_SmoothedKeyControl()
  };
});

// node_modules/phaser/src/cameras/2d/events/DESTROY_EVENT.js
var require_DESTROY_EVENT5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "cameradestroy";
});

// node_modules/phaser/src/cameras/2d/events/FADE_IN_COMPLETE_EVENT.js
var require_FADE_IN_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "camerafadeincomplete";
});

// node_modules/phaser/src/cameras/2d/events/FADE_IN_START_EVENT.js
var require_FADE_IN_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "camerafadeinstart";
});

// node_modules/phaser/src/cameras/2d/events/FADE_OUT_COMPLETE_EVENT.js
var require_FADE_OUT_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "camerafadeoutcomplete";
});

// node_modules/phaser/src/cameras/2d/events/FADE_OUT_START_EVENT.js
var require_FADE_OUT_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "camerafadeoutstart";
});

// node_modules/phaser/src/cameras/2d/events/FLASH_COMPLETE_EVENT.js
var require_FLASH_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "cameraflashcomplete";
});

// node_modules/phaser/src/cameras/2d/events/FLASH_START_EVENT.js
var require_FLASH_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "cameraflashstart";
});

// node_modules/phaser/src/cameras/2d/events/FOLLOW_UPDATE_EVENT.js
var require_FOLLOW_UPDATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "followupdate";
});

// node_modules/phaser/src/cameras/2d/events/PAN_COMPLETE_EVENT.js
var require_PAN_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "camerapancomplete";
});

// node_modules/phaser/src/cameras/2d/events/PAN_START_EVENT.js
var require_PAN_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "camerapanstart";
});

// node_modules/phaser/src/cameras/2d/events/POST_RENDER_EVENT.js
var require_POST_RENDER_EVENT3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "postrender";
});

// node_modules/phaser/src/cameras/2d/events/PRE_RENDER_EVENT.js
var require_PRE_RENDER_EVENT4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "prerender";
});

// node_modules/phaser/src/cameras/2d/events/ROTATE_COMPLETE_EVENT.js
var require_ROTATE_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "camerarotatecomplete";
});

// node_modules/phaser/src/cameras/2d/events/ROTATE_START_EVENT.js
var require_ROTATE_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "camerarotatestart";
});

// node_modules/phaser/src/cameras/2d/events/SHAKE_COMPLETE_EVENT.js
var require_SHAKE_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "camerashakecomplete";
});

// node_modules/phaser/src/cameras/2d/events/SHAKE_START_EVENT.js
var require_SHAKE_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "camerashakestart";
});

// node_modules/phaser/src/cameras/2d/events/ZOOM_COMPLETE_EVENT.js
var require_ZOOM_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "camerazoomcomplete";
});

// node_modules/phaser/src/cameras/2d/events/ZOOM_START_EVENT.js
var require_ZOOM_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "camerazoomstart";
});

// node_modules/phaser/src/cameras/2d/events/index.js
var require_events8 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    DESTROY: require_DESTROY_EVENT5(),
    FADE_IN_COMPLETE: require_FADE_IN_COMPLETE_EVENT(),
    FADE_IN_START: require_FADE_IN_START_EVENT(),
    FADE_OUT_COMPLETE: require_FADE_OUT_COMPLETE_EVENT(),
    FADE_OUT_START: require_FADE_OUT_START_EVENT(),
    FLASH_COMPLETE: require_FLASH_COMPLETE_EVENT(),
    FLASH_START: require_FLASH_START_EVENT(),
    FOLLOW_UPDATE: require_FOLLOW_UPDATE_EVENT(),
    PAN_COMPLETE: require_PAN_COMPLETE_EVENT(),
    PAN_START: require_PAN_START_EVENT(),
    POST_RENDER: require_POST_RENDER_EVENT3(),
    PRE_RENDER: require_PRE_RENDER_EVENT4(),
    ROTATE_COMPLETE: require_ROTATE_COMPLETE_EVENT(),
    ROTATE_START: require_ROTATE_START_EVENT(),
    SHAKE_COMPLETE: require_SHAKE_COMPLETE_EVENT(),
    SHAKE_START: require_SHAKE_START_EVENT(),
    ZOOM_COMPLETE: require_ZOOM_COMPLETE_EVENT(),
    ZOOM_START: require_ZOOM_START_EVENT()
  };
});

// node_modules/phaser/src/display/color/GetColor.js
var require_GetColor = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetColor = function(red, green, blue) {
    return red << 16 | green << 8 | blue;
  };
  module2.exports = GetColor;
});

// node_modules/phaser/src/display/color/GetColor32.js
var require_GetColor32 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetColor32 = function(red, green, blue, alpha) {
    return alpha << 24 | red << 16 | green << 8 | blue;
  };
  module2.exports = GetColor32;
});

// node_modules/phaser/src/display/color/HSVToRGB.js
var require_HSVToRGB = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetColor = require_GetColor();
  function ConvertValue(n, h, s, v) {
    var k = (n + h * 6) % 6;
    var min = Math.min(k, 4 - k, 1);
    return Math.round(255 * (v - v * s * Math.max(0, min)));
  }
  var HSVToRGB = function(h, s, v, out) {
    if (s === void 0) {
      s = 1;
    }
    if (v === void 0) {
      v = 1;
    }
    var r = ConvertValue(5, h, s, v);
    var g = ConvertValue(3, h, s, v);
    var b = ConvertValue(1, h, s, v);
    if (!out) {
      return {r, g, b, color: GetColor(r, g, b)};
    } else if (out.setTo) {
      return out.setTo(r, g, b, out.alpha, false);
    } else {
      out.r = r;
      out.g = g;
      out.b = b;
      out.color = GetColor(r, g, b);
      return out;
    }
  };
  module2.exports = HSVToRGB;
});

// node_modules/phaser/src/display/color/RGBToHSV.js
var require_RGBToHSV = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RGBToHSV = function(r, g, b, out) {
    if (out === void 0) {
      out = {h: 0, s: 0, v: 0};
    }
    r /= 255;
    g /= 255;
    b /= 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var d = max - min;
    var h = 0;
    var s = max === 0 ? 0 : d / max;
    var v = max;
    if (max !== min) {
      if (max === r) {
        h = (g - b) / d + (g < b ? 6 : 0);
      } else if (max === g) {
        h = (b - r) / d + 2;
      } else if (max === b) {
        h = (r - g) / d + 4;
      }
      h /= 6;
    }
    if (out.hasOwnProperty("_h")) {
      out._h = h;
      out._s = s;
      out._v = v;
    } else {
      out.h = h;
      out.s = s;
      out.v = v;
    }
    return out;
  };
  module2.exports = RGBToHSV;
});

// node_modules/phaser/src/display/color/Color.js
var require_Color = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetColor = require_GetColor();
  var GetColor32 = require_GetColor32();
  var HSVToRGB = require_HSVToRGB();
  var RGBToHSV = require_RGBToHSV();
  var Color = new Class({
    initialize: function Color2(red, green, blue, alpha) {
      if (red === void 0) {
        red = 0;
      }
      if (green === void 0) {
        green = 0;
      }
      if (blue === void 0) {
        blue = 0;
      }
      if (alpha === void 0) {
        alpha = 255;
      }
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 255;
      this._h = 0;
      this._s = 0;
      this._v = 0;
      this._locked = false;
      this.gl = [0, 0, 0, 1];
      this._color = 0;
      this._color32 = 0;
      this._rgba = "";
      this.setTo(red, green, blue, alpha);
    },
    transparent: function() {
      this._locked = true;
      this.red = 0;
      this.green = 0;
      this.blue = 0;
      this.alpha = 0;
      this._locked = false;
      return this.update(true);
    },
    setTo: function(red, green, blue, alpha, updateHSV) {
      if (alpha === void 0) {
        alpha = 255;
      }
      if (updateHSV === void 0) {
        updateHSV = true;
      }
      this._locked = true;
      this.red = red;
      this.green = green;
      this.blue = blue;
      this.alpha = alpha;
      this._locked = false;
      return this.update(updateHSV);
    },
    setGLTo: function(red, green, blue, alpha) {
      if (alpha === void 0) {
        alpha = 1;
      }
      this._locked = true;
      this.redGL = red;
      this.greenGL = green;
      this.blueGL = blue;
      this.alphaGL = alpha;
      this._locked = false;
      return this.update(true);
    },
    setFromRGB: function(color) {
      this._locked = true;
      this.red = color.r;
      this.green = color.g;
      this.blue = color.b;
      if (color.hasOwnProperty("a")) {
        this.alpha = color.a;
      }
      this._locked = false;
      return this.update(true);
    },
    setFromHSV: function(h, s, v) {
      return HSVToRGB(h, s, v, this);
    },
    update: function(updateHSV) {
      if (updateHSV === void 0) {
        updateHSV = false;
      }
      if (this._locked) {
        return this;
      }
      var r = this.r;
      var g = this.g;
      var b = this.b;
      var a = this.a;
      this._color = GetColor(r, g, b);
      this._color32 = GetColor32(r, g, b, a);
      this._rgba = "rgba(" + r + "," + g + "," + b + "," + a / 255 + ")";
      if (updateHSV) {
        RGBToHSV(r, g, b, this);
      }
      return this;
    },
    updateHSV: function() {
      var r = this.r;
      var g = this.g;
      var b = this.b;
      RGBToHSV(r, g, b, this);
      return this;
    },
    clone: function() {
      return new Color(this.r, this.g, this.b, this.a);
    },
    gray: function(shade) {
      return this.setTo(shade, shade, shade);
    },
    random: function(min, max) {
      if (min === void 0) {
        min = 0;
      }
      if (max === void 0) {
        max = 255;
      }
      var r = Math.floor(min + Math.random() * (max - min));
      var g = Math.floor(min + Math.random() * (max - min));
      var b = Math.floor(min + Math.random() * (max - min));
      return this.setTo(r, g, b);
    },
    randomGray: function(min, max) {
      if (min === void 0) {
        min = 0;
      }
      if (max === void 0) {
        max = 255;
      }
      var s = Math.floor(min + Math.random() * (max - min));
      return this.setTo(s, s, s);
    },
    saturate: function(amount) {
      this.s += amount / 100;
      return this;
    },
    desaturate: function(amount) {
      this.s -= amount / 100;
      return this;
    },
    lighten: function(amount) {
      this.v += amount / 100;
      return this;
    },
    darken: function(amount) {
      this.v -= amount / 100;
      return this;
    },
    brighten: function(amount) {
      var r = this.r;
      var g = this.g;
      var b = this.b;
      r = Math.max(0, Math.min(255, r - Math.round(255 * -(amount / 100))));
      g = Math.max(0, Math.min(255, g - Math.round(255 * -(amount / 100))));
      b = Math.max(0, Math.min(255, b - Math.round(255 * -(amount / 100))));
      return this.setTo(r, g, b);
    },
    color: {
      get: function() {
        return this._color;
      }
    },
    color32: {
      get: function() {
        return this._color32;
      }
    },
    rgba: {
      get: function() {
        return this._rgba;
      }
    },
    redGL: {
      get: function() {
        return this.gl[0];
      },
      set: function(value) {
        this.gl[0] = Math.min(Math.abs(value), 1);
        this.r = Math.floor(this.gl[0] * 255);
        this.update(true);
      }
    },
    greenGL: {
      get: function() {
        return this.gl[1];
      },
      set: function(value) {
        this.gl[1] = Math.min(Math.abs(value), 1);
        this.g = Math.floor(this.gl[1] * 255);
        this.update(true);
      }
    },
    blueGL: {
      get: function() {
        return this.gl[2];
      },
      set: function(value) {
        this.gl[2] = Math.min(Math.abs(value), 1);
        this.b = Math.floor(this.gl[2] * 255);
        this.update(true);
      }
    },
    alphaGL: {
      get: function() {
        return this.gl[3];
      },
      set: function(value) {
        this.gl[3] = Math.min(Math.abs(value), 1);
        this.a = Math.floor(this.gl[3] * 255);
        this.update();
      }
    },
    red: {
      get: function() {
        return this.r;
      },
      set: function(value) {
        value = Math.floor(Math.abs(value));
        this.r = Math.min(value, 255);
        this.gl[0] = value / 255;
        this.update(true);
      }
    },
    green: {
      get: function() {
        return this.g;
      },
      set: function(value) {
        value = Math.floor(Math.abs(value));
        this.g = Math.min(value, 255);
        this.gl[1] = value / 255;
        this.update(true);
      }
    },
    blue: {
      get: function() {
        return this.b;
      },
      set: function(value) {
        value = Math.floor(Math.abs(value));
        this.b = Math.min(value, 255);
        this.gl[2] = value / 255;
        this.update(true);
      }
    },
    alpha: {
      get: function() {
        return this.a;
      },
      set: function(value) {
        value = Math.floor(Math.abs(value));
        this.a = Math.min(value, 255);
        this.gl[3] = value / 255;
        this.update();
      }
    },
    h: {
      get: function() {
        return this._h;
      },
      set: function(value) {
        this._h = value;
        HSVToRGB(value, this._s, this._v, this);
      }
    },
    s: {
      get: function() {
        return this._s;
      },
      set: function(value) {
        this._s = value;
        HSVToRGB(this._h, value, this._v, this);
      }
    },
    v: {
      get: function() {
        return this._v;
      },
      set: function(value) {
        this._v = value;
        HSVToRGB(this._h, this._s, value, this);
      }
    }
  });
  module2.exports = Color;
});

// node_modules/phaser/src/display/color/HexStringToColor.js
var require_HexStringToColor = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Color = require_Color();
  var HexStringToColor = function(hex) {
    var color = new Color();
    hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r2, g2, b2) {
      return r2 + r2 + g2 + g2 + b2 + b2;
    });
    var result = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (result) {
      var r = parseInt(result[1], 16);
      var g = parseInt(result[2], 16);
      var b = parseInt(result[3], 16);
      color.setTo(r, g, b);
    }
    return color;
  };
  module2.exports = HexStringToColor;
});

// node_modules/phaser/src/display/color/IntegerToRGB.js
var require_IntegerToRGB = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var IntegerToRGB = function(color) {
    if (color > 16777215) {
      return {
        a: color >>> 24,
        r: color >> 16 & 255,
        g: color >> 8 & 255,
        b: color & 255
      };
    } else {
      return {
        a: 255,
        r: color >> 16 & 255,
        g: color >> 8 & 255,
        b: color & 255
      };
    }
  };
  module2.exports = IntegerToRGB;
});

// node_modules/phaser/src/display/color/IntegerToColor.js
var require_IntegerToColor = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Color = require_Color();
  var IntegerToRGB = require_IntegerToRGB();
  var IntegerToColor = function(input) {
    var rgb = IntegerToRGB(input);
    return new Color(rgb.r, rgb.g, rgb.b, rgb.a);
  };
  module2.exports = IntegerToColor;
});

// node_modules/phaser/src/display/color/ObjectToColor.js
var require_ObjectToColor = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Color = require_Color();
  var ObjectToColor = function(input) {
    return new Color(input.r, input.g, input.b, input.a);
  };
  module2.exports = ObjectToColor;
});

// node_modules/phaser/src/display/color/RGBStringToColor.js
var require_RGBStringToColor = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Color = require_Color();
  var RGBStringToColor = function(rgb) {
    var color = new Color();
    var result = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(rgb.toLowerCase());
    if (result) {
      var r = parseInt(result[1], 10);
      var g = parseInt(result[2], 10);
      var b = parseInt(result[3], 10);
      var a = result[4] !== void 0 ? parseFloat(result[4]) : 1;
      color.setTo(r, g, b, a * 255);
    }
    return color;
  };
  module2.exports = RGBStringToColor;
});

// node_modules/phaser/src/display/color/ValueToColor.js
var require_ValueToColor = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var HexStringToColor = require_HexStringToColor();
  var IntegerToColor = require_IntegerToColor();
  var ObjectToColor = require_ObjectToColor();
  var RGBStringToColor = require_RGBStringToColor();
  var ValueToColor = function(input) {
    var t = typeof input;
    switch (t) {
      case "string":
        if (input.substr(0, 3).toLowerCase() === "rgb") {
          return RGBStringToColor(input);
        } else {
          return HexStringToColor(input);
        }
      case "number":
        return IntegerToColor(input);
      case "object":
        return ObjectToColor(input);
    }
  };
  module2.exports = ValueToColor;
});

// node_modules/phaser/src/cameras/2d/BaseCamera.js
var require_BaseCamera = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components();
  var DegToRad = require_DegToRad();
  var EventEmitter = require_eventemitter3();
  var Events = require_events8();
  var Rectangle = require_Rectangle();
  var TransformMatrix = require_TransformMatrix();
  var ValueToColor = require_ValueToColor();
  var Vector2 = require_Vector2();
  var BaseCamera = new Class({
    Extends: EventEmitter,
    Mixins: [
      Components.Alpha,
      Components.Visible
    ],
    initialize: function BaseCamera2(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      EventEmitter.call(this);
      this.scene;
      this.sceneManager;
      this.scaleManager;
      this.cameraManager;
      this.id = 0;
      this.name = "";
      this.roundPixels = false;
      this.useBounds = false;
      this.worldView = new Rectangle();
      this.dirty = true;
      this._x = x;
      this._y = y;
      this._width = width;
      this._height = height;
      this._bounds = new Rectangle();
      this._scrollX = 0;
      this._scrollY = 0;
      this._zoomX = 1;
      this._zoomY = 1;
      this._rotation = 0;
      this.matrix = new TransformMatrix();
      this.transparent = true;
      this.backgroundColor = ValueToColor("rgba(0,0,0,0)");
      this.disableCull = false;
      this.culledObjects = [];
      this.midPoint = new Vector2(width / 2, height / 2);
      this.originX = 0.5;
      this.originY = 0.5;
      this._customViewport = false;
      this.mask = null;
      this._maskCamera = null;
      this.renderList = [];
    },
    addToRenderList: function(child) {
      this.renderList.push(child);
    },
    setOrigin: function(x, y) {
      if (x === void 0) {
        x = 0.5;
      }
      if (y === void 0) {
        y = x;
      }
      this.originX = x;
      this.originY = y;
      return this;
    },
    getScroll: function(x, y, out) {
      if (out === void 0) {
        out = new Vector2();
      }
      var originX = this.width * 0.5;
      var originY = this.height * 0.5;
      out.x = x - originX;
      out.y = y - originY;
      if (this.useBounds) {
        out.x = this.clampX(out.x);
        out.y = this.clampY(out.y);
      }
      return out;
    },
    centerOnX: function(x) {
      var originX = this.width * 0.5;
      this.midPoint.x = x;
      this.scrollX = x - originX;
      if (this.useBounds) {
        this.scrollX = this.clampX(this.scrollX);
      }
      return this;
    },
    centerOnY: function(y) {
      var originY = this.height * 0.5;
      this.midPoint.y = y;
      this.scrollY = y - originY;
      if (this.useBounds) {
        this.scrollY = this.clampY(this.scrollY);
      }
      return this;
    },
    centerOn: function(x, y) {
      this.centerOnX(x);
      this.centerOnY(y);
      return this;
    },
    centerToBounds: function() {
      if (this.useBounds) {
        var bounds = this._bounds;
        var originX = this.width * 0.5;
        var originY = this.height * 0.5;
        this.midPoint.set(bounds.centerX, bounds.centerY);
        this.scrollX = bounds.centerX - originX;
        this.scrollY = bounds.centerY - originY;
      }
      return this;
    },
    centerToSize: function() {
      this.scrollX = this.width * 0.5;
      this.scrollY = this.height * 0.5;
      return this;
    },
    cull: function(renderableObjects) {
      if (this.disableCull) {
        return renderableObjects;
      }
      var cameraMatrix = this.matrix.matrix;
      var mva = cameraMatrix[0];
      var mvb = cameraMatrix[1];
      var mvc = cameraMatrix[2];
      var mvd = cameraMatrix[3];
      var determinant = mva * mvd - mvb * mvc;
      if (!determinant) {
        return renderableObjects;
      }
      var mve = cameraMatrix[4];
      var mvf = cameraMatrix[5];
      var scrollX = this.scrollX;
      var scrollY = this.scrollY;
      var cameraW = this.width;
      var cameraH = this.height;
      var cullTop = this.y;
      var cullBottom = cullTop + cameraH;
      var cullLeft = this.x;
      var cullRight = cullLeft + cameraW;
      var culledObjects = this.culledObjects;
      var length = renderableObjects.length;
      determinant = 1 / determinant;
      culledObjects.length = 0;
      for (var index = 0; index < length; ++index) {
        var object = renderableObjects[index];
        if (!object.hasOwnProperty("width") || object.parentContainer) {
          culledObjects.push(object);
          continue;
        }
        var objectW = object.width;
        var objectH = object.height;
        var objectX = object.x - scrollX * object.scrollFactorX - objectW * object.originX;
        var objectY = object.y - scrollY * object.scrollFactorY - objectH * object.originY;
        var tx = objectX * mva + objectY * mvc + mve;
        var ty = objectX * mvb + objectY * mvd + mvf;
        var tw = (objectX + objectW) * mva + (objectY + objectH) * mvc + mve;
        var th = (objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf;
        if (tw > cullLeft && tx < cullRight && (th > cullTop && ty < cullBottom)) {
          culledObjects.push(object);
        }
      }
      return culledObjects;
    },
    getWorldPoint: function(x, y, output) {
      if (output === void 0) {
        output = new Vector2();
      }
      var cameraMatrix = this.matrix.matrix;
      var mva = cameraMatrix[0];
      var mvb = cameraMatrix[1];
      var mvc = cameraMatrix[2];
      var mvd = cameraMatrix[3];
      var mve = cameraMatrix[4];
      var mvf = cameraMatrix[5];
      var determinant = mva * mvd - mvb * mvc;
      if (!determinant) {
        output.x = x;
        output.y = y;
        return output;
      }
      determinant = 1 / determinant;
      var ima = mvd * determinant;
      var imb = -mvb * determinant;
      var imc = -mvc * determinant;
      var imd = mva * determinant;
      var ime = (mvc * mvf - mvd * mve) * determinant;
      var imf = (mvb * mve - mva * mvf) * determinant;
      var c = Math.cos(this.rotation);
      var s = Math.sin(this.rotation);
      var zoomX = this.zoomX;
      var zoomY = this.zoomY;
      var scrollX = this.scrollX;
      var scrollY = this.scrollY;
      var sx = x + (scrollX * c - scrollY * s) * zoomX;
      var sy = y + (scrollX * s + scrollY * c) * zoomY;
      output.x = sx * ima + sy * imc + ime;
      output.y = sx * imb + sy * imd + imf;
      return output;
    },
    ignore: function(entries) {
      var id = this.id;
      if (!Array.isArray(entries)) {
        entries = [entries];
      }
      for (var i = 0; i < entries.length; i++) {
        var entry = entries[i];
        if (Array.isArray(entry)) {
          this.ignore(entry);
        } else if (entry.isParent) {
          this.ignore(entry.getChildren());
        } else {
          entry.cameraFilter |= id;
        }
      }
      return this;
    },
    preRender: function() {
      this.renderList.length = 0;
      var width = this.width;
      var height = this.height;
      var halfWidth = width * 0.5;
      var halfHeight = height * 0.5;
      var zoomX = this.zoomX;
      var zoomY = this.zoomY;
      var matrix = this.matrix;
      var originX = width * this.originX;
      var originY = height * this.originY;
      var sx = this.scrollX;
      var sy = this.scrollY;
      if (this.useBounds) {
        sx = this.clampX(sx);
        sy = this.clampY(sy);
      }
      if (this.roundPixels) {
        originX = Math.round(originX);
        originY = Math.round(originY);
      }
      this.scrollX = sx;
      this.scrollY = sy;
      var midX = sx + halfWidth;
      var midY = sy + halfHeight;
      this.midPoint.set(midX, midY);
      var displayWidth = width / zoomX;
      var displayHeight = height / zoomY;
      this.worldView.setTo(midX - displayWidth / 2, midY - displayHeight / 2, displayWidth, displayHeight);
      matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoomX, zoomY);
      matrix.translate(-originX, -originY);
    },
    clampX: function(x) {
      var bounds = this._bounds;
      var dw = this.displayWidth;
      var bx = bounds.x + (dw - this.width) / 2;
      var bw = Math.max(bx, bx + bounds.width - dw);
      if (x < bx) {
        x = bx;
      } else if (x > bw) {
        x = bw;
      }
      return x;
    },
    clampY: function(y) {
      var bounds = this._bounds;
      var dh = this.displayHeight;
      var by = bounds.y + (dh - this.height) / 2;
      var bh = Math.max(by, by + bounds.height - dh);
      if (y < by) {
        y = by;
      } else if (y > bh) {
        y = bh;
      }
      return y;
    },
    removeBounds: function() {
      this.useBounds = false;
      this.dirty = true;
      this._bounds.setEmpty();
      return this;
    },
    setAngle: function(value) {
      if (value === void 0) {
        value = 0;
      }
      this.rotation = DegToRad(value);
      return this;
    },
    setBackgroundColor: function(color) {
      if (color === void 0) {
        color = "rgba(0,0,0,0)";
      }
      this.backgroundColor = ValueToColor(color);
      this.transparent = this.backgroundColor.alpha === 0;
      return this;
    },
    setBounds: function(x, y, width, height, centerOn) {
      if (centerOn === void 0) {
        centerOn = false;
      }
      this._bounds.setTo(x, y, width, height);
      this.dirty = true;
      this.useBounds = true;
      if (centerOn) {
        this.centerToBounds();
      } else {
        this.scrollX = this.clampX(this.scrollX);
        this.scrollY = this.clampY(this.scrollY);
      }
      return this;
    },
    getBounds: function(out) {
      if (out === void 0) {
        out = new Rectangle();
      }
      var source = this._bounds;
      out.setTo(source.x, source.y, source.width, source.height);
      return out;
    },
    setName: function(value) {
      if (value === void 0) {
        value = "";
      }
      this.name = value;
      return this;
    },
    setPosition: function(x, y) {
      if (y === void 0) {
        y = x;
      }
      this.x = x;
      this.y = y;
      return this;
    },
    setRotation: function(value) {
      if (value === void 0) {
        value = 0;
      }
      this.rotation = value;
      return this;
    },
    setRoundPixels: function(value) {
      this.roundPixels = value;
      return this;
    },
    setScene: function(scene) {
      if (this.scene && this._customViewport) {
        this.sceneManager.customViewports--;
      }
      this.scene = scene;
      var sys = scene.sys;
      this.sceneManager = sys.game.scene;
      this.scaleManager = sys.scale;
      this.cameraManager = sys.cameras;
      this.updateSystem();
      return this;
    },
    setScroll: function(x, y) {
      if (y === void 0) {
        y = x;
      }
      this.scrollX = x;
      this.scrollY = y;
      return this;
    },
    setSize: function(width, height) {
      if (height === void 0) {
        height = width;
      }
      this.width = width;
      this.height = height;
      return this;
    },
    setViewport: function(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      return this;
    },
    setZoom: function(x, y) {
      if (x === void 0) {
        x = 1;
      }
      if (y === void 0) {
        y = x;
      }
      if (x === 0) {
        x = 1e-3;
      }
      if (y === 0) {
        y = 1e-3;
      }
      this.zoomX = x;
      this.zoomY = y;
      return this;
    },
    setMask: function(mask, fixedPosition) {
      if (fixedPosition === void 0) {
        fixedPosition = true;
      }
      this.mask = mask;
      this._maskCamera = fixedPosition ? this.cameraManager.default : this;
      return this;
    },
    clearMask: function(destroyMask) {
      if (destroyMask === void 0) {
        destroyMask = false;
      }
      if (destroyMask && this.mask) {
        this.mask.destroy();
      }
      this.mask = null;
      return this;
    },
    toJSON: function() {
      var output = {
        name: this.name,
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height,
        zoom: this.zoom,
        rotation: this.rotation,
        roundPixels: this.roundPixels,
        scrollX: this.scrollX,
        scrollY: this.scrollY,
        backgroundColor: this.backgroundColor.rgba
      };
      if (this.useBounds) {
        output["bounds"] = {
          x: this._bounds.x,
          y: this._bounds.y,
          width: this._bounds.width,
          height: this._bounds.height
        };
      }
      return output;
    },
    update: function() {
    },
    updateSystem: function() {
      if (!this.scaleManager) {
        return;
      }
      var custom = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height;
      var sceneManager = this.sceneManager;
      if (custom && !this._customViewport) {
        sceneManager.customViewports++;
      } else if (!custom && this._customViewport) {
        sceneManager.customViewports--;
      }
      this.dirty = true;
      this._customViewport = custom;
    },
    destroy: function() {
      this.emit(Events.DESTROY, this);
      this.removeAllListeners();
      this.matrix.destroy();
      this.culledObjects = [];
      if (this._customViewport) {
        this.sceneManager.customViewports--;
      }
      this.renderList = [];
      this._bounds = null;
      this.scene = null;
      this.scaleManager = null;
      this.sceneManager = null;
      this.cameraManager = null;
    },
    x: {
      get: function() {
        return this._x;
      },
      set: function(value) {
        this._x = value;
        this.updateSystem();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(value) {
        this._y = value;
        this.updateSystem();
      }
    },
    width: {
      get: function() {
        return this._width;
      },
      set: function(value) {
        this._width = value;
        this.updateSystem();
      }
    },
    height: {
      get: function() {
        return this._height;
      },
      set: function(value) {
        this._height = value;
        this.updateSystem();
      }
    },
    scrollX: {
      get: function() {
        return this._scrollX;
      },
      set: function(value) {
        this._scrollX = value;
        this.dirty = true;
      }
    },
    scrollY: {
      get: function() {
        return this._scrollY;
      },
      set: function(value) {
        this._scrollY = value;
        this.dirty = true;
      }
    },
    zoom: {
      get: function() {
        return (this._zoomX + this._zoomY) / 2;
      },
      set: function(value) {
        this._zoomX = value;
        this._zoomY = value;
        this.dirty = true;
      }
    },
    zoomX: {
      get: function() {
        return this._zoomX;
      },
      set: function(value) {
        this._zoomX = value;
        this.dirty = true;
      }
    },
    zoomY: {
      get: function() {
        return this._zoomY;
      },
      set: function(value) {
        this._zoomY = value;
        this.dirty = true;
      }
    },
    rotation: {
      get: function() {
        return this._rotation;
      },
      set: function(value) {
        this._rotation = value;
        this.dirty = true;
      }
    },
    centerX: {
      get: function() {
        return this.x + 0.5 * this.width;
      }
    },
    centerY: {
      get: function() {
        return this.y + 0.5 * this.height;
      }
    },
    displayWidth: {
      get: function() {
        return this.width / this.zoomX;
      }
    },
    displayHeight: {
      get: function() {
        return this.height / this.zoomY;
      }
    }
  });
  module2.exports = BaseCamera;
});

// node_modules/phaser/src/geom/rectangle/CenterOn.js
var require_CenterOn2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CenterOn = function(rect, x, y) {
    rect.x = x - rect.width / 2;
    rect.y = y - rect.height / 2;
    return rect;
  };
  module2.exports = CenterOn;
});

// node_modules/phaser/src/cameras/2d/effects/Fade.js
var require_Fade = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = require_Clamp();
  var Class = require_Class();
  var Events = require_events8();
  var Fade = new Class({
    initialize: function Fade2(camera) {
      this.camera = camera;
      this.isRunning = false;
      this.isComplete = false;
      this.direction = true;
      this.duration = 0;
      this.red = 0;
      this.green = 0;
      this.blue = 0;
      this.alpha = 0;
      this.progress = 0;
      this._elapsed = 0;
      this._onUpdate;
      this._onUpdateScope;
    },
    start: function(direction, duration, red, green, blue, force, callback, context) {
      if (direction === void 0) {
        direction = true;
      }
      if (duration === void 0) {
        duration = 1e3;
      }
      if (red === void 0) {
        red = 0;
      }
      if (green === void 0) {
        green = 0;
      }
      if (blue === void 0) {
        blue = 0;
      }
      if (force === void 0) {
        force = false;
      }
      if (callback === void 0) {
        callback = null;
      }
      if (context === void 0) {
        context = this.camera.scene;
      }
      if (!force && this.isRunning) {
        return this.camera;
      }
      this.isRunning = true;
      this.isComplete = false;
      this.duration = duration;
      this.direction = direction;
      this.progress = 0;
      this.red = red;
      this.green = green;
      this.blue = blue;
      this.alpha = direction ? Number.MIN_VALUE : 1;
      this._elapsed = 0;
      this._onUpdate = callback;
      this._onUpdateScope = context;
      var eventName = direction ? Events.FADE_OUT_START : Events.FADE_IN_START;
      this.camera.emit(eventName, this.camera, this, duration, red, green, blue);
      return this.camera;
    },
    update: function(time, delta) {
      if (!this.isRunning) {
        return;
      }
      this._elapsed += delta;
      this.progress = Clamp(this._elapsed / this.duration, 0, 1);
      if (this._onUpdate) {
        this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
      }
      if (this._elapsed < this.duration) {
        this.alpha = this.direction ? this.progress : 1 - this.progress;
      } else {
        this.alpha = this.direction ? 1 : 0;
        this.effectComplete();
      }
    },
    postRenderCanvas: function(ctx) {
      if (!this.isRunning && !this.isComplete) {
        return false;
      }
      var camera = this.camera;
      ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
      ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
      return true;
    },
    postRenderWebGL: function(pipeline, getTintFunction) {
      if (!this.isRunning && !this.isComplete) {
        return false;
      }
      var camera = this.camera;
      var red = this.red / 255;
      var green = this.green / 255;
      var blue = this.blue / 255;
      pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha);
      return true;
    },
    effectComplete: function() {
      this._onUpdate = null;
      this._onUpdateScope = null;
      this.isRunning = false;
      this.isComplete = true;
      var eventName = this.direction ? Events.FADE_OUT_COMPLETE : Events.FADE_IN_COMPLETE;
      this.camera.emit(eventName, this.camera, this);
    },
    reset: function() {
      this.isRunning = false;
      this.isComplete = false;
      this._onUpdate = null;
      this._onUpdateScope = null;
    },
    destroy: function() {
      this.reset();
      this.camera = null;
    }
  });
  module2.exports = Fade;
});

// node_modules/phaser/src/cameras/2d/effects/Flash.js
var require_Flash = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = require_Clamp();
  var Class = require_Class();
  var Events = require_events8();
  var Flash = new Class({
    initialize: function Flash2(camera) {
      this.camera = camera;
      this.isRunning = false;
      this.duration = 0;
      this.red = 0;
      this.green = 0;
      this.blue = 0;
      this.alpha = 0;
      this.progress = 0;
      this._elapsed = 0;
      this._onUpdate;
      this._onUpdateScope;
    },
    start: function(duration, red, green, blue, force, callback, context) {
      if (duration === void 0) {
        duration = 250;
      }
      if (red === void 0) {
        red = 255;
      }
      if (green === void 0) {
        green = 255;
      }
      if (blue === void 0) {
        blue = 255;
      }
      if (force === void 0) {
        force = false;
      }
      if (callback === void 0) {
        callback = null;
      }
      if (context === void 0) {
        context = this.camera.scene;
      }
      if (!force && this.isRunning) {
        return this.camera;
      }
      this.isRunning = true;
      this.duration = duration;
      this.progress = 0;
      this.red = red;
      this.green = green;
      this.blue = blue;
      this.alpha = 1;
      this._elapsed = 0;
      this._onUpdate = callback;
      this._onUpdateScope = context;
      this.camera.emit(Events.FLASH_START, this.camera, this, duration, red, green, blue);
      return this.camera;
    },
    update: function(time, delta) {
      if (!this.isRunning) {
        return;
      }
      this._elapsed += delta;
      this.progress = Clamp(this._elapsed / this.duration, 0, 1);
      if (this._onUpdate) {
        this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
      }
      if (this._elapsed < this.duration) {
        this.alpha = 1 - this.progress;
      } else {
        this.effectComplete();
      }
    },
    postRenderCanvas: function(ctx) {
      if (!this.isRunning) {
        return false;
      }
      var camera = this.camera;
      ctx.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
      ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
      return true;
    },
    postRenderWebGL: function(pipeline, getTintFunction) {
      if (!this.isRunning) {
        return false;
      }
      var camera = this.camera;
      var red = this.red / 255;
      var green = this.green / 255;
      var blue = this.blue / 255;
      pipeline.drawFillRect(camera.x, camera.y, camera.width, camera.height, getTintFunction(blue, green, red, 1), this.alpha);
      return true;
    },
    effectComplete: function() {
      this._onUpdate = null;
      this._onUpdateScope = null;
      this.isRunning = false;
      this.camera.emit(Events.FLASH_COMPLETE, this.camera, this);
    },
    reset: function() {
      this.isRunning = false;
      this._onUpdate = null;
      this._onUpdateScope = null;
    },
    destroy: function() {
      this.reset();
      this.camera = null;
    }
  });
  module2.exports = Flash;
});

// node_modules/phaser/src/math/easing/back/In.js
var require_In = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var In = function(v, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    return v * v * ((overshoot + 1) * v - overshoot);
  };
  module2.exports = In;
});

// node_modules/phaser/src/math/easing/back/Out.js
var require_Out = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Out = function(v, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    return --v * v * ((overshoot + 1) * v + overshoot) + 1;
  };
  module2.exports = Out;
});

// node_modules/phaser/src/math/easing/back/InOut.js
var require_InOut = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var InOut = function(v, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    var s = overshoot * 1.525;
    if ((v *= 2) < 1) {
      return 0.5 * (v * v * ((s + 1) * v - s));
    } else {
      return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);
    }
  };
  module2.exports = InOut;
});

// node_modules/phaser/src/math/easing/back/index.js
var require_back = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    In: require_In(),
    Out: require_Out(),
    InOut: require_InOut()
  };
});

// node_modules/phaser/src/math/easing/bounce/In.js
var require_In2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var In = function(v) {
    v = 1 - v;
    if (v < 1 / 2.75) {
      return 1 - 7.5625 * v * v;
    } else if (v < 2 / 2.75) {
      return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);
    } else if (v < 2.5 / 2.75) {
      return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);
    } else {
      return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);
    }
  };
  module2.exports = In;
});

// node_modules/phaser/src/math/easing/bounce/Out.js
var require_Out2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Out = function(v) {
    if (v < 1 / 2.75) {
      return 7.5625 * v * v;
    } else if (v < 2 / 2.75) {
      return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    } else if (v < 2.5 / 2.75) {
      return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    } else {
      return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }
  };
  module2.exports = Out;
});

// node_modules/phaser/src/math/easing/bounce/InOut.js
var require_InOut2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var InOut = function(v) {
    var reverse = false;
    if (v < 0.5) {
      v = 1 - v * 2;
      reverse = true;
    } else {
      v = v * 2 - 1;
    }
    if (v < 1 / 2.75) {
      v = 7.5625 * v * v;
    } else if (v < 2 / 2.75) {
      v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;
    } else if (v < 2.5 / 2.75) {
      v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;
    } else {
      v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;
    }
    if (reverse) {
      return (1 - v) * 0.5;
    } else {
      return v * 0.5 + 0.5;
    }
  };
  module2.exports = InOut;
});

// node_modules/phaser/src/math/easing/bounce/index.js
var require_bounce = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    In: require_In2(),
    Out: require_Out2(),
    InOut: require_InOut2()
  };
});

// node_modules/phaser/src/math/easing/circular/In.js
var require_In3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var In = function(v) {
    return 1 - Math.sqrt(1 - v * v);
  };
  module2.exports = In;
});

// node_modules/phaser/src/math/easing/circular/Out.js
var require_Out3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Out = function(v) {
    return Math.sqrt(1 - --v * v);
  };
  module2.exports = Out;
});

// node_modules/phaser/src/math/easing/circular/InOut.js
var require_InOut3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var InOut = function(v) {
    if ((v *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - v * v) - 1);
    } else {
      return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);
    }
  };
  module2.exports = InOut;
});

// node_modules/phaser/src/math/easing/circular/index.js
var require_circular = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    In: require_In3(),
    Out: require_Out3(),
    InOut: require_InOut3()
  };
});

// node_modules/phaser/src/math/easing/cubic/In.js
var require_In4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var In = function(v) {
    return v * v * v;
  };
  module2.exports = In;
});

// node_modules/phaser/src/math/easing/cubic/Out.js
var require_Out4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Out = function(v) {
    return --v * v * v + 1;
  };
  module2.exports = Out;
});

// node_modules/phaser/src/math/easing/cubic/InOut.js
var require_InOut4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var InOut = function(v) {
    if ((v *= 2) < 1) {
      return 0.5 * v * v * v;
    } else {
      return 0.5 * ((v -= 2) * v * v + 2);
    }
  };
  module2.exports = InOut;
});

// node_modules/phaser/src/math/easing/cubic/index.js
var require_cubic = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    In: require_In4(),
    Out: require_Out4(),
    InOut: require_InOut4()
  };
});

// node_modules/phaser/src/math/easing/elastic/In.js
var require_In5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var In = function(v, amplitude, period) {
    if (amplitude === void 0) {
      amplitude = 0.1;
    }
    if (period === void 0) {
      period = 0.1;
    }
    if (v === 0) {
      return 0;
    } else if (v === 1) {
      return 1;
    } else {
      var s = period / 4;
      if (amplitude < 1) {
        amplitude = 1;
      } else {
        s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
      }
      return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
    }
  };
  module2.exports = In;
});

// node_modules/phaser/src/math/easing/elastic/Out.js
var require_Out5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Out = function(v, amplitude, period) {
    if (amplitude === void 0) {
      amplitude = 0.1;
    }
    if (period === void 0) {
      period = 0.1;
    }
    if (v === 0) {
      return 0;
    } else if (v === 1) {
      return 1;
    } else {
      var s = period / 4;
      if (amplitude < 1) {
        amplitude = 1;
      } else {
        s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
      }
      return amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1;
    }
  };
  module2.exports = Out;
});

// node_modules/phaser/src/math/easing/elastic/InOut.js
var require_InOut5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var InOut = function(v, amplitude, period) {
    if (amplitude === void 0) {
      amplitude = 0.1;
    }
    if (period === void 0) {
      period = 0.1;
    }
    if (v === 0) {
      return 0;
    } else if (v === 1) {
      return 1;
    } else {
      var s = period / 4;
      if (amplitude < 1) {
        amplitude = 1;
      } else {
        s = period * Math.asin(1 / amplitude) / (2 * Math.PI);
      }
      if ((v *= 2) < 1) {
        return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));
      } else {
        return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;
      }
    }
  };
  module2.exports = InOut;
});

// node_modules/phaser/src/math/easing/elastic/index.js
var require_elastic = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    In: require_In5(),
    Out: require_Out5(),
    InOut: require_InOut5()
  };
});

// node_modules/phaser/src/math/easing/expo/In.js
var require_In6 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var In = function(v) {
    return Math.pow(2, 10 * (v - 1)) - 1e-3;
  };
  module2.exports = In;
});

// node_modules/phaser/src/math/easing/expo/Out.js
var require_Out6 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Out = function(v) {
    return 1 - Math.pow(2, -10 * v);
  };
  module2.exports = Out;
});

// node_modules/phaser/src/math/easing/expo/InOut.js
var require_InOut6 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var InOut = function(v) {
    if ((v *= 2) < 1) {
      return 0.5 * Math.pow(2, 10 * (v - 1));
    } else {
      return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));
    }
  };
  module2.exports = InOut;
});

// node_modules/phaser/src/math/easing/expo/index.js
var require_expo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    In: require_In6(),
    Out: require_Out6(),
    InOut: require_InOut6()
  };
});

// node_modules/phaser/src/math/easing/linear/Linear.js
var require_Linear = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Linear = function(v) {
    return v;
  };
  module2.exports = Linear;
});

// node_modules/phaser/src/math/easing/linear/index.js
var require_linear = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = require_Linear();
});

// node_modules/phaser/src/math/easing/quadratic/In.js
var require_In7 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var In = function(v) {
    return v * v;
  };
  module2.exports = In;
});

// node_modules/phaser/src/math/easing/quadratic/Out.js
var require_Out7 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Out = function(v) {
    return v * (2 - v);
  };
  module2.exports = Out;
});

// node_modules/phaser/src/math/easing/quadratic/InOut.js
var require_InOut7 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var InOut = function(v) {
    if ((v *= 2) < 1) {
      return 0.5 * v * v;
    } else {
      return -0.5 * (--v * (v - 2) - 1);
    }
  };
  module2.exports = InOut;
});

// node_modules/phaser/src/math/easing/quadratic/index.js
var require_quadratic = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    In: require_In7(),
    Out: require_Out7(),
    InOut: require_InOut7()
  };
});

// node_modules/phaser/src/math/easing/quartic/In.js
var require_In8 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var In = function(v) {
    return v * v * v * v;
  };
  module2.exports = In;
});

// node_modules/phaser/src/math/easing/quartic/Out.js
var require_Out8 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Out = function(v) {
    return 1 - --v * v * v * v;
  };
  module2.exports = Out;
});

// node_modules/phaser/src/math/easing/quartic/InOut.js
var require_InOut8 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var InOut = function(v) {
    if ((v *= 2) < 1) {
      return 0.5 * v * v * v * v;
    } else {
      return -0.5 * ((v -= 2) * v * v * v - 2);
    }
  };
  module2.exports = InOut;
});

// node_modules/phaser/src/math/easing/quartic/index.js
var require_quartic = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    In: require_In8(),
    Out: require_Out8(),
    InOut: require_InOut8()
  };
});

// node_modules/phaser/src/math/easing/quintic/In.js
var require_In9 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var In = function(v) {
    return v * v * v * v * v;
  };
  module2.exports = In;
});

// node_modules/phaser/src/math/easing/quintic/Out.js
var require_Out9 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Out = function(v) {
    return --v * v * v * v * v + 1;
  };
  module2.exports = Out;
});

// node_modules/phaser/src/math/easing/quintic/InOut.js
var require_InOut9 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var InOut = function(v) {
    if ((v *= 2) < 1) {
      return 0.5 * v * v * v * v * v;
    } else {
      return 0.5 * ((v -= 2) * v * v * v * v + 2);
    }
  };
  module2.exports = InOut;
});

// node_modules/phaser/src/math/easing/quintic/index.js
var require_quintic = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    In: require_In9(),
    Out: require_Out9(),
    InOut: require_InOut9()
  };
});

// node_modules/phaser/src/math/easing/sine/In.js
var require_In10 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var In = function(v) {
    if (v === 0) {
      return 0;
    } else if (v === 1) {
      return 1;
    } else {
      return 1 - Math.cos(v * Math.PI / 2);
    }
  };
  module2.exports = In;
});

// node_modules/phaser/src/math/easing/sine/Out.js
var require_Out10 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Out = function(v) {
    if (v === 0) {
      return 0;
    } else if (v === 1) {
      return 1;
    } else {
      return Math.sin(v * Math.PI / 2);
    }
  };
  module2.exports = Out;
});

// node_modules/phaser/src/math/easing/sine/InOut.js
var require_InOut10 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var InOut = function(v) {
    if (v === 0) {
      return 0;
    } else if (v === 1) {
      return 1;
    } else {
      return 0.5 * (1 - Math.cos(Math.PI * v));
    }
  };
  module2.exports = InOut;
});

// node_modules/phaser/src/math/easing/sine/index.js
var require_sine = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    In: require_In10(),
    Out: require_Out10(),
    InOut: require_InOut10()
  };
});

// node_modules/phaser/src/math/easing/stepped/Stepped.js
var require_Stepped = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Stepped = function(v, steps) {
    if (steps === void 0) {
      steps = 1;
    }
    if (v <= 0) {
      return 0;
    } else if (v >= 1) {
      return 1;
    } else {
      return ((steps * v | 0) + 1) * (1 / steps);
    }
  };
  module2.exports = Stepped;
});

// node_modules/phaser/src/math/easing/stepped/index.js
var require_stepped = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = require_Stepped();
});

// node_modules/phaser/src/math/easing/EaseMap.js
var require_EaseMap = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Back = require_back();
  var Bounce = require_bounce();
  var Circular = require_circular();
  var Cubic = require_cubic();
  var Elastic = require_elastic();
  var Expo = require_expo();
  var Linear = require_linear();
  var Quadratic = require_quadratic();
  var Quartic = require_quartic();
  var Quintic = require_quintic();
  var Sine = require_sine();
  var Stepped = require_stepped();
  module2.exports = {
    Power0: Linear,
    Power1: Quadratic.Out,
    Power2: Cubic.Out,
    Power3: Quartic.Out,
    Power4: Quintic.Out,
    Linear,
    Quad: Quadratic.Out,
    Cubic: Cubic.Out,
    Quart: Quartic.Out,
    Quint: Quintic.Out,
    Sine: Sine.Out,
    Expo: Expo.Out,
    Circ: Circular.Out,
    Elastic: Elastic.Out,
    Back: Back.Out,
    Bounce: Bounce.Out,
    Stepped,
    "Quad.easeIn": Quadratic.In,
    "Cubic.easeIn": Cubic.In,
    "Quart.easeIn": Quartic.In,
    "Quint.easeIn": Quintic.In,
    "Sine.easeIn": Sine.In,
    "Expo.easeIn": Expo.In,
    "Circ.easeIn": Circular.In,
    "Elastic.easeIn": Elastic.In,
    "Back.easeIn": Back.In,
    "Bounce.easeIn": Bounce.In,
    "Quad.easeOut": Quadratic.Out,
    "Cubic.easeOut": Cubic.Out,
    "Quart.easeOut": Quartic.Out,
    "Quint.easeOut": Quintic.Out,
    "Sine.easeOut": Sine.Out,
    "Expo.easeOut": Expo.Out,
    "Circ.easeOut": Circular.Out,
    "Elastic.easeOut": Elastic.Out,
    "Back.easeOut": Back.Out,
    "Bounce.easeOut": Bounce.Out,
    "Quad.easeInOut": Quadratic.InOut,
    "Cubic.easeInOut": Cubic.InOut,
    "Quart.easeInOut": Quartic.InOut,
    "Quint.easeInOut": Quintic.InOut,
    "Sine.easeInOut": Sine.InOut,
    "Expo.easeInOut": Expo.InOut,
    "Circ.easeInOut": Circular.InOut,
    "Elastic.easeInOut": Elastic.InOut,
    "Back.easeInOut": Back.InOut,
    "Bounce.easeInOut": Bounce.InOut
  };
});

// node_modules/phaser/src/cameras/2d/effects/Pan.js
var require_Pan = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = require_Clamp();
  var Class = require_Class();
  var EaseMap = require_EaseMap();
  var Events = require_events8();
  var Vector2 = require_Vector2();
  var Pan = new Class({
    initialize: function Pan2(camera) {
      this.camera = camera;
      this.isRunning = false;
      this.duration = 0;
      this.source = new Vector2();
      this.current = new Vector2();
      this.destination = new Vector2();
      this.ease;
      this.progress = 0;
      this._elapsed = 0;
      this._onUpdate;
      this._onUpdateScope;
    },
    start: function(x, y, duration, ease, force, callback, context) {
      if (duration === void 0) {
        duration = 1e3;
      }
      if (ease === void 0) {
        ease = EaseMap.Linear;
      }
      if (force === void 0) {
        force = false;
      }
      if (callback === void 0) {
        callback = null;
      }
      if (context === void 0) {
        context = this.camera.scene;
      }
      var cam = this.camera;
      if (!force && this.isRunning) {
        return cam;
      }
      this.isRunning = true;
      this.duration = duration;
      this.progress = 0;
      this.source.set(cam.scrollX, cam.scrollY);
      this.destination.set(x, y);
      cam.getScroll(x, y, this.current);
      if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
        this.ease = EaseMap[ease];
      } else if (typeof ease === "function") {
        this.ease = ease;
      }
      this._elapsed = 0;
      this._onUpdate = callback;
      this._onUpdateScope = context;
      this.camera.emit(Events.PAN_START, this.camera, this, duration, x, y);
      return cam;
    },
    update: function(time, delta) {
      if (!this.isRunning) {
        return;
      }
      this._elapsed += delta;
      var progress = Clamp(this._elapsed / this.duration, 0, 1);
      this.progress = progress;
      var cam = this.camera;
      if (this._elapsed < this.duration) {
        var v = this.ease(progress);
        cam.getScroll(this.destination.x, this.destination.y, this.current);
        var x = this.source.x + (this.current.x - this.source.x) * v;
        var y = this.source.y + (this.current.y - this.source.y) * v;
        cam.setScroll(x, y);
        if (this._onUpdate) {
          this._onUpdate.call(this._onUpdateScope, cam, progress, x, y);
        }
      } else {
        cam.centerOn(this.destination.x, this.destination.y);
        if (this._onUpdate) {
          this._onUpdate.call(this._onUpdateScope, cam, progress, cam.scrollX, cam.scrollY);
        }
        this.effectComplete();
      }
    },
    effectComplete: function() {
      this._onUpdate = null;
      this._onUpdateScope = null;
      this.isRunning = false;
      this.camera.emit(Events.PAN_COMPLETE, this.camera, this);
    },
    reset: function() {
      this.isRunning = false;
      this._onUpdate = null;
      this._onUpdateScope = null;
    },
    destroy: function() {
      this.reset();
      this.camera = null;
      this.source = null;
      this.destination = null;
    }
  });
  module2.exports = Pan;
});

// node_modules/phaser/src/cameras/2d/effects/Shake.js
var require_Shake = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = require_Clamp();
  var Class = require_Class();
  var Events = require_events8();
  var Vector2 = require_Vector2();
  var Shake = new Class({
    initialize: function Shake2(camera) {
      this.camera = camera;
      this.isRunning = false;
      this.duration = 0;
      this.intensity = new Vector2();
      this.progress = 0;
      this._elapsed = 0;
      this._offsetX = 0;
      this._offsetY = 0;
      this._onUpdate;
      this._onUpdateScope;
    },
    start: function(duration, intensity, force, callback, context) {
      if (duration === void 0) {
        duration = 100;
      }
      if (intensity === void 0) {
        intensity = 0.05;
      }
      if (force === void 0) {
        force = false;
      }
      if (callback === void 0) {
        callback = null;
      }
      if (context === void 0) {
        context = this.camera.scene;
      }
      if (!force && this.isRunning) {
        return this.camera;
      }
      this.isRunning = true;
      this.duration = duration;
      this.progress = 0;
      if (typeof intensity === "number") {
        this.intensity.set(intensity);
      } else {
        this.intensity.set(intensity.x, intensity.y);
      }
      this._elapsed = 0;
      this._offsetX = 0;
      this._offsetY = 0;
      this._onUpdate = callback;
      this._onUpdateScope = context;
      this.camera.emit(Events.SHAKE_START, this.camera, this, duration, intensity);
      return this.camera;
    },
    preRender: function() {
      if (this.isRunning) {
        this.camera.matrix.translate(this._offsetX, this._offsetY);
      }
    },
    update: function(time, delta) {
      if (!this.isRunning) {
        return;
      }
      this._elapsed += delta;
      this.progress = Clamp(this._elapsed / this.duration, 0, 1);
      if (this._onUpdate) {
        this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
      }
      if (this._elapsed < this.duration) {
        var intensity = this.intensity;
        var width = this.camera.width;
        var height = this.camera.height;
        var zoom = this.camera.zoom;
        this._offsetX = (Math.random() * intensity.x * width * 2 - intensity.x * width) * zoom;
        this._offsetY = (Math.random() * intensity.y * height * 2 - intensity.y * height) * zoom;
        if (this.camera.roundPixels) {
          this._offsetX = Math.round(this._offsetX);
          this._offsetY = Math.round(this._offsetY);
        }
      } else {
        this.effectComplete();
      }
    },
    effectComplete: function() {
      this._offsetX = 0;
      this._offsetY = 0;
      this._onUpdate = null;
      this._onUpdateScope = null;
      this.isRunning = false;
      this.camera.emit(Events.SHAKE_COMPLETE, this.camera, this);
    },
    reset: function() {
      this.isRunning = false;
      this._offsetX = 0;
      this._offsetY = 0;
      this._onUpdate = null;
      this._onUpdateScope = null;
    },
    destroy: function() {
      this.reset();
      this.camera = null;
      this.intensity = null;
    }
  });
  module2.exports = Shake;
});

// node_modules/phaser/src/cameras/2d/effects/RotateTo.js
var require_RotateTo = __commonJS((exports2, module2) => {
  /**
   * @author       Jason Nicholls <nicholls.jason@gmail.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var Clamp = require_Clamp();
  var Class = require_Class();
  var Events = require_events8();
  var EaseMap = require_EaseMap();
  var RotateTo = new Class({
    initialize: function RotateTo2(camera) {
      this.camera = camera;
      this.isRunning = false;
      this.duration = 0;
      this.source = 0;
      this.current = 0;
      this.destination = 0;
      this.ease;
      this.progress = 0;
      this._elapsed = 0;
      this._onUpdate;
      this._onUpdateScope;
      this.clockwise = true;
      this.shortestPath = false;
    },
    start: function(radians, shortestPath, duration, ease, force, callback, context) {
      if (duration === void 0) {
        duration = 1e3;
      }
      if (ease === void 0) {
        ease = EaseMap.Linear;
      }
      if (force === void 0) {
        force = false;
      }
      if (callback === void 0) {
        callback = null;
      }
      if (context === void 0) {
        context = this.camera.scene;
      }
      if (shortestPath === void 0) {
        shortestPath = false;
      }
      this.shortestPath = shortestPath;
      var tmpDestination = radians;
      if (radians < 0) {
        tmpDestination = -1 * radians;
        this.clockwise = false;
      } else {
        this.clockwise = true;
      }
      var maxRad = 360 * Math.PI / 180;
      tmpDestination = tmpDestination - Math.floor(tmpDestination / maxRad) * maxRad;
      var cam = this.camera;
      if (!force && this.isRunning) {
        return cam;
      }
      this.isRunning = true;
      this.duration = duration;
      this.progress = 0;
      this.source = cam.rotation;
      this.destination = tmpDestination;
      if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
        this.ease = EaseMap[ease];
      } else if (typeof ease === "function") {
        this.ease = ease;
      }
      this._elapsed = 0;
      this._onUpdate = callback;
      this._onUpdateScope = context;
      if (this.shortestPath) {
        var cwDist = 0;
        var acwDist = 0;
        if (this.destination > this.source) {
          cwDist = Math.abs(this.destination - this.source);
        } else {
          cwDist = Math.abs(this.destination + maxRad) - this.source;
        }
        if (this.source > this.destination) {
          acwDist = Math.abs(this.source - this.destination);
        } else {
          acwDist = Math.abs(this.source + maxRad) - this.destination;
        }
        if (cwDist < acwDist) {
          this.clockwise = true;
        } else if (cwDist > acwDist) {
          this.clockwise = false;
        }
      }
      this.camera.emit(Events.ROTATE_START, this.camera, this, duration, tmpDestination);
      return cam;
    },
    update: function(time, delta) {
      if (!this.isRunning) {
        return;
      }
      this._elapsed += delta;
      var progress = Clamp(this._elapsed / this.duration, 0, 1);
      this.progress = progress;
      var cam = this.camera;
      if (this._elapsed < this.duration) {
        var v = this.ease(progress);
        this.current = cam.rotation;
        var distance = 0;
        var maxRad = 360 * Math.PI / 180;
        var target = this.destination;
        var current = this.current;
        if (this.clockwise === false) {
          target = this.current;
          current = this.destination;
        }
        if (target >= current) {
          distance = Math.abs(target - current);
        } else {
          distance = Math.abs(target + maxRad) - current;
        }
        var r = 0;
        if (this.clockwise) {
          r = cam.rotation + distance * v;
        } else {
          r = cam.rotation - distance * v;
        }
        cam.rotation = r;
        if (this._onUpdate) {
          this._onUpdate.call(this._onUpdateScope, cam, progress, r);
        }
      } else {
        cam.rotation = this.destination;
        if (this._onUpdate) {
          this._onUpdate.call(this._onUpdateScope, cam, progress, this.destination);
        }
        this.effectComplete();
      }
    },
    effectComplete: function() {
      this._onUpdate = null;
      this._onUpdateScope = null;
      this.isRunning = false;
      this.camera.emit(Events.ROTATE_COMPLETE, this.camera, this);
    },
    reset: function() {
      this.isRunning = false;
      this._onUpdate = null;
      this._onUpdateScope = null;
    },
    destroy: function() {
      this.reset();
      this.camera = null;
      this.source = null;
      this.destination = null;
    }
  });
  module2.exports = RotateTo;
});

// node_modules/phaser/src/cameras/2d/effects/Zoom.js
var require_Zoom = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = require_Clamp();
  var Class = require_Class();
  var EaseMap = require_EaseMap();
  var Events = require_events8();
  var Zoom = new Class({
    initialize: function Zoom2(camera) {
      this.camera = camera;
      this.isRunning = false;
      this.duration = 0;
      this.source = 1;
      this.destination = 1;
      this.ease;
      this.progress = 0;
      this._elapsed = 0;
      this._onUpdate;
      this._onUpdateScope;
    },
    start: function(zoom, duration, ease, force, callback, context) {
      if (duration === void 0) {
        duration = 1e3;
      }
      if (ease === void 0) {
        ease = EaseMap.Linear;
      }
      if (force === void 0) {
        force = false;
      }
      if (callback === void 0) {
        callback = null;
      }
      if (context === void 0) {
        context = this.camera.scene;
      }
      var cam = this.camera;
      if (!force && this.isRunning) {
        return cam;
      }
      this.isRunning = true;
      this.duration = duration;
      this.progress = 0;
      this.source = cam.zoom;
      this.destination = zoom;
      if (typeof ease === "string" && EaseMap.hasOwnProperty(ease)) {
        this.ease = EaseMap[ease];
      } else if (typeof ease === "function") {
        this.ease = ease;
      }
      this._elapsed = 0;
      this._onUpdate = callback;
      this._onUpdateScope = context;
      this.camera.emit(Events.ZOOM_START, this.camera, this, duration, zoom);
      return cam;
    },
    update: function(time, delta) {
      if (!this.isRunning) {
        return;
      }
      this._elapsed += delta;
      this.progress = Clamp(this._elapsed / this.duration, 0, 1);
      if (this._elapsed < this.duration) {
        this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress);
        if (this._onUpdate) {
          this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom);
        }
      } else {
        this.camera.zoom = this.destination;
        if (this._onUpdate) {
          this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination);
        }
        this.effectComplete();
      }
    },
    effectComplete: function() {
      this._onUpdate = null;
      this._onUpdateScope = null;
      this.isRunning = false;
      this.camera.emit(Events.ZOOM_COMPLETE, this.camera, this);
    },
    reset: function() {
      this.isRunning = false;
      this._onUpdate = null;
      this._onUpdateScope = null;
    },
    destroy: function() {
      this.reset();
      this.camera = null;
    }
  });
  module2.exports = Zoom;
});

// node_modules/phaser/src/cameras/2d/effects/index.js
var require_effects = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Fade: require_Fade(),
    Flash: require_Flash(),
    Pan: require_Pan(),
    Shake: require_Shake(),
    RotateTo: require_RotateTo(),
    Zoom: require_Zoom()
  };
});

// node_modules/phaser/src/math/Linear.js
var require_Linear2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Linear = function(p0, p1, t) {
    return (p1 - p0) * t + p0;
  };
  module2.exports = Linear;
});

// node_modules/phaser/src/cameras/2d/Camera.js
var require_Camera = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BaseCamera = require_BaseCamera();
  var CenterOn = require_CenterOn2();
  var Clamp = require_Clamp();
  var Class = require_Class();
  var Components = require_components();
  var Effects = require_effects();
  var Events = require_events8();
  var Linear = require_Linear2();
  var Rectangle = require_Rectangle();
  var Vector2 = require_Vector2();
  var Camera = new Class({
    Extends: BaseCamera,
    Mixins: [
      Components.Flip,
      Components.Tint,
      Components.Pipeline
    ],
    initialize: function Camera2(x, y, width, height) {
      BaseCamera.call(this, x, y, width, height);
      this.postPipelines = [];
      this.pipelineData = {};
      this.inputEnabled = true;
      this.fadeEffect = new Effects.Fade(this);
      this.flashEffect = new Effects.Flash(this);
      this.shakeEffect = new Effects.Shake(this);
      this.panEffect = new Effects.Pan(this);
      this.rotateToEffect = new Effects.RotateTo(this);
      this.zoomEffect = new Effects.Zoom(this);
      this.lerp = new Vector2(1, 1);
      this.followOffset = new Vector2();
      this.deadzone = null;
      this._follow = null;
    },
    setDeadzone: function(width, height) {
      if (width === void 0) {
        this.deadzone = null;
      } else {
        if (this.deadzone) {
          this.deadzone.width = width;
          this.deadzone.height = height;
        } else {
          this.deadzone = new Rectangle(0, 0, width, height);
        }
        if (this._follow) {
          var originX = this.width / 2;
          var originY = this.height / 2;
          var fx = this._follow.x - this.followOffset.x;
          var fy = this._follow.y - this.followOffset.y;
          this.midPoint.set(fx, fy);
          this.scrollX = fx - originX;
          this.scrollY = fy - originY;
        }
        CenterOn(this.deadzone, this.midPoint.x, this.midPoint.y);
      }
      return this;
    },
    fadeIn: function(duration, red, green, blue, callback, context) {
      return this.fadeEffect.start(false, duration, red, green, blue, true, callback, context);
    },
    fadeOut: function(duration, red, green, blue, callback, context) {
      return this.fadeEffect.start(true, duration, red, green, blue, true, callback, context);
    },
    fadeFrom: function(duration, red, green, blue, force, callback, context) {
      return this.fadeEffect.start(false, duration, red, green, blue, force, callback, context);
    },
    fade: function(duration, red, green, blue, force, callback, context) {
      return this.fadeEffect.start(true, duration, red, green, blue, force, callback, context);
    },
    flash: function(duration, red, green, blue, force, callback, context) {
      return this.flashEffect.start(duration, red, green, blue, force, callback, context);
    },
    shake: function(duration, intensity, force, callback, context) {
      return this.shakeEffect.start(duration, intensity, force, callback, context);
    },
    pan: function(x, y, duration, ease, force, callback, context) {
      return this.panEffect.start(x, y, duration, ease, force, callback, context);
    },
    rotateTo: function(radians, shortestPath, duration, ease, force, callback, context) {
      return this.rotateToEffect.start(radians, shortestPath, duration, ease, force, callback, context);
    },
    zoomTo: function(zoom, duration, ease, force, callback, context) {
      return this.zoomEffect.start(zoom, duration, ease, force, callback, context);
    },
    preRender: function() {
      this.renderList.length = 0;
      var width = this.width;
      var height = this.height;
      var halfWidth = width * 0.5;
      var halfHeight = height * 0.5;
      var zoom = this.zoom;
      var matrix = this.matrix;
      var originX = width * this.originX;
      var originY = height * this.originY;
      var follow = this._follow;
      var deadzone = this.deadzone;
      var sx = this.scrollX;
      var sy = this.scrollY;
      if (deadzone) {
        CenterOn(deadzone, this.midPoint.x, this.midPoint.y);
      }
      var emitFollowEvent = false;
      if (follow && !this.panEffect.isRunning) {
        var fx = follow.x - this.followOffset.x;
        var fy = follow.y - this.followOffset.y;
        if (deadzone) {
          if (fx < deadzone.x) {
            sx = Linear(sx, sx - (deadzone.x - fx), this.lerp.x);
          } else if (fx > deadzone.right) {
            sx = Linear(sx, sx + (fx - deadzone.right), this.lerp.x);
          }
          if (fy < deadzone.y) {
            sy = Linear(sy, sy - (deadzone.y - fy), this.lerp.y);
          } else if (fy > deadzone.bottom) {
            sy = Linear(sy, sy + (fy - deadzone.bottom), this.lerp.y);
          }
        } else {
          sx = Linear(sx, fx - originX, this.lerp.x);
          sy = Linear(sy, fy - originY, this.lerp.y);
        }
        emitFollowEvent = true;
      }
      if (this.useBounds) {
        sx = this.clampX(sx);
        sy = this.clampY(sy);
      }
      if (this.roundPixels) {
        originX = Math.round(originX);
        originY = Math.round(originY);
        sx = Math.round(sx);
        sy = Math.round(sy);
      }
      this.scrollX = sx;
      this.scrollY = sy;
      var midX = sx + halfWidth;
      var midY = sy + halfHeight;
      this.midPoint.set(midX, midY);
      var displayWidth = width / zoom;
      var displayHeight = height / zoom;
      var vwx = midX - displayWidth / 2;
      var vwy = midY - displayHeight / 2;
      if (this.roundPixels) {
        vwx = Math.round(vwx);
        vwy = Math.round(vwy);
      }
      this.worldView.setTo(vwx, vwy, displayWidth, displayHeight);
      matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoom, zoom);
      matrix.translate(-originX, -originY);
      this.shakeEffect.preRender();
      if (emitFollowEvent) {
        this.emit(Events.FOLLOW_UPDATE, this, follow);
      }
    },
    setLerp: function(x, y) {
      if (x === void 0) {
        x = 1;
      }
      if (y === void 0) {
        y = x;
      }
      this.lerp.set(x, y);
      return this;
    },
    setFollowOffset: function(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      this.followOffset.set(x, y);
      return this;
    },
    startFollow: function(target, roundPixels, lerpX, lerpY, offsetX, offsetY) {
      if (roundPixels === void 0) {
        roundPixels = false;
      }
      if (lerpX === void 0) {
        lerpX = 1;
      }
      if (lerpY === void 0) {
        lerpY = lerpX;
      }
      if (offsetX === void 0) {
        offsetX = 0;
      }
      if (offsetY === void 0) {
        offsetY = offsetX;
      }
      this._follow = target;
      this.roundPixels = roundPixels;
      lerpX = Clamp(lerpX, 0, 1);
      lerpY = Clamp(lerpY, 0, 1);
      this.lerp.set(lerpX, lerpY);
      this.followOffset.set(offsetX, offsetY);
      var originX = this.width / 2;
      var originY = this.height / 2;
      var fx = target.x - offsetX;
      var fy = target.y - offsetY;
      this.midPoint.set(fx, fy);
      this.scrollX = fx - originX;
      this.scrollY = fy - originY;
      if (this.useBounds) {
        this.scrollX = this.clampX(this.scrollX);
        this.scrollY = this.clampY(this.scrollY);
      }
      return this;
    },
    stopFollow: function() {
      this._follow = null;
      return this;
    },
    resetFX: function() {
      this.rotateToEffect.reset();
      this.panEffect.reset();
      this.shakeEffect.reset();
      this.flashEffect.reset();
      this.fadeEffect.reset();
      return this;
    },
    update: function(time, delta) {
      if (this.visible) {
        this.rotateToEffect.update(time, delta);
        this.panEffect.update(time, delta);
        this.zoomEffect.update(time, delta);
        this.shakeEffect.update(time, delta);
        this.flashEffect.update(time, delta);
        this.fadeEffect.update(time, delta);
      }
    },
    destroy: function() {
      this.resetFX();
      BaseCamera.prototype.destroy.call(this);
      this._follow = null;
      this.deadzone = null;
    }
  });
  module2.exports = Camera;
});

// node_modules/phaser/src/plugins/PluginCache.js
var require_PluginCache = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var corePlugins = {};
  var customPlugins = {};
  var PluginCache = {};
  PluginCache.register = function(key, plugin, mapping, custom) {
    if (custom === void 0) {
      custom = false;
    }
    corePlugins[key] = {plugin, mapping, custom};
  };
  PluginCache.registerCustom = function(key, plugin, mapping, data) {
    customPlugins[key] = {plugin, mapping, data};
  };
  PluginCache.hasCore = function(key) {
    return corePlugins.hasOwnProperty(key);
  };
  PluginCache.hasCustom = function(key) {
    return customPlugins.hasOwnProperty(key);
  };
  PluginCache.getCore = function(key) {
    return corePlugins[key];
  };
  PluginCache.getCustom = function(key) {
    return customPlugins[key];
  };
  PluginCache.getCustomClass = function(key) {
    return customPlugins.hasOwnProperty(key) ? customPlugins[key].plugin : null;
  };
  PluginCache.remove = function(key) {
    if (corePlugins.hasOwnProperty(key)) {
      delete corePlugins[key];
    }
  };
  PluginCache.removeCustom = function(key) {
    if (customPlugins.hasOwnProperty(key)) {
      delete customPlugins[key];
    }
  };
  PluginCache.destroyCorePlugins = function() {
    for (var key in corePlugins) {
      if (corePlugins.hasOwnProperty(key)) {
        delete corePlugins[key];
      }
    }
  };
  PluginCache.destroyCustomPlugins = function() {
    for (var key in customPlugins) {
      if (customPlugins.hasOwnProperty(key)) {
        delete customPlugins[key];
      }
    }
  };
  module2.exports = PluginCache;
});

// node_modules/phaser/src/scale/events/ENTER_FULLSCREEN_EVENT.js
var require_ENTER_FULLSCREEN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "enterfullscreen";
});

// node_modules/phaser/src/scale/events/FULLSCREEN_FAILED_EVENT.js
var require_FULLSCREEN_FAILED_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "fullscreenfailed";
});

// node_modules/phaser/src/scale/events/FULLSCREEN_UNSUPPORTED_EVENT.js
var require_FULLSCREEN_UNSUPPORTED_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "fullscreenunsupported";
});

// node_modules/phaser/src/scale/events/LEAVE_FULLSCREEN_EVENT.js
var require_LEAVE_FULLSCREEN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "leavefullscreen";
});

// node_modules/phaser/src/scale/events/ORIENTATION_CHANGE_EVENT.js
var require_ORIENTATION_CHANGE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "orientationchange";
});

// node_modules/phaser/src/scale/events/RESIZE_EVENT.js
var require_RESIZE_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "resize";
});

// node_modules/phaser/src/scale/events/index.js
var require_events9 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ENTER_FULLSCREEN: require_ENTER_FULLSCREEN_EVENT(),
    FULLSCREEN_FAILED: require_FULLSCREEN_FAILED_EVENT(),
    FULLSCREEN_UNSUPPORTED: require_FULLSCREEN_UNSUPPORTED_EVENT(),
    LEAVE_FULLSCREEN: require_LEAVE_FULLSCREEN_EVENT(),
    ORIENTATION_CHANGE: require_ORIENTATION_CHANGE_EVENT(),
    RESIZE: require_RESIZE_EVENT2()
  };
});

// node_modules/phaser/src/cameras/2d/CameraManager.js
var require_CameraManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Camera = require_Camera();
  var Class = require_Class();
  var GetFastValue = require_GetFastValue();
  var PluginCache = require_PluginCache();
  var RectangleContains = require_Contains2();
  var ScaleEvents = require_events9();
  var SceneEvents = require_events5();
  var CameraManager = new Class({
    initialize: function CameraManager2(scene) {
      this.scene = scene;
      this.systems = scene.sys;
      this.roundPixels = scene.sys.game.config.roundPixels;
      this.cameras = [];
      this.main;
      this.default;
      scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
      scene.sys.events.on(SceneEvents.START, this.start, this);
    },
    boot: function() {
      var sys = this.systems;
      if (sys.settings.cameras) {
        this.fromJSON(sys.settings.cameras);
      } else {
        this.add();
      }
      this.main = this.cameras[0];
      this.default = new Camera(0, 0, sys.scale.width, sys.scale.height).setScene(this.scene);
      sys.game.scale.on(ScaleEvents.RESIZE, this.onResize, this);
      this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
    },
    start: function() {
      if (!this.main) {
        var sys = this.systems;
        if (sys.settings.cameras) {
          this.fromJSON(sys.settings.cameras);
        } else {
          this.add();
        }
        this.main = this.cameras[0];
      }
      var eventEmitter = this.systems.events;
      eventEmitter.on(SceneEvents.UPDATE, this.update, this);
      eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    add: function(x, y, width, height, makeMain, name) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = this.scene.sys.scale.width;
      }
      if (height === void 0) {
        height = this.scene.sys.scale.height;
      }
      if (makeMain === void 0) {
        makeMain = false;
      }
      if (name === void 0) {
        name = "";
      }
      var camera = new Camera(x, y, width, height);
      camera.setName(name);
      camera.setScene(this.scene);
      camera.setRoundPixels(this.roundPixels);
      camera.id = this.getNextID();
      this.cameras.push(camera);
      if (makeMain) {
        this.main = camera;
      }
      return camera;
    },
    addExisting: function(camera, makeMain) {
      if (makeMain === void 0) {
        makeMain = false;
      }
      var index = this.cameras.indexOf(camera);
      if (index === -1) {
        camera.id = this.getNextID();
        camera.setRoundPixels(this.roundPixels);
        this.cameras.push(camera);
        if (makeMain) {
          this.main = camera;
        }
        return camera;
      }
      return null;
    },
    getNextID: function() {
      var cameras = this.cameras;
      var testID = 1;
      for (var t = 0; t < 32; t++) {
        var found = false;
        for (var i = 0; i < cameras.length; i++) {
          var camera = cameras[i];
          if (camera && camera.id === testID) {
            found = true;
            continue;
          }
        }
        if (found) {
          testID = testID << 1;
        } else {
          return testID;
        }
      }
      return 0;
    },
    getTotal: function(isVisible) {
      if (isVisible === void 0) {
        isVisible = false;
      }
      var total = 0;
      var cameras = this.cameras;
      for (var i = 0; i < cameras.length; i++) {
        var camera = cameras[i];
        if (!isVisible || isVisible && camera.visible) {
          total++;
        }
      }
      return total;
    },
    fromJSON: function(config2) {
      if (!Array.isArray(config2)) {
        config2 = [config2];
      }
      var gameWidth = this.scene.sys.scale.width;
      var gameHeight = this.scene.sys.scale.height;
      for (var i = 0; i < config2.length; i++) {
        var cameraConfig = config2[i];
        var x = GetFastValue(cameraConfig, "x", 0);
        var y = GetFastValue(cameraConfig, "y", 0);
        var width = GetFastValue(cameraConfig, "width", gameWidth);
        var height = GetFastValue(cameraConfig, "height", gameHeight);
        var camera = this.add(x, y, width, height);
        camera.name = GetFastValue(cameraConfig, "name", "");
        camera.zoom = GetFastValue(cameraConfig, "zoom", 1);
        camera.rotation = GetFastValue(cameraConfig, "rotation", 0);
        camera.scrollX = GetFastValue(cameraConfig, "scrollX", 0);
        camera.scrollY = GetFastValue(cameraConfig, "scrollY", 0);
        camera.roundPixels = GetFastValue(cameraConfig, "roundPixels", false);
        camera.visible = GetFastValue(cameraConfig, "visible", true);
        var backgroundColor = GetFastValue(cameraConfig, "backgroundColor", false);
        if (backgroundColor) {
          camera.setBackgroundColor(backgroundColor);
        }
        var boundsConfig = GetFastValue(cameraConfig, "bounds", null);
        if (boundsConfig) {
          var bx = GetFastValue(boundsConfig, "x", 0);
          var by = GetFastValue(boundsConfig, "y", 0);
          var bwidth = GetFastValue(boundsConfig, "width", gameWidth);
          var bheight = GetFastValue(boundsConfig, "height", gameHeight);
          camera.setBounds(bx, by, bwidth, bheight);
        }
      }
      return this;
    },
    getCamera: function(name) {
      var cameras = this.cameras;
      for (var i = 0; i < cameras.length; i++) {
        if (cameras[i].name === name) {
          return cameras[i];
        }
      }
      return null;
    },
    getCamerasBelowPointer: function(pointer) {
      var cameras = this.cameras;
      var x = pointer.x;
      var y = pointer.y;
      var output = [];
      for (var i = 0; i < cameras.length; i++) {
        var camera = cameras[i];
        if (camera.visible && camera.inputEnabled && RectangleContains(camera, x, y)) {
          output.unshift(camera);
        }
      }
      return output;
    },
    remove: function(camera, runDestroy) {
      if (runDestroy === void 0) {
        runDestroy = true;
      }
      if (!Array.isArray(camera)) {
        camera = [camera];
      }
      var total = 0;
      var cameras = this.cameras;
      for (var i = 0; i < camera.length; i++) {
        var index = cameras.indexOf(camera[i]);
        if (index !== -1) {
          if (runDestroy) {
            cameras[index].destroy();
          } else {
            cameras[index].renderList = [];
          }
          cameras.splice(index, 1);
          total++;
        }
      }
      if (!this.main && cameras[0]) {
        this.main = cameras[0];
      }
      return total;
    },
    render: function(renderer, displayList) {
      var scene = this.scene;
      var cameras = this.cameras;
      for (var i = 0; i < this.cameras.length; i++) {
        var camera = cameras[i];
        if (camera.visible && camera.alpha > 0) {
          camera.preRender();
          var visibleChildren = this.getVisibleChildren(displayList.getChildren(), camera);
          renderer.render(scene, visibleChildren, camera);
        }
      }
    },
    getVisibleChildren: function(children, camera) {
      var visible = [];
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.willRender(camera)) {
          visible.push(child);
        }
      }
      return visible;
    },
    resetAll: function() {
      for (var i = 0; i < this.cameras.length; i++) {
        this.cameras[i].destroy();
      }
      this.cameras = [];
      this.main = this.add();
      return this.main;
    },
    update: function(time, delta) {
      for (var i = 0; i < this.cameras.length; i++) {
        this.cameras[i].update(time, delta);
      }
    },
    onResize: function(gameSize, baseSize, displaySize, previousWidth, previousHeight) {
      for (var i = 0; i < this.cameras.length; i++) {
        var cam = this.cameras[i];
        if (cam._x === 0 && cam._y === 0 && cam._width === previousWidth && cam._height === previousHeight) {
          cam.setSize(baseSize.width, baseSize.height);
        }
      }
    },
    resize: function(width, height) {
      for (var i = 0; i < this.cameras.length; i++) {
        this.cameras[i].setSize(width, height);
      }
    },
    shutdown: function() {
      this.main = void 0;
      for (var i = 0; i < this.cameras.length; i++) {
        this.cameras[i].destroy();
      }
      this.cameras = [];
      var eventEmitter = this.systems.events;
      eventEmitter.off(SceneEvents.UPDATE, this.update, this);
      eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    destroy: function() {
      this.shutdown();
      this.default.destroy();
      this.scene.sys.events.off(SceneEvents.START, this.start, this);
      this.scene = null;
      this.systems = null;
    }
  });
  PluginCache.register("CameraManager", CameraManager, "cameras");
  module2.exports = CameraManager;
});

// node_modules/phaser/src/cameras/2d/index.js
var require_d = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Camera: require_Camera(),
    BaseCamera: require_BaseCamera(),
    CameraManager: require_CameraManager(),
    Effects: require_effects(),
    Events: require_events8()
  };
});

// node_modules/phaser/src/cameras/index.js
var require_cameras = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Controls: require_controls(),
    Scene2D: require_d()
  };
});

// node_modules/phaser/src/device/OS.js
var require_OS = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var OS = {
    android: false,
    chromeOS: false,
    cordova: false,
    crosswalk: false,
    desktop: false,
    ejecta: false,
    electron: false,
    iOS: false,
    iOSVersion: 0,
    iPad: false,
    iPhone: false,
    kindle: false,
    linux: false,
    macOS: false,
    node: false,
    nodeWebkit: false,
    pixelRatio: 1,
    webApp: false,
    windows: false,
    windowsPhone: false
  };
  function init() {
    if (typeof importScripts === "function") {
      return OS;
    }
    var ua = navigator.userAgent;
    if (/Windows/.test(ua)) {
      OS.windows = true;
    } else if (/Mac OS/.test(ua) && !/like Mac OS/.test(ua)) {
      if (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) {
        OS.iOS = true;
        OS.iPad = true;
        navigator.appVersion.match(/Version\/(\d+)/);
        OS.iOSVersion = parseInt(RegExp.$1, 10);
      } else {
        OS.macOS = true;
      }
    } else if (/Android/.test(ua)) {
      OS.android = true;
    } else if (/Linux/.test(ua)) {
      OS.linux = true;
    } else if (/iP[ao]d|iPhone/i.test(ua)) {
      OS.iOS = true;
      navigator.appVersion.match(/OS (\d+)/);
      OS.iOSVersion = parseInt(RegExp.$1, 10);
      OS.iPhone = ua.toLowerCase().indexOf("iphone") !== -1;
      OS.iPad = ua.toLowerCase().indexOf("ipad") !== -1;
    } else if (/Kindle/.test(ua) || /\bKF[A-Z][A-Z]+/.test(ua) || /Silk.*Mobile Safari/.test(ua)) {
      OS.kindle = true;
    } else if (/CrOS/.test(ua)) {
      OS.chromeOS = true;
    }
    if (/Windows Phone/i.test(ua) || /IEMobile/i.test(ua)) {
      OS.android = false;
      OS.iOS = false;
      OS.macOS = false;
      OS.windows = true;
      OS.windowsPhone = true;
    }
    var silk = /Silk/.test(ua);
    if (OS.windows || OS.macOS || OS.linux && !silk || OS.chromeOS) {
      OS.desktop = true;
    }
    if (OS.windowsPhone || /Windows NT/i.test(ua) && /Touch/i.test(ua)) {
      OS.desktop = false;
    }
    if (navigator.standalone) {
      OS.webApp = true;
    }
    if (typeof importScripts !== "function") {
      if (window.cordova !== void 0) {
        OS.cordova = true;
      }
      if (window.ejecta !== void 0) {
        OS.ejecta = true;
      }
    }
    if (typeof process !== "undefined" && process.versions && process.versions.node) {
      OS.node = true;
    }
    if (OS.node && typeof process.versions === "object") {
      OS.nodeWebkit = !!process.versions["node-webkit"];
      OS.electron = !!process.versions.electron;
    }
    if (/Crosswalk/.test(ua)) {
      OS.crosswalk = true;
    }
    OS.pixelRatio = window["devicePixelRatio"] || 1;
    return OS;
  }
  module2.exports = init();
});

// node_modules/phaser/src/device/Browser.js
var require_Browser = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var OS = require_OS();
  var Browser = {
    chrome: false,
    chromeVersion: 0,
    edge: false,
    firefox: false,
    firefoxVersion: 0,
    ie: false,
    ieVersion: 0,
    mobileSafari: false,
    opera: false,
    safari: false,
    safariVersion: 0,
    silk: false,
    trident: false,
    tridentVersion: 0
  };
  function init() {
    var ua = navigator.userAgent;
    if (/Edge\/\d+/.test(ua)) {
      Browser.edge = true;
    } else if (/Chrome\/(\d+)/.test(ua) && !OS.windowsPhone) {
      Browser.chrome = true;
      Browser.chromeVersion = parseInt(RegExp.$1, 10);
    } else if (/Firefox\D+(\d+)/.test(ua)) {
      Browser.firefox = true;
      Browser.firefoxVersion = parseInt(RegExp.$1, 10);
    } else if (/AppleWebKit/.test(ua) && OS.iOS) {
      Browser.mobileSafari = true;
    } else if (/MSIE (\d+\.\d+);/.test(ua)) {
      Browser.ie = true;
      Browser.ieVersion = parseInt(RegExp.$1, 10);
    } else if (/Opera/.test(ua)) {
      Browser.opera = true;
    } else if (/Safari/.test(ua) && !OS.windowsPhone) {
      Browser.safari = true;
    } else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(ua)) {
      Browser.ie = true;
      Browser.trident = true;
      Browser.tridentVersion = parseInt(RegExp.$1, 10);
      Browser.ieVersion = parseInt(RegExp.$3, 10);
    }
    if (/Silk/.test(ua)) {
      Browser.silk = true;
    }
    return Browser;
  }
  module2.exports = init();
});

// node_modules/phaser/src/display/canvas/Smoothing.js
var require_Smoothing = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var prefix = "";
  var Smoothing = function() {
    var getPrefix = function(context) {
      var vendors = ["i", "webkitI", "msI", "mozI", "oI"];
      for (var i = 0; i < vendors.length; i++) {
        var s = vendors[i] + "mageSmoothingEnabled";
        if (s in context) {
          return s;
        }
      }
      return null;
    };
    var enable = function(context) {
      if (prefix === "") {
        prefix = getPrefix(context);
      }
      if (prefix) {
        context[prefix] = true;
      }
      return context;
    };
    var disable = function(context) {
      if (prefix === "") {
        prefix = getPrefix(context);
      }
      if (prefix) {
        context[prefix] = false;
      }
      return context;
    };
    var isEnabled = function(context) {
      return prefix !== null ? context[prefix] : null;
    };
    return {
      disable,
      enable,
      getPrefix,
      isEnabled
    };
  };
  module2.exports = Smoothing();
});

// node_modules/phaser/src/display/canvas/CanvasPool.js
var require_CanvasPool = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const();
  var Smoothing = require_Smoothing();
  var pool = [];
  var _disableContextSmoothing = false;
  var CanvasPool = function() {
    var create = function(parent, width, height, canvasType, selfParent) {
      if (width === void 0) {
        width = 1;
      }
      if (height === void 0) {
        height = 1;
      }
      if (canvasType === void 0) {
        canvasType = CONST.CANVAS;
      }
      if (selfParent === void 0) {
        selfParent = false;
      }
      var canvas;
      var container = first(canvasType);
      if (container === null) {
        container = {
          parent,
          canvas: document.createElement("canvas"),
          type: canvasType
        };
        if (canvasType === CONST.CANVAS) {
          pool.push(container);
        }
        canvas = container.canvas;
      } else {
        container.parent = parent;
        canvas = container.canvas;
      }
      if (selfParent) {
        container.parent = canvas;
      }
      canvas.width = width;
      canvas.height = height;
      if (_disableContextSmoothing && canvasType === CONST.CANVAS) {
        Smoothing.disable(canvas.getContext("2d"));
      }
      return canvas;
    };
    var create2D = function(parent, width, height) {
      return create(parent, width, height, CONST.CANVAS);
    };
    var createWebGL = function(parent, width, height) {
      return create(parent, width, height, CONST.WEBGL);
    };
    var first = function(canvasType) {
      if (canvasType === void 0) {
        canvasType = CONST.CANVAS;
      }
      if (canvasType === CONST.WEBGL) {
        return null;
      }
      for (var i = 0; i < pool.length; i++) {
        var container = pool[i];
        if (!container.parent && container.type === canvasType) {
          return container;
        }
      }
      return null;
    };
    var remove = function(parent) {
      var isCanvas = parent instanceof HTMLCanvasElement;
      pool.forEach(function(container) {
        if (isCanvas && container.canvas === parent || !isCanvas && container.parent === parent) {
          container.parent = null;
          container.canvas.width = 1;
          container.canvas.height = 1;
        }
      });
    };
    var total = function() {
      var c = 0;
      pool.forEach(function(container) {
        if (container.parent) {
          c++;
        }
      });
      return c;
    };
    var free = function() {
      return pool.length - total();
    };
    var disableSmoothing = function() {
      _disableContextSmoothing = true;
    };
    var enableSmoothing = function() {
      _disableContextSmoothing = false;
    };
    return {
      create2D,
      create,
      createWebGL,
      disableSmoothing,
      enableSmoothing,
      first,
      free,
      pool,
      remove,
      total
    };
  };
  module2.exports = CanvasPool();
});

// node_modules/phaser/src/device/Features.js
var require_Features = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var OS = require_OS();
  var Browser = require_Browser();
  var CanvasPool = require_CanvasPool();
  var Features = {
    canvas: false,
    canvasBitBltShift: null,
    file: false,
    fileSystem: false,
    getUserMedia: true,
    littleEndian: false,
    localStorage: false,
    pointerLock: false,
    support32bit: false,
    vibration: false,
    webGL: false,
    worker: false
  };
  function checkIsLittleEndian() {
    var a = new ArrayBuffer(4);
    var b = new Uint8Array(a);
    var c = new Uint32Array(a);
    b[0] = 161;
    b[1] = 178;
    b[2] = 195;
    b[3] = 212;
    if (c[0] === 3569595041) {
      return true;
    }
    if (c[0] === 2712847316) {
      return false;
    } else {
      return null;
    }
  }
  function init() {
    if (typeof importScripts === "function") {
      return Features;
    }
    Features.canvas = !!window["CanvasRenderingContext2D"];
    try {
      Features.localStorage = !!localStorage.getItem;
    } catch (error) {
      Features.localStorage = false;
    }
    Features.file = !!window["File"] && !!window["FileReader"] && !!window["FileList"] && !!window["Blob"];
    Features.fileSystem = !!window["requestFileSystem"];
    var isUint8 = false;
    var testWebGL = function() {
      if (window["WebGLRenderingContext"]) {
        try {
          var canvas = CanvasPool.createWebGL(this);
          var ctx = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
          var canvas2D = CanvasPool.create2D(this);
          var ctx2D = canvas2D.getContext("2d");
          var image = ctx2D.createImageData(1, 1);
          isUint8 = image.data instanceof Uint8ClampedArray;
          CanvasPool.remove(canvas);
          CanvasPool.remove(canvas2D);
          return !!ctx;
        } catch (e) {
          return false;
        }
      }
      return false;
    };
    Features.webGL = testWebGL();
    Features.worker = !!window["Worker"];
    Features.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
    window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
    Features.getUserMedia = Features.getUserMedia && !!navigator.getUserMedia && !!window.URL;
    if (Browser.firefox && Browser.firefoxVersion < 21) {
      Features.getUserMedia = false;
    }
    if (!OS.iOS && (Browser.ie || Browser.firefox || Browser.chrome)) {
      Features.canvasBitBltShift = true;
    }
    if (Browser.safari || Browser.mobileSafari) {
      Features.canvasBitBltShift = false;
    }
    navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
    if (navigator.vibrate) {
      Features.vibration = true;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint32Array !== "undefined") {
      Features.littleEndian = checkIsLittleEndian();
    }
    Features.support32bit = typeof ArrayBuffer !== "undefined" && typeof Uint8ClampedArray !== "undefined" && typeof Int32Array !== "undefined" && Features.littleEndian !== null && isUint8;
    return Features;
  }
  module2.exports = init();
});

// node_modules/phaser/src/device/Input.js
var require_Input = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Browser = require_Browser();
  var Input = {
    gamepads: false,
    mspointer: false,
    touch: false,
    wheelEvent: null
  };
  function init() {
    if (typeof importScripts === "function") {
      return Input;
    }
    if ("ontouchstart" in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) {
      Input.touch = true;
    }
    if (navigator.msPointerEnabled || navigator.pointerEnabled) {
      Input.mspointer = true;
    }
    if (navigator.getGamepads) {
      Input.gamepads = true;
    }
    if ("onwheel" in window || Browser.ie && "WheelEvent" in window) {
      Input.wheelEvent = "wheel";
    } else if ("onmousewheel" in window) {
      Input.wheelEvent = "mousewheel";
    } else if (Browser.firefox && "MouseScrollEvent" in window) {
      Input.wheelEvent = "DOMMouseScroll";
    }
    return Input;
  }
  module2.exports = init();
});

// node_modules/phaser/src/device/Audio.js
var require_Audio = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Browser = require_Browser();
  var Audio2 = {
    audioData: false,
    dolby: false,
    m4a: false,
    mp3: false,
    ogg: false,
    opus: false,
    wav: false,
    webAudio: false,
    webm: false
  };
  function init() {
    if (typeof importScripts === "function") {
      return Audio2;
    }
    Audio2.audioData = !!window["Audio"];
    Audio2.webAudio = !!(window["AudioContext"] || window["webkitAudioContext"]);
    var audioElement = document.createElement("audio");
    var result = !!audioElement.canPlayType;
    try {
      if (result) {
        if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
          Audio2.ogg = true;
        }
        if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || audioElement.canPlayType("audio/opus;").replace(/^no$/, "")) {
          Audio2.opus = true;
        }
        if (audioElement.canPlayType("audio/mpeg;").replace(/^no$/, "")) {
          Audio2.mp3 = true;
        }
        if (audioElement.canPlayType("audio/wav").replace(/^no$/, "")) {
          Audio2.wav = true;
        }
        if (audioElement.canPlayType("audio/x-m4a;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, "")) {
          Audio2.m4a = true;
        }
        if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")) {
          Audio2.webm = true;
        }
        if (audioElement.canPlayType('audio/mp4;codecs="ec-3"') !== "") {
          if (Browser.edge) {
            Audio2.dolby = true;
          } else if (Browser.safari && Browser.safariVersion >= 9) {
            if (/Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
              var major = parseInt(RegExp.$1, 10);
              var minor = parseInt(RegExp.$2, 10);
              if (major === 10 && minor >= 11 || major > 10) {
                Audio2.dolby = true;
              }
            }
          }
        }
      }
    } catch (e) {
    }
    return Audio2;
  }
  module2.exports = init();
});

// node_modules/phaser/src/device/Video.js
var require_Video = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Video = {
    h264: false,
    hls: false,
    mp4: false,
    ogg: false,
    vp9: false,
    webm: false
  };
  function init() {
    if (typeof importScripts === "function") {
      return Video;
    }
    var videoElement = document.createElement("video");
    var result = !!videoElement.canPlayType;
    try {
      if (result) {
        if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "")) {
          Video.ogg = true;
        }
        if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "")) {
          Video.h264 = true;
          Video.mp4 = true;
        }
        if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "")) {
          Video.webm = true;
        }
        if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "")) {
          Video.vp9 = true;
        }
        if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "")) {
          Video.hls = true;
        }
      }
    } catch (e) {
    }
    return Video;
  }
  module2.exports = init();
});

// node_modules/phaser/src/device/Fullscreen.js
var require_Fullscreen = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Fullscreen = {
    available: false,
    cancel: "",
    keyboard: false,
    request: ""
  };
  function init() {
    if (typeof importScripts === "function") {
      return Fullscreen;
    }
    var i;
    var suffix1 = "Fullscreen";
    var suffix2 = "FullScreen";
    var fs = [
      "request" + suffix1,
      "request" + suffix2,
      "webkitRequest" + suffix1,
      "webkitRequest" + suffix2,
      "msRequest" + suffix1,
      "msRequest" + suffix2,
      "mozRequest" + suffix2,
      "mozRequest" + suffix1
    ];
    for (i = 0; i < fs.length; i++) {
      if (document.documentElement[fs[i]]) {
        Fullscreen.available = true;
        Fullscreen.request = fs[i];
        break;
      }
    }
    var cfs = [
      "cancel" + suffix2,
      "exit" + suffix1,
      "webkitCancel" + suffix2,
      "webkitExit" + suffix1,
      "msCancel" + suffix2,
      "msExit" + suffix1,
      "mozCancel" + suffix2,
      "mozExit" + suffix1
    ];
    if (Fullscreen.available) {
      for (i = 0; i < cfs.length; i++) {
        if (document[cfs[i]]) {
          Fullscreen.cancel = cfs[i];
          break;
        }
      }
    }
    if (window["Element"] && Element["ALLOW_KEYBOARD_INPUT"] && !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent)) {
      Fullscreen.keyboard = true;
    }
    Object.defineProperty(Fullscreen, "active", {get: function() {
      return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
    }});
    return Fullscreen;
  }
  module2.exports = init();
});

// node_modules/phaser/src/device/CanvasFeatures.js
var require_CanvasFeatures = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CanvasPool = require_CanvasPool();
  var CanvasFeatures = {
    supportInverseAlpha: false,
    supportNewBlendModes: false
  };
  function checkBlendMode() {
    var pngHead = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/";
    var pngEnd = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==";
    var magenta = new Image();
    magenta.onload = function() {
      var yellow = new Image();
      yellow.onload = function() {
        var canvas = CanvasPool.create(yellow, 6, 1);
        var context = canvas.getContext("2d");
        context.globalCompositeOperation = "multiply";
        context.drawImage(magenta, 0, 0);
        context.drawImage(yellow, 2, 0);
        if (!context.getImageData(2, 0, 1, 1)) {
          return false;
        }
        var data = context.getImageData(2, 0, 1, 1).data;
        CanvasPool.remove(yellow);
        CanvasFeatures.supportNewBlendModes = data[0] === 255 && data[1] === 0 && data[2] === 0;
      };
      yellow.src = pngHead + "/wCKxvRF" + pngEnd;
    };
    magenta.src = pngHead + "AP804Oa6" + pngEnd;
    return false;
  }
  function checkInverseAlpha() {
    var canvas = CanvasPool.create(this, 2, 1);
    var context = canvas.getContext("2d");
    context.fillStyle = "rgba(10, 20, 30, 0.5)";
    context.fillRect(0, 0, 1, 1);
    var s1 = context.getImageData(0, 0, 1, 1);
    if (s1 === null) {
      return false;
    }
    context.putImageData(s1, 1, 0);
    var s2 = context.getImageData(1, 0, 1, 1);
    return s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3];
  }
  function init() {
    if (typeof importScripts !== "function" && document !== void 0) {
      CanvasFeatures.supportNewBlendModes = checkBlendMode();
      CanvasFeatures.supportInverseAlpha = checkInverseAlpha();
    }
    return CanvasFeatures;
  }
  module2.exports = init();
});

// node_modules/phaser/src/device/index.js
var require_device = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    os: require_OS(),
    browser: require_Browser(),
    features: require_Features(),
    input: require_Input(),
    audio: require_Audio(),
    video: require_Video(),
    fullscreen: require_Fullscreen(),
    canvasFeatures: require_CanvasFeatures()
  };
});

// node_modules/phaser/src/math/angle/Between.js
var require_Between = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Between = function(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  };
  module2.exports = Between;
});

// node_modules/phaser/src/math/angle/BetweenPoints.js
var require_BetweenPoints = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BetweenPoints = function(point1, point2) {
    return Math.atan2(point2.y - point1.y, point2.x - point1.x);
  };
  module2.exports = BetweenPoints;
});

// node_modules/phaser/src/math/angle/BetweenPointsY.js
var require_BetweenPointsY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BetweenPointsY = function(point1, point2) {
    return Math.atan2(point2.x - point1.x, point2.y - point1.y);
  };
  module2.exports = BetweenPointsY;
});

// node_modules/phaser/src/math/angle/BetweenY.js
var require_BetweenY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BetweenY = function(x1, y1, x2, y2) {
    return Math.atan2(x2 - x1, y2 - y1);
  };
  module2.exports = BetweenY;
});

// node_modules/phaser/src/math/angle/CounterClockwise.js
var require_CounterClockwise = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const4();
  var CounterClockwise = function(angle) {
    if (angle > Math.PI) {
      angle -= CONST.PI2;
    }
    return Math.abs(((angle + CONST.TAU) % CONST.PI2 - CONST.PI2) % CONST.PI2);
  };
  module2.exports = CounterClockwise;
});

// node_modules/phaser/src/math/angle/Normalize.js
var require_Normalize = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Normalize = function(angle) {
    angle = angle % (2 * Math.PI);
    if (angle >= 0) {
      return angle;
    } else {
      return angle + 2 * Math.PI;
    }
  };
  module2.exports = Normalize;
});

// node_modules/phaser/src/math/FloatBetween.js
var require_FloatBetween = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FloatBetween = function(min, max) {
    return Math.random() * (max - min) + min;
  };
  module2.exports = FloatBetween;
});

// node_modules/phaser/src/math/angle/Random.js
var require_Random6 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       @samme
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FloatBetween = require_FloatBetween();
  var Random = function() {
    return FloatBetween(-Math.PI, Math.PI);
  };
  module2.exports = Random;
});

// node_modules/phaser/src/math/angle/RandomDegrees.js
var require_RandomDegrees = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       @samme
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FloatBetween = require_FloatBetween();
  var RandomDegrees = function() {
    return FloatBetween(-180, 180);
  };
  module2.exports = RandomDegrees;
});

// node_modules/phaser/src/math/angle/Reverse.js
var require_Reverse = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Normalize = require_Normalize();
  var Reverse = function(angle) {
    return Normalize(angle + Math.PI);
  };
  module2.exports = Reverse;
});

// node_modules/phaser/src/math/angle/RotateTo.js
var require_RotateTo2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MATH_CONST = require_const4();
  var RotateTo = function(currentAngle, targetAngle, lerp) {
    if (lerp === void 0) {
      lerp = 0.05;
    }
    if (currentAngle === targetAngle) {
      return currentAngle;
    }
    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= MATH_CONST.PI2 - lerp) {
      currentAngle = targetAngle;
    } else {
      if (Math.abs(targetAngle - currentAngle) > Math.PI) {
        if (targetAngle < currentAngle) {
          targetAngle += MATH_CONST.PI2;
        } else {
          targetAngle -= MATH_CONST.PI2;
        }
      }
      if (targetAngle > currentAngle) {
        currentAngle += lerp;
      } else if (targetAngle < currentAngle) {
        currentAngle -= lerp;
      }
    }
    return currentAngle;
  };
  module2.exports = RotateTo;
});

// node_modules/phaser/src/math/angle/ShortestBetween.js
var require_ShortestBetween = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ShortestBetween = function(angle1, angle2) {
    var difference = angle2 - angle1;
    if (difference === 0) {
      return 0;
    }
    var times = Math.floor((difference - -180) / 360);
    return difference - times * 360;
  };
  module2.exports = ShortestBetween;
});

// node_modules/phaser/src/math/angle/index.js
var require_angle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Between: require_Between(),
    BetweenPoints: require_BetweenPoints(),
    BetweenPointsY: require_BetweenPointsY(),
    BetweenY: require_BetweenY(),
    CounterClockwise: require_CounterClockwise(),
    Normalize: require_Normalize(),
    Random: require_Random6(),
    RandomDegrees: require_RandomDegrees(),
    Reverse: require_Reverse(),
    RotateTo: require_RotateTo2(),
    ShortestBetween: require_ShortestBetween(),
    Wrap: require_Wrap2(),
    WrapDegrees: require_WrapDegrees()
  };
});

// node_modules/phaser/src/math/distance/DistanceBetweenPoints.js
var require_DistanceBetweenPoints = __commonJS((exports2, module2) => {
  /**
   * @author       samme
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DistanceBetweenPoints = function(a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  module2.exports = DistanceBetweenPoints;
});

// node_modules/phaser/src/math/distance/DistanceBetweenPointsSquared.js
var require_DistanceBetweenPointsSquared = __commonJS((exports2, module2) => {
  /**
   * @author       samme
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DistanceBetweenPointsSquared = function(a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return dx * dx + dy * dy;
  };
  module2.exports = DistanceBetweenPointsSquared;
});

// node_modules/phaser/src/math/distance/DistanceChebyshev.js
var require_DistanceChebyshev = __commonJS((exports2, module2) => {
  /**
   * @author       samme
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ChebyshevDistance = function(x1, y1, x2, y2) {
    return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
  };
  module2.exports = ChebyshevDistance;
});

// node_modules/phaser/src/math/distance/DistancePower.js
var require_DistancePower = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DistancePower = function(x1, y1, x2, y2, pow) {
    if (pow === void 0) {
      pow = 2;
    }
    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
  };
  module2.exports = DistancePower;
});

// node_modules/phaser/src/math/distance/DistanceSnake.js
var require_DistanceSnake = __commonJS((exports2, module2) => {
  /**
   * @author       samme
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SnakeDistance = function(x1, y1, x2, y2) {
    return Math.abs(x1 - x2) + Math.abs(y1 - y2);
  };
  module2.exports = SnakeDistance;
});

// node_modules/phaser/src/math/distance/DistanceSquared.js
var require_DistanceSquared = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DistanceSquared = function(x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return dx * dx + dy * dy;
  };
  module2.exports = DistanceSquared;
});

// node_modules/phaser/src/math/distance/index.js
var require_distance = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Between: require_DistanceBetween(),
    BetweenPoints: require_DistanceBetweenPoints(),
    BetweenPointsSquared: require_DistanceBetweenPointsSquared(),
    Chebyshev: require_DistanceChebyshev(),
    Power: require_DistancePower(),
    Snake: require_DistanceSnake(),
    Squared: require_DistanceSquared()
  };
});

// node_modules/phaser/src/math/easing/index.js
var require_easing = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Back: require_back(),
    Bounce: require_bounce(),
    Circular: require_circular(),
    Cubic: require_cubic(),
    Elastic: require_elastic(),
    Expo: require_expo(),
    Linear: require_linear(),
    Quadratic: require_quadratic(),
    Quartic: require_quartic(),
    Quintic: require_quintic(),
    Sine: require_sine(),
    Stepped: require_stepped()
  };
});

// node_modules/phaser/src/math/fuzzy/Ceil.js
var require_Ceil = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Ceil = function(value, epsilon) {
    if (epsilon === void 0) {
      epsilon = 1e-4;
    }
    return Math.ceil(value - epsilon);
  };
  module2.exports = Ceil;
});

// node_modules/phaser/src/math/fuzzy/Floor.js
var require_Floor = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Floor = function(value, epsilon) {
    if (epsilon === void 0) {
      epsilon = 1e-4;
    }
    return Math.floor(value + epsilon);
  };
  module2.exports = Floor;
});

// node_modules/phaser/src/math/fuzzy/GreaterThan.js
var require_GreaterThan = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GreaterThan = function(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = 1e-4;
    }
    return a > b - epsilon;
  };
  module2.exports = GreaterThan;
});

// node_modules/phaser/src/math/fuzzy/LessThan.js
var require_LessThan = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var LessThan = function(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = 1e-4;
    }
    return a < b + epsilon;
  };
  module2.exports = LessThan;
});

// node_modules/phaser/src/math/fuzzy/index.js
var require_fuzzy = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Ceil: require_Ceil(),
    Equal: require_Equal(),
    Floor: require_Floor(),
    GreaterThan: require_GreaterThan(),
    LessThan: require_LessThan()
  };
});

// node_modules/phaser/src/math/Factorial.js
var require_Factorial = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Factorial = function(value) {
    if (value === 0) {
      return 1;
    }
    var res = value;
    while (--value) {
      res *= value;
    }
    return res;
  };
  module2.exports = Factorial;
});

// node_modules/phaser/src/math/Bernstein.js
var require_Bernstein = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Factorial = require_Factorial();
  var Bernstein = function(n, i) {
    return Factorial(n) / Factorial(i) / Factorial(n - i);
  };
  module2.exports = Bernstein;
});

// node_modules/phaser/src/math/interpolation/BezierInterpolation.js
var require_BezierInterpolation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Bernstein = require_Bernstein();
  var BezierInterpolation = function(v, k) {
    var b = 0;
    var n = v.length - 1;
    for (var i = 0; i <= n; i++) {
      b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);
    }
    return b;
  };
  module2.exports = BezierInterpolation;
});

// node_modules/phaser/src/math/CatmullRom.js
var require_CatmullRom = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CatmullRom = function(t, p0, p1, p2, p3) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
  };
  module2.exports = CatmullRom;
});

// node_modules/phaser/src/math/interpolation/CatmullRomInterpolation.js
var require_CatmullRomInterpolation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CatmullRom = require_CatmullRom();
  var CatmullRomInterpolation = function(v, k) {
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);
    if (v[0] === v[m]) {
      if (k < 0) {
        i = Math.floor(f = m * (1 + k));
      }
      return CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m]);
    } else {
      if (k < 0) {
        return v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]);
      }
      if (k > 1) {
        return v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]);
      }
      return CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);
    }
  };
  module2.exports = CatmullRomInterpolation;
});

// node_modules/phaser/src/math/interpolation/CubicBezierInterpolation.js
var require_CubicBezierInterpolation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  function P0(t, p) {
    var k = 1 - t;
    return k * k * k * p;
  }
  function P1(t, p) {
    var k = 1 - t;
    return 3 * k * k * t * p;
  }
  function P2(t, p) {
    return 3 * (1 - t) * t * t * p;
  }
  function P3(t, p) {
    return t * t * t * p;
  }
  var CubicBezierInterpolation = function(t, p0, p1, p2, p3) {
    return P0(t, p0) + P1(t, p1) + P2(t, p2) + P3(t, p3);
  };
  module2.exports = CubicBezierInterpolation;
});

// node_modules/phaser/src/math/interpolation/LinearInterpolation.js
var require_LinearInterpolation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Linear = require_Linear2();
  var LinearInterpolation = function(v, k) {
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);
    if (k < 0) {
      return Linear(v[0], v[1], f);
    } else if (k > 1) {
      return Linear(v[m], v[m - 1], m - f);
    } else {
      return Linear(v[i], v[i + 1 > m ? m : i + 1], f - i);
    }
  };
  module2.exports = LinearInterpolation;
});

// node_modules/phaser/src/math/interpolation/QuadraticBezierInterpolation.js
var require_QuadraticBezierInterpolation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  function P0(t, p) {
    var k = 1 - t;
    return k * k * p;
  }
  function P1(t, p) {
    return 2 * (1 - t) * t * p;
  }
  function P2(t, p) {
    return t * t * p;
  }
  var QuadraticBezierInterpolation = function(t, p0, p1, p2) {
    return P0(t, p0) + P1(t, p1) + P2(t, p2);
  };
  module2.exports = QuadraticBezierInterpolation;
});

// node_modules/phaser/src/math/interpolation/SmoothStepInterpolation.js
var require_SmoothStepInterpolation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SmoothStep = require_SmoothStep();
  var SmoothStepInterpolation = function(t, min, max) {
    return min + (max - min) * SmoothStep(t, 0, 1);
  };
  module2.exports = SmoothStepInterpolation;
});

// node_modules/phaser/src/math/interpolation/SmootherStepInterpolation.js
var require_SmootherStepInterpolation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SmootherStep = require_SmootherStep();
  var SmootherStepInterpolation = function(t, min, max) {
    return min + (max - min) * SmootherStep(t, 0, 1);
  };
  module2.exports = SmootherStepInterpolation;
});

// node_modules/phaser/src/math/interpolation/index.js
var require_interpolation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Bezier: require_BezierInterpolation(),
    CatmullRom: require_CatmullRomInterpolation(),
    CubicBezier: require_CubicBezierInterpolation(),
    Linear: require_LinearInterpolation(),
    QuadraticBezier: require_QuadraticBezierInterpolation(),
    SmoothStep: require_SmoothStepInterpolation(),
    SmootherStep: require_SmootherStepInterpolation()
  };
});

// node_modules/phaser/src/math/pow2/GetPowerOfTwo.js
var require_GetPowerOfTwo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetPowerOfTwo = function(value) {
    var index = Math.log(value) / 0.6931471805599453;
    return 1 << Math.ceil(index);
  };
  module2.exports = GetPowerOfTwo;
});

// node_modules/phaser/src/math/pow2/IsSizePowerOfTwo.js
var require_IsSizePowerOfTwo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var IsSizePowerOfTwo = function(width, height) {
    return width > 0 && (width & width - 1) === 0 && height > 0 && (height & height - 1) === 0;
  };
  module2.exports = IsSizePowerOfTwo;
});

// node_modules/phaser/src/math/pow2/IsValuePowerOfTwo.js
var require_IsValuePowerOfTwo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var IsValuePowerOfTwo = function(value) {
    return value > 0 && (value & value - 1) === 0;
  };
  module2.exports = IsValuePowerOfTwo;
});

// node_modules/phaser/src/math/pow2/index.js
var require_pow2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    GetNext: require_GetPowerOfTwo(),
    IsSize: require_IsSizePowerOfTwo(),
    IsValue: require_IsValuePowerOfTwo()
  };
});

// node_modules/phaser/src/math/snap/SnapCeil.js
var require_SnapCeil = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SnapCeil = function(value, gap, start, divide) {
    if (start === void 0) {
      start = 0;
    }
    if (gap === 0) {
      return value;
    }
    value -= start;
    value = gap * Math.ceil(value / gap);
    return divide ? (start + value) / gap : start + value;
  };
  module2.exports = SnapCeil;
});

// node_modules/phaser/src/math/snap/SnapFloor.js
var require_SnapFloor = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SnapFloor = function(value, gap, start, divide) {
    if (start === void 0) {
      start = 0;
    }
    if (gap === 0) {
      return value;
    }
    value -= start;
    value = gap * Math.floor(value / gap);
    return divide ? (start + value) / gap : start + value;
  };
  module2.exports = SnapFloor;
});

// node_modules/phaser/src/math/snap/SnapTo.js
var require_SnapTo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SnapTo = function(value, gap, start, divide) {
    if (start === void 0) {
      start = 0;
    }
    if (gap === 0) {
      return value;
    }
    value -= start;
    value = gap * Math.round(value / gap);
    return divide ? (start + value) / gap : start + value;
  };
  module2.exports = SnapTo;
});

// node_modules/phaser/src/math/snap/index.js
var require_snap = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Ceil: require_SnapCeil(),
    Floor: require_SnapFloor(),
    To: require_SnapTo()
  };
});

// node_modules/phaser/src/math/random-data-generator/RandomDataGenerator.js
var require_RandomDataGenerator = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var RandomDataGenerator = new Class({
    initialize: function RandomDataGenerator2(seeds) {
      if (seeds === void 0) {
        seeds = [(Date.now() * Math.random()).toString()];
      }
      this.c = 1;
      this.s0 = 0;
      this.s1 = 0;
      this.s2 = 0;
      this.n = 0;
      this.signs = [-1, 1];
      if (seeds) {
        this.init(seeds);
      }
    },
    rnd: function() {
      var t = 2091639 * this.s0 + this.c * 23283064365386963e-26;
      this.c = t | 0;
      this.s0 = this.s1;
      this.s1 = this.s2;
      this.s2 = t - this.c;
      return this.s2;
    },
    hash: function(data) {
      var h;
      var n = this.n;
      data = data.toString();
      for (var i = 0; i < data.length; i++) {
        n += data.charCodeAt(i);
        h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 4294967296;
      }
      this.n = n;
      return (n >>> 0) * 23283064365386963e-26;
    },
    init: function(seeds) {
      if (typeof seeds === "string") {
        this.state(seeds);
      } else {
        this.sow(seeds);
      }
    },
    sow: function(seeds) {
      this.n = 4022871197;
      this.s0 = this.hash(" ");
      this.s1 = this.hash(" ");
      this.s2 = this.hash(" ");
      this.c = 1;
      if (!seeds) {
        return;
      }
      for (var i = 0; i < seeds.length && seeds[i] != null; i++) {
        var seed = seeds[i];
        this.s0 -= this.hash(seed);
        this.s0 += ~~(this.s0 < 0);
        this.s1 -= this.hash(seed);
        this.s1 += ~~(this.s1 < 0);
        this.s2 -= this.hash(seed);
        this.s2 += ~~(this.s2 < 0);
      }
    },
    integer: function() {
      return this.rnd() * 4294967296;
    },
    frac: function() {
      return this.rnd() + (this.rnd() * 2097152 | 0) * 11102230246251565e-32;
    },
    real: function() {
      return this.integer() + this.frac();
    },
    integerInRange: function(min, max) {
      return Math.floor(this.realInRange(0, max - min + 1) + min);
    },
    between: function(min, max) {
      return Math.floor(this.realInRange(0, max - min + 1) + min);
    },
    realInRange: function(min, max) {
      return this.frac() * (max - min) + min;
    },
    normal: function() {
      return 1 - 2 * this.frac();
    },
    uuid: function() {
      var a = "";
      var b = "";
      for (b = a = ""; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
      }
      return b;
    },
    pick: function(array) {
      return array[this.integerInRange(0, array.length - 1)];
    },
    sign: function() {
      return this.pick(this.signs);
    },
    weightedPick: function(array) {
      return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];
    },
    timestamp: function(min, max) {
      return this.realInRange(min || 9466848e5, max || 1577862e6);
    },
    angle: function() {
      return this.integerInRange(-180, 180);
    },
    rotation: function() {
      return this.realInRange(-3.1415926, 3.1415926);
    },
    state: function(state) {
      if (typeof state === "string" && state.match(/^!rnd/)) {
        state = state.split(",");
        this.c = parseFloat(state[1]);
        this.s0 = parseFloat(state[2]);
        this.s1 = parseFloat(state[3]);
        this.s2 = parseFloat(state[4]);
      }
      return ["!rnd", this.c, this.s0, this.s1, this.s2].join(",");
    },
    shuffle: function(array) {
      var len = array.length - 1;
      for (var i = len; i > 0; i--) {
        var randomIndex = Math.floor(this.frac() * (i + 1));
        var itemAtIndex = array[randomIndex];
        array[randomIndex] = array[i];
        array[i] = itemAtIndex;
      }
      return array;
    }
  });
  module2.exports = RandomDataGenerator;
});

// node_modules/phaser/src/math/Average.js
var require_Average = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Average = function(values) {
    var sum = 0;
    for (var i = 0; i < values.length; i++) {
      sum += +values[i];
    }
    return sum / values.length;
  };
  module2.exports = Average;
});

// node_modules/phaser/src/math/Between.js
var require_Between2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Between = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  };
  module2.exports = Between;
});

// node_modules/phaser/src/math/CeilTo.js
var require_CeilTo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CeilTo = function(value, place, base) {
    if (place === void 0) {
      place = 0;
    }
    if (base === void 0) {
      base = 10;
    }
    var p = Math.pow(base, -place);
    return Math.ceil(value * p) / p;
  };
  module2.exports = CeilTo;
});

// node_modules/phaser/src/math/Difference.js
var require_Difference = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Difference = function(a, b) {
    return Math.abs(a - b);
  };
  module2.exports = Difference;
});

// node_modules/phaser/src/math/Vector3.js
var require_Vector3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Vector3 = new Class({
    initialize: function Vector32(x, y, z) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      if (typeof x === "object") {
        this.x = x.x || 0;
        this.y = x.y || 0;
        this.z = x.z || 0;
      } else {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
      }
    },
    up: function() {
      this.x = 0;
      this.y = 1;
      this.z = 0;
      return this;
    },
    min: function(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    },
    max: function(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    },
    clone: function() {
      return new Vector3(this.x, this.y, this.z);
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    },
    crossVectors: function(a, b) {
      var ax = a.x;
      var ay = a.y;
      var az = a.z;
      var bx = b.x;
      var by = b.y;
      var bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    },
    equals: function(v) {
      return this.x === v.x && this.y === v.y && this.z === v.z;
    },
    copy: function(src) {
      this.x = src.x;
      this.y = src.y;
      this.z = src.z || 0;
      return this;
    },
    set: function(x, y, z) {
      if (typeof x === "object") {
        this.x = x.x || 0;
        this.y = x.y || 0;
        this.z = x.z || 0;
      } else {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
      }
      return this;
    },
    setFromMatrixPosition: function(m) {
      return this.fromArray(m.val, 12);
    },
    setFromMatrixColumn: function(mat4, index) {
      return this.fromArray(mat4.val, index * 4);
    },
    fromArray: function(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    },
    add: function(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z || 0;
      return this;
    },
    addScalar: function(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    },
    addScale: function(v, scale) {
      this.x += v.x * scale;
      this.y += v.y * scale;
      this.z += v.z * scale || 0;
      return this;
    },
    subtract: function(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z || 0;
      return this;
    },
    multiply: function(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z || 1;
      return this;
    },
    scale: function(scale) {
      if (isFinite(scale)) {
        this.x *= scale;
        this.y *= scale;
        this.z *= scale;
      } else {
        this.x = 0;
        this.y = 0;
        this.z = 0;
      }
      return this;
    },
    divide: function(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z || 1;
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    },
    distance: function(v) {
      var dx = v.x - this.x;
      var dy = v.y - this.y;
      var dz = v.z - this.z || 0;
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    },
    distanceSq: function(v) {
      var dx = v.x - this.x;
      var dy = v.y - this.y;
      var dz = v.z - this.z || 0;
      return dx * dx + dy * dy + dz * dz;
    },
    length: function() {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      return Math.sqrt(x * x + y * y + z * z);
    },
    lengthSq: function() {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      return x * x + y * y + z * z;
    },
    normalize: function() {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var len = x * x + y * y + z * z;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
        this.x = x * len;
        this.y = y * len;
        this.z = z * len;
      }
      return this;
    },
    dot: function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    },
    cross: function(v) {
      var ax = this.x;
      var ay = this.y;
      var az = this.z;
      var bx = v.x;
      var by = v.y;
      var bz = v.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    },
    lerp: function(v, t) {
      if (t === void 0) {
        t = 0;
      }
      var ax = this.x;
      var ay = this.y;
      var az = this.z;
      this.x = ax + t * (v.x - ax);
      this.y = ay + t * (v.y - ay);
      this.z = az + t * (v.z - az);
      return this;
    },
    applyMatrix3: function(mat3) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var m = mat3.val;
      this.x = m[0] * x + m[3] * y + m[6] * z;
      this.y = m[1] * x + m[4] * y + m[7] * z;
      this.z = m[2] * x + m[5] * y + m[8] * z;
      return this;
    },
    applyMatrix4: function(mat4) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var m = mat4.val;
      var w = 1 / (m[3] * x + m[7] * y + m[11] * z + m[15]);
      this.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) * w;
      this.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) * w;
      this.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) * w;
      return this;
    },
    transformMat3: function(mat) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var m = mat.val;
      this.x = x * m[0] + y * m[3] + z * m[6];
      this.y = x * m[1] + y * m[4] + z * m[7];
      this.z = x * m[2] + y * m[5] + z * m[8];
      return this;
    },
    transformMat4: function(mat) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var m = mat.val;
      this.x = m[0] * x + m[4] * y + m[8] * z + m[12];
      this.y = m[1] * x + m[5] * y + m[9] * z + m[13];
      this.z = m[2] * x + m[6] * y + m[10] * z + m[14];
      return this;
    },
    transformCoordinates: function(mat) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var m = mat.val;
      var tx = x * m[0] + y * m[4] + z * m[8] + m[12];
      var ty = x * m[1] + y * m[5] + z * m[9] + m[13];
      var tz = x * m[2] + y * m[6] + z * m[10] + m[14];
      var tw = x * m[3] + y * m[7] + z * m[11] + m[15];
      this.x = tx / tw;
      this.y = ty / tw;
      this.z = tz / tw;
      return this;
    },
    transformQuat: function(q) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var qx = q.x;
      var qy = q.y;
      var qz = q.z;
      var qw = q.w;
      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z;
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    },
    project: function(mat) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var m = mat.val;
      var a00 = m[0];
      var a01 = m[1];
      var a02 = m[2];
      var a03 = m[3];
      var a10 = m[4];
      var a11 = m[5];
      var a12 = m[6];
      var a13 = m[7];
      var a20 = m[8];
      var a21 = m[9];
      var a22 = m[10];
      var a23 = m[11];
      var a30 = m[12];
      var a31 = m[13];
      var a32 = m[14];
      var a33 = m[15];
      var lw = 1 / (x * a03 + y * a13 + z * a23 + a33);
      this.x = (x * a00 + y * a10 + z * a20 + a30) * lw;
      this.y = (x * a01 + y * a11 + z * a21 + a31) * lw;
      this.z = (x * a02 + y * a12 + z * a22 + a32) * lw;
      return this;
    },
    projectViewMatrix: function(viewMatrix, projectionMatrix) {
      return this.applyMatrix4(viewMatrix).applyMatrix4(projectionMatrix);
    },
    unprojectViewMatrix: function(projectionMatrix, worldMatrix) {
      return this.applyMatrix4(projectionMatrix).applyMatrix4(worldMatrix);
    },
    unproject: function(viewport, invProjectionView) {
      var viewX = viewport.x;
      var viewY = viewport.y;
      var viewWidth = viewport.z;
      var viewHeight = viewport.w;
      var x = this.x - viewX;
      var y = viewHeight - this.y - 1 - viewY;
      var z = this.z;
      this.x = 2 * x / viewWidth - 1;
      this.y = 2 * y / viewHeight - 1;
      this.z = 2 * z - 1;
      return this.project(invProjectionView);
    },
    reset: function() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      return this;
    }
  });
  Vector3.ZERO = new Vector3();
  Vector3.RIGHT = new Vector3(1, 0, 0);
  Vector3.LEFT = new Vector3(-1, 0, 0);
  Vector3.UP = new Vector3(0, -1, 0);
  Vector3.DOWN = new Vector3(0, 1, 0);
  Vector3.FORWARD = new Vector3(0, 0, 1);
  Vector3.BACK = new Vector3(0, 0, -1);
  Vector3.ONE = new Vector3(1, 1, 1);
  module2.exports = Vector3;
});

// node_modules/phaser/src/math/Matrix4.js
var require_Matrix4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Vector3 = require_Vector3();
  var EPSILON = 1e-6;
  var Matrix4 = new Class({
    initialize: function Matrix42(m) {
      this.val = new Float32Array(16);
      if (m) {
        this.copy(m);
      } else {
        this.identity();
      }
    },
    clone: function() {
      return new Matrix4(this);
    },
    set: function(src) {
      return this.copy(src);
    },
    setValues: function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      var out = this.val;
      out[0] = m00;
      out[1] = m01;
      out[2] = m02;
      out[3] = m03;
      out[4] = m10;
      out[5] = m11;
      out[6] = m12;
      out[7] = m13;
      out[8] = m20;
      out[9] = m21;
      out[10] = m22;
      out[11] = m23;
      out[12] = m30;
      out[13] = m31;
      out[14] = m32;
      out[15] = m33;
      return this;
    },
    copy: function(src) {
      var a = src.val;
      return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
    },
    fromArray: function(a) {
      return this.setValues(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
    },
    zero: function() {
      return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    },
    transform: function(position, scale, rotation) {
      var rotMatrix = _tempMat1.fromQuat(rotation);
      var rm = rotMatrix.val;
      var sx = scale.x;
      var sy = scale.y;
      var sz = scale.z;
      return this.setValues(rm[0] * sx, rm[1] * sx, rm[2] * sx, 0, rm[4] * sy, rm[5] * sy, rm[6] * sy, 0, rm[8] * sz, rm[9] * sz, rm[10] * sz, 0, position.x, position.y, position.z, 1);
    },
    xyz: function(x, y, z) {
      this.identity();
      var out = this.val;
      out[12] = x;
      out[13] = y;
      out[14] = z;
      return this;
    },
    scaling: function(x, y, z) {
      this.zero();
      var out = this.val;
      out[0] = x;
      out[5] = y;
      out[10] = z;
      out[15] = 1;
      return this;
    },
    identity: function() {
      return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    },
    transpose: function() {
      var a = this.val;
      var a01 = a[1];
      var a02 = a[2];
      var a03 = a[3];
      var a12 = a[6];
      var a13 = a[7];
      var a23 = a[11];
      a[1] = a[4];
      a[2] = a[8];
      a[3] = a[12];
      a[4] = a01;
      a[6] = a[9];
      a[7] = a[13];
      a[8] = a02;
      a[9] = a12;
      a[11] = a[14];
      a[12] = a03;
      a[13] = a13;
      a[14] = a23;
      return this;
    },
    getInverse: function(m) {
      this.copy(m);
      return this.invert();
    },
    invert: function() {
      var a = this.val;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a03 = a[3];
      var a10 = a[4];
      var a11 = a[5];
      var a12 = a[6];
      var a13 = a[7];
      var a20 = a[8];
      var a21 = a[9];
      var a22 = a[10];
      var a23 = a[11];
      var a30 = a[12];
      var a31 = a[13];
      var a32 = a[14];
      var a33 = a[15];
      var b00 = a00 * a11 - a01 * a10;
      var b01 = a00 * a12 - a02 * a10;
      var b02 = a00 * a13 - a03 * a10;
      var b03 = a01 * a12 - a02 * a11;
      var b04 = a01 * a13 - a03 * a11;
      var b05 = a02 * a13 - a03 * a12;
      var b06 = a20 * a31 - a21 * a30;
      var b07 = a20 * a32 - a22 * a30;
      var b08 = a20 * a33 - a23 * a30;
      var b09 = a21 * a32 - a22 * a31;
      var b10 = a21 * a33 - a23 * a31;
      var b11 = a22 * a33 - a23 * a32;
      var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) {
        return this;
      }
      det = 1 / det;
      return this.setValues((a11 * b11 - a12 * b10 + a13 * b09) * det, (a02 * b10 - a01 * b11 - a03 * b09) * det, (a31 * b05 - a32 * b04 + a33 * b03) * det, (a22 * b04 - a21 * b05 - a23 * b03) * det, (a12 * b08 - a10 * b11 - a13 * b07) * det, (a00 * b11 - a02 * b08 + a03 * b07) * det, (a32 * b02 - a30 * b05 - a33 * b01) * det, (a20 * b05 - a22 * b02 + a23 * b01) * det, (a10 * b10 - a11 * b08 + a13 * b06) * det, (a01 * b08 - a00 * b10 - a03 * b06) * det, (a30 * b04 - a31 * b02 + a33 * b00) * det, (a21 * b02 - a20 * b04 - a23 * b00) * det, (a11 * b07 - a10 * b09 - a12 * b06) * det, (a00 * b09 - a01 * b07 + a02 * b06) * det, (a31 * b01 - a30 * b03 - a32 * b00) * det, (a20 * b03 - a21 * b01 + a22 * b00) * det);
    },
    adjoint: function() {
      var a = this.val;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a03 = a[3];
      var a10 = a[4];
      var a11 = a[5];
      var a12 = a[6];
      var a13 = a[7];
      var a20 = a[8];
      var a21 = a[9];
      var a22 = a[10];
      var a23 = a[11];
      var a30 = a[12];
      var a31 = a[13];
      var a32 = a[14];
      var a33 = a[15];
      return this.setValues(a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22), -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22)), a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12), -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12)), -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22)), a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22), -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12)), a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12), a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21), -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21)), a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11), -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11)), -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21)), a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21), -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11)), a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    },
    determinant: function() {
      var a = this.val;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a03 = a[3];
      var a10 = a[4];
      var a11 = a[5];
      var a12 = a[6];
      var a13 = a[7];
      var a20 = a[8];
      var a21 = a[9];
      var a22 = a[10];
      var a23 = a[11];
      var a30 = a[12];
      var a31 = a[13];
      var a32 = a[14];
      var a33 = a[15];
      var b00 = a00 * a11 - a01 * a10;
      var b01 = a00 * a12 - a02 * a10;
      var b02 = a00 * a13 - a03 * a10;
      var b03 = a01 * a12 - a02 * a11;
      var b04 = a01 * a13 - a03 * a11;
      var b05 = a02 * a13 - a03 * a12;
      var b06 = a20 * a31 - a21 * a30;
      var b07 = a20 * a32 - a22 * a30;
      var b08 = a20 * a33 - a23 * a30;
      var b09 = a21 * a32 - a22 * a31;
      var b10 = a21 * a33 - a23 * a31;
      var b11 = a22 * a33 - a23 * a32;
      return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    },
    multiply: function(src) {
      var a = this.val;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a03 = a[3];
      var a10 = a[4];
      var a11 = a[5];
      var a12 = a[6];
      var a13 = a[7];
      var a20 = a[8];
      var a21 = a[9];
      var a22 = a[10];
      var a23 = a[11];
      var a30 = a[12];
      var a31 = a[13];
      var a32 = a[14];
      var a33 = a[15];
      var b = src.val;
      var b0 = b[0];
      var b1 = b[1];
      var b2 = b[2];
      var b3 = b[3];
      a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return this;
    },
    multiplyLocal: function(src) {
      var a = this.val;
      var b = src.val;
      return this.setValues(a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12], a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13], a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14], a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15], a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12], a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13], a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14], a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15], a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12], a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13], a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14], a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15], a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12], a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13], a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14], a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]);
    },
    premultiply: function(m) {
      return this.multiplyMatrices(m, this);
    },
    multiplyMatrices: function(a, b) {
      var am = a.val;
      var bm = b.val;
      var a11 = am[0];
      var a12 = am[4];
      var a13 = am[8];
      var a14 = am[12];
      var a21 = am[1];
      var a22 = am[5];
      var a23 = am[9];
      var a24 = am[13];
      var a31 = am[2];
      var a32 = am[6];
      var a33 = am[10];
      var a34 = am[14];
      var a41 = am[3];
      var a42 = am[7];
      var a43 = am[11];
      var a44 = am[15];
      var b11 = bm[0];
      var b12 = bm[4];
      var b13 = bm[8];
      var b14 = bm[12];
      var b21 = bm[1];
      var b22 = bm[5];
      var b23 = bm[9];
      var b24 = bm[13];
      var b31 = bm[2];
      var b32 = bm[6];
      var b33 = bm[10];
      var b34 = bm[14];
      var b41 = bm[3];
      var b42 = bm[7];
      var b43 = bm[11];
      var b44 = bm[15];
      return this.setValues(a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42, a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42, a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42, a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42, a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44, a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44, a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44, a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44);
    },
    translate: function(v) {
      return this.translateXYZ(v.x, v.y, v.z);
    },
    translateXYZ: function(x, y, z) {
      var a = this.val;
      a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
      return this;
    },
    scale: function(v) {
      return this.scaleXYZ(v.x, v.y, v.z);
    },
    scaleXYZ: function(x, y, z) {
      var a = this.val;
      a[0] = a[0] * x;
      a[1] = a[1] * x;
      a[2] = a[2] * x;
      a[3] = a[3] * x;
      a[4] = a[4] * y;
      a[5] = a[5] * y;
      a[6] = a[6] * y;
      a[7] = a[7] * y;
      a[8] = a[8] * z;
      a[9] = a[9] * z;
      a[10] = a[10] * z;
      a[11] = a[11] * z;
      return this;
    },
    makeRotationAxis: function(axis, angle) {
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      var t = 1 - c;
      var x = axis.x;
      var y = axis.y;
      var z = axis.z;
      var tx = t * x;
      var ty = t * y;
      return this.setValues(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    },
    rotate: function(rad, axis) {
      var a = this.val;
      var x = axis.x;
      var y = axis.y;
      var z = axis.z;
      var len = Math.sqrt(x * x + y * y + z * z);
      if (Math.abs(len) < EPSILON) {
        return this;
      }
      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      var t = 1 - c;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a03 = a[3];
      var a10 = a[4];
      var a11 = a[5];
      var a12 = a[6];
      var a13 = a[7];
      var a20 = a[8];
      var a21 = a[9];
      var a22 = a[10];
      var a23 = a[11];
      var a30 = a[12];
      var a31 = a[13];
      var a32 = a[14];
      var a33 = a[15];
      var b00 = x * x * t + c;
      var b01 = y * x * t + z * s;
      var b02 = z * x * t - y * s;
      var b10 = x * y * t - z * s;
      var b11 = y * y * t + c;
      var b12 = z * y * t + x * s;
      var b20 = x * z * t + y * s;
      var b21 = y * z * t - x * s;
      var b22 = z * z * t + c;
      return this.setValues(a00 * b00 + a10 * b01 + a20 * b02, a01 * b00 + a11 * b01 + a21 * b02, a02 * b00 + a12 * b01 + a22 * b02, a03 * b00 + a13 * b01 + a23 * b02, a00 * b10 + a10 * b11 + a20 * b12, a01 * b10 + a11 * b11 + a21 * b12, a02 * b10 + a12 * b11 + a22 * b12, a03 * b10 + a13 * b11 + a23 * b12, a00 * b20 + a10 * b21 + a20 * b22, a01 * b20 + a11 * b21 + a21 * b22, a02 * b20 + a12 * b21 + a22 * b22, a03 * b20 + a13 * b21 + a23 * b22, a30, a31, a32, a33);
    },
    rotateX: function(rad) {
      var a = this.val;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      var a10 = a[4];
      var a11 = a[5];
      var a12 = a[6];
      var a13 = a[7];
      var a20 = a[8];
      var a21 = a[9];
      var a22 = a[10];
      var a23 = a[11];
      a[4] = a10 * c + a20 * s;
      a[5] = a11 * c + a21 * s;
      a[6] = a12 * c + a22 * s;
      a[7] = a13 * c + a23 * s;
      a[8] = a20 * c - a10 * s;
      a[9] = a21 * c - a11 * s;
      a[10] = a22 * c - a12 * s;
      a[11] = a23 * c - a13 * s;
      return this;
    },
    rotateY: function(rad) {
      var a = this.val;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a03 = a[3];
      var a20 = a[8];
      var a21 = a[9];
      var a22 = a[10];
      var a23 = a[11];
      a[0] = a00 * c - a20 * s;
      a[1] = a01 * c - a21 * s;
      a[2] = a02 * c - a22 * s;
      a[3] = a03 * c - a23 * s;
      a[8] = a00 * s + a20 * c;
      a[9] = a01 * s + a21 * c;
      a[10] = a02 * s + a22 * c;
      a[11] = a03 * s + a23 * c;
      return this;
    },
    rotateZ: function(rad) {
      var a = this.val;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a03 = a[3];
      var a10 = a[4];
      var a11 = a[5];
      var a12 = a[6];
      var a13 = a[7];
      a[0] = a00 * c + a10 * s;
      a[1] = a01 * c + a11 * s;
      a[2] = a02 * c + a12 * s;
      a[3] = a03 * c + a13 * s;
      a[4] = a10 * c - a00 * s;
      a[5] = a11 * c - a01 * s;
      a[6] = a12 * c - a02 * s;
      a[7] = a13 * c - a03 * s;
      return this;
    },
    fromRotationTranslation: function(q, v) {
      var x = q.x;
      var y = q.y;
      var z = q.z;
      var w = q.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var xy = x * y2;
      var xz = x * z2;
      var yy = y * y2;
      var yz = y * z2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, v.x, v.y, v.z, 1);
    },
    fromQuat: function(q) {
      var x = q.x;
      var y = q.y;
      var z = q.z;
      var w = q.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var xy = x * y2;
      var xz = x * z2;
      var yy = y * y2;
      var yz = y * z2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      return this.setValues(1 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1 - (xx + yy), 0, 0, 0, 0, 1);
    },
    frustum: function(left, right, bottom, top, near, far) {
      var rl = 1 / (right - left);
      var tb = 1 / (top - bottom);
      var nf = 1 / (near - far);
      return this.setValues(near * 2 * rl, 0, 0, 0, 0, near * 2 * tb, 0, 0, (right + left) * rl, (top + bottom) * tb, (far + near) * nf, -1, 0, 0, far * near * 2 * nf, 0);
    },
    perspective: function(fovy, aspect, near, far) {
      var f = 1 / Math.tan(fovy / 2);
      var nf = 1 / (near - far);
      return this.setValues(f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (far + near) * nf, -1, 0, 0, 2 * far * near * nf, 0);
    },
    perspectiveLH: function(width, height, near, far) {
      return this.setValues(2 * near / width, 0, 0, 0, 0, 2 * near / height, 0, 0, 0, 0, -far / (near - far), 1, 0, 0, near * far / (near - far), 0);
    },
    ortho: function(left, right, bottom, top, near, far) {
      var lr = left - right;
      var bt = bottom - top;
      var nf = near - far;
      lr = lr === 0 ? lr : 1 / lr;
      bt = bt === 0 ? bt : 1 / bt;
      nf = nf === 0 ? nf : 1 / nf;
      return this.setValues(-2 * lr, 0, 0, 0, 0, -2 * bt, 0, 0, 0, 0, 2 * nf, 0, (left + right) * lr, (top + bottom) * bt, (far + near) * nf, 1);
    },
    lookAtRH: function(eye, target, up) {
      var m = this.val;
      _z.subVectors(eye, target);
      if (_z.getLengthSquared() === 0) {
        _z.z = 1;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
      if (_x.getLengthSquared() === 0) {
        if (Math.abs(up.z) === 1) {
          _z.x += 1e-4;
        } else {
          _z.z += 1e-4;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
      }
      _x.normalize();
      _y.crossVectors(_z, _x);
      m[0] = _x.x;
      m[1] = _x.y;
      m[2] = _x.z;
      m[4] = _y.x;
      m[5] = _y.y;
      m[6] = _y.z;
      m[8] = _z.x;
      m[9] = _z.y;
      m[10] = _z.z;
      return this;
    },
    lookAt: function(eye, center, up) {
      var eyex = eye.x;
      var eyey = eye.y;
      var eyez = eye.z;
      var upx = up.x;
      var upy = up.y;
      var upz = up.z;
      var centerx = center.x;
      var centery = center.y;
      var centerz = center.z;
      if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
        return this.identity();
      }
      var z0 = eyex - centerx;
      var z1 = eyey - centery;
      var z2 = eyez - centerz;
      var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
      z0 *= len;
      z1 *= len;
      z2 *= len;
      var x0 = upy * z2 - upz * z1;
      var x1 = upz * z0 - upx * z2;
      var x2 = upx * z1 - upy * z0;
      len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
      if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
      } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
      }
      var y0 = z1 * x2 - z2 * x1;
      var y1 = z2 * x0 - z0 * x2;
      var y2 = z0 * x1 - z1 * x0;
      len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
      if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
      } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
      }
      return this.setValues(x0, y0, z0, 0, x1, y1, z1, 0, x2, y2, z2, 0, -(x0 * eyex + x1 * eyey + x2 * eyez), -(y0 * eyex + y1 * eyey + y2 * eyez), -(z0 * eyex + z1 * eyey + z2 * eyez), 1);
    },
    yawPitchRoll: function(yaw, pitch, roll) {
      this.zero();
      _tempMat1.zero();
      _tempMat2.zero();
      var m0 = this.val;
      var m1 = _tempMat1.val;
      var m2 = _tempMat2.val;
      var s = Math.sin(roll);
      var c = Math.cos(roll);
      m0[10] = 1;
      m0[15] = 1;
      m0[0] = c;
      m0[1] = s;
      m0[4] = -s;
      m0[5] = c;
      s = Math.sin(pitch);
      c = Math.cos(pitch);
      m1[0] = 1;
      m1[15] = 1;
      m1[5] = c;
      m1[10] = c;
      m1[9] = -s;
      m1[6] = s;
      s = Math.sin(yaw);
      c = Math.cos(yaw);
      m2[5] = 1;
      m2[15] = 1;
      m2[0] = c;
      m2[2] = -s;
      m2[8] = s;
      m2[10] = c;
      this.multiplyLocal(_tempMat1);
      this.multiplyLocal(_tempMat2);
      return this;
    },
    setWorldMatrix: function(rotation, position, scale, viewMatrix, projectionMatrix) {
      this.yawPitchRoll(rotation.y, rotation.x, rotation.z);
      _tempMat1.scaling(scale.x, scale.y, scale.z);
      _tempMat2.xyz(position.x, position.y, position.z);
      this.multiplyLocal(_tempMat1);
      this.multiplyLocal(_tempMat2);
      if (viewMatrix) {
        this.multiplyLocal(viewMatrix);
      }
      if (projectionMatrix) {
        this.multiplyLocal(projectionMatrix);
      }
      return this;
    },
    multiplyToMat4: function(src, out) {
      var a = this.val;
      var b = src.val;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a03 = a[3];
      var a10 = a[4];
      var a11 = a[5];
      var a12 = a[6];
      var a13 = a[7];
      var a20 = a[8];
      var a21 = a[9];
      var a22 = a[10];
      var a23 = a[11];
      var a30 = a[12];
      var a31 = a[13];
      var a32 = a[14];
      var a33 = a[15];
      var b00 = b[0];
      var b01 = b[1];
      var b02 = b[2];
      var b03 = b[3];
      var b10 = b[4];
      var b11 = b[5];
      var b12 = b[6];
      var b13 = b[7];
      var b20 = b[8];
      var b21 = b[9];
      var b22 = b[10];
      var b23 = b[11];
      var b30 = b[12];
      var b31 = b[13];
      var b32 = b[14];
      var b33 = b[15];
      return out.setValues(b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30, b01 * a01 + b01 * a11 + b02 * a21 + b03 * a31, b02 * a02 + b01 * a12 + b02 * a22 + b03 * a32, b03 * a03 + b01 * a13 + b02 * a23 + b03 * a33, b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30, b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31, b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32, b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33, b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30, b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31, b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32, b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33, b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30, b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31, b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32, b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33);
    },
    fromRotationXYTranslation: function(rotation, position, translateFirst) {
      var x = position.x;
      var y = position.y;
      var z = position.z;
      var sx = Math.sin(rotation.x);
      var cx = Math.cos(rotation.x);
      var sy = Math.sin(rotation.y);
      var cy = Math.cos(rotation.y);
      var a30 = x;
      var a31 = y;
      var a32 = z;
      var b21 = -sx;
      var c01 = 0 - b21 * sy;
      var c02 = 0 - cx * sy;
      var c21 = b21 * cy;
      var c22 = cx * cy;
      if (!translateFirst) {
        a30 = cy * x + sy * z;
        a31 = c01 * x + cx * y + c21 * z;
        a32 = c02 * x + sx * y + c22 * z;
      }
      return this.setValues(cy, c01, c02, 0, 0, cx, sx, 0, sy, c21, c22, 0, a30, a31, a32, 1);
    },
    getMaxScaleOnAxis: function() {
      var m = this.val;
      var scaleXSq = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];
      var scaleYSq = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];
      var scaleZSq = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
  });
  var _tempMat1 = new Matrix4();
  var _tempMat2 = new Matrix4();
  var _x = new Vector3();
  var _y = new Vector3();
  var _z = new Vector3();
  module2.exports = Matrix4;
});

// node_modules/phaser/src/math/Euler.js
var require_Euler = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = require_Clamp();
  var Class = require_Class();
  var Matrix4 = require_Matrix4();
  var NOOP = require_NOOP();
  var tempMatrix = new Matrix4();
  var Euler = new Class({
    initialize: function Euler2(x, y, z, order) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      if (order === void 0) {
        order = Euler2.DefaultOrder;
      }
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
      this.onChangeCallback = NOOP;
    },
    x: {
      get: function() {
        return this._x;
      },
      set: function(value) {
        this._x = value;
        this.onChangeCallback(this);
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(value) {
        this._y = value;
        this.onChangeCallback(this);
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(value) {
        this._z = value;
        this.onChangeCallback(this);
      }
    },
    order: {
      get: function() {
        return this._order;
      },
      set: function(value) {
        this._order = value;
        this.onChangeCallback(this);
      }
    },
    set: function(x, y, z, order) {
      if (order === void 0) {
        order = this._order;
      }
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
      this.onChangeCallback(this);
      return this;
    },
    copy: function(euler) {
      return this.set(euler.x, euler.y, euler.z, euler.order);
    },
    setFromQuaternion: function(quaternion, order, update) {
      if (order === void 0) {
        order = this._order;
      }
      if (update === void 0) {
        update = false;
      }
      tempMatrix.fromQuat(quaternion);
      return this.setFromRotationMatrix(tempMatrix, order, update);
    },
    setFromRotationMatrix: function(matrix, order, update) {
      if (order === void 0) {
        order = this._order;
      }
      if (update === void 0) {
        update = false;
      }
      var elements = matrix.val;
      var m11 = elements[0];
      var m12 = elements[4];
      var m13 = elements[8];
      var m21 = elements[1];
      var m22 = elements[5];
      var m23 = elements[9];
      var m31 = elements[2];
      var m32 = elements[6];
      var m33 = elements[10];
      var x = 0;
      var y = 0;
      var z = 0;
      var epsilon = 0.99999;
      switch (order) {
        case "XYZ": {
          y = Math.asin(Clamp(m13, -1, 1));
          if (Math.abs(m13) < epsilon) {
            x = Math.atan2(-m23, m33);
            z = Math.atan2(-m12, m11);
          } else {
            x = Math.atan2(m32, m22);
          }
          break;
        }
        case "YXZ": {
          x = Math.asin(-Clamp(m23, -1, 1));
          if (Math.abs(m23) < epsilon) {
            y = Math.atan2(m13, m33);
            z = Math.atan2(m21, m22);
          } else {
            y = Math.atan2(-m31, m11);
          }
          break;
        }
        case "ZXY": {
          x = Math.asin(Clamp(m32, -1, 1));
          if (Math.abs(m32) < epsilon) {
            y = Math.atan2(-m31, m33);
            z = Math.atan2(-m12, m22);
          } else {
            z = Math.atan2(m21, m11);
          }
          break;
        }
        case "ZYX": {
          y = Math.asin(-Clamp(m31, -1, 1));
          if (Math.abs(m31) < epsilon) {
            x = Math.atan2(m32, m33);
            z = Math.atan2(m21, m11);
          } else {
            z = Math.atan2(-m12, m22);
          }
          break;
        }
        case "YZX": {
          z = Math.asin(Clamp(m21, -1, 1));
          if (Math.abs(m21) < epsilon) {
            x = Math.atan2(-m23, m22);
            y = Math.atan2(-m31, m11);
          } else {
            y = Math.atan2(m13, m33);
          }
          break;
        }
        case "XZY": {
          z = Math.asin(-Clamp(m12, -1, 1));
          if (Math.abs(m12) < epsilon) {
            x = Math.atan2(m32, m22);
            y = Math.atan2(m13, m11);
          } else {
            x = Math.atan2(-m23, m33);
          }
          break;
        }
      }
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
      if (update) {
        this.onChangeCallback(this);
      }
      return this;
    }
  });
  Euler.RotationOrders = ["XYZ", "YXZ", "ZXY", "ZYX", "YZX", "XZY"];
  Euler.DefaultOrder = "XYZ";
  module2.exports = Euler;
});

// node_modules/phaser/src/math/FloorTo.js
var require_FloorTo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FloorTo = function(value, place, base) {
    if (place === void 0) {
      place = 0;
    }
    if (base === void 0) {
      base = 10;
    }
    var p = Math.pow(base, -place);
    return Math.floor(value * p) / p;
  };
  module2.exports = FloorTo;
});

// node_modules/phaser/src/math/GetSpeed.js
var require_GetSpeed = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetSpeed = function(distance, time) {
    return distance / time / 1e3;
  };
  module2.exports = GetSpeed;
});

// node_modules/phaser/src/math/IsEven.js
var require_IsEven = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var IsEven = function(value) {
    return value == parseFloat(value) ? !(value % 2) : void 0;
  };
  module2.exports = IsEven;
});

// node_modules/phaser/src/math/IsEvenStrict.js
var require_IsEvenStrict = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var IsEvenStrict = function(value) {
    return value === parseFloat(value) ? !(value % 2) : void 0;
  };
  module2.exports = IsEvenStrict;
});

// node_modules/phaser/src/math/MaxAdd.js
var require_MaxAdd = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MaxAdd = function(value, amount, max) {
    return Math.min(value + amount, max);
  };
  module2.exports = MaxAdd;
});

// node_modules/phaser/src/math/Median.js
var require_Median = __commonJS((exports2, module2) => {
  /**
   * @author       Vladislav Forsh <vlad@robowhale.com>
   * @copyright    2021 RoboWhale
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Median = function(values) {
    var valuesNum = values.length;
    if (valuesNum === 0) {
      return 0;
    }
    values.sort(function(a, b) {
      return a - b;
    });
    var halfIndex = Math.floor(valuesNum / 2);
    return valuesNum % 2 === 0 ? (values[halfIndex] + values[halfIndex - 1]) / 2 : values[halfIndex];
  };
  module2.exports = Median;
});

// node_modules/phaser/src/math/MinSub.js
var require_MinSub = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MinSub = function(value, amount, min) {
    return Math.max(value - amount, min);
  };
  module2.exports = MinSub;
});

// node_modules/phaser/src/math/Percent.js
var require_Percent = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Percent = function(value, min, max, upperMax) {
    if (max === void 0) {
      max = min + 1;
    }
    var percentage = (value - min) / (max - min);
    if (percentage > 1) {
      if (upperMax !== void 0) {
        percentage = (upperMax - value) / (upperMax - max);
        if (percentage < 0) {
          percentage = 0;
        }
      } else {
        percentage = 1;
      }
    } else if (percentage < 0) {
      percentage = 0;
    }
    return percentage;
  };
  module2.exports = Percent;
});

// node_modules/phaser/src/math/RadToDeg.js
var require_RadToDeg = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const4();
  var RadToDeg = function(radians) {
    return radians * CONST.RAD_TO_DEG;
  };
  module2.exports = RadToDeg;
});

// node_modules/phaser/src/math/RandomXY.js
var require_RandomXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RandomXY = function(vector, scale) {
    if (scale === void 0) {
      scale = 1;
    }
    var r = Math.random() * 2 * Math.PI;
    vector.x = Math.cos(r) * scale;
    vector.y = Math.sin(r) * scale;
    return vector;
  };
  module2.exports = RandomXY;
});

// node_modules/phaser/src/math/RandomXYZ.js
var require_RandomXYZ = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RandomXYZ = function(vec3, radius) {
    if (radius === void 0) {
      radius = 1;
    }
    var r = Math.random() * 2 * Math.PI;
    var z = Math.random() * 2 - 1;
    var zScale = Math.sqrt(1 - z * z) * radius;
    vec3.x = Math.cos(r) * zScale;
    vec3.y = Math.sin(r) * zScale;
    vec3.z = z * radius;
    return vec3;
  };
  module2.exports = RandomXYZ;
});

// node_modules/phaser/src/math/RandomXYZW.js
var require_RandomXYZW = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RandomXYZW = function(vec4, scale) {
    if (scale === void 0) {
      scale = 1;
    }
    vec4.x = (Math.random() * 2 - 1) * scale;
    vec4.y = (Math.random() * 2 - 1) * scale;
    vec4.z = (Math.random() * 2 - 1) * scale;
    vec4.w = (Math.random() * 2 - 1) * scale;
    return vec4;
  };
  module2.exports = RandomXYZW;
});

// node_modules/phaser/src/math/Rotate.js
var require_Rotate2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rotate = function(point, angle) {
    var x = point.x;
    var y = point.y;
    point.x = x * Math.cos(angle) - y * Math.sin(angle);
    point.y = x * Math.sin(angle) + y * Math.cos(angle);
    return point;
  };
  module2.exports = Rotate;
});

// node_modules/phaser/src/math/RotateTo.js
var require_RotateTo3 = __commonJS((exports2, module2) => {
  /**
   * @author       samme
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateTo = function(point, x, y, angle, distance) {
    point.x = x + distance * Math.cos(angle);
    point.y = y + distance * Math.sin(angle);
    return point;
  };
  module2.exports = RotateTo;
});

// node_modules/phaser/src/math/RoundAwayFromZero.js
var require_RoundAwayFromZero = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RoundAwayFromZero = function(value) {
    return value > 0 ? Math.ceil(value) : Math.floor(value);
  };
  module2.exports = RoundAwayFromZero;
});

// node_modules/phaser/src/math/RoundTo.js
var require_RoundTo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RoundTo = function(value, place, base) {
    if (place === void 0) {
      place = 0;
    }
    if (base === void 0) {
      base = 10;
    }
    var p = Math.pow(base, -place);
    return Math.round(value * p) / p;
  };
  module2.exports = RoundTo;
});

// node_modules/phaser/src/math/SinCosTableGenerator.js
var require_SinCosTableGenerator = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SinCosTableGenerator = function(length, sinAmp, cosAmp, frequency) {
    if (sinAmp === void 0) {
      sinAmp = 1;
    }
    if (cosAmp === void 0) {
      cosAmp = 1;
    }
    if (frequency === void 0) {
      frequency = 1;
    }
    frequency *= Math.PI / length;
    var cos = [];
    var sin = [];
    for (var c = 0; c < length; c++) {
      cosAmp -= sinAmp * frequency;
      sinAmp += cosAmp * frequency;
      cos[c] = cosAmp;
      sin[c] = sinAmp;
    }
    return {
      sin,
      cos,
      length
    };
  };
  module2.exports = SinCosTableGenerator;
});

// node_modules/phaser/src/math/ToXY.js
var require_ToXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector2 = require_Vector2();
  var ToXY = function(index, width, height, out) {
    if (out === void 0) {
      out = new Vector2();
    }
    var x = 0;
    var y = 0;
    var total = width * height;
    if (index > 0 && index <= total) {
      if (index > width - 1) {
        y = Math.floor(index / width);
        x = index - y * width;
      } else {
        x = index;
      }
    }
    return out.set(x, y);
  };
  module2.exports = ToXY;
});

// node_modules/phaser/src/math/Within.js
var require_Within = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Within = function(a, b, tolerance) {
    return Math.abs(a - b) <= tolerance;
  };
  module2.exports = Within;
});

// node_modules/phaser/src/math/Vector4.js
var require_Vector4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Vector4 = new Class({
    initialize: function Vector42(x, y, z, w) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
      if (typeof x === "object") {
        this.x = x.x || 0;
        this.y = x.y || 0;
        this.z = x.z || 0;
        this.w = x.w || 0;
      } else {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = w || 0;
      }
    },
    clone: function() {
      return new Vector4(this.x, this.y, this.z, this.w);
    },
    copy: function(src) {
      this.x = src.x;
      this.y = src.y;
      this.z = src.z || 0;
      this.w = src.w || 0;
      return this;
    },
    equals: function(v) {
      return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
    },
    set: function(x, y, z, w) {
      if (typeof x === "object") {
        this.x = x.x || 0;
        this.y = x.y || 0;
        this.z = x.z || 0;
        this.w = x.w || 0;
      } else {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = w || 0;
      }
      return this;
    },
    add: function(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z || 0;
      this.w += v.w || 0;
      return this;
    },
    subtract: function(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z || 0;
      this.w -= v.w || 0;
      return this;
    },
    scale: function(scale) {
      this.x *= scale;
      this.y *= scale;
      this.z *= scale;
      this.w *= scale;
      return this;
    },
    length: function() {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var w = this.w;
      return Math.sqrt(x * x + y * y + z * z + w * w);
    },
    lengthSq: function() {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var w = this.w;
      return x * x + y * y + z * z + w * w;
    },
    normalize: function() {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var w = this.w;
      var len = x * x + y * y + z * z + w * w;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
        this.x = x * len;
        this.y = y * len;
        this.z = z * len;
        this.w = w * len;
      }
      return this;
    },
    dot: function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },
    lerp: function(v, t) {
      if (t === void 0) {
        t = 0;
      }
      var ax = this.x;
      var ay = this.y;
      var az = this.z;
      var aw = this.w;
      this.x = ax + t * (v.x - ax);
      this.y = ay + t * (v.y - ay);
      this.z = az + t * (v.z - az);
      this.w = aw + t * (v.w - aw);
      return this;
    },
    multiply: function(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z || 1;
      this.w *= v.w || 1;
      return this;
    },
    divide: function(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z || 1;
      this.w /= v.w || 1;
      return this;
    },
    distance: function(v) {
      var dx = v.x - this.x;
      var dy = v.y - this.y;
      var dz = v.z - this.z || 0;
      var dw = v.w - this.w || 0;
      return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
    },
    distanceSq: function(v) {
      var dx = v.x - this.x;
      var dy = v.y - this.y;
      var dz = v.z - this.z || 0;
      var dw = v.w - this.w || 0;
      return dx * dx + dy * dy + dz * dz + dw * dw;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    },
    transformMat4: function(mat) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var w = this.w;
      var m = mat.val;
      this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
      this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
      this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
      this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
      return this;
    },
    transformQuat: function(q) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var qx = q.x;
      var qy = q.y;
      var qz = q.z;
      var qw = q.w;
      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z;
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    },
    reset: function() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
      return this;
    }
  });
  Vector4.prototype.sub = Vector4.prototype.subtract;
  Vector4.prototype.mul = Vector4.prototype.multiply;
  Vector4.prototype.div = Vector4.prototype.divide;
  Vector4.prototype.dist = Vector4.prototype.distance;
  Vector4.prototype.distSq = Vector4.prototype.distanceSq;
  Vector4.prototype.len = Vector4.prototype.length;
  Vector4.prototype.lenSq = Vector4.prototype.lengthSq;
  module2.exports = Vector4;
});

// node_modules/phaser/src/math/Matrix3.js
var require_Matrix3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Matrix3 = new Class({
    initialize: function Matrix32(m) {
      this.val = new Float32Array(9);
      if (m) {
        this.copy(m);
      } else {
        this.identity();
      }
    },
    clone: function() {
      return new Matrix3(this);
    },
    set: function(src) {
      return this.copy(src);
    },
    copy: function(src) {
      var out = this.val;
      var a = src.val;
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[8] = a[8];
      return this;
    },
    fromMat4: function(m) {
      var a = m.val;
      var out = this.val;
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[4];
      out[4] = a[5];
      out[5] = a[6];
      out[6] = a[8];
      out[7] = a[9];
      out[8] = a[10];
      return this;
    },
    fromArray: function(a) {
      var out = this.val;
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[8] = a[8];
      return this;
    },
    identity: function() {
      var out = this.val;
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 1;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 1;
      return this;
    },
    transpose: function() {
      var a = this.val;
      var a01 = a[1];
      var a02 = a[2];
      var a12 = a[5];
      a[1] = a[3];
      a[2] = a[6];
      a[3] = a01;
      a[5] = a[7];
      a[6] = a02;
      a[7] = a12;
      return this;
    },
    invert: function() {
      var a = this.val;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a10 = a[3];
      var a11 = a[4];
      var a12 = a[5];
      var a20 = a[6];
      var a21 = a[7];
      var a22 = a[8];
      var b01 = a22 * a11 - a12 * a21;
      var b11 = -a22 * a10 + a12 * a20;
      var b21 = a21 * a10 - a11 * a20;
      var det = a00 * b01 + a01 * b11 + a02 * b21;
      if (!det) {
        return null;
      }
      det = 1 / det;
      a[0] = b01 * det;
      a[1] = (-a22 * a01 + a02 * a21) * det;
      a[2] = (a12 * a01 - a02 * a11) * det;
      a[3] = b11 * det;
      a[4] = (a22 * a00 - a02 * a20) * det;
      a[5] = (-a12 * a00 + a02 * a10) * det;
      a[6] = b21 * det;
      a[7] = (-a21 * a00 + a01 * a20) * det;
      a[8] = (a11 * a00 - a01 * a10) * det;
      return this;
    },
    adjoint: function() {
      var a = this.val;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a10 = a[3];
      var a11 = a[4];
      var a12 = a[5];
      var a20 = a[6];
      var a21 = a[7];
      var a22 = a[8];
      a[0] = a11 * a22 - a12 * a21;
      a[1] = a02 * a21 - a01 * a22;
      a[2] = a01 * a12 - a02 * a11;
      a[3] = a12 * a20 - a10 * a22;
      a[4] = a00 * a22 - a02 * a20;
      a[5] = a02 * a10 - a00 * a12;
      a[6] = a10 * a21 - a11 * a20;
      a[7] = a01 * a20 - a00 * a21;
      a[8] = a00 * a11 - a01 * a10;
      return this;
    },
    determinant: function() {
      var a = this.val;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a10 = a[3];
      var a11 = a[4];
      var a12 = a[5];
      var a20 = a[6];
      var a21 = a[7];
      var a22 = a[8];
      return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
    },
    multiply: function(src) {
      var a = this.val;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a10 = a[3];
      var a11 = a[4];
      var a12 = a[5];
      var a20 = a[6];
      var a21 = a[7];
      var a22 = a[8];
      var b = src.val;
      var b00 = b[0];
      var b01 = b[1];
      var b02 = b[2];
      var b10 = b[3];
      var b11 = b[4];
      var b12 = b[5];
      var b20 = b[6];
      var b21 = b[7];
      var b22 = b[8];
      a[0] = b00 * a00 + b01 * a10 + b02 * a20;
      a[1] = b00 * a01 + b01 * a11 + b02 * a21;
      a[2] = b00 * a02 + b01 * a12 + b02 * a22;
      a[3] = b10 * a00 + b11 * a10 + b12 * a20;
      a[4] = b10 * a01 + b11 * a11 + b12 * a21;
      a[5] = b10 * a02 + b11 * a12 + b12 * a22;
      a[6] = b20 * a00 + b21 * a10 + b22 * a20;
      a[7] = b20 * a01 + b21 * a11 + b22 * a21;
      a[8] = b20 * a02 + b21 * a12 + b22 * a22;
      return this;
    },
    translate: function(v) {
      var a = this.val;
      var x = v.x;
      var y = v.y;
      a[6] = x * a[0] + y * a[3] + a[6];
      a[7] = x * a[1] + y * a[4] + a[7];
      a[8] = x * a[2] + y * a[5] + a[8];
      return this;
    },
    rotate: function(rad) {
      var a = this.val;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a10 = a[3];
      var a11 = a[4];
      var a12 = a[5];
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      a[0] = c * a00 + s * a10;
      a[1] = c * a01 + s * a11;
      a[2] = c * a02 + s * a12;
      a[3] = c * a10 - s * a00;
      a[4] = c * a11 - s * a01;
      a[5] = c * a12 - s * a02;
      return this;
    },
    scale: function(v) {
      var a = this.val;
      var x = v.x;
      var y = v.y;
      a[0] = x * a[0];
      a[1] = x * a[1];
      a[2] = x * a[2];
      a[3] = y * a[3];
      a[4] = y * a[4];
      a[5] = y * a[5];
      return this;
    },
    fromQuat: function(q) {
      var x = q.x;
      var y = q.y;
      var z = q.z;
      var w = q.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var xy = x * y2;
      var xz = x * z2;
      var yy = y * y2;
      var yz = y * z2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      var out = this.val;
      out[0] = 1 - (yy + zz);
      out[3] = xy + wz;
      out[6] = xz - wy;
      out[1] = xy - wz;
      out[4] = 1 - (xx + zz);
      out[7] = yz + wx;
      out[2] = xz + wy;
      out[5] = yz - wx;
      out[8] = 1 - (xx + yy);
      return this;
    },
    normalFromMat4: function(m) {
      var a = m.val;
      var out = this.val;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a03 = a[3];
      var a10 = a[4];
      var a11 = a[5];
      var a12 = a[6];
      var a13 = a[7];
      var a20 = a[8];
      var a21 = a[9];
      var a22 = a[10];
      var a23 = a[11];
      var a30 = a[12];
      var a31 = a[13];
      var a32 = a[14];
      var a33 = a[15];
      var b00 = a00 * a11 - a01 * a10;
      var b01 = a00 * a12 - a02 * a10;
      var b02 = a00 * a13 - a03 * a10;
      var b03 = a01 * a12 - a02 * a11;
      var b04 = a01 * a13 - a03 * a11;
      var b05 = a02 * a13 - a03 * a12;
      var b06 = a20 * a31 - a21 * a30;
      var b07 = a20 * a32 - a22 * a30;
      var b08 = a20 * a33 - a23 * a30;
      var b09 = a21 * a32 - a22 * a31;
      var b10 = a21 * a33 - a23 * a31;
      var b11 = a22 * a33 - a23 * a32;
      var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) {
        return null;
      }
      det = 1 / det;
      out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
      out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
      out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
      out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
      out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
      return this;
    }
  });
  module2.exports = Matrix3;
});

// node_modules/phaser/src/math/Quaternion.js
var require_Quaternion = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Matrix3 = require_Matrix3();
  var NOOP = require_NOOP();
  var Vector3 = require_Vector3();
  var EPSILON = 1e-6;
  var siNext = new Int8Array([1, 2, 0]);
  var tmp = new Float32Array([0, 0, 0]);
  var xUnitVec3 = new Vector3(1, 0, 0);
  var yUnitVec3 = new Vector3(0, 1, 0);
  var tmpvec = new Vector3();
  var tmpMat3 = new Matrix3();
  var Quaternion = new Class({
    initialize: function Quaternion2(x, y, z, w) {
      this.onChangeCallback = NOOP;
      this.set(x, y, z, w);
    },
    x: {
      get: function() {
        return this._x;
      },
      set: function(value) {
        this._x = value;
        this.onChangeCallback(this);
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(value) {
        this._y = value;
        this.onChangeCallback(this);
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(value) {
        this._z = value;
        this.onChangeCallback(this);
      }
    },
    w: {
      get: function() {
        return this._w;
      },
      set: function(value) {
        this._w = value;
        this.onChangeCallback(this);
      }
    },
    copy: function(src) {
      return this.set(src);
    },
    set: function(x, y, z, w, update) {
      if (update === void 0) {
        update = true;
      }
      if (typeof x === "object") {
        this._x = x.x || 0;
        this._y = x.y || 0;
        this._z = x.z || 0;
        this._w = x.w || 0;
      } else {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._w = w || 0;
      }
      if (update) {
        this.onChangeCallback(this);
      }
      return this;
    },
    add: function(v) {
      this._x += v.x;
      this._y += v.y;
      this._z += v.z;
      this._w += v.w;
      this.onChangeCallback(this);
      return this;
    },
    subtract: function(v) {
      this._x -= v.x;
      this._y -= v.y;
      this._z -= v.z;
      this._w -= v.w;
      this.onChangeCallback(this);
      return this;
    },
    scale: function(scale) {
      this._x *= scale;
      this._y *= scale;
      this._z *= scale;
      this._w *= scale;
      this.onChangeCallback(this);
      return this;
    },
    length: function() {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var w = this.w;
      return Math.sqrt(x * x + y * y + z * z + w * w);
    },
    lengthSq: function() {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var w = this.w;
      return x * x + y * y + z * z + w * w;
    },
    normalize: function() {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var w = this.w;
      var len = x * x + y * y + z * z + w * w;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
        this._x = x * len;
        this._y = y * len;
        this._z = z * len;
        this._w = w * len;
      }
      this.onChangeCallback(this);
      return this;
    },
    dot: function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },
    lerp: function(v, t) {
      if (t === void 0) {
        t = 0;
      }
      var ax = this.x;
      var ay = this.y;
      var az = this.z;
      var aw = this.w;
      return this.set(ax + t * (v.x - ax), ay + t * (v.y - ay), az + t * (v.z - az), aw + t * (v.w - aw));
    },
    rotationTo: function(a, b) {
      var dot = a.x * b.x + a.y * b.y + a.z * b.z;
      if (dot < -0.999999) {
        if (tmpvec.copy(xUnitVec3).cross(a).length() < EPSILON) {
          tmpvec.copy(yUnitVec3).cross(a);
        }
        tmpvec.normalize();
        return this.setAxisAngle(tmpvec, Math.PI);
      } else if (dot > 0.999999) {
        return this.set(0, 0, 0, 1);
      } else {
        tmpvec.copy(a).cross(b);
        this._x = tmpvec.x;
        this._y = tmpvec.y;
        this._z = tmpvec.z;
        this._w = 1 + dot;
        return this.normalize();
      }
    },
    setAxes: function(view, right, up) {
      var m = tmpMat3.val;
      m[0] = right.x;
      m[3] = right.y;
      m[6] = right.z;
      m[1] = up.x;
      m[4] = up.y;
      m[7] = up.z;
      m[2] = -view.x;
      m[5] = -view.y;
      m[8] = -view.z;
      return this.fromMat3(tmpMat3).normalize();
    },
    identity: function() {
      return this.set(0, 0, 0, 1);
    },
    setAxisAngle: function(axis, rad) {
      rad = rad * 0.5;
      var s = Math.sin(rad);
      return this.set(s * axis.x, s * axis.y, s * axis.z, Math.cos(rad));
    },
    multiply: function(b) {
      var ax = this.x;
      var ay = this.y;
      var az = this.z;
      var aw = this.w;
      var bx = b.x;
      var by = b.y;
      var bz = b.z;
      var bw = b.w;
      return this.set(ax * bw + aw * bx + ay * bz - az * by, ay * bw + aw * by + az * bx - ax * bz, az * bw + aw * bz + ax * by - ay * bx, aw * bw - ax * bx - ay * by - az * bz);
    },
    slerp: function(b, t) {
      var ax = this.x;
      var ay = this.y;
      var az = this.z;
      var aw = this.w;
      var bx = b.x;
      var by = b.y;
      var bz = b.z;
      var bw = b.w;
      var cosom = ax * bx + ay * by + az * bz + aw * bw;
      if (cosom < 0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
      }
      var scale0 = 1 - t;
      var scale1 = t;
      if (1 - cosom > EPSILON) {
        var omega = Math.acos(cosom);
        var sinom = Math.sin(omega);
        scale0 = Math.sin((1 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
      }
      return this.set(scale0 * ax + scale1 * bx, scale0 * ay + scale1 * by, scale0 * az + scale1 * bz, scale0 * aw + scale1 * bw);
    },
    invert: function() {
      var a0 = this.x;
      var a1 = this.y;
      var a2 = this.z;
      var a3 = this.w;
      var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
      var invDot = dot ? 1 / dot : 0;
      return this.set(-a0 * invDot, -a1 * invDot, -a2 * invDot, a3 * invDot);
    },
    conjugate: function() {
      this._x = -this.x;
      this._y = -this.y;
      this._z = -this.z;
      this.onChangeCallback(this);
      return this;
    },
    rotateX: function(rad) {
      rad *= 0.5;
      var ax = this.x;
      var ay = this.y;
      var az = this.z;
      var aw = this.w;
      var bx = Math.sin(rad);
      var bw = Math.cos(rad);
      return this.set(ax * bw + aw * bx, ay * bw + az * bx, az * bw - ay * bx, aw * bw - ax * bx);
    },
    rotateY: function(rad) {
      rad *= 0.5;
      var ax = this.x;
      var ay = this.y;
      var az = this.z;
      var aw = this.w;
      var by = Math.sin(rad);
      var bw = Math.cos(rad);
      return this.set(ax * bw - az * by, ay * bw + aw * by, az * bw + ax * by, aw * bw - ay * by);
    },
    rotateZ: function(rad) {
      rad *= 0.5;
      var ax = this.x;
      var ay = this.y;
      var az = this.z;
      var aw = this.w;
      var bz = Math.sin(rad);
      var bw = Math.cos(rad);
      return this.set(ax * bw + ay * bz, ay * bw - ax * bz, az * bw + aw * bz, aw * bw - az * bz);
    },
    calculateW: function() {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      this.w = -Math.sqrt(1 - x * x - y * y - z * z);
      return this;
    },
    setFromEuler: function(euler, update) {
      var x = euler.x / 2;
      var y = euler.y / 2;
      var z = euler.z / 2;
      var c1 = Math.cos(x);
      var c2 = Math.cos(y);
      var c3 = Math.cos(z);
      var s1 = Math.sin(x);
      var s2 = Math.sin(y);
      var s3 = Math.sin(z);
      switch (euler.order) {
        case "XYZ": {
          this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
          break;
        }
        case "YXZ": {
          this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
          break;
        }
        case "ZXY": {
          this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
          break;
        }
        case "ZYX": {
          this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
          break;
        }
        case "YZX": {
          this.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3, update);
          break;
        }
        case "XZY": {
          this.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3, update);
          break;
        }
      }
      return this;
    },
    setFromRotationMatrix: function(mat4) {
      var m = mat4.val;
      var m11 = m[0];
      var m12 = m[4];
      var m13 = m[8];
      var m21 = m[1];
      var m22 = m[5];
      var m23 = m[9];
      var m31 = m[2];
      var m32 = m[6];
      var m33 = m[10];
      var trace = m11 + m22 + m33;
      var s;
      if (trace > 0) {
        s = 0.5 / Math.sqrt(trace + 1);
        this.set((m32 - m23) * s, (m13 - m31) * s, (m21 - m12) * s, 0.25 / s);
      } else if (m11 > m22 && m11 > m33) {
        s = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this.set(0.25 * s, (m12 + m21) / s, (m13 + m31) / s, (m32 - m23) / s);
      } else if (m22 > m33) {
        s = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this.set((m12 + m21) / s, 0.25 * s, (m23 + m32) / s, (m13 - m31) / s);
      } else {
        s = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this.set((m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s);
      }
      return this;
    },
    fromMat3: function(mat) {
      var m = mat.val;
      var fTrace = m[0] + m[4] + m[8];
      var fRoot;
      if (fTrace > 0) {
        fRoot = Math.sqrt(fTrace + 1);
        this.w = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        this._x = (m[7] - m[5]) * fRoot;
        this._y = (m[2] - m[6]) * fRoot;
        this._z = (m[3] - m[1]) * fRoot;
      } else {
        var i = 0;
        if (m[4] > m[0]) {
          i = 1;
        }
        if (m[8] > m[i * 3 + i]) {
          i = 2;
        }
        var j = siNext[i];
        var k = siNext[j];
        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
        tmp[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        tmp[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
        tmp[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
        this._x = tmp[0];
        this._y = tmp[1];
        this._z = tmp[2];
        this._w = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;
      }
      this.onChangeCallback(this);
      return this;
    }
  });
  module2.exports = Quaternion;
});

// node_modules/phaser/src/math/RotateVec3.js
var require_RotateVec3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector3 = require_Vector3();
  var Matrix4 = require_Matrix4();
  var Quaternion = require_Quaternion();
  var tmpMat4 = new Matrix4();
  var tmpQuat = new Quaternion();
  var tmpVec3 = new Vector3();
  var RotateVec3 = function(vec, axis, radians) {
    tmpQuat.setAxisAngle(axis, radians);
    tmpMat4.fromRotationTranslation(tmpQuat, tmpVec3.set(0, 0, 0));
    return vec.transformMat4(tmpMat4);
  };
  module2.exports = RotateVec3;
});

// node_modules/phaser/src/math/index.js
var require_math = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const4();
  var Extend = require_Extend();
  var PhaserMath = {
    Angle: require_angle(),
    Distance: require_distance(),
    Easing: require_easing(),
    Fuzzy: require_fuzzy(),
    Interpolation: require_interpolation(),
    Pow2: require_pow2(),
    Snap: require_snap(),
    RandomDataGenerator: require_RandomDataGenerator(),
    Average: require_Average(),
    Bernstein: require_Bernstein(),
    Between: require_Between2(),
    CatmullRom: require_CatmullRom(),
    CeilTo: require_CeilTo(),
    Clamp: require_Clamp(),
    DegToRad: require_DegToRad(),
    Difference: require_Difference(),
    Euler: require_Euler(),
    Factorial: require_Factorial(),
    FloatBetween: require_FloatBetween(),
    FloorTo: require_FloorTo(),
    FromPercent: require_FromPercent(),
    GetSpeed: require_GetSpeed(),
    IsEven: require_IsEven(),
    IsEvenStrict: require_IsEvenStrict(),
    Linear: require_Linear2(),
    MaxAdd: require_MaxAdd(),
    Median: require_Median(),
    MinSub: require_MinSub(),
    Percent: require_Percent(),
    RadToDeg: require_RadToDeg(),
    RandomXY: require_RandomXY(),
    RandomXYZ: require_RandomXYZ(),
    RandomXYZW: require_RandomXYZW(),
    Rotate: require_Rotate2(),
    RotateAround: require_RotateAround(),
    RotateAroundDistance: require_RotateAroundDistance(),
    RotateTo: require_RotateTo3(),
    RoundAwayFromZero: require_RoundAwayFromZero(),
    RoundTo: require_RoundTo(),
    SinCosTableGenerator: require_SinCosTableGenerator(),
    SmootherStep: require_SmootherStep(),
    SmoothStep: require_SmoothStep(),
    ToXY: require_ToXY(),
    TransformXY: require_TransformXY(),
    Within: require_Within(),
    Wrap: require_Wrap(),
    Vector2: require_Vector2(),
    Vector3: require_Vector3(),
    Vector4: require_Vector4(),
    Matrix3: require_Matrix3(),
    Matrix4: require_Matrix4(),
    Quaternion: require_Quaternion(),
    RotateVec3: require_RotateVec3()
  };
  PhaserMath = Extend(false, PhaserMath, CONST);
  module2.exports = PhaserMath;
});

// node_modules/phaser/src/plugins/DefaultPlugins.js
var require_DefaultPlugins = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DefaultPlugins = {
    Global: [
      "game",
      "anims",
      "cache",
      "plugins",
      "registry",
      "scale",
      "sound",
      "textures",
      "renderer"
    ],
    CoreScene: [
      "EventEmitter",
      "CameraManager",
      "GameObjectCreator",
      "GameObjectFactory",
      "ScenePlugin",
      "DisplayList",
      "UpdateList"
    ],
    DefaultScene: [
      "Clock",
      "DataManagerPlugin",
      "InputPlugin",
      "Loader",
      "TweenManager",
      "LightsPlugin"
    ]
  };
  if (typeof PLUGIN_CAMERA3D) {
    DefaultPlugins.DefaultScene.push("CameraManager3D");
  }
  if (typeof PLUGIN_FBINSTANT) {
    DefaultPlugins.Global.push("facebook");
  }
  module2.exports = DefaultPlugins;
});

// node_modules/phaser/src/core/Config.js
var require_Config = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const();
  var Device = require_device();
  var GetFastValue = require_GetFastValue();
  var GetValue = require_GetValue();
  var IsPlainObject = require_IsPlainObject();
  var PhaserMath = require_math();
  var NOOP = require_NOOP();
  var DefaultPlugins = require_DefaultPlugins();
  var ValueToColor = require_ValueToColor();
  var Config = new Class({
    initialize: function Config2(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      var defaultBannerColor = [
        "#ff0000",
        "#ffff00",
        "#00ff00",
        "#00ffff",
        "#000000"
      ];
      var defaultBannerTextColor = "#ffffff";
      this.width = GetValue(config2, "width", 1024);
      this.height = GetValue(config2, "height", 768);
      this.zoom = GetValue(config2, "zoom", 1);
      this.parent = GetValue(config2, "parent", void 0);
      this.scaleMode = GetValue(config2, "scaleMode", 0);
      this.expandParent = GetValue(config2, "expandParent", true);
      this.autoRound = GetValue(config2, "autoRound", false);
      this.autoCenter = GetValue(config2, "autoCenter", 0);
      this.resizeInterval = GetValue(config2, "resizeInterval", 500);
      this.fullscreenTarget = GetValue(config2, "fullscreenTarget", null);
      this.minWidth = GetValue(config2, "minWidth", 0);
      this.maxWidth = GetValue(config2, "maxWidth", 0);
      this.minHeight = GetValue(config2, "minHeight", 0);
      this.maxHeight = GetValue(config2, "maxHeight", 0);
      var scaleConfig = GetValue(config2, "scale", null);
      if (scaleConfig) {
        this.width = GetValue(scaleConfig, "width", this.width);
        this.height = GetValue(scaleConfig, "height", this.height);
        this.zoom = GetValue(scaleConfig, "zoom", this.zoom);
        this.parent = GetValue(scaleConfig, "parent", this.parent);
        this.scaleMode = GetValue(scaleConfig, "mode", this.scaleMode);
        this.expandParent = GetValue(scaleConfig, "expandParent", this.expandParent);
        this.autoRound = GetValue(scaleConfig, "autoRound", this.autoRound);
        this.autoCenter = GetValue(scaleConfig, "autoCenter", this.autoCenter);
        this.resizeInterval = GetValue(scaleConfig, "resizeInterval", this.resizeInterval);
        this.fullscreenTarget = GetValue(scaleConfig, "fullscreenTarget", this.fullscreenTarget);
        this.minWidth = GetValue(scaleConfig, "min.width", this.minWidth);
        this.maxWidth = GetValue(scaleConfig, "max.width", this.maxWidth);
        this.minHeight = GetValue(scaleConfig, "min.height", this.minHeight);
        this.maxHeight = GetValue(scaleConfig, "max.height", this.maxHeight);
      }
      this.renderType = GetValue(config2, "type", CONST.AUTO);
      this.canvas = GetValue(config2, "canvas", null);
      this.context = GetValue(config2, "context", null);
      this.canvasStyle = GetValue(config2, "canvasStyle", null);
      this.customEnvironment = GetValue(config2, "customEnvironment", false);
      this.sceneConfig = GetValue(config2, "scene", null);
      this.seed = GetValue(config2, "seed", [(Date.now() * Math.random()).toString()]);
      PhaserMath.RND = new PhaserMath.RandomDataGenerator(this.seed);
      this.gameTitle = GetValue(config2, "title", "");
      this.gameURL = GetValue(config2, "url", "https://phaser.io");
      this.gameVersion = GetValue(config2, "version", "");
      this.autoFocus = GetValue(config2, "autoFocus", true);
      this.domCreateContainer = GetValue(config2, "dom.createContainer", false);
      this.domBehindCanvas = GetValue(config2, "dom.behindCanvas", false);
      this.domPointerEvents = GetValue(config2, "dom.pointerEvents", "none");
      this.inputKeyboard = GetValue(config2, "input.keyboard", true);
      this.inputKeyboardEventTarget = GetValue(config2, "input.keyboard.target", window);
      this.inputKeyboardCapture = GetValue(config2, "input.keyboard.capture", []);
      this.inputMouse = GetValue(config2, "input.mouse", true);
      this.inputMouseEventTarget = GetValue(config2, "input.mouse.target", null);
      this.inputMousePreventDefaultDown = GetValue(config2, "input.mouse.preventDefaultDown", true);
      this.inputMousePreventDefaultUp = GetValue(config2, "input.mouse.preventDefaultUp", true);
      this.inputMousePreventDefaultMove = GetValue(config2, "input.mouse.preventDefaultMove", true);
      this.inputMousePreventDefaultWheel = GetValue(config2, "input.mouse.preventDefaultWheel", true);
      this.inputTouch = GetValue(config2, "input.touch", Device.input.touch);
      this.inputTouchEventTarget = GetValue(config2, "input.touch.target", null);
      this.inputTouchCapture = GetValue(config2, "input.touch.capture", true);
      this.inputActivePointers = GetValue(config2, "input.activePointers", 1);
      this.inputSmoothFactor = GetValue(config2, "input.smoothFactor", 0);
      this.inputWindowEvents = GetValue(config2, "input.windowEvents", true);
      this.inputGamepad = GetValue(config2, "input.gamepad", false);
      this.inputGamepadEventTarget = GetValue(config2, "input.gamepad.target", window);
      this.disableContextMenu = GetValue(config2, "disableContextMenu", false);
      this.audio = GetValue(config2, "audio", {});
      this.hideBanner = GetValue(config2, "banner", null) === false;
      this.hidePhaser = GetValue(config2, "banner.hidePhaser", false);
      this.bannerTextColor = GetValue(config2, "banner.text", defaultBannerTextColor);
      this.bannerBackgroundColor = GetValue(config2, "banner.background", defaultBannerColor);
      if (this.gameTitle === "" && this.hidePhaser) {
        this.hideBanner = true;
      }
      this.fps = GetValue(config2, "fps", null);
      var renderConfig = GetValue(config2, "render", config2);
      this.pipeline = GetValue(renderConfig, "pipeline", null);
      this.antialias = GetValue(renderConfig, "antialias", true);
      this.antialiasGL = GetValue(renderConfig, "antialiasGL", true);
      this.mipmapFilter = GetValue(renderConfig, "mipmapFilter", "LINEAR");
      this.desynchronized = GetValue(renderConfig, "desynchronized", false);
      this.roundPixels = GetValue(renderConfig, "roundPixels", false);
      this.pixelArt = GetValue(renderConfig, "pixelArt", this.zoom !== 1);
      if (this.pixelArt) {
        this.antialias = false;
        this.antialiasGL = false;
        this.roundPixels = true;
      }
      this.transparent = GetValue(renderConfig, "transparent", false);
      this.clearBeforeRender = GetValue(renderConfig, "clearBeforeRender", true);
      this.preserveDrawingBuffer = GetValue(renderConfig, "preserveDrawingBuffer", false);
      this.premultipliedAlpha = GetValue(renderConfig, "premultipliedAlpha", true);
      this.failIfMajorPerformanceCaveat = GetValue(renderConfig, "failIfMajorPerformanceCaveat", false);
      this.powerPreference = GetValue(renderConfig, "powerPreference", "default");
      this.batchSize = GetValue(renderConfig, "batchSize", 4096);
      this.maxTextures = GetValue(renderConfig, "maxTextures", -1);
      this.maxLights = GetValue(renderConfig, "maxLights", 10);
      var bgc = GetValue(config2, "backgroundColor", 0);
      this.backgroundColor = ValueToColor(bgc);
      if (this.transparent) {
        this.backgroundColor = ValueToColor(0);
        this.backgroundColor.alpha = 0;
      }
      this.preBoot = GetValue(config2, "callbacks.preBoot", NOOP);
      this.postBoot = GetValue(config2, "callbacks.postBoot", NOOP);
      this.physics = GetValue(config2, "physics", {});
      this.defaultPhysicsSystem = GetValue(this.physics, "default", false);
      this.loaderBaseURL = GetValue(config2, "loader.baseURL", "");
      this.loaderPath = GetValue(config2, "loader.path", "");
      var defaultParallel = Device.os.android ? 6 : 32;
      this.loaderMaxParallelDownloads = GetValue(config2, "loader.maxParallelDownloads", defaultParallel);
      this.loaderCrossOrigin = GetValue(config2, "loader.crossOrigin", void 0);
      this.loaderResponseType = GetValue(config2, "loader.responseType", "");
      this.loaderAsync = GetValue(config2, "loader.async", true);
      this.loaderUser = GetValue(config2, "loader.user", "");
      this.loaderPassword = GetValue(config2, "loader.password", "");
      this.loaderTimeout = GetValue(config2, "loader.timeout", 0);
      this.loaderWithCredentials = GetValue(config2, "loader.withCredentials", false);
      this.installGlobalPlugins = [];
      this.installScenePlugins = [];
      var plugins = GetValue(config2, "plugins", null);
      var defaultPlugins = DefaultPlugins.DefaultScene;
      if (plugins) {
        if (Array.isArray(plugins)) {
          this.defaultPlugins = plugins;
        } else if (IsPlainObject(plugins)) {
          this.installGlobalPlugins = GetFastValue(plugins, "global", []);
          this.installScenePlugins = GetFastValue(plugins, "scene", []);
          if (Array.isArray(plugins.default)) {
            defaultPlugins = plugins.default;
          } else if (Array.isArray(plugins.defaultMerge)) {
            defaultPlugins = defaultPlugins.concat(plugins.defaultMerge);
          }
        }
      }
      this.defaultPlugins = defaultPlugins;
      var pngPrefix = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg";
      this.defaultImage = GetValue(config2, "images.default", pngPrefix + "AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==");
      this.missingImage = GetValue(config2, "images.missing", pngPrefix + "CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==");
      this.whiteImage = GetValue(config2, "images.white", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC");
      if (window) {
        if (window.FORCE_WEBGL) {
          this.renderType = CONST.WEBGL;
        } else if (window.FORCE_CANVAS) {
          this.renderType = CONST.CANVAS;
        }
      }
    }
  });
  module2.exports = Config;
});

// node_modules/phaser/src/display/canvas/CanvasInterpolation.js
var require_CanvasInterpolation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CanvasInterpolation = {
    setCrisp: function(canvas) {
      var types = ["optimizeSpeed", "-moz-crisp-edges", "-o-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "crisp-edges", "pixelated"];
      types.forEach(function(type) {
        canvas.style["image-rendering"] = type;
      });
      canvas.style.msInterpolationMode = "nearest-neighbor";
      return canvas;
    },
    setBicubic: function(canvas) {
      canvas.style["image-rendering"] = "auto";
      canvas.style.msInterpolationMode = "bicubic";
      return canvas;
    }
  };
  module2.exports = CanvasInterpolation;
});

// node_modules/phaser/src/renderer/snapshot/CanvasSnapshot.js
var require_CanvasSnapshot = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CanvasPool = require_CanvasPool();
  var Color = require_Color();
  var GetFastValue = require_GetFastValue();
  var CanvasSnapshot = function(canvas, config2) {
    var callback = GetFastValue(config2, "callback");
    var type = GetFastValue(config2, "type", "image/png");
    var encoderOptions = GetFastValue(config2, "encoder", 0.92);
    var x = Math.abs(Math.round(GetFastValue(config2, "x", 0)));
    var y = Math.abs(Math.round(GetFastValue(config2, "y", 0)));
    var width = GetFastValue(config2, "width", canvas.width);
    var height = GetFastValue(config2, "height", canvas.height);
    var getPixel = GetFastValue(config2, "getPixel", false);
    if (getPixel) {
      var context = canvas.getContext("2d");
      var imageData = context.getImageData(x, y, 1, 1);
      var data = imageData.data;
      callback.call(null, new Color(data[0], data[1], data[2], data[3] / 255));
    } else if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height) {
      var copyCanvas = CanvasPool.createWebGL(this, width, height);
      var ctx = copyCanvas.getContext("2d");
      ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);
      var image1 = new Image();
      image1.onerror = function() {
        callback.call(null);
        CanvasPool.remove(copyCanvas);
      };
      image1.onload = function() {
        callback.call(null, image1);
        CanvasPool.remove(copyCanvas);
      };
      image1.src = copyCanvas.toDataURL(type, encoderOptions);
    } else {
      var image2 = new Image();
      image2.onerror = function() {
        callback.call(null);
      };
      image2.onload = function() {
        callback.call(null, image2);
      };
      image2.src = canvas.toDataURL(type, encoderOptions);
    }
  };
  module2.exports = CanvasSnapshot;
});

// node_modules/phaser/src/renderer/canvas/utils/GetBlendModes.js
var require_GetBlendModes = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var modes = require_BlendModes();
  var CanvasFeatures = require_CanvasFeatures();
  var GetBlendModes = function() {
    var output = [];
    var useNew = CanvasFeatures.supportNewBlendModes;
    var so = "source-over";
    output[modes.NORMAL] = so;
    output[modes.ADD] = "lighter";
    output[modes.MULTIPLY] = useNew ? "multiply" : so;
    output[modes.SCREEN] = useNew ? "screen" : so;
    output[modes.OVERLAY] = useNew ? "overlay" : so;
    output[modes.DARKEN] = useNew ? "darken" : so;
    output[modes.LIGHTEN] = useNew ? "lighten" : so;
    output[modes.COLOR_DODGE] = useNew ? "color-dodge" : so;
    output[modes.COLOR_BURN] = useNew ? "color-burn" : so;
    output[modes.HARD_LIGHT] = useNew ? "hard-light" : so;
    output[modes.SOFT_LIGHT] = useNew ? "soft-light" : so;
    output[modes.DIFFERENCE] = useNew ? "difference" : so;
    output[modes.EXCLUSION] = useNew ? "exclusion" : so;
    output[modes.HUE] = useNew ? "hue" : so;
    output[modes.SATURATION] = useNew ? "saturation" : so;
    output[modes.COLOR] = useNew ? "color" : so;
    output[modes.LUMINOSITY] = useNew ? "luminosity" : so;
    output[modes.ERASE] = "destination-out";
    output[modes.SOURCE_IN] = "source-in";
    output[modes.SOURCE_OUT] = "source-out";
    output[modes.SOURCE_ATOP] = "source-atop";
    output[modes.DESTINATION_OVER] = "destination-over";
    output[modes.DESTINATION_IN] = "destination-in";
    output[modes.DESTINATION_OUT] = "destination-out";
    output[modes.DESTINATION_ATOP] = "destination-atop";
    output[modes.LIGHTER] = "lighter";
    output[modes.COPY] = "copy";
    output[modes.XOR] = "xor";
    return output;
  };
  module2.exports = GetBlendModes;
});

// node_modules/phaser/src/textures/events/ADD_EVENT.js
var require_ADD_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "addtexture";
});

// node_modules/phaser/src/textures/events/ERROR_EVENT.js
var require_ERROR_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "onerror";
});

// node_modules/phaser/src/textures/events/LOAD_EVENT.js
var require_LOAD_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "onload";
});

// node_modules/phaser/src/textures/events/READY_EVENT.js
var require_READY_EVENT3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "ready";
});

// node_modules/phaser/src/textures/events/REMOVE_EVENT.js
var require_REMOVE_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "removetexture";
});

// node_modules/phaser/src/textures/events/index.js
var require_events10 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ADD: require_ADD_EVENT2(),
    ERROR: require_ERROR_EVENT(),
    LOAD: require_LOAD_EVENT(),
    READY: require_READY_EVENT3(),
    REMOVE: require_REMOVE_EVENT2()
  };
});

// node_modules/phaser/src/renderer/canvas/CanvasRenderer.js
var require_CanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CameraEvents = require_events8();
  var CanvasSnapshot = require_CanvasSnapshot();
  var Class = require_Class();
  var CONST = require_const();
  var EventEmitter = require_eventemitter3();
  var Events = require_events2();
  var GetBlendModes = require_GetBlendModes();
  var ScaleEvents = require_events9();
  var TextureEvents = require_events10();
  var TransformMatrix = require_TransformMatrix();
  var CanvasRenderer = new Class({
    Extends: EventEmitter,
    initialize: function CanvasRenderer2(game2) {
      EventEmitter.call(this);
      var gameConfig = game2.config;
      this.config = {
        clearBeforeRender: gameConfig.clearBeforeRender,
        backgroundColor: gameConfig.backgroundColor,
        antialias: gameConfig.antialias,
        roundPixels: gameConfig.roundPixels
      };
      this.game = game2;
      this.type = CONST.CANVAS;
      this.drawCount = 0;
      this.width = 0;
      this.height = 0;
      this.gameCanvas = game2.canvas;
      var contextOptions = {
        alpha: game2.config.transparent,
        desynchronized: game2.config.desynchronized
      };
      this.gameContext = gameConfig.context ? gameConfig.context : this.gameCanvas.getContext("2d", contextOptions);
      this.currentContext = this.gameContext;
      this.antialias = game2.config.antialias;
      this.blendModes = GetBlendModes();
      this.snapshotState = {
        x: 0,
        y: 0,
        width: 1,
        height: 1,
        getPixel: false,
        callback: null,
        type: "image/png",
        encoder: 0.92
      };
      this._tempMatrix1 = new TransformMatrix();
      this._tempMatrix2 = new TransformMatrix();
      this._tempMatrix3 = new TransformMatrix();
      this.isBooted = false;
      this.init();
    },
    init: function() {
      this.game.textures.once(TextureEvents.READY, this.boot, this);
    },
    boot: function() {
      var game2 = this.game;
      var baseSize = game2.scale.baseSize;
      this.width = baseSize.width;
      this.height = baseSize.height;
      this.isBooted = true;
      game2.scale.on(ScaleEvents.RESIZE, this.onResize, this);
      this.resize(baseSize.width, baseSize.height);
    },
    onResize: function(gameSize, baseSize) {
      if (baseSize.width !== this.width || baseSize.height !== this.height) {
        this.resize(baseSize.width, baseSize.height);
      }
    },
    resize: function(width, height) {
      this.width = width;
      this.height = height;
      this.emit(Events.RESIZE, width, height);
    },
    resetTransform: function() {
      this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
    },
    setBlendMode: function(blendMode) {
      this.currentContext.globalCompositeOperation = blendMode;
      return this;
    },
    setContext: function(ctx) {
      this.currentContext = ctx ? ctx : this.gameContext;
      return this;
    },
    setAlpha: function(alpha) {
      this.currentContext.globalAlpha = alpha;
      return this;
    },
    preRender: function() {
      var ctx = this.gameContext;
      var config2 = this.config;
      var width = this.width;
      var height = this.height;
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = "source-over";
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      if (config2.clearBeforeRender) {
        ctx.clearRect(0, 0, width, height);
        if (!config2.transparent) {
          ctx.fillStyle = config2.backgroundColor.rgba;
          ctx.fillRect(0, 0, width, height);
        }
      }
      ctx.save();
      this.drawCount = 0;
      this.emit(Events.PRE_RENDER);
    },
    render: function(scene, children, camera) {
      var childCount = children.length;
      this.emit(Events.RENDER, scene, camera);
      var cx = camera.x;
      var cy = camera.y;
      var cw = camera.width;
      var ch = camera.height;
      var ctx = camera.renderToTexture ? camera.context : scene.sys.context;
      ctx.save();
      if (this.game.scene.customViewports) {
        ctx.beginPath();
        ctx.rect(cx, cy, cw, ch);
        ctx.clip();
      }
      this.currentContext = ctx;
      var mask = camera.mask;
      if (mask) {
        mask.preRenderCanvas(this, null, camera._maskCamera);
      }
      if (!camera.transparent) {
        ctx.fillStyle = camera.backgroundColor.rgba;
        ctx.fillRect(cx, cy, cw, ch);
      }
      ctx.globalAlpha = camera.alpha;
      ctx.globalCompositeOperation = "source-over";
      this.drawCount += childCount;
      if (camera.renderToTexture) {
        camera.emit(CameraEvents.PRE_RENDER, camera);
      }
      camera.matrix.copyToContext(ctx);
      for (var i = 0; i < childCount; i++) {
        var child = children[i];
        if (child.mask) {
          child.mask.preRenderCanvas(this, child, camera);
        }
        child.renderCanvas(this, child, camera);
        if (child.mask) {
          child.mask.postRenderCanvas(this, child, camera);
        }
      }
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.globalCompositeOperation = "source-over";
      ctx.globalAlpha = 1;
      camera.flashEffect.postRenderCanvas(ctx);
      camera.fadeEffect.postRenderCanvas(ctx);
      camera.dirty = false;
      if (mask) {
        mask.postRenderCanvas(this);
      }
      ctx.restore();
      if (camera.renderToTexture) {
        camera.emit(CameraEvents.POST_RENDER, camera);
        if (camera.renderToGame) {
          scene.sys.context.drawImage(camera.canvas, cx, cy);
        }
      }
    },
    postRender: function() {
      var ctx = this.gameContext;
      ctx.restore();
      this.emit(Events.POST_RENDER);
      var state = this.snapshotState;
      if (state.callback) {
        CanvasSnapshot(this.gameCanvas, state);
        state.callback = null;
      }
    },
    snapshotCanvas: function(canvas, callback, getPixel, x, y, width, height, type, encoderOptions) {
      if (getPixel === void 0) {
        getPixel = false;
      }
      this.snapshotArea(x, y, width, height, callback, type, encoderOptions);
      var state = this.snapshotState;
      state.getPixel = getPixel;
      CanvasSnapshot(this.canvas, state);
      state.callback = null;
      return this;
    },
    snapshot: function(callback, type, encoderOptions) {
      return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);
    },
    snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
      var state = this.snapshotState;
      state.callback = callback;
      state.type = type;
      state.encoder = encoderOptions;
      state.getPixel = false;
      state.x = x;
      state.y = y;
      state.width = Math.min(width, this.gameCanvas.width);
      state.height = Math.min(height, this.gameCanvas.height);
      return this;
    },
    snapshotPixel: function(x, y, callback) {
      this.snapshotArea(x, y, 1, 1, callback);
      this.snapshotState.getPixel = true;
      return this;
    },
    batchSprite: function(sprite, frame, camera, parentTransformMatrix) {
      var alpha = camera.alpha * sprite.alpha;
      if (alpha === 0) {
        return;
      }
      var ctx = this.currentContext;
      var camMatrix = this._tempMatrix1;
      var spriteMatrix = this._tempMatrix2;
      var cd = frame.canvasData;
      var frameX = cd.x;
      var frameY = cd.y;
      var frameWidth = frame.cutWidth;
      var frameHeight = frame.cutHeight;
      var customPivot = frame.customPivot;
      var res = frame.source.resolution;
      var displayOriginX = sprite.displayOriginX;
      var displayOriginY = sprite.displayOriginY;
      var x = -displayOriginX + frame.x;
      var y = -displayOriginY + frame.y;
      if (sprite.isCropped) {
        var crop = sprite._crop;
        if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY) {
          frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);
        }
        frameWidth = crop.cw;
        frameHeight = crop.ch;
        frameX = crop.cx;
        frameY = crop.cy;
        x = -displayOriginX + crop.x;
        y = -displayOriginY + crop.y;
        if (sprite.flipX) {
          if (x >= 0) {
            x = -(x + frameWidth);
          } else if (x < 0) {
            x = Math.abs(x) - frameWidth;
          }
        }
        if (sprite.flipY) {
          if (y >= 0) {
            y = -(y + frameHeight);
          } else if (y < 0) {
            y = Math.abs(y) - frameHeight;
          }
        }
      }
      var flipX = 1;
      var flipY = 1;
      if (sprite.flipX) {
        if (!customPivot) {
          x += -frame.realWidth + displayOriginX * 2;
        }
        flipX = -1;
      }
      if (sprite.flipY) {
        if (!customPivot) {
          y += -frame.realHeight + displayOriginY * 2;
        }
        flipY = -1;
      }
      spriteMatrix.applyITRS(sprite.x, sprite.y, sprite.rotation, sprite.scaleX * flipX, sprite.scaleY * flipY);
      camMatrix.copyFrom(camera.matrix);
      if (parentTransformMatrix) {
        camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY);
        spriteMatrix.e = sprite.x;
        spriteMatrix.f = sprite.y;
      } else {
        spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;
        spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY;
      }
      camMatrix.multiply(spriteMatrix);
      ctx.save();
      camMatrix.setToContext(ctx);
      ctx.globalCompositeOperation = this.blendModes[sprite.blendMode];
      ctx.globalAlpha = alpha;
      ctx.imageSmoothingEnabled = !(!this.antialias || frame.source.scaleMode);
      if (sprite.mask) {
        sprite.mask.preRenderCanvas(this, sprite, camera);
      }
      ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, x, y, frameWidth / res, frameHeight / res);
      if (sprite.mask) {
        sprite.mask.postRenderCanvas(this, sprite, camera);
      }
      ctx.restore();
    },
    destroy: function() {
      this.removeAllListeners();
      this.game = null;
      this.gameCanvas = null;
      this.gameContext = null;
    }
  });
  module2.exports = CanvasRenderer;
});

// node_modules/phaser/src/utils/array/Remove.js
var require_Remove = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SpliceOne = require_SpliceOne();
  var Remove = function(array, item, callback, context) {
    if (context === void 0) {
      context = array;
    }
    var index;
    if (!Array.isArray(item)) {
      index = array.indexOf(item);
      if (index !== -1) {
        SpliceOne(array, index);
        if (callback) {
          callback.call(context, item);
        }
        return item;
      } else {
        return null;
      }
    }
    var itemLength = item.length - 1;
    var removed = [];
    while (itemLength >= 0) {
      var entry = item[itemLength];
      index = array.indexOf(entry);
      if (index !== -1) {
        SpliceOne(array, index);
        removed.push(entry);
        if (callback) {
          callback.call(context, entry);
        }
      }
      itemLength--;
    }
    return removed;
  };
  module2.exports = Remove;
});

// node_modules/phaser/src/renderer/webgl/shaders/BitmapMask-frag.js
var require_BitmapMask_frag = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_BITMAP_MASK_FS",
    "",
    "precision mediump float;",
    "",
    "uniform vec2 uResolution;",
    "uniform sampler2D uMainSampler;",
    "uniform sampler2D uMaskSampler;",
    "uniform bool uInvertMaskAlpha;",
    "",
    "void main ()",
    "{",
    "    vec2 uv = gl_FragCoord.xy / uResolution;",
    "    vec4 mainColor = texture2D(uMainSampler, uv);",
    "    vec4 maskColor = texture2D(uMaskSampler, uv);",
    "    float alpha = mainColor.a;",
    "",
    "    if (!uInvertMaskAlpha)",
    "    {",
    "        alpha *= (maskColor.a);",
    "    }",
    "    else",
    "    {",
    "        alpha *= (1.0 - maskColor.a);",
    "    }",
    "",
    "    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/shaders/BitmapMask-vert.js
var require_BitmapMask_vert = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_BITMAP_MASK_VS",
    "",
    "precision mediump float;",
    "",
    "attribute vec2 inPosition;",
    "",
    "void main ()",
    "{",
    "    gl_Position = vec4(inPosition, 0.0, 1.0);",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/const.js
var require_const7 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var WEBGL_CONST = {
    BYTE: {enum: 5120, size: 1},
    UNSIGNED_BYTE: {enum: 5121, size: 1},
    SHORT: {enum: 5122, size: 2},
    UNSIGNED_SHORT: {enum: 5123, size: 2},
    INT: {enum: 5124, size: 4},
    UNSIGNED_INT: {enum: 5125, size: 4},
    FLOAT: {enum: 5126, size: 4}
  };
  module2.exports = WEBGL_CONST;
});

// node_modules/phaser/src/renderer/webgl/pipelines/events/AFTER_FLUSH_EVENT.js
var require_AFTER_FLUSH_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pipelineafterflush";
});

// node_modules/phaser/src/renderer/webgl/pipelines/events/BEFORE_FLUSH_EVENT.js
var require_BEFORE_FLUSH_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pipelinebeforeflush";
});

// node_modules/phaser/src/renderer/webgl/pipelines/events/BIND_EVENT.js
var require_BIND_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pipelinebind";
});

// node_modules/phaser/src/renderer/webgl/pipelines/events/BOOT_EVENT.js
var require_BOOT_EVENT3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pipelineboot";
});

// node_modules/phaser/src/renderer/webgl/pipelines/events/DESTROY_EVENT.js
var require_DESTROY_EVENT6 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pipelinedestroy";
});

// node_modules/phaser/src/renderer/webgl/pipelines/events/REBIND_EVENT.js
var require_REBIND_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pipelinerebind";
});

// node_modules/phaser/src/renderer/webgl/pipelines/events/RESIZE_EVENT.js
var require_RESIZE_EVENT3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pipelineresize";
});

// node_modules/phaser/src/renderer/webgl/pipelines/events/index.js
var require_events11 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    AFTER_FLUSH: require_AFTER_FLUSH_EVENT(),
    BEFORE_FLUSH: require_BEFORE_FLUSH_EVENT(),
    BIND: require_BIND_EVENT(),
    BOOT: require_BOOT_EVENT3(),
    DESTROY: require_DESTROY_EVENT6(),
    REBIND: require_REBIND_EVENT(),
    RESIZE: require_RESIZE_EVENT3()
  };
});

// node_modules/phaser/src/renderer/webgl/RenderTarget.js
var require_RenderTarget = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Events = require_events2();
  var RenderTarget = new Class({
    initialize: function RenderTarget2(renderer, width, height, scale, minFilter, autoClear, autoResize) {
      if (scale === void 0) {
        scale = 1;
      }
      if (minFilter === void 0) {
        minFilter = 0;
      }
      if (autoClear === void 0) {
        autoClear = true;
      }
      if (autoResize === void 0) {
        autoResize = false;
      }
      this.renderer = renderer;
      this.framebuffer = null;
      this.texture = null;
      this.width = 0;
      this.height = 0;
      this.scale = scale;
      this.minFilter = minFilter;
      this.autoClear = autoClear;
      this.autoResize = false;
      this.resize(width, height);
      if (autoResize) {
        this.setAutoResize(true);
      }
    },
    setAutoResize: function(autoResize) {
      if (autoResize && !this.autoResize) {
        this.renderer.on(Events.RESIZE, this.resize, this);
        this.autoResize = true;
      } else if (!autoResize && this.autoResize) {
        this.renderer.off(Events.RESIZE, this.resize, this);
        this.autoResize = false;
      }
      return this;
    },
    resize: function(width, height) {
      var scaledWidth = width * this.scale;
      var scaledHeight = height * this.scale;
      if (scaledWidth !== this.width || scaledHeight !== this.height) {
        var renderer = this.renderer;
        renderer.deleteFramebuffer(this.framebuffer);
        renderer.deleteTexture(this.texture);
        width *= this.scale;
        height *= this.scale;
        width = Math.round(width);
        height = Math.round(height);
        if (width <= 0) {
          width = 1;
        }
        if (height <= 0) {
          height = 1;
        }
        this.texture = renderer.createTextureFromSource(null, width, height, this.minFilter);
        this.framebuffer = renderer.createFramebuffer(width, height, this.texture, false);
        this.width = width;
        this.height = height;
      }
      return this;
    },
    bind: function(adjustViewport, width, height) {
      if (adjustViewport === void 0) {
        adjustViewport = false;
      }
      if (adjustViewport) {
        this.renderer.flush();
      }
      if (width && height) {
        this.resize(width, height);
      }
      this.renderer.pushFramebuffer(this.framebuffer, false, false, false);
      if (adjustViewport) {
        this.adjustViewport();
      }
      if (this.autoClear) {
        var gl = this.renderer.gl;
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
    },
    adjustViewport: function() {
      var gl = this.renderer.gl;
      gl.viewport(0, 0, this.width, this.height);
      gl.disable(gl.SCISSOR_TEST);
    },
    clear: function() {
      var renderer = this.renderer;
      var gl = renderer.gl;
      renderer.pushFramebuffer(this.framebuffer);
      gl.disable(gl.SCISSOR_TEST);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      renderer.popFramebuffer();
      renderer.resetScissor();
    },
    unbind: function(flush) {
      if (flush === void 0) {
        flush = false;
      }
      var renderer = this.renderer;
      if (flush) {
        renderer.flush();
      }
      return renderer.popFramebuffer();
    },
    destroy: function() {
      var renderer = this.renderer;
      renderer.deleteFramebuffer(this.framebuffer);
      renderer.deleteTexture(this.texture);
      renderer.off(Events.RESIZE, this.resize, this);
      this.renderer = null;
      this.framebuffer = null;
      this.texture = null;
    }
  });
  module2.exports = RenderTarget;
});

// node_modules/phaser/src/renderer/webgl/Utils.js
var require_Utils = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @author       Matthew Groves <@doormat>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  function GenerateSrc(maxIfs) {
    var src = "";
    for (var i = 0; i < maxIfs; ++i) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxIfs - 1) {
        src += "if(test == " + i + ".0){}";
      }
    }
    return src;
  }
  module2.exports = {
    getTintFromFloats: function(r, g, b, a) {
      var ur = (r * 255 | 0) & 255;
      var ug = (g * 255 | 0) & 255;
      var ub = (b * 255 | 0) & 255;
      var ua = (a * 255 | 0) & 255;
      return (ua << 24 | ur << 16 | ug << 8 | ub) >>> 0;
    },
    getTintAppendFloatAlpha: function(rgb, a) {
      var ua = (a * 255 | 0) & 255;
      return (ua << 24 | rgb) >>> 0;
    },
    getTintAppendFloatAlphaAndSwap: function(rgb, a) {
      var ur = (rgb >> 16 | 0) & 255;
      var ug = (rgb >> 8 | 0) & 255;
      var ub = (rgb | 0) & 255;
      var ua = (a * 255 | 0) & 255;
      return (ua << 24 | ub << 16 | ug << 8 | ur) >>> 0;
    },
    getFloatsFromUintRGB: function(rgb) {
      var ur = (rgb >> 16 | 0) & 255;
      var ug = (rgb >> 8 | 0) & 255;
      var ub = (rgb | 0) & 255;
      return [ur / 255, ug / 255, ub / 255];
    },
    checkShaderMax: function(gl, maxTextures) {
      if (!maxTextures || maxTextures === -1) {
        maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      }
      var shader = gl.createShader(gl.FRAGMENT_SHADER);
      var fragTemplate = [
        "precision mediump float;",
        "void main(void){",
        "float test = 0.1;",
        "%forloop%",
        "gl_FragColor = vec4(0.0);",
        "}"
      ].join("\n");
      while (true) {
        var fragmentSrc = fragTemplate.replace(/%forloop%/gi, GenerateSrc(maxTextures));
        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          maxTextures = maxTextures / 2 | 0;
        } else {
          break;
        }
      }
      return maxTextures;
    },
    parseFragmentShaderMaxTextures: function(fragmentShaderSource, maxTextures) {
      if (!fragmentShaderSource) {
        return "";
      }
      var src = "";
      for (var i = 0; i < maxTextures; i++) {
        if (i > 0) {
          src += "\n	else ";
        }
        if (i < maxTextures - 1) {
          src += "if (outTexId < " + i + ".5)";
        }
        src += "\n	{";
        src += "\n		texture = texture2D(uMainSampler[" + i + "], outTexCoord);";
        src += "\n	}";
      }
      fragmentShaderSource = fragmentShaderSource.replace(/%count%/gi, maxTextures.toString());
      return fragmentShaderSource.replace(/%forloop%/gi, src);
    }
  };
});

// node_modules/phaser/src/renderer/webgl/WebGLShader.js
var require_WebGLShader = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetFastValue = require_GetFastValue();
  var WEBGL_CONST = require_const7();
  var WebGLShader = new Class({
    initialize: function WebGLShader2(pipeline, name, vertexShader, fragmentShader, attributes) {
      this.pipeline = pipeline;
      this.name = name;
      this.renderer = pipeline.renderer;
      this.gl = this.renderer.gl;
      this.program = this.renderer.createProgram(vertexShader, fragmentShader);
      this.attributes;
      this.vertexComponentCount = 0;
      this.vertexSize = 0;
      this.uniforms = {};
      this.createAttributes(attributes);
      this.createUniforms();
    },
    createAttributes: function(attributes) {
      var count = 0;
      var offset = 0;
      var result = [];
      this.vertexComponentCount = 0;
      for (var i = 0; i < attributes.length; i++) {
        var element = attributes[i];
        var name = element.name;
        var size = GetFastValue(element, "size", 1);
        var glType = GetFastValue(element, "type", WEBGL_CONST.FLOAT);
        var type = glType.enum;
        var typeSize = glType.size;
        var normalized = element.normalized ? true : false;
        result.push({
          name,
          size,
          type,
          normalized,
          offset,
          enabled: false,
          location: -1
        });
        if (typeSize === 4) {
          count += size;
        } else {
          count++;
        }
        offset += size * typeSize;
      }
      this.vertexSize = offset;
      this.vertexComponentCount = count;
      this.attributes = result;
    },
    bind: function(setAttributes, flush) {
      if (setAttributes === void 0) {
        setAttributes = false;
      }
      if (flush === void 0) {
        flush = false;
      }
      if (flush) {
        this.pipeline.flush();
      }
      this.renderer.setProgram(this.program);
      if (setAttributes) {
        this.setAttribPointers();
      }
      return this;
    },
    rebind: function() {
      this.renderer.setProgram(this.program);
      this.setAttribPointers(true);
      return this;
    },
    setAttribPointers: function(reset) {
      if (reset === void 0) {
        reset = false;
      }
      var gl = this.gl;
      var vertexSize = this.vertexSize;
      var attributes = this.attributes;
      var program = this.program;
      for (var i = 0; i < attributes.length; i++) {
        var element = attributes[i];
        var size = element.size;
        var type = element.type;
        var offset = element.offset;
        var enabled = element.enabled;
        var location = element.location;
        var normalized = element.normalized ? true : false;
        if (reset) {
          var attribLocation = gl.getAttribLocation(program, element.name);
          if (attribLocation >= 0) {
            gl.enableVertexAttribArray(attribLocation);
            gl.vertexAttribPointer(attribLocation, size, type, normalized, vertexSize, offset);
            element.enabled = true;
            element.location = attribLocation;
          } else if (attribLocation !== -1) {
            gl.disableVertexAttribArray(attribLocation);
          }
        } else if (enabled) {
          gl.vertexAttribPointer(location, size, type, normalized, vertexSize, offset);
        } else if (!enabled && location > -1) {
          gl.disableVertexAttribArray(location);
          element.location = -1;
        }
      }
      return this;
    },
    createUniforms: function() {
      var gl = this.gl;
      var program = this.program;
      var uniforms = this.uniforms;
      var i;
      var name;
      var location;
      var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      for (i = 0; i < totalUniforms; i++) {
        var info = gl.getActiveUniform(program, i);
        if (info) {
          name = info.name;
          location = gl.getUniformLocation(program, name);
          if (location !== null) {
            uniforms[name] = {
              name,
              location,
              value1: null,
              value2: null,
              value3: null,
              value4: null
            };
          }
          var struct = name.indexOf("[");
          if (struct > 0) {
            name = name.substr(0, struct);
            if (!uniforms.hasOwnProperty(name)) {
              location = gl.getUniformLocation(program, name);
              if (location !== null) {
                uniforms[name] = {
                  name,
                  location,
                  value1: null,
                  value2: null,
                  value3: null,
                  value4: null
                };
              }
            }
          }
        }
      }
      return this;
    },
    hasUniform: function(name) {
      return this.uniforms.hasOwnProperty(name);
    },
    resetUniform: function(name) {
      var uniform = this.uniforms[name];
      if (uniform) {
        uniform.value1 = null;
        uniform.value2 = null;
        uniform.value3 = null;
        uniform.value4 = null;
      }
      return this;
    },
    setUniform1: function(setter, name, value1, skipCheck) {
      var uniform = this.uniforms[name];
      if (!uniform) {
        return this;
      }
      if (skipCheck || uniform.value1 !== value1) {
        uniform.value1 = value1;
        this.renderer.setProgram(this.program);
        setter.call(this.gl, uniform.location, value1);
        this.pipeline.currentShader = this;
      }
      return this;
    },
    setUniform2: function(setter, name, value1, value2, skipCheck) {
      var uniform = this.uniforms[name];
      if (!uniform) {
        return this;
      }
      if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2) {
        uniform.value1 = value1;
        uniform.value2 = value2;
        this.renderer.setProgram(this.program);
        setter.call(this.gl, uniform.location, value1, value2);
        this.pipeline.currentShader = this;
      }
      return this;
    },
    setUniform3: function(setter, name, value1, value2, value3, skipCheck) {
      var uniform = this.uniforms[name];
      if (!uniform) {
        return this;
      }
      if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3) {
        uniform.value1 = value1;
        uniform.value2 = value2;
        uniform.value3 = value3;
        this.renderer.setProgram(this.program);
        setter.call(this.gl, uniform.location, value1, value2, value3);
        this.pipeline.currentShader = this;
      }
      return this;
    },
    setUniform4: function(setter, name, value1, value2, value3, value4, skipCheck) {
      var uniform = this.uniforms[name];
      if (!uniform) {
        return this;
      }
      if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3 || uniform.value4 !== value4) {
        uniform.value1 = value1;
        uniform.value2 = value2;
        uniform.value3 = value3;
        uniform.value4 = value4;
        this.renderer.setProgram(this.program);
        setter.call(this.gl, uniform.location, value1, value2, value3, value4);
        this.pipeline.currentShader = this;
      }
      return this;
    },
    set1f: function(name, x) {
      return this.setUniform1(this.gl.uniform1f, name, x);
    },
    set2f: function(name, x, y) {
      return this.setUniform2(this.gl.uniform2f, name, x, y);
    },
    set3f: function(name, x, y, z) {
      return this.setUniform3(this.gl.uniform3f, name, x, y, z);
    },
    set4f: function(name, x, y, z, w) {
      return this.setUniform4(this.gl.uniform4f, name, x, y, z, w);
    },
    set1fv: function(name, arr) {
      return this.setUniform1(this.gl.uniform1fv, name, arr, true);
    },
    set2fv: function(name, arr) {
      return this.setUniform1(this.gl.uniform2fv, name, arr, true);
    },
    set3fv: function(name, arr) {
      return this.setUniform1(this.gl.uniform3fv, name, arr, true);
    },
    set4fv: function(name, arr) {
      return this.setUniform1(this.gl.uniform4fv, name, arr, true);
    },
    set1iv: function(name, arr) {
      return this.setUniform1(this.gl.uniform1iv, name, arr, true);
    },
    set2iv: function(name, arr) {
      return this.setUniform1(this.gl.uniform2iv, name, arr, true);
    },
    set3iv: function(name, arr) {
      return this.setUniform1(this.gl.uniform3iv, name, arr, true);
    },
    set4iv: function(name, arr) {
      return this.setUniform1(this.gl.uniform4iv, name, arr, true);
    },
    set1i: function(name, x) {
      return this.setUniform1(this.gl.uniform1i, name, x);
    },
    set2i: function(name, x, y) {
      return this.setUniform2(this.gl.uniform2i, name, x, y);
    },
    set3i: function(name, x, y, z) {
      return this.setUniform3(this.gl.uniform3i, name, x, y, z);
    },
    set4i: function(name, x, y, z, w) {
      return this.setUniform4(this.gl.uniform4i, name, x, y, z, w);
    },
    setMatrix2fv: function(name, transpose, matrix) {
      return this.setUniform2(this.gl.uniformMatrix2fv, name, transpose, matrix, true);
    },
    setMatrix3fv: function(name, transpose, matrix) {
      return this.setUniform2(this.gl.uniformMatrix3fv, name, transpose, matrix, true);
    },
    setMatrix4fv: function(name, transpose, matrix) {
      return this.setUniform2(this.gl.uniformMatrix4fv, name, transpose, matrix, true);
    },
    destroy: function() {
      this.gl.deleteProgram(this.program);
      this.pipeline = null;
      this.renderer = null;
      this.gl = null;
      this.program = null;
      this.attributes = null;
      this.uniforms = null;
    }
  });
  module2.exports = WebGLShader;
});

// node_modules/phaser/src/renderer/webgl/WebGLPipeline.js
var require_WebGLPipeline = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var DeepCopy = require_DeepCopy();
  var EventEmitter = require_eventemitter3();
  var Events = require_events11();
  var GetFastValue = require_GetFastValue();
  var Matrix4 = require_Matrix4();
  var RendererEvents = require_events2();
  var RenderTarget = require_RenderTarget();
  var Utils = require_Utils();
  var WebGLShader = require_WebGLShader();
  var WebGLPipeline = new Class({
    Extends: EventEmitter,
    initialize: function WebGLPipeline2(config2) {
      EventEmitter.call(this);
      var game2 = config2.game;
      var renderer = game2.renderer;
      var gl = renderer.gl;
      this.name = GetFastValue(config2, "name", "WebGLPipeline");
      this.game = game2;
      this.renderer = renderer;
      this.manager;
      this.gl = gl;
      this.view = game2.canvas;
      this.width = 0;
      this.height = 0;
      this.vertexCount = 0;
      this.vertexCapacity = 0;
      this.vertexData;
      this.vertexBuffer;
      this.topology = GetFastValue(config2, "topology", gl.TRIANGLES);
      this.bytes;
      this.vertexViewF32;
      this.vertexViewU32;
      this.active = true;
      this.currentUnit = 0;
      this.forceZero = GetFastValue(config2, "forceZero", false);
      this.hasBooted = false;
      this.isPostFX = false;
      this.renderTargets = [];
      this.currentRenderTarget;
      this.shaders = [];
      this.currentShader;
      this.projectionMatrix;
      this.projectionWidth = 0;
      this.projectionHeight = 0;
      this.config = config2;
      this.glReset = false;
    },
    boot: function() {
      var i;
      var gl = this.gl;
      var config2 = this.config;
      var renderer = this.renderer;
      if (!this.isPostFX) {
        this.projectionMatrix = new Matrix4().identity();
      }
      var renderTargets = this.renderTargets;
      var targets = GetFastValue(config2, "renderTarget", false);
      if (typeof targets === "boolean" && targets) {
        targets = 1;
      }
      var width = renderer.width;
      var height = renderer.height;
      if (typeof targets === "number") {
        for (i = 0; i < targets; i++) {
          renderTargets.push(new RenderTarget(renderer, width, height, 1, 0, true));
        }
      } else if (Array.isArray(targets)) {
        for (i = 0; i < targets.length; i++) {
          var scale = GetFastValue(targets[i], "scale", 1);
          var minFilter = GetFastValue(targets[i], "minFilter", 0);
          var autoClear = GetFastValue(targets[i], "autoClear", 1);
          renderTargets.push(new RenderTarget(renderer, width, height, scale, minFilter, autoClear));
        }
      }
      if (renderTargets.length) {
        this.currentRenderTarget = renderTargets[0];
      }
      this.setShadersFromConfig(config2);
      var shaders = this.shaders;
      var vertexSize = 0;
      for (i = 0; i < shaders.length; i++) {
        if (shaders[i].vertexSize > vertexSize) {
          vertexSize = shaders[i].vertexSize;
        }
      }
      var batchSize = GetFastValue(config2, "batchSize", renderer.config.batchSize);
      this.vertexCapacity = batchSize * 6;
      var data = new ArrayBuffer(this.vertexCapacity * vertexSize);
      this.vertexData = data;
      this.bytes = new Uint8Array(data);
      this.vertexViewF32 = new Float32Array(data);
      this.vertexViewU32 = new Uint32Array(data);
      var configVerts = GetFastValue(config2, "vertices", null);
      if (configVerts) {
        this.vertexViewF32.set(configVerts);
        this.vertexBuffer = renderer.createVertexBuffer(data, gl.STATIC_DRAW);
      } else {
        this.vertexBuffer = renderer.createVertexBuffer(data.byteLength, gl.DYNAMIC_DRAW);
      }
      this.setVertexBuffer();
      for (i = shaders.length - 1; i >= 0; i--) {
        shaders[i].rebind();
      }
      this.hasBooted = true;
      renderer.on(RendererEvents.RESIZE, this.resize, this);
      renderer.on(RendererEvents.PRE_RENDER, this.onPreRender, this);
      renderer.on(RendererEvents.RENDER, this.onRender, this);
      renderer.on(RendererEvents.POST_RENDER, this.onPostRender, this);
      this.emit(Events.BOOT, this);
      this.onBoot();
    },
    onBoot: function() {
    },
    onResize: function() {
    },
    setShader: function(shader, setAttributes) {
      var renderer = this.renderer;
      if (shader !== this.currentShader || renderer.currentProgram !== this.currentShader.program) {
        this.flush();
        renderer.resetTextures();
        var wasBound = this.setVertexBuffer();
        if (wasBound && !setAttributes) {
          setAttributes = true;
        }
        shader.bind(setAttributes, false);
        this.currentShader = shader;
      }
      return this;
    },
    getShaderByName: function(name) {
      var shaders = this.shaders;
      for (var i = 0; i < shaders.length; i++) {
        if (shaders[i].name === name) {
          return shaders[i];
        }
      }
    },
    setShadersFromConfig: function(config2) {
      var i;
      var shaders = this.shaders;
      var renderer = this.renderer;
      for (i = 0; i < shaders.length; i++) {
        shaders[i].destroy();
      }
      var vName = "vertShader";
      var fName = "fragShader";
      var aName = "attributes";
      var defaultVertShader = GetFastValue(config2, vName, null);
      var defaultFragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(config2, fName, null), renderer.maxTextures);
      var defaultAttribs = GetFastValue(config2, aName, null);
      var configShaders = GetFastValue(config2, "shaders", []);
      var len = configShaders.length;
      if (len === 0) {
        if (defaultVertShader && defaultFragShader) {
          this.shaders = [new WebGLShader(this, "default", defaultVertShader, defaultFragShader, DeepCopy(defaultAttribs))];
        }
      } else {
        var newShaders = [];
        for (i = 0; i < len; i++) {
          var shaderEntry = configShaders[i];
          var name = GetFastValue(shaderEntry, "name", "default");
          var vertShader = GetFastValue(shaderEntry, vName, defaultVertShader);
          var fragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(shaderEntry, fName, defaultFragShader), renderer.maxTextures);
          var attributes = GetFastValue(shaderEntry, aName, defaultAttribs);
          if (vertShader && fragShader) {
            newShaders.push(new WebGLShader(this, name, vertShader, fragShader, DeepCopy(attributes)));
          }
        }
        this.shaders = newShaders;
      }
      if (this.shaders.length === 0) {
        console.warn("Pipeline: " + this.name + " - Invalid shader config");
      } else {
        this.currentShader = this.shaders[0];
      }
      return this;
    },
    setGameObject: function(gameObject, frame) {
      if (frame === void 0) {
        frame = gameObject.frame;
      }
      this.currentUnit = this.renderer.setTextureSource(frame.source);
      return this.currentUnit;
    },
    shouldFlush: function(amount) {
      if (amount === void 0) {
        amount = 0;
      }
      return this.vertexCount + amount > this.vertexCapacity;
    },
    resize: function(width, height) {
      if (width !== this.width || height !== this.height) {
        this.flush();
      }
      this.width = width;
      this.height = height;
      var targets = this.renderTargets;
      for (var i = 0; i < targets.length; i++) {
        targets[i].resize(width, height);
      }
      this.setProjectionMatrix(width, height);
      this.emit(Events.RESIZE, width, height, this);
      this.onResize(width, height);
      return this;
    },
    setProjectionMatrix: function(width, height) {
      var projectionMatrix = this.projectionMatrix;
      if (!projectionMatrix) {
        return this;
      }
      this.projectionWidth = width;
      this.projectionHeight = height;
      projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
      var shaders = this.shaders;
      var name = "uProjectionMatrix";
      for (var i = 0; i < shaders.length; i++) {
        var shader = shaders[i];
        if (shader.hasUniform(name)) {
          shader.resetUniform(name);
          shader.setMatrix4fv(name, false, projectionMatrix.val, shader);
        }
      }
      return this;
    },
    updateProjectionMatrix: function() {
      if (this.projectionMatrix) {
        var globalWidth = this.renderer.projectionWidth;
        var globalHeight = this.renderer.projectionHeight;
        if (this.projectionWidth !== globalWidth || this.projectionHeight !== globalHeight) {
          this.setProjectionMatrix(globalWidth, globalHeight);
        }
      }
    },
    bind: function(currentShader) {
      if (currentShader === void 0) {
        currentShader = this.currentShader;
      }
      if (this.glReset) {
        return this.rebind(currentShader);
      }
      var wasBound = this.setVertexBuffer();
      currentShader.bind(wasBound);
      this.currentShader = currentShader;
      this.emit(Events.BIND, this, currentShader);
      this.onActive(currentShader);
      return this;
    },
    rebind: function(currentShader) {
      this.setVertexBuffer();
      var shaders = this.shaders;
      for (var i = shaders.length - 1; i >= 0; i--) {
        var shader = shaders[i].rebind();
        if (!currentShader || shader === currentShader) {
          this.currentShader = shader;
        }
      }
      this.emit(Events.REBIND, this.currentShader);
      this.onActive(this.currentShader);
      this.onRebind();
      this.glReset = false;
      return this;
    },
    setVertexBuffer: function() {
      var gl = this.gl;
      var buffer = this.vertexBuffer;
      if (gl.getParameter(gl.ARRAY_BUFFER_BINDING) !== buffer) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        return true;
      }
      return false;
    },
    preBatch: function(gameObject) {
      if (this.currentRenderTarget) {
        this.currentRenderTarget.bind();
      }
      this.onPreBatch(gameObject);
      return this;
    },
    postBatch: function(gameObject) {
      this.onDraw(this.currentRenderTarget);
      this.onPostBatch(gameObject);
      return this;
    },
    onDraw: function() {
    },
    unbind: function() {
      if (this.currentRenderTarget) {
        this.currentRenderTarget.unbind();
      }
    },
    flush: function(isPostFlush) {
      if (isPostFlush === void 0) {
        isPostFlush = false;
      }
      if (this.vertexCount > 0) {
        this.emit(Events.BEFORE_FLUSH, this, isPostFlush);
        this.onBeforeFlush(isPostFlush);
        var gl = this.gl;
        var vertexCount = this.vertexCount;
        var vertexSize = this.currentShader.vertexSize;
        if (this.active) {
          this.setVertexBuffer();
          if (vertexCount === this.vertexCapacity) {
            gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.DYNAMIC_DRAW);
          } else {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));
          }
          gl.drawArrays(this.topology, 0, vertexCount);
        }
        this.vertexCount = 0;
        this.emit(Events.AFTER_FLUSH, this, isPostFlush);
        this.onAfterFlush(isPostFlush);
      }
      return this;
    },
    onActive: function() {
    },
    onBind: function() {
    },
    onRebind: function() {
    },
    onBatch: function() {
    },
    onPreBatch: function() {
    },
    onPostBatch: function() {
    },
    onPreRender: function() {
    },
    onRender: function() {
    },
    onPostRender: function() {
    },
    onBeforeFlush: function() {
    },
    onAfterFlush: function() {
    },
    batchVert: function(x, y, u, v, unit, tintEffect, tint) {
      var vertexViewF32 = this.vertexViewF32;
      var vertexViewU32 = this.vertexViewU32;
      var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
      vertexViewF32[++vertexOffset] = x;
      vertexViewF32[++vertexOffset] = y;
      vertexViewF32[++vertexOffset] = u;
      vertexViewF32[++vertexOffset] = v;
      vertexViewF32[++vertexOffset] = unit;
      vertexViewF32[++vertexOffset] = tintEffect;
      vertexViewU32[++vertexOffset] = tint;
      this.vertexCount++;
    },
    batchQuad: function(gameObject, x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, unit) {
      if (unit === void 0) {
        unit = this.currentUnit;
      }
      var hasFlushed = false;
      if (this.shouldFlush(6)) {
        this.flush();
        hasFlushed = true;
        unit = this.setTexture2D(texture);
      }
      this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);
      this.batchVert(x1, y1, u0, v1, unit, tintEffect, tintBL);
      this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBR);
      this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);
      this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBR);
      this.batchVert(x3, y3, u1, v0, unit, tintEffect, tintTR);
      this.onBatch(gameObject);
      return hasFlushed;
    },
    batchTri: function(gameObject, x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintEffect, texture, unit) {
      if (unit === void 0) {
        unit = this.currentUnit;
      }
      var hasFlushed = false;
      if (this.shouldFlush(3)) {
        this.flush();
        hasFlushed = true;
        unit = this.setTexture2D(texture);
      }
      this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);
      this.batchVert(x1, y1, u0, v1, unit, tintEffect, tintTR);
      this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBL);
      this.onBatch(gameObject);
      return hasFlushed;
    },
    drawFillRect: function(x, y, width, height, color, alpha, texture, flipUV) {
      if (texture === void 0) {
        texture = this.renderer.whiteTexture.glTexture;
      }
      if (flipUV === void 0) {
        flipUV = true;
      }
      x = Math.floor(x);
      y = Math.floor(y);
      var xw = Math.floor(x + width);
      var yh = Math.floor(y + height);
      var unit = this.setTexture2D(texture);
      var tint = Utils.getTintAppendFloatAlphaAndSwap(color, alpha);
      var u0 = 0;
      var v0 = 0;
      var u1 = 1;
      var v1 = 1;
      if (flipUV) {
        v0 = 1;
        v1 = 0;
      }
      this.batchQuad(null, x, y, x, yh, xw, yh, xw, y, u0, v0, u1, v1, tint, tint, tint, tint, 0, texture, unit);
    },
    setTexture2D: function(texture) {
      if (texture === void 0) {
        texture = this.renderer.whiteTexture.glTexture;
      }
      this.currentUnit = this.renderer.setTexture2D(texture);
      return this.currentUnit;
    },
    bindTexture: function(texture, unit) {
      if (unit === void 0) {
        unit = 0;
      }
      var gl = this.gl;
      gl.activeTexture(gl.TEXTURE0 + unit);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      return this;
    },
    bindRenderTarget: function(target, unit) {
      return this.bindTexture(target.texture, unit);
    },
    setTime: function(uniform) {
      this.set1f(uniform, this.game.loop.getDuration());
      return this;
    },
    set1f: function(name, x, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set1f(name, x);
      return this;
    },
    set2f: function(name, x, y, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set2f(name, x, y);
      return this;
    },
    set3f: function(name, x, y, z, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set3f(name, x, y, z);
      return this;
    },
    set4f: function(name, x, y, z, w, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set4f(name, x, y, z, w);
      return this;
    },
    set1fv: function(name, arr, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set1fv(name, arr);
      return this;
    },
    set2fv: function(name, arr, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set2fv(name, arr);
      return this;
    },
    set3fv: function(name, arr, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set3fv(name, arr);
      return this;
    },
    set4fv: function(name, arr, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set4fv(name, arr);
      return this;
    },
    set1iv: function(name, arr, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set1iv(name, arr);
      return this;
    },
    set2iv: function(name, arr, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set2iv(name, arr);
      return this;
    },
    set3iv: function(name, arr, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set3iv(name, arr);
      return this;
    },
    set4iv: function(name, arr, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set4iv(name, arr);
      return this;
    },
    set1i: function(name, x, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set1i(name, x);
      return this;
    },
    set2i: function(name, x, y, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set2i(name, x, y);
      return this;
    },
    set3i: function(name, x, y, z, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set3i(name, x, y, z);
      return this;
    },
    set4i: function(name, x, y, z, w, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.set4i(name, x, y, z, w);
      return this;
    },
    setMatrix2fv: function(name, transpose, matrix, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.setMatrix2fv(name, transpose, matrix);
      return this;
    },
    setMatrix3fv: function(name, transpose, matrix, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.setMatrix3fv(name, transpose, matrix);
      return this;
    },
    setMatrix4fv: function(name, transpose, matrix, shader) {
      if (shader === void 0) {
        shader = this.currentShader;
      }
      shader.setMatrix4fv(name, transpose, matrix);
      return this;
    },
    destroy: function() {
      this.emit(Events.DESTROY, this);
      var i;
      var shaders = this.shaders;
      for (i = 0; i < shaders.length; i++) {
        shaders[i].destroy();
      }
      var targets = this.renderTargets;
      for (i = 0; i < targets.length; i++) {
        targets[i].destroy();
      }
      this.gl.deleteBuffer(this.vertexBuffer);
      var renderer = this.renderer;
      renderer.off(RendererEvents.RESIZE, this.resize, this);
      renderer.off(RendererEvents.PRE_RENDER, this.onPreRender, this);
      renderer.off(RendererEvents.RENDER, this.onRender, this);
      renderer.off(RendererEvents.POST_RENDER, this.onPostRender, this);
      this.removeAllListeners();
      this.game = null;
      this.renderer = null;
      this.manager = null;
      this.gl = null;
      this.view = null;
      this.shaders = null;
      this.renderTargets = null;
      this.bytes = null;
      this.vertexViewF32 = null;
      this.vertexViewU32 = null;
      this.vertexData = null;
      this.vertexBuffer = null;
      this.currentShader = null;
      this.currentRenderTarget = null;
      return this;
    }
  });
  module2.exports = WebGLPipeline;
});

// node_modules/phaser/src/renderer/webgl/pipelines/BitmapMaskPipeline.js
var require_BitmapMaskPipeline = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetFastValue = require_GetFastValue();
  var ShaderSourceFS = require_BitmapMask_frag();
  var ShaderSourceVS = require_BitmapMask_vert();
  var WEBGL_CONST = require_const7();
  var WebGLPipeline = require_WebGLPipeline();
  var BitmapMaskPipeline = new Class({
    Extends: WebGLPipeline,
    initialize: function BitmapMaskPipeline2(config2) {
      config2.fragShader = GetFastValue(config2, "fragShader", ShaderSourceFS), config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS), config2.batchSize = GetFastValue(config2, "batchSize", 1), config2.vertices = GetFastValue(config2, "vertices", [-1, 1, -1, -7, 7, 1]), config2.attributes = GetFastValue(config2, "attributes", [
        {
          name: "inPosition",
          size: 2,
          type: WEBGL_CONST.FLOAT
        }
      ]);
      WebGLPipeline.call(this, config2);
    },
    boot: function() {
      WebGLPipeline.prototype.boot.call(this);
      this.set1i("uMainSampler", 0);
      this.set1i("uMaskSampler", 1);
    },
    resize: function(width, height) {
      WebGLPipeline.prototype.resize.call(this, width, height);
      this.set2f("uResolution", width, height);
    },
    beginMask: function(mask, maskedObject, camera) {
      var gl = this.gl;
      if (mask.bitmapMask && gl) {
        var renderer = this.renderer;
        renderer.flush();
        renderer.pushFramebuffer(mask.mainFramebuffer);
        gl.disable(gl.STENCIL_TEST);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        if (renderer.currentCameraMask.mask !== mask) {
          renderer.currentMask.mask = mask;
          renderer.currentMask.camera = camera;
        }
      }
    },
    endMask: function(mask, camera) {
      var gl = this.gl;
      var renderer = this.renderer;
      var bitmapMask = mask.bitmapMask;
      if (bitmapMask && gl) {
        renderer.flush();
        renderer.pushFramebuffer(mask.maskFramebuffer);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        renderer.setBlendMode(0, true);
        bitmapMask.renderWebGL(renderer, bitmapMask, camera);
        renderer.flush();
        renderer.popFramebuffer();
        renderer.popFramebuffer();
        var prev = renderer.getCurrentStencilMask();
        if (prev) {
          gl.enable(gl.STENCIL_TEST);
          prev.mask.applyStencil(renderer, prev.camera, true);
        } else {
          renderer.currentMask.mask = null;
        }
        renderer.pipelines.set(this);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, mask.maskTexture);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, mask.mainTexture);
        this.set1i("uInvertMaskAlpha", mask.invertAlpha);
        gl.drawArrays(this.topology, 0, 3);
        renderer.resetTextures();
      }
    }
  });
  module2.exports = BitmapMaskPipeline;
});

// node_modules/phaser/src/geom/polygon/Earcut.js
var require_Earcut = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  "use strict";
  function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (var i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i = start; i < end; i += dim)
        last = insertNode(i, data[i], data[i + 1], last);
    } else {
      for (i = end - dim; i >= start; i -= dim)
        last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    var p = start, again;
    do {
      again = false;
      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next)
          break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    var stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    var p = ear.next.next;
    while (p !== ear.prev) {
      if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    var p = ear.prevZ, n = ear.nextZ;
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    while (p && p.z >= minZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
      var a = p.prev, b = p.next.next;
      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim);
        triangles.push(p.i / dim);
        triangles.push(b.i / dim);
        removeNode(p);
        removeNode(p.next);
        p = start = b;
      }
      p = p.next;
    } while (p !== start);
    return filterPoints(p);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    var a = start;
    do {
      var b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          var c = splitPolygon(a, b);
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);
          earcutLinked(a, triangles, dim, minX, minY, invSize);
          earcutLinked(c, triangles, dim, minX, minY, invSize);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i = 0; i < queue.length; i++) {
      eliminateHole(queue[i], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
  }
  function compareX(a, b) {
    return a.x - b.x;
  }
  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
      var b = splitPolygon(outerNode, hole);
      filterPoints(outerNode, outerNode.next);
      filterPoints(b, b.next);
    }
  }
  function findHoleBridge(hole, outerNode) {
    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          if (x === hx) {
            if (hy === p.y)
              return p;
            if (hy === p.next.y)
              return p.next;
          }
          m = p.x < p.next.x ? p : p.next;
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m)
      return null;
    if (hx === qx)
      return m;
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x);
        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
      if (p.z === null)
        p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }
  function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x, y, minX, minY, invSize) {
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  }
  function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
        leftmost = p;
      p = p.next;
    } while (p !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
  }
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
  }
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a, b) {
    var p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
        return true;
      p = p.next;
    } while (p !== a);
    return false;
  }
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }
  function middleInside(a, b) {
    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
      if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
        inside = !inside;
      p = p.next;
    } while (p !== a);
    return inside;
  }
  function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
      p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
      p.nextZ.prevZ = p.prevZ;
  }
  function Node(i, x, y) {
    this.i = i;
    this.x = x;
    this.y = y;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  earcut.deviation = function(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
      for (var i = 0, len = holeIndices.length; i < len; i++) {
        var start = holeIndices[i] * dim;
        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
      }
    }
    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
      var a = triangles[i] * dim;
      var b = triangles[i + 1] * dim;
      var c = triangles[i + 2] * dim;
      trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
  };
  function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  }
  earcut.flatten = function(data) {
    var dim = data[0][0].length, result = {vertices: [], holes: [], dimensions: dim}, holeIndex = 0;
    for (var i = 0; i < data.length; i++) {
      for (var j = 0; j < data[i].length; j++) {
        for (var d = 0; d < dim; d++)
          result.vertices.push(data[i][j][d]);
      }
      if (i > 0) {
        holeIndex += data[i - 1].length;
        result.holes.push(holeIndex);
      }
    }
    return result;
  };
  module2.exports = earcut;
});

// node_modules/phaser/src/renderer/webgl/shaders/Graphics-frag.js
var require_Graphics_frag = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_GRAPHICS_FS",
    "",
    "precision mediump float;",
    "",
    "varying vec4 outColor;",
    "",
    "void main ()",
    "{",
    "    gl_FragColor = vec4(outColor.bgr * outColor.a, outColor.a);",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/shaders/Graphics-vert.js
var require_Graphics_vert = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_GRAPHICS_VS",
    "",
    "precision mediump float;",
    "",
    "uniform mat4 uProjectionMatrix;",
    "",
    "attribute vec2 inPosition;",
    "attribute vec4 inColor;",
    "",
    "varying vec4 outColor;",
    "",
    "void main ()",
    "{",
    "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
    "",
    "    outColor = inColor;",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/pipelines/GraphicsPipeline.js
var require_GraphicsPipeline = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Earcut = require_Earcut();
  var GetFastValue = require_GetFastValue();
  var ShaderSourceFS = require_Graphics_frag();
  var ShaderSourceVS = require_Graphics_vert();
  var TransformMatrix = require_TransformMatrix();
  var WEBGL_CONST = require_const7();
  var WebGLPipeline = require_WebGLPipeline();
  var GraphicsPipeline = new Class({
    Extends: WebGLPipeline,
    initialize: function GraphicsPipeline2(config2) {
      config2.fragShader = GetFastValue(config2, "fragShader", ShaderSourceFS);
      config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS);
      config2.attributes = GetFastValue(config2, "attributes", [
        {
          name: "inPosition",
          size: 2
        },
        {
          name: "inColor",
          size: 4,
          type: WEBGL_CONST.UNSIGNED_BYTE,
          normalized: true
        }
      ]);
      WebGLPipeline.call(this, config2);
      this.calcMatrix = new TransformMatrix();
      this.tempTriangle = [
        {x: 0, y: 0, width: 0},
        {x: 0, y: 0, width: 0},
        {x: 0, y: 0, width: 0},
        {x: 0, y: 0, width: 0}
      ];
      this.strokeTint = {TL: 0, TR: 0, BL: 0, BR: 0};
      this.fillTint = {TL: 0, TR: 0, BL: 0, BR: 0};
      this.currentFrame = {u0: 0, v0: 0, u1: 1, v1: 1};
      this.firstQuad = [0, 0, 0, 0, 0];
      this.prevQuad = [0, 0, 0, 0, 0];
      this.polygonCache = [];
    },
    batchFillRect: function(x, y, width, height, currentMatrix, parentMatrix) {
      this.renderer.pipelines.set(this);
      var calcMatrix = this.calcMatrix;
      if (parentMatrix) {
        parentMatrix.multiply(currentMatrix, calcMatrix);
      }
      var xw = x + width;
      var yh = y + height;
      var x0 = calcMatrix.getX(x, y);
      var y0 = calcMatrix.getY(x, y);
      var x1 = calcMatrix.getX(x, yh);
      var y1 = calcMatrix.getY(x, yh);
      var x2 = calcMatrix.getX(xw, yh);
      var y2 = calcMatrix.getY(xw, yh);
      var x3 = calcMatrix.getX(xw, y);
      var y3 = calcMatrix.getY(xw, y);
      var tint = this.fillTint;
      this.batchQuad(x0, y0, x1, y1, x2, y2, x3, y3, tint.TL, tint.TR, tint.BL, tint.BR);
    },
    batchFillTriangle: function(x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix) {
      this.renderer.pipelines.set(this);
      var calcMatrix = this.calcMatrix;
      if (parentMatrix) {
        parentMatrix.multiply(currentMatrix, calcMatrix);
      }
      var tx0 = calcMatrix.getX(x0, y0);
      var ty0 = calcMatrix.getY(x0, y0);
      var tx1 = calcMatrix.getX(x1, y1);
      var ty1 = calcMatrix.getY(x1, y1);
      var tx2 = calcMatrix.getX(x2, y2);
      var ty2 = calcMatrix.getY(x2, y2);
      var tint = this.fillTint;
      this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, tint.TL, tint.TR, tint.BL);
    },
    batchStrokeTriangle: function(x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix) {
      var tempTriangle = this.tempTriangle;
      tempTriangle[0].x = x0;
      tempTriangle[0].y = y0;
      tempTriangle[0].width = lineWidth;
      tempTriangle[1].x = x1;
      tempTriangle[1].y = y1;
      tempTriangle[1].width = lineWidth;
      tempTriangle[2].x = x2;
      tempTriangle[2].y = y2;
      tempTriangle[2].width = lineWidth;
      tempTriangle[3].x = x0;
      tempTriangle[3].y = y0;
      tempTriangle[3].width = lineWidth;
      this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);
    },
    batchFillPath: function(path, currentMatrix, parentMatrix) {
      this.renderer.pipelines.set(this);
      var calcMatrix = this.calcMatrix;
      if (parentMatrix) {
        parentMatrix.multiply(currentMatrix, calcMatrix);
      }
      var length = path.length;
      var polygonCache = this.polygonCache;
      var polygonIndexArray;
      var point;
      var tintTL = this.fillTint.TL;
      var tintTR = this.fillTint.TR;
      var tintBL = this.fillTint.BL;
      for (var pathIndex = 0; pathIndex < length; ++pathIndex) {
        point = path[pathIndex];
        polygonCache.push(point.x, point.y);
      }
      polygonIndexArray = Earcut(polygonCache);
      length = polygonIndexArray.length;
      for (var index = 0; index < length; index += 3) {
        var p0 = polygonIndexArray[index + 0] * 2;
        var p1 = polygonIndexArray[index + 1] * 2;
        var p2 = polygonIndexArray[index + 2] * 2;
        var x0 = polygonCache[p0 + 0];
        var y0 = polygonCache[p0 + 1];
        var x1 = polygonCache[p1 + 0];
        var y1 = polygonCache[p1 + 1];
        var x2 = polygonCache[p2 + 0];
        var y2 = polygonCache[p2 + 1];
        var tx0 = calcMatrix.getX(x0, y0);
        var ty0 = calcMatrix.getY(x0, y0);
        var tx1 = calcMatrix.getX(x1, y1);
        var ty1 = calcMatrix.getY(x1, y1);
        var tx2 = calcMatrix.getX(x2, y2);
        var ty2 = calcMatrix.getY(x2, y2);
        this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, tintTL, tintTR, tintBL);
      }
      polygonCache.length = 0;
    },
    batchStrokePath: function(path, lineWidth, pathOpen, currentMatrix, parentMatrix) {
      this.renderer.pipelines.set(this);
      this.prevQuad[4] = 0;
      this.firstQuad[4] = 0;
      var pathLength = path.length - 1;
      for (var pathIndex = 0; pathIndex < pathLength; pathIndex++) {
        var point0 = path[pathIndex];
        var point1 = path[pathIndex + 1];
        this.batchLine(point0.x, point0.y, point1.x, point1.y, point0.width / 2, point1.width / 2, lineWidth, pathIndex, !pathOpen && pathIndex === pathLength - 1, currentMatrix, parentMatrix);
      }
    },
    batchLine: function(ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index, closePath, currentMatrix, parentMatrix) {
      this.renderer.pipelines.set(this);
      var calcMatrix = this.calcMatrix;
      if (parentMatrix) {
        parentMatrix.multiply(currentMatrix, calcMatrix);
      }
      var dx = bx - ax;
      var dy = by - ay;
      var len = Math.sqrt(dx * dx + dy * dy);
      var al0 = aLineWidth * (by - ay) / len;
      var al1 = aLineWidth * (ax - bx) / len;
      var bl0 = bLineWidth * (by - ay) / len;
      var bl1 = bLineWidth * (ax - bx) / len;
      var lx0 = bx - bl0;
      var ly0 = by - bl1;
      var lx1 = ax - al0;
      var ly1 = ay - al1;
      var lx2 = bx + bl0;
      var ly2 = by + bl1;
      var lx3 = ax + al0;
      var ly3 = ay + al1;
      var brX = calcMatrix.getX(lx0, ly0);
      var brY = calcMatrix.getY(lx0, ly0);
      var blX = calcMatrix.getX(lx1, ly1);
      var blY = calcMatrix.getY(lx1, ly1);
      var trX = calcMatrix.getX(lx2, ly2);
      var trY = calcMatrix.getY(lx2, ly2);
      var tlX = calcMatrix.getX(lx3, ly3);
      var tlY = calcMatrix.getY(lx3, ly3);
      var tint = this.strokeTint;
      var tintTL = tint.TL;
      var tintTR = tint.TR;
      var tintBL = tint.BL;
      var tintBR = tint.BR;
      this.batchQuad(tlX, tlY, blX, blY, brX, brY, trX, trY, tintTL, tintTR, tintBL, tintBR);
      if (lineWidth <= 2) {
        return;
      }
      var prev = this.prevQuad;
      var first = this.firstQuad;
      if (index > 0 && prev[4]) {
        this.batchQuad(tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], tintTL, tintTR, tintBL, tintBR);
      } else {
        first[0] = tlX;
        first[1] = tlY;
        first[2] = blX;
        first[3] = blY;
        first[4] = 1;
      }
      if (closePath && first[4]) {
        this.batchQuad(brX, brY, trX, trY, first[0], first[1], first[2], first[3], tintTL, tintTR, tintBL, tintBR);
      } else {
        prev[0] = brX;
        prev[1] = brY;
        prev[2] = trX;
        prev[3] = trY;
        prev[4] = 1;
      }
    },
    batchVert: function(x, y, tint) {
      var vertexViewF32 = this.vertexViewF32;
      var vertexViewU32 = this.vertexViewU32;
      var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
      vertexViewF32[++vertexOffset] = x;
      vertexViewF32[++vertexOffset] = y;
      vertexViewU32[++vertexOffset] = tint;
      this.vertexCount++;
    },
    batchQuad: function(x0, y0, x1, y1, x2, y2, x3, y3, tintTL, tintTR, tintBL, tintBR) {
      var hasFlushed = false;
      if (this.shouldFlush(6)) {
        this.flush();
        hasFlushed = true;
      }
      this.batchVert(x0, y0, tintTL);
      this.batchVert(x1, y1, tintBL);
      this.batchVert(x2, y2, tintBR);
      this.batchVert(x0, y0, tintTL);
      this.batchVert(x2, y2, tintBR);
      this.batchVert(x3, y3, tintTR);
      return hasFlushed;
    },
    batchTri: function(x0, y0, x1, y1, x2, y2, tintTL, tintTR, tintBL) {
      var hasFlushed = false;
      if (this.shouldFlush(3)) {
        this.flush();
        hasFlushed = true;
      }
      this.batchVert(x0, y0, tintTL);
      this.batchVert(x1, y1, tintTR);
      this.batchVert(x2, y2, tintBL);
      return hasFlushed;
    },
    destroy: function() {
      WebGLPipeline.prototype.destroy.call(this);
      this.polygonCache = null;
      return this;
    }
  });
  module2.exports = GraphicsPipeline;
});

// node_modules/phaser/src/renderer/webgl/shaders/Light-frag.js
var require_Light_frag = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_LIGHT_FS",
    "",
    "precision mediump float;",
    "",
    "struct Light",
    "{",
    "    vec2 position;",
    "    vec3 color;",
    "    float intensity;",
    "    float radius;",
    "};",
    "",
    "const int kMaxLights = %LIGHT_COUNT%;",
    "",
    "uniform vec4 uCamera; /* x, y, rotation, zoom */",
    "uniform vec2 uResolution;",
    "uniform sampler2D uMainSampler;",
    "uniform sampler2D uNormSampler;",
    "uniform vec3 uAmbientLightColor;",
    "uniform Light uLights[kMaxLights];",
    "uniform mat3 uInverseRotationMatrix;",
    "",
    "varying vec2 outTexCoord;",
    "varying vec4 outTint;",
    "",
    "void main()",
    "{",
    "    vec3 finalColor = vec3(0.0, 0.0, 0.0);",
    "    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.bgr * outTint.a, outTint.a);",
    "    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;",
    "    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));",
    "    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;",
    "",
    "    for (int index = 0; index < kMaxLights; ++index)",
    "    {",
    "        Light light = uLights[index];",
    "        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);",
    "        vec3 lightNormal = normalize(lightDir);",
    "        float distToSurf = length(lightDir) * uCamera.w;",
    "        float diffuseFactor = max(dot(normal, lightNormal), 0.0);",
    "        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;",
    "        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);",
    "        vec3 diffuse = light.color * diffuseFactor;",
    "        finalColor += (attenuation * diffuse) * light.intensity;",
    "    }",
    "",
    "    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);",
    "",
    "    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/shaders/Multi-frag.js
var require_Multi_frag = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_MULTI_FS",
    "",
    "precision mediump float;",
    "",
    "uniform sampler2D uMainSampler[%count%];",
    "",
    "varying vec2 outTexCoord;",
    "varying float outTexId;",
    "varying float outTintEffect;",
    "varying vec4 outTint;",
    "",
    "void main ()",
    "{",
    "    vec4 texture;",
    "",
    "    %forloop%",
    "",
    "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
    "",
    "    //  Multiply texture tint",
    "    vec4 color = texture * texel;",
    "",
    "    if (outTintEffect == 1.0)",
    "    {",
    "        //  Solid color + texture alpha",
    "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
    "    }",
    "    else if (outTintEffect == 2.0)",
    "    {",
    "        //  Solid color, no texture",
    "        color = texel;",
    "    }",
    "",
    "    gl_FragColor = color;",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/shaders/Multi-vert.js
var require_Multi_vert = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_MULTI_VS",
    "",
    "precision mediump float;",
    "",
    "uniform mat4 uProjectionMatrix;",
    "",
    "attribute vec2 inPosition;",
    "attribute vec2 inTexCoord;",
    "attribute float inTexId;",
    "attribute float inTintEffect;",
    "attribute vec4 inTint;",
    "",
    "varying vec2 outTexCoord;",
    "varying float outTexId;",
    "varying float outTintEffect;",
    "varying vec4 outTint;",
    "",
    "void main ()",
    "{",
    "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
    "",
    "    outTexCoord = inTexCoord;",
    "    outTexId = inTexId;",
    "    outTint = inTint;",
    "    outTintEffect = inTintEffect;",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/pipelines/MultiPipeline.js
var require_MultiPipeline = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Earcut = require_Earcut();
  var GetFastValue = require_GetFastValue();
  var ShaderSourceFS = require_Multi_frag();
  var ShaderSourceVS = require_Multi_vert();
  var TransformMatrix = require_TransformMatrix();
  var Utils = require_Utils();
  var WEBGL_CONST = require_const7();
  var WebGLPipeline = require_WebGLPipeline();
  var MultiPipeline = new Class({
    Extends: WebGLPipeline,
    initialize: function MultiPipeline2(config2) {
      var renderer = config2.game.renderer;
      var fragmentShaderSource = GetFastValue(config2, "fragShader", ShaderSourceFS);
      config2.fragShader = Utils.parseFragmentShaderMaxTextures(fragmentShaderSource, renderer.maxTextures);
      config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS);
      config2.attributes = GetFastValue(config2, "attributes", [
        {
          name: "inPosition",
          size: 2
        },
        {
          name: "inTexCoord",
          size: 2
        },
        {
          name: "inTexId"
        },
        {
          name: "inTintEffect"
        },
        {
          name: "inTint",
          size: 4,
          type: WEBGL_CONST.UNSIGNED_BYTE,
          normalized: true
        }
      ]);
      WebGLPipeline.call(this, config2);
      this._tempMatrix1 = new TransformMatrix();
      this._tempMatrix2 = new TransformMatrix();
      this._tempMatrix3 = new TransformMatrix();
      this.calcMatrix = new TransformMatrix();
      this.tempTriangle = [
        {x: 0, y: 0, width: 0},
        {x: 0, y: 0, width: 0},
        {x: 0, y: 0, width: 0},
        {x: 0, y: 0, width: 0}
      ];
      this.strokeTint = {TL: 0, TR: 0, BL: 0, BR: 0};
      this.fillTint = {TL: 0, TR: 0, BL: 0, BR: 0};
      this.currentFrame = {u0: 0, v0: 0, u1: 1, v1: 1};
      this.firstQuad = [0, 0, 0, 0, 0];
      this.prevQuad = [0, 0, 0, 0, 0];
      this.polygonCache = [];
    },
    boot: function() {
      WebGLPipeline.prototype.boot.call(this);
      this.currentShader.set1iv("uMainSampler", this.renderer.textureIndexes);
    },
    batchSprite: function(gameObject, camera, parentTransformMatrix) {
      this.manager.set(this, gameObject);
      var camMatrix = this._tempMatrix1;
      var spriteMatrix = this._tempMatrix2;
      var calcMatrix = this._tempMatrix3;
      var frame = gameObject.frame;
      var texture = frame.glTexture;
      var u0 = frame.u0;
      var v0 = frame.v0;
      var u1 = frame.u1;
      var v1 = frame.v1;
      var frameX = frame.x;
      var frameY = frame.y;
      var frameWidth = frame.cutWidth;
      var frameHeight = frame.cutHeight;
      var customPivot = frame.customPivot;
      var displayOriginX = gameObject.displayOriginX;
      var displayOriginY = gameObject.displayOriginY;
      var x = -displayOriginX + frameX;
      var y = -displayOriginY + frameY;
      if (gameObject.isCropped) {
        var crop = gameObject._crop;
        if (crop.flipX !== gameObject.flipX || crop.flipY !== gameObject.flipY) {
          frame.updateCropUVs(crop, gameObject.flipX, gameObject.flipY);
        }
        u0 = crop.u0;
        v0 = crop.v0;
        u1 = crop.u1;
        v1 = crop.v1;
        frameWidth = crop.width;
        frameHeight = crop.height;
        frameX = crop.x;
        frameY = crop.y;
        x = -displayOriginX + frameX;
        y = -displayOriginY + frameY;
      }
      var flipX = 1;
      var flipY = 1;
      if (gameObject.flipX) {
        if (!customPivot) {
          x += -frame.realWidth + displayOriginX * 2;
        }
        flipX = -1;
      }
      if (gameObject.flipY || frame.source.isGLTexture && !texture.flipY) {
        if (!customPivot) {
          y += -frame.realHeight + displayOriginY * 2;
        }
        flipY = -1;
      }
      spriteMatrix.applyITRS(gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX * flipX, gameObject.scaleY * flipY);
      camMatrix.copyFrom(camera.matrix);
      if (parentTransformMatrix) {
        camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * gameObject.scrollFactorX, -camera.scrollY * gameObject.scrollFactorY);
        spriteMatrix.e = gameObject.x;
        spriteMatrix.f = gameObject.y;
      } else {
        spriteMatrix.e -= camera.scrollX * gameObject.scrollFactorX;
        spriteMatrix.f -= camera.scrollY * gameObject.scrollFactorY;
      }
      camMatrix.multiply(spriteMatrix, calcMatrix);
      var xw = x + frameWidth;
      var yh = y + frameHeight;
      var roundPixels = camera.roundPixels;
      var tx0 = calcMatrix.getXRound(x, y, roundPixels);
      var ty0 = calcMatrix.getYRound(x, y, roundPixels);
      var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
      var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
      var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
      var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
      var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
      var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
      var getTint = Utils.getTintAppendFloatAlpha;
      var cameraAlpha = camera.alpha;
      var tintTL = getTint(gameObject.tintTopLeft, cameraAlpha * gameObject._alphaTL);
      var tintTR = getTint(gameObject.tintTopRight, cameraAlpha * gameObject._alphaTR);
      var tintBL = getTint(gameObject.tintBottomLeft, cameraAlpha * gameObject._alphaBL);
      var tintBR = getTint(gameObject.tintBottomRight, cameraAlpha * gameObject._alphaBR);
      if (this.shouldFlush(6)) {
        this.flush();
      }
      var unit = this.setGameObject(gameObject, frame);
      this.manager.preBatch(gameObject);
      this.batchQuad(gameObject, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, gameObject.tintFill, texture, unit);
      this.manager.postBatch(gameObject);
    },
    batchTexture: function(gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit) {
      this.manager.set(this, gameObject);
      var camMatrix = this._tempMatrix1;
      var spriteMatrix = this._tempMatrix2;
      var calcMatrix = this._tempMatrix3;
      var u0 = frameX / textureWidth + uOffset;
      var v0 = frameY / textureHeight + vOffset;
      var u1 = (frameX + frameWidth) / textureWidth + uOffset;
      var v1 = (frameY + frameHeight) / textureHeight + vOffset;
      var width = srcWidth;
      var height = srcHeight;
      var x = -displayOriginX;
      var y = -displayOriginY;
      if (gameObject.isCropped) {
        var crop = gameObject._crop;
        var cropWidth = crop.width;
        var cropHeight = crop.height;
        width = cropWidth;
        height = cropHeight;
        srcWidth = cropWidth;
        srcHeight = cropHeight;
        frameX = crop.x;
        frameY = crop.y;
        var ox = frameX;
        var oy = frameY;
        if (flipX) {
          ox = frameWidth - crop.x - cropWidth;
        }
        if (flipY) {
          oy = frameHeight - crop.y - cropHeight;
        }
        u0 = ox / textureWidth + uOffset;
        v0 = oy / textureHeight + vOffset;
        u1 = (ox + cropWidth) / textureWidth + uOffset;
        v1 = (oy + cropHeight) / textureHeight + vOffset;
        x = -displayOriginX + frameX;
        y = -displayOriginY + frameY;
      }
      flipY = flipY ^ (!skipFlip && texture.isRenderTexture ? 1 : 0);
      if (flipX) {
        width *= -1;
        x += srcWidth;
      }
      if (flipY) {
        height *= -1;
        y += srcHeight;
      }
      var xw = x + width;
      var yh = y + height;
      spriteMatrix.applyITRS(srcX, srcY, rotation, scaleX, scaleY);
      camMatrix.copyFrom(camera.matrix);
      if (parentTransformMatrix) {
        camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
        spriteMatrix.e = srcX;
        spriteMatrix.f = srcY;
      } else {
        spriteMatrix.e -= camera.scrollX * scrollFactorX;
        spriteMatrix.f -= camera.scrollY * scrollFactorY;
      }
      camMatrix.multiply(spriteMatrix, calcMatrix);
      var roundPixels = camera.roundPixels;
      var tx0 = calcMatrix.getXRound(x, y, roundPixels);
      var ty0 = calcMatrix.getYRound(x, y, roundPixels);
      var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
      var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
      var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
      var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
      var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
      var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
      if (textureUnit === void 0) {
        textureUnit = this.renderer.setTexture2D(texture);
      }
      if (gameObject) {
        this.manager.preBatch(gameObject);
      }
      this.batchQuad(gameObject, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
      if (gameObject) {
        this.manager.postBatch(gameObject);
      }
    },
    batchTextureFrame: function(frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix) {
      this.manager.set(this);
      var spriteMatrix = this._tempMatrix1.copyFrom(transformMatrix);
      var calcMatrix = this._tempMatrix2;
      var xw = x + frame.width;
      var yh = y + frame.height;
      if (parentTransformMatrix) {
        spriteMatrix.multiply(parentTransformMatrix, calcMatrix);
      } else {
        calcMatrix = spriteMatrix;
      }
      var tx0 = calcMatrix.getX(x, y);
      var ty0 = calcMatrix.getY(x, y);
      var tx1 = calcMatrix.getX(x, yh);
      var ty1 = calcMatrix.getY(x, yh);
      var tx2 = calcMatrix.getX(xw, yh);
      var ty2 = calcMatrix.getY(xw, yh);
      var tx3 = calcMatrix.getX(xw, y);
      var ty3 = calcMatrix.getY(xw, y);
      var unit = this.renderer.setTextureSource(frame.source);
      tint = Utils.getTintAppendFloatAlpha(tint, alpha);
      this.batchQuad(null, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, 0, frame.glTexture, unit);
    },
    batchFillRect: function(x, y, width, height, currentMatrix, parentMatrix) {
      this.renderer.pipelines.set(this);
      var calcMatrix = this.calcMatrix;
      if (parentMatrix) {
        parentMatrix.multiply(currentMatrix, calcMatrix);
      }
      var xw = x + width;
      var yh = y + height;
      var x0 = calcMatrix.getX(x, y);
      var y0 = calcMatrix.getY(x, y);
      var x1 = calcMatrix.getX(x, yh);
      var y1 = calcMatrix.getY(x, yh);
      var x2 = calcMatrix.getX(xw, yh);
      var y2 = calcMatrix.getY(xw, yh);
      var x3 = calcMatrix.getX(xw, y);
      var y3 = calcMatrix.getY(xw, y);
      var tint = this.fillTint;
      this.batchQuad(null, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, tint.BR, 2);
    },
    batchFillTriangle: function(x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix) {
      this.renderer.pipelines.set(this);
      var calcMatrix = this.calcMatrix;
      if (parentMatrix) {
        parentMatrix.multiply(currentMatrix, calcMatrix);
      }
      var tx0 = calcMatrix.getX(x0, y0);
      var ty0 = calcMatrix.getY(x0, y0);
      var tx1 = calcMatrix.getX(x1, y1);
      var ty1 = calcMatrix.getY(x1, y1);
      var tx2 = calcMatrix.getX(x2, y2);
      var ty2 = calcMatrix.getY(x2, y2);
      var tint = this.fillTint;
      this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, 2);
    },
    batchStrokeTriangle: function(x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix) {
      var tempTriangle = this.tempTriangle;
      tempTriangle[0].x = x0;
      tempTriangle[0].y = y0;
      tempTriangle[0].width = lineWidth;
      tempTriangle[1].x = x1;
      tempTriangle[1].y = y1;
      tempTriangle[1].width = lineWidth;
      tempTriangle[2].x = x2;
      tempTriangle[2].y = y2;
      tempTriangle[2].width = lineWidth;
      tempTriangle[3].x = x0;
      tempTriangle[3].y = y0;
      tempTriangle[3].width = lineWidth;
      this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);
    },
    batchFillPath: function(path, currentMatrix, parentMatrix) {
      this.renderer.pipelines.set(this);
      var calcMatrix = this.calcMatrix;
      if (parentMatrix) {
        parentMatrix.multiply(currentMatrix, calcMatrix);
      }
      var length = path.length;
      var polygonCache = this.polygonCache;
      var polygonIndexArray;
      var point;
      var tintTL = this.fillTint.TL;
      var tintTR = this.fillTint.TR;
      var tintBL = this.fillTint.BL;
      for (var pathIndex = 0; pathIndex < length; ++pathIndex) {
        point = path[pathIndex];
        polygonCache.push(point.x, point.y);
      }
      polygonIndexArray = Earcut(polygonCache);
      length = polygonIndexArray.length;
      for (var index = 0; index < length; index += 3) {
        var p0 = polygonIndexArray[index + 0] * 2;
        var p1 = polygonIndexArray[index + 1] * 2;
        var p2 = polygonIndexArray[index + 2] * 2;
        var x0 = polygonCache[p0 + 0];
        var y0 = polygonCache[p0 + 1];
        var x1 = polygonCache[p1 + 0];
        var y1 = polygonCache[p1 + 1];
        var x2 = polygonCache[p2 + 0];
        var y2 = polygonCache[p2 + 1];
        var tx0 = calcMatrix.getX(x0, y0);
        var ty0 = calcMatrix.getY(x0, y0);
        var tx1 = calcMatrix.getX(x1, y1);
        var ty1 = calcMatrix.getY(x1, y1);
        var tx2 = calcMatrix.getX(x2, y2);
        var ty2 = calcMatrix.getY(x2, y2);
        this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tintTL, tintTR, tintBL, 2);
      }
      polygonCache.length = 0;
    },
    batchStrokePath: function(path, lineWidth, pathOpen, currentMatrix, parentMatrix) {
      this.renderer.pipelines.set(this);
      this.prevQuad[4] = 0;
      this.firstQuad[4] = 0;
      var pathLength = path.length - 1;
      for (var pathIndex = 0; pathIndex < pathLength; pathIndex++) {
        var point0 = path[pathIndex];
        var point1 = path[pathIndex + 1];
        this.batchLine(point0.x, point0.y, point1.x, point1.y, point0.width / 2, point1.width / 2, lineWidth, pathIndex, !pathOpen && pathIndex === pathLength - 1, currentMatrix, parentMatrix);
      }
    },
    batchLine: function(ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index, closePath, currentMatrix, parentMatrix) {
      this.renderer.pipelines.set(this);
      var calcMatrix = this.calcMatrix;
      if (parentMatrix) {
        parentMatrix.multiply(currentMatrix, calcMatrix);
      }
      var dx = bx - ax;
      var dy = by - ay;
      var len = Math.sqrt(dx * dx + dy * dy);
      var al0 = aLineWidth * (by - ay) / len;
      var al1 = aLineWidth * (ax - bx) / len;
      var bl0 = bLineWidth * (by - ay) / len;
      var bl1 = bLineWidth * (ax - bx) / len;
      var lx0 = bx - bl0;
      var ly0 = by - bl1;
      var lx1 = ax - al0;
      var ly1 = ay - al1;
      var lx2 = bx + bl0;
      var ly2 = by + bl1;
      var lx3 = ax + al0;
      var ly3 = ay + al1;
      var brX = calcMatrix.getX(lx0, ly0);
      var brY = calcMatrix.getY(lx0, ly0);
      var blX = calcMatrix.getX(lx1, ly1);
      var blY = calcMatrix.getY(lx1, ly1);
      var trX = calcMatrix.getX(lx2, ly2);
      var trY = calcMatrix.getY(lx2, ly2);
      var tlX = calcMatrix.getX(lx3, ly3);
      var tlY = calcMatrix.getY(lx3, ly3);
      var tint = this.strokeTint;
      var tintTL = tint.TL;
      var tintTR = tint.TR;
      var tintBL = tint.BL;
      var tintBR = tint.BR;
      this.batchQuad(null, tlX, tlY, blX, blY, brX, brY, trX, trY, 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
      if (lineWidth <= 2) {
        return;
      }
      var prev = this.prevQuad;
      var first = this.firstQuad;
      if (index > 0 && prev[4]) {
        this.batchQuad(null, tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
      } else {
        first[0] = tlX;
        first[1] = tlY;
        first[2] = blX;
        first[3] = blY;
        first[4] = 1;
      }
      if (closePath && first[4]) {
        this.batchQuad(null, brX, brY, trX, trY, first[0], first[1], first[2], first[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);
      } else {
        prev[0] = brX;
        prev[1] = brY;
        prev[2] = trX;
        prev[3] = trY;
        prev[4] = 1;
      }
    }
  });
  module2.exports = MultiPipeline;
});

// node_modules/phaser/src/renderer/webgl/pipelines/LightPipeline.js
var require_LightPipeline = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetFastValue = require_GetFastValue();
  var LightShaderSourceFS = require_Light_frag();
  var MultiPipeline = require_MultiPipeline();
  var Vec2 = require_Vector2();
  var WebGLPipeline = require_WebGLPipeline();
  var LIGHT_COUNT = 10;
  var tempVec2 = new Vec2();
  var LightPipeline = new Class({
    Extends: MultiPipeline,
    initialize: function LightPipeline2(config2) {
      LIGHT_COUNT = config2.game.renderer.config.maxLights;
      var fragShader = GetFastValue(config2, "fragShader", LightShaderSourceFS);
      var shaders = [];
      for (var i = 1; i <= LIGHT_COUNT; i++) {
        shaders.push({
          name: "lights" + i,
          fragShader: fragShader.replace("%LIGHT_COUNT%", i.toString())
        });
      }
      config2.shaders = shaders;
      MultiPipeline.call(this, config2);
      this.inverseRotationMatrix = new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
      this.defaultNormalMap;
      this.lightsActive = true;
    },
    boot: function() {
      WebGLPipeline.prototype.boot.call(this);
      var gl = this.gl;
      var tempTexture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, tempTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([127, 127, 255, 255]));
      this.defaultNormalMap = {glTexture: tempTexture};
      for (var i = 0; i < this.shaders.length; i++) {
        this["lightShader" + (i + 1)] = this.shaders[i];
      }
    },
    onRender: function(scene, camera) {
      var lightManager = scene.sys.lights;
      this.lightsActive = false;
      if (!lightManager || !lightManager.active) {
        return;
      }
      var lights = lightManager.getLights(camera);
      var lightsCount = lights.length;
      if (lightsCount === 0) {
        return;
      }
      this.lightsActive = true;
      this.setShader(this["lightShader" + lightsCount], true);
      var i;
      var renderer = this.renderer;
      var height = renderer.height;
      var cameraMatrix = camera.matrix;
      this.set1i("uMainSampler", 0);
      this.set1i("uNormSampler", 1);
      this.set2f("uResolution", this.width / 2, this.height / 2);
      this.set4f("uCamera", camera.x, camera.y, camera.rotation, camera.zoom);
      this.set3f("uAmbientLightColor", lightManager.ambientColor.r, lightManager.ambientColor.g, lightManager.ambientColor.b);
      for (i = 0; i < lightsCount; i++) {
        var light = lights[i].light;
        var color = light.color;
        var lightName = "uLights[" + i + "].";
        cameraMatrix.transformPoint(light.x, light.y, tempVec2);
        this.set2f(lightName + "position", tempVec2.x - camera.scrollX * light.scrollFactorX * camera.zoom, height - (tempVec2.y - camera.scrollY * light.scrollFactorY * camera.zoom));
        this.set3f(lightName + "color", color.r, color.g, color.b);
        this.set1f(lightName + "intensity", light.intensity);
        this.set1f(lightName + "radius", light.radius);
      }
      this.currentNormalMapRotation = null;
    },
    setNormalMapRotation: function(rotation) {
      if (rotation !== this.currentNormalMapRotation || this.vertexCount === 0) {
        if (this.vertexCount > 0) {
          this.flush();
        }
        var inverseRotationMatrix = this.inverseRotationMatrix;
        if (rotation) {
          var rot = -rotation;
          var c = Math.cos(rot);
          var s = Math.sin(rot);
          inverseRotationMatrix[1] = s;
          inverseRotationMatrix[3] = -s;
          inverseRotationMatrix[0] = inverseRotationMatrix[4] = c;
        } else {
          inverseRotationMatrix[0] = inverseRotationMatrix[4] = 1;
          inverseRotationMatrix[1] = inverseRotationMatrix[3] = 0;
        }
        this.setMatrix3fv("uInverseRotationMatrix", false, inverseRotationMatrix);
        this.currentNormalMapRotation = rotation;
      }
    },
    setTexture2D: function(texture, gameObject) {
      var renderer = this.renderer;
      if (texture === void 0) {
        texture = renderer.tempTextures[0];
      }
      var normalTexture = this.getNormalMap(gameObject);
      if (renderer.isNewNormalMap(texture, normalTexture)) {
        this.flush();
        renderer.setTextureZero(texture);
        renderer.setNormalMap(normalTexture);
      }
      var rotation = gameObject ? gameObject.rotation : 0;
      this.setNormalMapRotation(rotation);
      this.currentUnit = 0;
      return 0;
    },
    setGameObject: function(gameObject, frame) {
      if (frame === void 0) {
        frame = gameObject.frame;
      }
      var renderer = this.renderer;
      var texture = frame.glTexture;
      var normalTexture = this.getNormalMap(gameObject);
      if (renderer.isNewNormalMap()) {
        this.flush();
        renderer.setTextureZero(texture);
        renderer.setNormalMap(normalTexture);
      }
      this.setNormalMapRotation(gameObject.rotation);
      this.currentUnit = 0;
      return 0;
    },
    getNormalMap: function(gameObject) {
      var normalTexture;
      if (!gameObject) {
        normalTexture = this.defaultNormalMap;
      } else if (gameObject.displayTexture) {
        normalTexture = gameObject.displayTexture.dataSource[gameObject.displayFrame.sourceIndex];
      } else if (gameObject.texture) {
        normalTexture = gameObject.texture.dataSource[gameObject.frame.sourceIndex];
      } else if (gameObject.tileset) {
        if (Array.isArray(gameObject.tileset)) {
          normalTexture = gameObject.tileset[0].image.dataSource[0];
        } else {
          normalTexture = gameObject.tileset.image.dataSource[0];
        }
      }
      if (!normalTexture) {
        normalTexture = this.defaultNormalMap;
      }
      return normalTexture.glTexture;
    },
    batchSprite: function(gameObject, camera, parentTransformMatrix) {
      if (this.lightsActive) {
        MultiPipeline.prototype.batchSprite.call(this, gameObject, camera, parentTransformMatrix);
      }
    },
    batchTexture: function(gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit) {
      if (this.lightsActive) {
        MultiPipeline.prototype.batchTexture.call(this, gameObject, texture, textureWidth, textureHeight, srcX, srcY, srcWidth, srcHeight, scaleX, scaleY, rotation, flipX, flipY, scrollFactorX, scrollFactorY, displayOriginX, displayOriginY, frameX, frameY, frameWidth, frameHeight, tintTL, tintTR, tintBL, tintBR, tintEffect, uOffset, vOffset, camera, parentTransformMatrix, skipFlip, textureUnit);
      }
    },
    batchTextureFrame: function(frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix) {
      if (this.lightsActive) {
        MultiPipeline.prototype.batchTextureFrame.call(this, frame, x, y, tint, alpha, transformMatrix, parentTransformMatrix);
      }
    }
  });
  LightPipeline.LIGHT_COUNT = LIGHT_COUNT;
  module2.exports = LightPipeline;
});

// node_modules/phaser/src/renderer/webgl/shaders/PointLight-frag.js
var require_PointLight_frag = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_POINTLIGHT_FS",
    "",
    "precision mediump float;",
    "",
    "uniform vec2 uResolution;",
    "uniform float uCameraZoom;",
    "",
    "varying vec4 lightPosition;",
    "varying vec4 lightColor;",
    "varying float lightRadius;",
    "varying float lightAttenuation;",
    "",
    "void main ()",
    "{",
    "    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);",
    "",
    "    float distToSurf = length(center - gl_FragCoord.xy);",
    "",
    "    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);",
    "",
    "    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);",
    "",
    "    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;",
    "",
    "    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/shaders/PointLight-vert.js
var require_PointLight_vert = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_POINTLIGHT_VS",
    "",
    "precision mediump float;",
    "",
    "uniform mat4 uProjectionMatrix;",
    "",
    "attribute vec2 inPosition;",
    "attribute vec2 inLightPosition;",
    "attribute vec4 inLightColor;",
    "attribute float inLightRadius;",
    "attribute float inLightAttenuation;",
    "",
    "varying vec4 lightPosition;",
    "varying vec4 lightColor;",
    "varying float lightRadius;",
    "varying float lightAttenuation;",
    "",
    "void main ()",
    "{",
    "    lightColor = inLightColor;",
    "    lightRadius = inLightRadius;",
    "    lightAttenuation = inLightAttenuation;",
    "    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);",
    "",
    "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/pipelines/PointLightPipeline.js
var require_PointLightPipeline = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetFastValue = require_GetFastValue();
  var PointLightShaderSourceFS = require_PointLight_frag();
  var PointLightShaderSourceVS = require_PointLight_vert();
  var WebGLPipeline = require_WebGLPipeline();
  var PointLightPipeline = new Class({
    Extends: WebGLPipeline,
    initialize: function PointLightPipeline2(config2) {
      config2.vertShader = GetFastValue(config2, "vertShader", PointLightShaderSourceVS);
      config2.fragShader = GetFastValue(config2, "fragShader", PointLightShaderSourceFS);
      config2.attributes = GetFastValue(config2, "attributes", [
        {
          name: "inPosition",
          size: 2
        },
        {
          name: "inLightPosition",
          size: 2
        },
        {
          name: "inLightRadius"
        },
        {
          name: "inLightAttenuation"
        },
        {
          name: "inLightColor",
          size: 4
        }
      ]);
      WebGLPipeline.call(this, config2);
    },
    onRender: function(scene, camera) {
      this.set2f("uResolution", this.width, this.height);
      this.set1f("uCameraZoom", camera.zoom);
    },
    batchPointLight: function(light, camera, x0, y0, x1, y1, x2, y2, x3, y3, lightX, lightY) {
      var color = light.color;
      var intensity = light.intensity;
      var radius = light.radius;
      var attenuation = light.attenuation;
      var r = color.r * intensity;
      var g = color.g * intensity;
      var b = color.b * intensity;
      var a = camera.alpha * light.alpha;
      if (this.shouldFlush(6)) {
        this.flush();
      }
      this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);
      this.batchLightVert(x1, y1, lightX, lightY, radius, attenuation, r, g, b, a);
      this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);
      this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);
      this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);
      this.batchLightVert(x3, y3, lightX, lightY, radius, attenuation, r, g, b, a);
    },
    batchLightVert: function(x, y, lightX, lightY, radius, attenuation, r, g, b, a) {
      var vertexViewF32 = this.vertexViewF32;
      var vertexOffset = this.vertexCount * this.currentShader.vertexComponentCount - 1;
      vertexViewF32[++vertexOffset] = x;
      vertexViewF32[++vertexOffset] = y;
      vertexViewF32[++vertexOffset] = lightX;
      vertexViewF32[++vertexOffset] = lightY;
      vertexViewF32[++vertexOffset] = radius;
      vertexViewF32[++vertexOffset] = attenuation;
      vertexViewF32[++vertexOffset] = r;
      vertexViewF32[++vertexOffset] = g;
      vertexViewF32[++vertexOffset] = b;
      vertexViewF32[++vertexOffset] = a;
      this.vertexCount++;
    }
  });
  module2.exports = PointLightPipeline;
});

// node_modules/phaser/src/renderer/webgl/pipelines/RopePipeline.js
var require_RopePipeline = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetFastValue = require_GetFastValue();
  var MultiPipeline = require_MultiPipeline();
  var RopePipeline = new Class({
    Extends: MultiPipeline,
    initialize: function RopePipeline2(config2) {
      config2.topology = 5;
      config2.batchSize = GetFastValue(config2, "batchSize", 256);
      MultiPipeline.call(this, config2);
    }
  });
  module2.exports = RopePipeline;
});

// node_modules/phaser/src/renderer/webgl/shaders/Single-frag.js
var require_Single_frag = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_SINGLE_FS",
    "",
    "precision mediump float;",
    "",
    "uniform sampler2D uMainSampler;",
    "",
    "varying vec2 outTexCoord;",
    "varying float outTintEffect;",
    "varying vec4 outTint;",
    "",
    "void main ()",
    "{",
    "    vec4 texture = texture2D(uMainSampler, outTexCoord);",
    "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);",
    "",
    "    //  Multiply texture tint",
    "    vec4 color = texture * texel;",
    "",
    "    if (outTintEffect == 1.0)",
    "    {",
    "        //  Solid color + texture alpha",
    "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);",
    "    }",
    "    else if (outTintEffect == 2.0)",
    "    {",
    "        //  Solid color, no texture",
    "        color = texel;",
    "    }",
    "",
    "    gl_FragColor = color;",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/shaders/Single-vert.js
var require_Single_vert = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_SINGLE_VS",
    "",
    "precision mediump float;",
    "",
    "uniform mat4 uProjectionMatrix;",
    "",
    "attribute vec2 inPosition;",
    "attribute vec2 inTexCoord;",
    "attribute float inTexId;",
    "attribute float inTintEffect;",
    "attribute vec4 inTint;",
    "",
    "varying vec2 outTexCoord;",
    "varying float outTintEffect;",
    "varying vec4 outTint;",
    "",
    "void main ()",
    "{",
    "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);",
    "",
    "    outTexCoord = inTexCoord;",
    "    outTint = inTint;",
    "    outTintEffect = inTintEffect;",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/pipelines/SinglePipeline.js
var require_SinglePipeline = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetFastValue = require_GetFastValue();
  var MultiPipeline = require_MultiPipeline();
  var ShaderSourceFS = require_Single_frag();
  var ShaderSourceVS = require_Single_vert();
  var WebGLPipeline = require_WebGLPipeline();
  var SinglePipeline = new Class({
    Extends: MultiPipeline,
    initialize: function SinglePipeline2(config2) {
      config2.fragShader = GetFastValue(config2, "fragShader", ShaderSourceFS), config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS), config2.forceZero = true;
      MultiPipeline.call(this, config2);
    },
    boot: function() {
      WebGLPipeline.prototype.boot.call(this);
      this.set1i("uMainSampler", 0);
    }
  });
  module2.exports = SinglePipeline;
});

// node_modules/phaser/src/renderer/webgl/shaders/AddBlend-frag.js
var require_AddBlend_frag = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_ADD_BLEND_FS",
    "",
    "precision mediump float;",
    "",
    "uniform sampler2D uMainSampler1;",
    "uniform sampler2D uMainSampler2;",
    "uniform float uStrength;",
    "",
    "varying vec2 outTexCoord;",
    "",
    "void main ()",
    "{",
    "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);",
    "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);",
    "",
    "    gl_FragColor = frame1 + frame2 * uStrength;",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/display/ColorMatrix.js
var require_ColorMatrix = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var ColorMatrix = new Class({
    initialize: function ColorMatrix2() {
      this._matrix = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this.alpha = 1;
      this._dirty = true;
      this._data;
    },
    set: function(value) {
      this._matrix = value;
      this._dirty = true;
      return this;
    },
    reset: function() {
      var m = this._matrix;
      m[0] = 1;
      m[1] = 0;
      m[2] = 0;
      m[3] = 0;
      m[4] = 0;
      m[5] = 0;
      m[6] = 1;
      m[7] = 0;
      m[8] = 0;
      m[9] = 0;
      m[10] = 0;
      m[11] = 0;
      m[12] = 1;
      m[13] = 0;
      m[14] = 0;
      m[15] = 0;
      m[16] = 0;
      m[17] = 0;
      m[18] = 1;
      m[19] = 0;
      this._dirty = true;
      return this;
    },
    getData: function() {
      if (this._dirty) {
        var f32 = new Float32Array(this._matrix);
        f32[4] /= 255;
        f32[9] /= 255;
        f32[14] /= 255;
        f32[19] /= 255;
        this._data = f32;
        this._dirty = false;
      }
      return this._data;
    },
    brightness: function(value, multiply) {
      if (value === void 0) {
        value = 0;
      }
      if (multiply === void 0) {
        multiply = false;
      }
      var b = value;
      return this.multiply([
        b,
        0,
        0,
        0,
        0,
        0,
        b,
        0,
        0,
        0,
        0,
        0,
        b,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    saturate: function(value, multiply) {
      if (value === void 0) {
        value = 0;
      }
      if (multiply === void 0) {
        multiply = false;
      }
      var x = value * 2 / 3 + 1;
      var y = (x - 1) * -0.5;
      return this.multiply([
        x,
        y,
        y,
        0,
        0,
        y,
        x,
        y,
        0,
        0,
        y,
        y,
        x,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    desaturate: function(multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      return this.saturate(-1, multiply);
    },
    hue: function(rotation, multiply) {
      if (rotation === void 0) {
        rotation = 0;
      }
      if (multiply === void 0) {
        multiply = false;
      }
      rotation = rotation / 180 * Math.PI;
      var cos = Math.cos(rotation);
      var sin = Math.sin(rotation);
      var lumR = 0.213;
      var lumG = 0.715;
      var lumB = 0.072;
      return this.multiply([
        lumR + cos * (1 - lumR) + sin * -lumR,
        lumG + cos * -lumG + sin * -lumG,
        lumB + cos * -lumB + sin * (1 - lumB),
        0,
        0,
        lumR + cos * -lumR + sin * 0.143,
        lumG + cos * (1 - lumG) + sin * 0.14,
        lumB + cos * -lumB + sin * -0.283,
        0,
        0,
        lumR + cos * -lumR + sin * -(1 - lumR),
        lumG + cos * -lumG + sin * lumG,
        lumB + cos * (1 - lumB) + sin * lumB,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    grayscale: function(value, multiply) {
      if (value === void 0) {
        value = 1;
      }
      if (multiply === void 0) {
        multiply = false;
      }
      return this.saturate(-value, multiply);
    },
    blackWhite: function(multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      return this.multiply([
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    contrast: function(value, multiply) {
      if (value === void 0) {
        value = 0;
      }
      if (multiply === void 0) {
        multiply = false;
      }
      var v = value + 1;
      var o = -0.5 * (v - 1);
      return this.multiply([
        v,
        0,
        0,
        0,
        o,
        0,
        v,
        0,
        0,
        o,
        0,
        0,
        v,
        0,
        o,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    negative: function(multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      return this.multiply([
        -1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        -1,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    desaturateLuminance: function(multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      return this.multiply([
        0.2764723,
        0.929708,
        0.0938197,
        0,
        -37.1,
        0.2764723,
        0.929708,
        0.0938197,
        0,
        -37.1,
        0.2764723,
        0.929708,
        0.0938197,
        0,
        -37.1,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    sepia: function(multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      return this.multiply([
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    night: function(intensity, multiply) {
      if (intensity === void 0) {
        intensity = 0.1;
      }
      if (multiply === void 0) {
        multiply = false;
      }
      return this.multiply([
        intensity * -2,
        -intensity,
        0,
        0,
        0,
        -intensity,
        0,
        intensity,
        0,
        0,
        0,
        intensity,
        intensity * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    lsd: function(multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      return this.multiply([
        2,
        -0.4,
        0.5,
        0,
        0,
        -0.5,
        2,
        -0.4,
        0,
        0,
        -0.4,
        -0.5,
        3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    brown: function(multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      return this.multiply([
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    vintagePinhole: function(multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      return this.multiply([
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    kodachrome: function(multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      return this.multiply([
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    technicolor: function(multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      return this.multiply([
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    polaroid: function(multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      return this.multiply([
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    shiftToBGR: function(multiply) {
      if (multiply === void 0) {
        multiply = false;
      }
      return this.multiply([
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ], multiply);
    },
    multiply: function(a, multiply) {
      if (!multiply) {
        this.reset();
      }
      var m = this._matrix;
      var c = [];
      for (var i = 0; i < 20; i++) {
        c[i] = m[i];
      }
      m[0] = c[0] * a[0] + c[1] * a[5] + c[2] * a[10] + c[3] * a[15];
      m[1] = c[0] * a[1] + c[1] * a[6] + c[2] * a[11] + c[3] * a[16];
      m[2] = c[0] * a[2] + c[1] * a[7] + c[2] * a[12] + c[3] * a[17];
      m[3] = c[0] * a[3] + c[1] * a[8] + c[2] * a[13] + c[3] * a[18];
      m[4] = c[0] * a[4] + c[1] * a[9] + c[2] * a[14] + c[3] * a[19] + c[4];
      m[5] = c[5] * a[0] + c[6] * a[5] + c[7] * a[10] + c[8] * a[15];
      m[6] = c[5] * a[1] + c[6] * a[6] + c[7] * a[11] + c[8] * a[16];
      m[7] = c[5] * a[2] + c[6] * a[7] + c[7] * a[12] + c[8] * a[17];
      m[8] = c[5] * a[3] + c[6] * a[8] + c[7] * a[13] + c[8] * a[18];
      m[9] = c[5] * a[4] + c[6] * a[9] + c[7] * a[14] + c[8] * a[19] + c[9];
      m[10] = c[10] * a[0] + c[11] * a[5] + c[12] * a[10] + c[13] * a[15];
      m[11] = c[10] * a[1] + c[11] * a[6] + c[12] * a[11] + c[13] * a[16];
      m[12] = c[10] * a[2] + c[11] * a[7] + c[12] * a[12] + c[13] * a[17];
      m[13] = c[10] * a[3] + c[11] * a[8] + c[12] * a[13] + c[13] * a[18];
      m[14] = c[10] * a[4] + c[11] * a[9] + c[12] * a[14] + c[13] * a[19] + c[14];
      m[15] = c[15] * a[0] + c[16] * a[5] + c[17] * a[10] + c[18] * a[15];
      m[16] = c[15] * a[1] + c[16] * a[6] + c[17] * a[11] + c[18] * a[16];
      m[17] = c[15] * a[2] + c[16] * a[7] + c[17] * a[12] + c[18] * a[17];
      m[18] = c[15] * a[3] + c[16] * a[8] + c[17] * a[13] + c[18] * a[18];
      m[19] = c[15] * a[4] + c[16] * a[9] + c[17] * a[14] + c[18] * a[19] + c[19];
      this._dirty = true;
      return this;
    }
  });
  module2.exports = ColorMatrix;
});

// node_modules/phaser/src/renderer/webgl/shaders/ColorMatrix-frag.js
var require_ColorMatrix_frag = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_COLORMATRIX_FS",
    "",
    "precision mediump float;",
    "",
    "uniform sampler2D uMainSampler;",
    "uniform float uColorMatrix[20];",
    "uniform float uAlpha;",
    "",
    "varying vec2 outTexCoord;",
    "",
    "void main ()",
    "{",
    "    vec4 c = texture2D(uMainSampler, outTexCoord);",
    "",
    "    if (uAlpha == 0.0)",
    "    {",
    "        gl_FragColor = c;",
    "",
    "        return;",
    "    }",
    "",
    "    if (c.a > 0.0)",
    "    {",
    "        c.rgb /= c.a;",
    "    }",
    "",
    "    vec4 result;",
    "",
    "    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];",
    "    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];",
    "    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];",
    "    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];",
    "",
    "    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);",
    "",
    "    rgb *= result.a;",
    "",
    "    gl_FragColor = vec4(rgb, result.a);",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/shaders/Copy-frag.js
var require_Copy_frag = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_COPY_FS",
    "",
    "precision mediump float;",
    "",
    "uniform sampler2D uMainSampler;",
    "uniform float uBrightness;",
    "",
    "varying vec2 outTexCoord;",
    "",
    "void main ()",
    "{",
    "    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/shaders/LinearBlend-frag.js
var require_LinearBlend_frag = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_LINEAR_BLEND_FS",
    "",
    "precision mediump float;",
    "",
    "uniform sampler2D uMainSampler1;",
    "uniform sampler2D uMainSampler2;",
    "uniform float uStrength;",
    "",
    "varying vec2 outTexCoord;",
    "",
    "void main ()",
    "{",
    "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);",
    "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);",
    "",
    "    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/shaders/Quad-vert.js
var require_Quad_vert = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_QUAD_VS",
    "",
    "precision mediump float;",
    "",
    "attribute vec2 inPosition;",
    "attribute vec2 inTexCoord;",
    "",
    "varying vec2 outFragCoord;",
    "varying vec2 outTexCoord;",
    "",
    "void main ()",
    "{",
    "    outFragCoord = inPosition.xy * 0.5 + 0.5;",
    "    outTexCoord = inTexCoord;",
    "",
    "    gl_Position = vec4(inPosition, 0, 1);",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/pipelines/UtilityPipeline.js
var require_UtilityPipeline = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AddBlendFS = require_AddBlend_frag();
  var BlendModes = require_BlendModes();
  var Class = require_Class();
  var ColorMatrix = require_ColorMatrix();
  var ColorMatrixFS = require_ColorMatrix_frag();
  var CopyFS = require_Copy_frag();
  var GetFastValue = require_GetFastValue();
  var LinearBlendFS = require_LinearBlend_frag();
  var QuadVS = require_Quad_vert();
  var WebGLPipeline = require_WebGLPipeline();
  var UtilityPipeline = new Class({
    Extends: WebGLPipeline,
    initialize: function UtilityPipeline2(config2) {
      config2.renderTarget = GetFastValue(config2, "renderTarget", [
        {
          scale: 1
        },
        {
          scale: 1
        },
        {
          scale: 0.5
        },
        {
          scale: 0.5
        }
      ]);
      config2.vertShader = GetFastValue(config2, "vertShader", QuadVS);
      config2.shaders = GetFastValue(config2, "shaders", [
        {
          name: "Copy",
          fragShader: CopyFS
        },
        {
          name: "AddBlend",
          fragShader: AddBlendFS
        },
        {
          name: "LinearBlend",
          fragShader: LinearBlendFS
        },
        {
          name: "ColorMatrix",
          fragShader: ColorMatrixFS
        }
      ]);
      config2.attributes = GetFastValue(config2, "attributes", [
        {
          name: "inPosition",
          size: 2
        },
        {
          name: "inTexCoord",
          size: 2
        }
      ]);
      config2.vertices = [
        -1,
        -1,
        0,
        0,
        -1,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        -1,
        1,
        0
      ];
      config2.batchSize = 1;
      WebGLPipeline.call(this, config2);
      this.colorMatrix = new ColorMatrix();
      this.copyShader;
      this.addShader;
      this.linearShader;
      this.colorMatrixShader;
      this.fullFrame1;
      this.fullFrame2;
      this.halfFrame1;
      this.halfFrame2;
    },
    boot: function() {
      WebGLPipeline.prototype.boot.call(this);
      var shaders = this.shaders;
      var targets = this.renderTargets;
      this.copyShader = shaders[0];
      this.addShader = shaders[1];
      this.linearShader = shaders[2];
      this.colorMatrixShader = shaders[3];
      this.fullFrame1 = targets[0];
      this.fullFrame2 = targets[1];
      this.halfFrame1 = targets[2];
      this.halfFrame2 = targets[3];
    },
    copyFrame: function(source, target, brightness, clear, clearAlpha) {
      if (brightness === void 0) {
        brightness = 1;
      }
      if (clear === void 0) {
        clear = true;
      }
      if (clearAlpha === void 0) {
        clearAlpha = true;
      }
      var gl = this.gl;
      this.setShader(this.copyShader);
      this.set1i("uMainSampler", 0);
      this.set1f("uBrightness", brightness);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, source.texture);
      if (target) {
        gl.viewport(0, 0, target.width, target.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
      } else {
        gl.viewport(0, 0, source.width, source.height);
      }
      if (clear) {
        if (clearAlpha) {
          gl.clearColor(0, 0, 0, 0);
        } else {
          gl.clearColor(0, 0, 0, 1);
        }
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
      gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
    },
    blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
      if (brightness === void 0) {
        brightness = 1;
      }
      if (clear === void 0) {
        clear = true;
      }
      if (clearAlpha === void 0) {
        clearAlpha = true;
      }
      if (eraseMode === void 0) {
        eraseMode = false;
      }
      var gl = this.gl;
      this.setShader(this.copyShader);
      this.set1i("uMainSampler", 0);
      this.set1f("uBrightness", brightness);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, source.texture);
      if (source.height > target.height) {
        gl.viewport(0, 0, source.width, source.height);
        this.setTargetUVs(source, target);
      } else {
        var diff = target.height - source.height;
        gl.viewport(0, diff, source.width, source.height);
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
      if (clear) {
        if (clearAlpha) {
          gl.clearColor(0, 0, 0, 0);
        } else {
          gl.clearColor(0, 0, 0, 1);
        }
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
      if (eraseMode) {
        var blendMode = this.renderer.currentBlendMode;
        this.renderer.setBlendMode(BlendModes.ERASE);
      }
      gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      if (eraseMode) {
        this.renderer.setBlendMode(blendMode);
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      this.resetUVs();
    },
    copyFrameRect: function(source, target, x, y, width, height, clear, clearAlpha) {
      if (clear === void 0) {
        clear = true;
      }
      if (clearAlpha === void 0) {
        clearAlpha = true;
      }
      var gl = this.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, source.framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, source.texture, 0);
      if (clear) {
        if (clearAlpha) {
          gl.clearColor(0, 0, 0, 0);
        } else {
          gl.clearColor(0, 0, 0, 1);
        }
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, target.texture);
      gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, width, height);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
    },
    copyToGame: function(source) {
      var gl = this.gl;
      this.setShader(this.copyShader);
      this.set1i("uMainSampler", 0);
      this.set1f("uBrightness", 1);
      this.renderer.popFramebuffer();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, source.texture);
      gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      this.renderer.resetTextures();
    },
    drawFrame: function(source, target, clearAlpha, colorMatrix) {
      if (clearAlpha === void 0) {
        clearAlpha = true;
      }
      if (colorMatrix === void 0) {
        colorMatrix = this.colorMatrix;
      }
      var gl = this.gl;
      this.setShader(this.colorMatrixShader);
      this.set1i("uMainSampler", 0);
      this.set1fv("uColorMatrix", colorMatrix.getData());
      this.set1f("uAlpha", colorMatrix.alpha);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, source.texture);
      if (target) {
        gl.viewport(0, 0, target.width, target.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
      } else {
        gl.viewport(0, 0, source.width, source.height);
      }
      if (clearAlpha) {
        gl.clearColor(0, 0, 0, 0);
      } else {
        gl.clearColor(0, 0, 0, 1);
      }
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
    },
    blendFrames: function(source1, source2, target, strength, clearAlpha, blendShader) {
      if (strength === void 0) {
        strength = 1;
      }
      if (clearAlpha === void 0) {
        clearAlpha = true;
      }
      if (blendShader === void 0) {
        blendShader = this.linearShader;
      }
      var gl = this.gl;
      this.setShader(blendShader);
      this.set1i("uMainSampler1", 0);
      this.set1i("uMainSampler2", 1);
      this.set1f("uStrength", strength);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, source1.texture);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, source2.texture);
      if (target) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
        gl.viewport(0, 0, target.width, target.height);
      } else {
        gl.viewport(0, 0, source1.width, source1.height);
      }
      if (clearAlpha) {
        gl.clearColor(0, 0, 0, 0);
      } else {
        gl.clearColor(0, 0, 0, 1);
      }
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
    },
    blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
      this.blendFrames(source1, source2, target, strength, clearAlpha, this.addShader);
    },
    clearFrame: function(target, clearAlpha) {
      if (clearAlpha === void 0) {
        clearAlpha = true;
      }
      var gl = this.gl;
      gl.viewport(0, 0, target.width, target.height);
      gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
      if (clearAlpha) {
        gl.clearColor(0, 0, 0, 0);
      } else {
        gl.clearColor(0, 0, 0, 1);
      }
      gl.clear(gl.COLOR_BUFFER_BIT);
      var fbo = this.renderer.currentFramebuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    },
    setUVs: function(uA, vA, uB, vB, uC, vC, uD, vD) {
      var vertexViewF32 = this.vertexViewF32;
      vertexViewF32[2] = uA;
      vertexViewF32[3] = vA;
      vertexViewF32[6] = uB;
      vertexViewF32[7] = vB;
      vertexViewF32[10] = uC;
      vertexViewF32[11] = vC;
      vertexViewF32[14] = uA;
      vertexViewF32[15] = vA;
      vertexViewF32[18] = uC;
      vertexViewF32[19] = vC;
      vertexViewF32[22] = uD;
      vertexViewF32[23] = vD;
    },
    setTargetUVs: function(source, target) {
      var diff = target.height / source.height;
      if (diff > 0.5) {
        diff = 0.5 - (diff - 0.5);
      } else {
        diff = 0.5 + (0.5 - diff);
      }
      this.setUVs(0, diff, 0, 1 + diff, 1, 1 + diff, 1, diff);
    },
    flipX: function() {
      this.setUVs(1, 0, 1, 1, 0, 1, 0, 0);
    },
    flipY: function() {
      this.setUVs(0, 1, 0, 0, 1, 0, 1, 1);
    },
    resetUVs: function() {
      this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
    }
  });
  module2.exports = UtilityPipeline;
});

// node_modules/phaser/src/renderer/webgl/PipelineManager.js
var require_PipelineManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const6();
  var CustomMap = require_Map();
  var BitmapMaskPipeline = require_BitmapMaskPipeline();
  var GraphicsPipeline = require_GraphicsPipeline();
  var LightPipeline = require_LightPipeline();
  var MultiPipeline = require_MultiPipeline();
  var PointLightPipeline = require_PointLightPipeline();
  var RopePipeline = require_RopePipeline();
  var SinglePipeline = require_SinglePipeline();
  var UtilityPipeline = require_UtilityPipeline();
  var PipelineManager = new Class({
    initialize: function PipelineManager2(renderer) {
      this.game = renderer.game;
      this.renderer = renderer;
      this.classes = new CustomMap([
        [CONST.UTILITY_PIPELINE, UtilityPipeline],
        [CONST.MULTI_PIPELINE, MultiPipeline],
        [CONST.BITMAPMASK_PIPELINE, BitmapMaskPipeline],
        [CONST.SINGLE_PIPELINE, SinglePipeline],
        [CONST.ROPE_PIPELINE, RopePipeline],
        [CONST.LIGHT_PIPELINE, LightPipeline],
        [CONST.POINTLIGHT_PIPELINE, PointLightPipeline],
        [CONST.GRAPHICS_PIPELINE, GraphicsPipeline]
      ]);
      this.postPipelineClasses = new CustomMap();
      this.pipelines = new CustomMap();
      this.current = null;
      this.previous = null;
      this.MULTI_PIPELINE = null;
      this.BITMAPMASK_PIPELINE = null;
      this.UTILITY_PIPELINE = null;
      this.fullFrame1;
      this.fullFrame2;
      this.halfFrame1;
      this.halfFrame2;
    },
    boot: function(pipelineConfig) {
      var instance;
      var pipelineName;
      var _this = this;
      var game2 = this.game;
      this.classes.each(function(pipelineName2, pipeline) {
        instance = _this.add(pipelineName2, new pipeline({game: game2}));
        if (pipelineName2 === CONST.UTILITY_PIPELINE) {
          _this.UTILITY_PIPELINE = instance;
          _this.fullFrame1 = instance.fullFrame1;
          _this.fullFrame2 = instance.fullFrame2;
          _this.halfFrame1 = instance.halfFrame1;
          _this.halfFrame2 = instance.halfFrame2;
        }
      });
      this.MULTI_PIPELINE = this.get(CONST.MULTI_PIPELINE);
      this.BITMAPMASK_PIPELINE = this.get(CONST.BITMAPMASK_PIPELINE);
      if (pipelineConfig) {
        for (pipelineName in pipelineConfig) {
          var pipelineClass = pipelineConfig[pipelineName];
          instance = new pipelineClass(game2);
          if (instance.isPostFX) {
            this.postPipelineClasses.set(pipelineName, pipelineClass);
          } else if (!this.has(pipelineName)) {
            this.classes.set(pipelineName, pipelineClass);
            this.add(pipelineName, instance);
          }
        }
      }
    },
    add: function(name, pipeline) {
      if (pipeline.isPostFX) {
        console.warn(name + " is a Post Pipeline. Use `addPostPipeline` instead");
        return;
      }
      var pipelines = this.pipelines;
      var renderer = this.renderer;
      if (!pipelines.has(name)) {
        pipeline.name = name;
        pipeline.manager = this;
        pipelines.set(name, pipeline);
      } else {
        console.warn("Pipeline exists: " + name);
      }
      if (!pipeline.hasBooted) {
        pipeline.boot();
      }
      if (renderer.width !== 0 && renderer.height !== 0) {
        pipeline.resize(renderer.width, renderer.height);
      }
      return pipeline;
    },
    addPostPipeline: function(name, pipeline) {
      if (!this.postPipelineClasses.has(name)) {
        this.postPipelineClasses.set(name, pipeline);
      }
    },
    flush: function() {
      if (this.current) {
        this.current.flush();
      }
    },
    has: function(pipeline) {
      var pipelines = this.pipelines;
      if (typeof pipeline === "string") {
        return pipelines.has(pipeline);
      } else if (pipelines.contains(pipeline)) {
        return true;
      }
      return false;
    },
    get: function(pipeline) {
      var pipelines = this.pipelines;
      if (typeof pipeline === "string") {
        return pipelines.get(pipeline);
      } else if (pipelines.contains(pipeline)) {
        return pipeline;
      }
    },
    getPostPipeline: function(pipeline, gameObject) {
      var pipelineClasses = this.postPipelineClasses;
      var instance;
      if (typeof pipeline === "string") {
        instance = pipelineClasses.get(pipeline);
      } else if (typeof pipeline === "function") {
        if (pipelineClasses.contains(pipeline)) {
          instance = pipeline;
        }
      } else if (typeof pipeline === "object") {
        instance = pipelineClasses.get(pipeline.name);
      }
      if (instance) {
        var newPipeline = new instance(this.game);
        if (gameObject) {
          newPipeline.gameObject = gameObject;
        }
        return newPipeline;
      }
    },
    remove: function(name, removeClass, removePostPipelineClass) {
      if (removeClass === void 0) {
        removeClass = true;
      }
      if (removePostPipelineClass === void 0) {
        removePostPipelineClass = true;
      }
      this.pipelines.delete(name);
      if (removeClass) {
        this.classes.delete(name);
      }
      if (removePostPipelineClass) {
        this.postPipelineClasses.delete(name);
      }
    },
    set: function(pipeline, gameObject, currentShader) {
      if (pipeline.isPostFX) {
        return;
      }
      if (!this.isCurrent(pipeline, currentShader)) {
        this.flush();
        if (this.current) {
          this.current.unbind();
        }
        this.current = pipeline;
        pipeline.bind(currentShader);
      }
      pipeline.updateProjectionMatrix();
      pipeline.onBind(gameObject);
      return pipeline;
    },
    preBatch: function(gameObject) {
      if (gameObject.hasPostPipeline) {
        this.flush();
        var pipelines = gameObject.postPipelines;
        for (var i = pipelines.length - 1; i >= 0; i--) {
          var pipeline = pipelines[i];
          if (pipeline.active) {
            pipeline.preBatch(gameObject);
          }
        }
      }
    },
    postBatch: function(gameObject) {
      if (gameObject.hasPostPipeline) {
        this.flush();
        var pipelines = gameObject.postPipelines;
        for (var i = 0; i < pipelines.length; i++) {
          var pipeline = pipelines[i];
          if (pipeline.active) {
            pipeline.postBatch(gameObject);
          }
        }
      }
    },
    preBatchCamera: function(camera) {
      if (camera.hasPostPipeline) {
        this.flush();
        var pipelines = camera.postPipelines;
        for (var i = pipelines.length - 1; i >= 0; i--) {
          var pipeline = pipelines[i];
          if (pipeline.active) {
            pipeline.preBatch(camera);
          }
        }
      }
    },
    postBatchCamera: function(camera) {
      if (camera.hasPostPipeline) {
        this.flush();
        var pipelines = camera.postPipelines;
        for (var i = 0; i < pipelines.length; i++) {
          var pipeline = pipelines[i];
          if (pipeline.active) {
            pipeline.postBatch(camera);
          }
        }
      }
    },
    isCurrent: function(pipeline, currentShader) {
      var renderer = this.renderer;
      var current = this.current;
      if (current && !currentShader) {
        currentShader = current.currentShader;
      }
      return !(current !== pipeline || currentShader.program !== renderer.currentProgram);
    },
    copyFrame: function(source, target, brightness, clear, clearAlpha) {
      this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(source, target, brightness, clear, clearAlpha);
      return this;
    },
    copyToGame: function(source) {
      this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(source);
      return this;
    },
    drawFrame: function(source, target, clearAlpha, colorMatrix) {
      this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(source, target, clearAlpha, colorMatrix);
      return this;
    },
    blendFrames: function(source1, source2, target, strength, clearAlpha) {
      this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(source1, source2, target, strength, clearAlpha);
      return this;
    },
    blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
      this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(source1, source2, target, strength, clearAlpha);
      return this;
    },
    clearFrame: function(target, clearAlpha) {
      this.UTILITY_PIPELINE.clearFrame(target, clearAlpha);
      return this;
    },
    blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
      this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
      return this;
    },
    copyFrameRect: function(source, target, x, y, width, height, clear, clearAlpha) {
      this.UTILITY_PIPELINE.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);
      return this;
    },
    forceZero: function() {
      return this.current && this.current.forceZero;
    },
    setMulti: function() {
      return this.set(this.MULTI_PIPELINE);
    },
    setUtility: function(currentShader) {
      return this.UTILITY_PIPELINE.bind(currentShader);
    },
    rebind: function(pipeline) {
      if (pipeline === void 0 && this.previous) {
        pipeline = this.previous;
      }
      var renderer = this.renderer;
      var gl = renderer.gl;
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.CULL_FACE);
      if (renderer.hasActiveStencilMask()) {
        gl.clear(gl.DEPTH_BUFFER_BIT);
      } else {
        gl.disable(gl.STENCIL_TEST);
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
      }
      gl.viewport(0, 0, renderer.width, renderer.height);
      renderer.currentProgram = null;
      renderer.setBlendMode(0, true);
      var entries = this.pipelines.entries;
      for (var key in entries) {
        entries[key].glReset = true;
      }
      if (pipeline) {
        this.current = pipeline;
        pipeline.rebind();
      }
      renderer.resetTextures();
    },
    clear: function() {
      var renderer = this.renderer;
      this.flush();
      if (this.current) {
        this.current.unbind();
        this.previous = this.current;
        this.current = null;
      } else {
        this.previous = null;
      }
      renderer.currentProgram = null;
      renderer.setBlendMode(0, true);
    },
    destroy: function() {
      this.flush();
      this.classes.clear();
      this.postPipelineClasses.clear();
      this.pipelines.clear();
      this.renderer = null;
      this.game = null;
      this.classes = null;
      this.postPipelineClasses = null;
      this.pipelines = null;
      this.current = null;
      this.previous = null;
    }
  });
  module2.exports = PipelineManager;
});

// node_modules/phaser/src/renderer/snapshot/WebGLSnapshot.js
var require_WebGLSnapshot = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CanvasPool = require_CanvasPool();
  var Color = require_Color();
  var GetFastValue = require_GetFastValue();
  var WebGLSnapshot = function(sourceCanvas, config2) {
    var gl = sourceCanvas.getContext("experimental-webgl");
    var callback = GetFastValue(config2, "callback");
    var type = GetFastValue(config2, "type", "image/png");
    var encoderOptions = GetFastValue(config2, "encoder", 0.92);
    var x = GetFastValue(config2, "x", 0);
    var y = GetFastValue(config2, "y", 0);
    var getPixel = GetFastValue(config2, "getPixel", false);
    var isFramebuffer = GetFastValue(config2, "isFramebuffer", false);
    var bufferWidth = isFramebuffer ? GetFastValue(config2, "bufferWidth", 1) : gl.drawingBufferWidth;
    var bufferHeight = isFramebuffer ? GetFastValue(config2, "bufferHeight", 1) : gl.drawingBufferHeight;
    if (getPixel) {
      var pixel = new Uint8Array(4);
      var destY = isFramebuffer ? y : bufferHeight - y;
      gl.readPixels(x, destY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
      callback.call(null, new Color(pixel[0], pixel[1], pixel[2], pixel[3] / 255));
    } else {
      var width = GetFastValue(config2, "width", bufferWidth);
      var height = GetFastValue(config2, "height", bufferHeight);
      var total = width * height * 4;
      var pixels = new Uint8Array(total);
      gl.readPixels(x, bufferHeight - y - height, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      var canvas = CanvasPool.createWebGL(this, width, height);
      var ctx = canvas.getContext("2d");
      var imageData = ctx.getImageData(0, 0, width, height);
      var data = imageData.data;
      for (var py = 0; py < height; py++) {
        for (var px = 0; px < width; px++) {
          var sourceIndex = ((height - py - 1) * width + px) * 4;
          var destIndex = (py * width + px) * 4;
          data[destIndex + 0] = pixels[sourceIndex + 0];
          data[destIndex + 1] = pixels[sourceIndex + 1];
          data[destIndex + 2] = pixels[sourceIndex + 2];
          data[destIndex + 3] = pixels[sourceIndex + 3];
        }
      }
      ctx.putImageData(imageData, 0, 0);
      var image = new Image();
      image.onerror = function() {
        callback.call(null);
        CanvasPool.remove(canvas);
      };
      image.onload = function() {
        callback.call(null, image);
        CanvasPool.remove(canvas);
      };
      image.src = canvas.toDataURL(type, encoderOptions);
    }
  };
  module2.exports = WebGLSnapshot;
});

// node_modules/phaser/src/renderer/webgl/WebGLRenderer.js
var require_WebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ArrayRemove = require_Remove();
  var CameraEvents = require_events8();
  var Class = require_Class();
  var CONST = require_const();
  var EventEmitter = require_eventemitter3();
  var Events = require_events2();
  var GameEvents = require_events();
  var IsSizePowerOfTwo = require_IsSizePowerOfTwo();
  var Matrix4 = require_Matrix4();
  var NOOP = require_NOOP();
  var PipelineManager = require_PipelineManager();
  var RenderTarget = require_RenderTarget();
  var ScaleEvents = require_events9();
  var TextureEvents = require_events10();
  var Utils = require_Utils();
  var WebGLSnapshot = require_WebGLSnapshot();
  var WebGLRenderer = new Class({
    Extends: EventEmitter,
    initialize: function WebGLRenderer2(game2) {
      EventEmitter.call(this);
      var gameConfig = game2.config;
      var contextCreationConfig = {
        alpha: gameConfig.transparent,
        desynchronized: gameConfig.desynchronized,
        depth: false,
        antialias: gameConfig.antialiasGL,
        premultipliedAlpha: gameConfig.premultipliedAlpha,
        stencil: true,
        failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,
        powerPreference: gameConfig.powerPreference,
        preserveDrawingBuffer: gameConfig.preserveDrawingBuffer
      };
      this.config = {
        clearBeforeRender: gameConfig.clearBeforeRender,
        antialias: gameConfig.antialias,
        backgroundColor: gameConfig.backgroundColor,
        contextCreation: contextCreationConfig,
        roundPixels: gameConfig.roundPixels,
        maxTextures: gameConfig.maxTextures,
        maxTextureSize: gameConfig.maxTextureSize,
        batchSize: gameConfig.batchSize,
        maxLights: gameConfig.maxLights,
        mipmapFilter: gameConfig.mipmapFilter
      };
      this.game = game2;
      this.type = CONST.WEBGL;
      this.pipelines = null;
      this.width = 0;
      this.height = 0;
      this.canvas = game2.canvas;
      this.blendModes = [];
      this.contextLost = false;
      this.snapshotState = {
        x: 0,
        y: 0,
        width: 1,
        height: 1,
        getPixel: false,
        callback: null,
        type: "image/png",
        encoder: 0.92,
        isFramebuffer: false,
        bufferWidth: 0,
        bufferHeight: 0
      };
      this.currentActiveTexture = 0;
      this.startActiveTexture = 0;
      this.maxTextures = 0;
      this.textureIndexes;
      this.tempTextures;
      this.textureZero;
      this.normalTexture;
      this.currentFramebuffer = null;
      this.fboStack = [];
      this.currentProgram = null;
      this.currentBlendMode = Infinity;
      this.currentScissorEnabled = false;
      this.currentScissor = null;
      this.scissorStack = [];
      this.contextLostHandler = NOOP;
      this.contextRestoredHandler = NOOP;
      this.gl = null;
      this.supportedExtensions = null;
      this.instancedArraysExtension = null;
      this.vaoExtension = null;
      this.extensions = {};
      this.glFormats = [];
      this.compression = {
        ETC1: false,
        PVRTC: false,
        S3TC: false
      };
      this.drawingBufferHeight = 0;
      this.blankTexture = null;
      this.whiteTexture = null;
      this.maskCount = 0;
      this.maskStack = [];
      this.currentMask = {mask: null, camera: null};
      this.currentCameraMask = {mask: null, camera: null};
      this.glFuncMap = null;
      this.currentType = "";
      this.newType = false;
      this.nextTypeMatch = false;
      this.finalType = false;
      this.mipmapFilter = null;
      this.textureFlush = 0;
      this.isTextureClean = false;
      this.defaultScissor = [0, 0, 0, 0];
      this.isBooted = false;
      this.renderTarget = null;
      this.projectionMatrix;
      this.projectionWidth = 0;
      this.projectionHeight = 0;
      this.init(this.config);
    },
    init: function(config2) {
      var gl;
      var game2 = this.game;
      var canvas = this.canvas;
      var clearColor = config2.backgroundColor;
      if (game2.config.context) {
        gl = game2.config.context;
      } else {
        gl = canvas.getContext("webgl", config2.contextCreation) || canvas.getContext("experimental-webgl", config2.contextCreation);
      }
      if (!gl || gl.isContextLost()) {
        this.contextLost = true;
        throw new Error("WebGL unsupported");
      }
      this.gl = gl;
      var _this = this;
      this.contextLostHandler = function(event) {
        _this.contextLost = true;
        _this.game.events.emit(GameEvents.CONTEXT_LOST, _this);
        event.preventDefault();
      };
      this.contextRestoredHandler = function() {
        _this.contextLost = false;
        _this.init(_this.config);
        _this.game.events.emit(GameEvents.CONTEXT_RESTORED, _this);
      };
      canvas.addEventListener("webglcontextlost", this.contextLostHandler, false);
      canvas.addEventListener("webglcontextrestored", this.contextRestoredHandler, false);
      game2.context = gl;
      for (var i = 0; i <= 27; i++) {
        this.blendModes.push({func: [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], equation: gl.FUNC_ADD});
      }
      this.blendModes[1].func = [gl.ONE, gl.DST_ALPHA];
      this.blendModes[2].func = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
      this.blendModes[3].func = [gl.ONE, gl.ONE_MINUS_SRC_COLOR];
      this.blendModes[17] = {func: [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA], equation: gl.FUNC_REVERSE_SUBTRACT};
      this.glFormats[0] = gl.BYTE;
      this.glFormats[1] = gl.SHORT;
      this.glFormats[2] = gl.UNSIGNED_BYTE;
      this.glFormats[3] = gl.UNSIGNED_SHORT;
      this.glFormats[4] = gl.FLOAT;
      this.glFuncMap = {
        mat2: {func: gl.uniformMatrix2fv, length: 1, matrix: true},
        mat3: {func: gl.uniformMatrix3fv, length: 1, matrix: true},
        mat4: {func: gl.uniformMatrix4fv, length: 1, matrix: true},
        "1f": {func: gl.uniform1f, length: 1},
        "1fv": {func: gl.uniform1fv, length: 1},
        "1i": {func: gl.uniform1i, length: 1},
        "1iv": {func: gl.uniform1iv, length: 1},
        "2f": {func: gl.uniform2f, length: 2},
        "2fv": {func: gl.uniform2fv, length: 1},
        "2i": {func: gl.uniform2i, length: 2},
        "2iv": {func: gl.uniform2iv, length: 1},
        "3f": {func: gl.uniform3f, length: 3},
        "3fv": {func: gl.uniform3fv, length: 1},
        "3i": {func: gl.uniform3i, length: 3},
        "3iv": {func: gl.uniform3iv, length: 1},
        "4f": {func: gl.uniform4f, length: 4},
        "4fv": {func: gl.uniform4fv, length: 1},
        "4i": {func: gl.uniform4i, length: 4},
        "4iv": {func: gl.uniform4iv, length: 1}
      };
      var exts = gl.getSupportedExtensions();
      if (!config2.maxTextures || config2.maxTextures === -1) {
        config2.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      }
      if (!config2.maxTextureSize) {
        config2.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      }
      var extString = "WEBGL_compressed_texture_";
      var wkExtString = "WEBKIT_" + extString;
      this.compression.ETC1 = gl.getExtension(extString + "etc1") || gl.getExtension(wkExtString + "etc1");
      this.compression.PVRTC = gl.getExtension(extString + "pvrtc") || gl.getExtension(wkExtString + "pvrtc");
      this.compression.S3TC = gl.getExtension(extString + "s3tc") || gl.getExtension(wkExtString + "s3tc");
      this.supportedExtensions = exts;
      var angleString = "ANGLE_instanced_arrays";
      this.instancedArraysExtension = exts.indexOf(angleString) > -1 ? gl.getExtension(angleString) : null;
      var vaoString = "OES_vertex_array_object";
      this.vaoExtension = exts.indexOf(vaoString) > -1 ? gl.getExtension(vaoString) : null;
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.CULL_FACE);
      gl.enable(gl.BLEND);
      gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
      this.mipmapFilter = gl[config2.mipmapFilter];
      this.maxTextures = Utils.checkShaderMax(gl, config2.maxTextures);
      this.textureIndexes = [];
      var tempTextures = this.tempTextures;
      if (Array.isArray(tempTextures)) {
        for (var t = 0; i < this.maxTextures; t++) {
          gl.deleteTexture(tempTextures[t]);
        }
      } else {
        tempTextures = new Array(this.maxTextures);
      }
      for (var index = 0; index < this.maxTextures; index++) {
        var tempTexture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0 + index);
        gl.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
        tempTextures[index] = tempTexture;
        this.textureIndexes.push(index);
      }
      this.tempTextures = tempTextures;
      this.currentActiveTexture = 1;
      this.startActiveTexture++;
      gl.activeTexture(gl.TEXTURE1);
      this.pipelines = new PipelineManager(this);
      this.setBlendMode(CONST.BlendModes.NORMAL);
      this.projectionMatrix = new Matrix4().identity();
      game2.textures.once(TextureEvents.READY, this.boot, this);
      return this;
    },
    boot: function() {
      var game2 = this.game;
      var pipelineManager = this.pipelines;
      var baseSize = game2.scale.baseSize;
      this.width = baseSize.width;
      this.height = baseSize.height;
      this.isBooted = true;
      this.renderTarget = new RenderTarget(this, this.width, this.height, 1, 0, true, true);
      pipelineManager.boot(game2.config.pipeline);
      this.blankTexture = game2.textures.getFrame("__DEFAULT");
      this.whiteTexture = game2.textures.getFrame("__WHITE");
      var gl = this.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.enable(gl.SCISSOR_TEST);
      game2.scale.on(ScaleEvents.RESIZE, this.onResize, this);
      this.resize(baseSize.width, baseSize.height);
    },
    onResize: function(gameSize, baseSize) {
      if (baseSize.width !== this.width || baseSize.height !== this.height) {
        this.resize(baseSize.width, baseSize.height);
      }
    },
    beginCapture: function(width, height) {
      if (width === void 0) {
        width = this.width;
      }
      if (height === void 0) {
        height = this.height;
      }
      this.renderTarget.bind(true, width, height);
      this.setProjectionMatrix(width, height);
      this.resetTextures();
    },
    endCapture: function() {
      this.renderTarget.unbind(true);
      this.resetProjectionMatrix();
      return this.renderTarget;
    },
    resize: function(width, height) {
      var gl = this.gl;
      this.width = width;
      this.height = height;
      this.setProjectionMatrix(width, height);
      gl.viewport(0, 0, width, height);
      this.drawingBufferHeight = gl.drawingBufferHeight;
      gl.scissor(0, gl.drawingBufferHeight - height, width, height);
      this.defaultScissor[2] = width;
      this.defaultScissor[3] = height;
      this.emit(Events.RESIZE, width, height);
      return this;
    },
    getAspectRatio: function() {
      return this.width / this.height;
    },
    setProjectionMatrix: function(width, height) {
      if (width !== this.projectionWidth || height !== this.projectionHeight) {
        this.projectionWidth = width;
        this.projectionHeight = height;
        this.projectionMatrix.ortho(0, width, height, 0, -1e3, 1e3);
      }
      return this;
    },
    resetProjectionMatrix: function() {
      this.projectionWidth = this.width;
      this.projectionHeight = this.height;
      this.projectionMatrix.ortho(0, this.width, this.height, 0, -1e3, 1e3);
    },
    hasExtension: function(extensionName) {
      return this.supportedExtensions ? this.supportedExtensions.indexOf(extensionName) : false;
    },
    getExtension: function(extensionName) {
      if (!this.hasExtension(extensionName)) {
        return null;
      }
      if (!(extensionName in this.extensions)) {
        this.extensions[extensionName] = this.gl.getExtension(extensionName);
      }
      return this.extensions[extensionName];
    },
    flush: function() {
      this.pipelines.flush();
    },
    pushScissor: function(x, y, width, height, drawingBufferHeight) {
      if (drawingBufferHeight === void 0) {
        drawingBufferHeight = this.drawingBufferHeight;
      }
      var scissorStack = this.scissorStack;
      var scissor = [x, y, width, height];
      scissorStack.push(scissor);
      this.setScissor(x, y, width, height, drawingBufferHeight);
      this.currentScissor = scissor;
      return scissor;
    },
    setScissor: function(x, y, width, height, drawingBufferHeight) {
      if (drawingBufferHeight === void 0) {
        drawingBufferHeight = this.drawingBufferHeight;
      }
      var gl = this.gl;
      var current = this.currentScissor;
      var setScissor = width > 0 && height > 0;
      if (current && setScissor) {
        var cx = current[0];
        var cy = current[1];
        var cw = current[2];
        var ch = current[3];
        setScissor = cx !== x || cy !== y || cw !== width || ch !== height;
      }
      if (setScissor) {
        this.flush();
        gl.scissor(x, drawingBufferHeight - y - height, width, height);
      }
    },
    resetScissor: function() {
      var gl = this.gl;
      gl.enable(gl.SCISSOR_TEST);
      var current = this.currentScissor;
      if (current) {
        var x = current[0];
        var y = current[1];
        var width = current[2];
        var height = current[3];
        if (width > 0 && height > 0) {
          gl.scissor(x, this.drawingBufferHeight - y - height, width, height);
        }
      }
    },
    popScissor: function() {
      var scissorStack = this.scissorStack;
      scissorStack.pop();
      var scissor = scissorStack[scissorStack.length - 1];
      if (scissor) {
        this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]);
      }
      this.currentScissor = scissor;
    },
    hasActiveStencilMask: function() {
      var mask = this.currentMask.mask;
      var camMask = this.currentCameraMask.mask;
      return mask && mask.isStencil || camMask && camMask.isStencil;
    },
    resetViewport: function() {
      var gl = this.gl;
      gl.viewport(0, 0, this.width, this.height);
      this.drawingBufferHeight = gl.drawingBufferHeight;
    },
    setBlendMode: function(blendModeId, force) {
      if (force === void 0) {
        force = false;
      }
      var gl = this.gl;
      var blendMode = this.blendModes[blendModeId];
      if (force || blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId) {
        this.flush();
        gl.enable(gl.BLEND);
        gl.blendEquation(blendMode.equation);
        if (blendMode.func.length > 2) {
          gl.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]);
        } else {
          gl.blendFunc(blendMode.func[0], blendMode.func[1]);
        }
        this.currentBlendMode = blendModeId;
        return true;
      }
      return false;
    },
    addBlendMode: function(func, equation) {
      var index = this.blendModes.push({func, equation});
      return index - 1;
    },
    updateBlendMode: function(index, func, equation) {
      if (this.blendModes[index]) {
        this.blendModes[index].func = func;
        if (equation) {
          this.blendModes[index].equation = equation;
        }
      }
      return this;
    },
    removeBlendMode: function(index) {
      if (index > 17 && this.blendModes[index]) {
        this.blendModes.splice(index, 1);
      }
      return this;
    },
    setBlankTexture: function() {
      this.setTexture2D(this.blankTexture.glTexture);
    },
    setTextureSource: function(textureSource) {
      if (this.pipelines.forceZero()) {
        this.setTextureZero(textureSource.glTexture, true);
        return 0;
      }
      var gl = this.gl;
      var currentActiveTexture = this.currentActiveTexture;
      if (textureSource.glIndexCounter < this.startActiveTexture) {
        textureSource.glIndexCounter = this.startActiveTexture;
        if (currentActiveTexture < this.maxTextures) {
          textureSource.glIndex = currentActiveTexture;
          gl.activeTexture(gl.TEXTURE0 + currentActiveTexture);
          gl.bindTexture(gl.TEXTURE_2D, textureSource.glTexture);
          this.currentActiveTexture++;
        } else {
          this.flush();
          this.startActiveTexture++;
          this.textureFlush++;
          textureSource.glIndexCounter = this.startActiveTexture;
          textureSource.glIndex = 1;
          gl.activeTexture(gl.TEXTURE1);
          gl.bindTexture(gl.TEXTURE_2D, textureSource.glTexture);
          this.currentActiveTexture = 2;
        }
      }
      this.isTextureClean = false;
      return textureSource.glIndex;
    },
    isNewNormalMap: function(texture, normalMap) {
      return this.textureZero !== texture || this.normalTexture !== normalMap;
    },
    setTextureZero: function(texture, flush) {
      if (this.textureZero !== texture) {
        if (flush) {
          this.flush();
        }
        var gl = this.gl;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        this.textureZero = texture;
      }
    },
    clearTextureZero: function() {
      this.textureZero = null;
    },
    setNormalMap: function(texture) {
      if (this.normalTexture !== texture) {
        var gl = this.gl;
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        this.normalTexture = texture;
        if (this.currentActiveTexture === 1) {
          this.currentActiveTexture = 2;
        }
      }
    },
    clearNormalMap: function() {
      this.normalTexture = null;
      this.startActiveTexture++;
      this.currentActiveTexture = 1;
      this.textureFlush++;
    },
    unbindTextures: function() {
      var gl = this.gl;
      var temp = this.tempTextures;
      for (var i = 0; i < temp.length; i++) {
        gl.activeTexture(gl.TEXTURE0 + i);
        gl.bindTexture(gl.TEXTURE_2D, null);
      }
      this.normalTexture = null;
      this.textureZero = null;
      this.currentActiveTexture = 1;
      this.startActiveTexture++;
      this.textureFlush++;
    },
    resetTextures: function(all) {
      if (all === void 0) {
        all = false;
      }
      if (this.isTextureClean) {
        return;
      }
      this.flush();
      var gl = this.gl;
      var temp = this.tempTextures;
      if (all) {
        for (var i = 0; i < temp.length; i++) {
          gl.activeTexture(gl.TEXTURE0 + i);
          gl.bindTexture(gl.TEXTURE_2D, temp[i]);
        }
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, temp[1]);
        this.isTextureClean = true;
      } else {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, temp[0]);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, temp[1]);
      }
      this.normalTexture = null;
      this.textureZero = null;
      this.currentActiveTexture = 1;
      this.startActiveTexture++;
      this.textureFlush++;
    },
    setTexture2D: function(texture) {
      if (this.pipelines.forceZero()) {
        this.setTextureZero(texture, true);
        return 0;
      }
      var gl = this.gl;
      var currentActiveTexture = this.currentActiveTexture;
      if (texture.glIndexCounter < this.startActiveTexture) {
        texture.glIndexCounter = this.startActiveTexture;
        if (currentActiveTexture < this.maxTextures) {
          texture.glIndex = currentActiveTexture;
          gl.activeTexture(gl.TEXTURE0 + currentActiveTexture);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          this.currentActiveTexture++;
        } else {
          this.flush();
          this.startActiveTexture++;
          this.textureFlush++;
          texture.glIndexCounter = this.startActiveTexture;
          texture.glIndex = 1;
          gl.activeTexture(gl.TEXTURE1);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          this.currentActiveTexture = 2;
        }
      }
      this.isTextureClean = false;
      return texture.glIndex;
    },
    pushFramebuffer: function(framebuffer, updateScissor, resetTextures, setViewport) {
      if (framebuffer === this.currentFramebuffer) {
        return this;
      }
      this.fboStack.push(framebuffer);
      return this.setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport);
    },
    setFramebuffer: function(framebuffer, updateScissor, resetTextures, setViewport) {
      if (updateScissor === void 0) {
        updateScissor = false;
      }
      if (resetTextures === void 0) {
        resetTextures = false;
      }
      if (setViewport === void 0) {
        setViewport = true;
      }
      if (framebuffer === this.currentFramebuffer) {
        return this;
      }
      var gl = this.gl;
      var width = this.width;
      var height = this.height;
      if (framebuffer && framebuffer.renderTexture && setViewport) {
        width = framebuffer.renderTexture.width;
        height = framebuffer.renderTexture.height;
      } else {
        this.flush();
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      if (setViewport) {
        gl.viewport(0, 0, width, height);
      }
      if (updateScissor) {
        if (framebuffer) {
          this.drawingBufferHeight = height;
          this.pushScissor(0, 0, width, height);
        } else {
          this.drawingBufferHeight = this.height;
          this.popScissor();
        }
      }
      this.currentFramebuffer = framebuffer;
      if (resetTextures) {
        this.resetTextures();
      }
      return this;
    },
    popFramebuffer: function(updateScissor, resetTextures, setViewport) {
      if (updateScissor === void 0) {
        updateScissor = false;
      }
      if (resetTextures === void 0) {
        resetTextures = false;
      }
      if (setViewport === void 0) {
        setViewport = true;
      }
      var fboStack = this.fboStack;
      fboStack.pop();
      var framebuffer = fboStack[fboStack.length - 1];
      if (!framebuffer) {
        framebuffer = null;
      }
      this.setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport);
      return framebuffer;
    },
    setProgram: function(program) {
      if (program !== this.currentProgram) {
        this.flush();
        this.gl.useProgram(program);
        this.currentProgram = program;
        return true;
      }
      return false;
    },
    resetProgram: function() {
      this.gl.useProgram(this.currentProgram);
      return this;
    },
    createTextureFromSource: function(source, width, height, scaleMode) {
      var gl = this.gl;
      var minFilter = gl.NEAREST;
      var magFilter = gl.NEAREST;
      var wrap = gl.CLAMP_TO_EDGE;
      var texture = null;
      width = source ? source.width : width;
      height = source ? source.height : height;
      var pow = IsSizePowerOfTwo(width, height);
      if (pow) {
        wrap = gl.REPEAT;
      }
      if (scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias) {
        minFilter = pow ? this.mipmapFilter : gl.LINEAR;
        magFilter = gl.LINEAR;
      }
      if (!source && typeof width === "number" && typeof height === "number") {
        texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, null, width, height);
      } else {
        texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, source);
      }
      return texture;
    },
    createTexture2D: function(mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY) {
      pma = pma === void 0 || pma === null ? true : pma;
      if (forceSize === void 0) {
        forceSize = false;
      }
      if (flipY === void 0) {
        flipY = false;
      }
      var gl = this.gl;
      var texture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pma);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      if (pixels === null || pixels === void 0) {
        gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);
      } else {
        if (!forceSize) {
          width = pixels.width;
          height = pixels.height;
        }
        gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);
      }
      if (IsSizePowerOfTwo(width, height)) {
        gl.generateMipmap(gl.TEXTURE_2D);
      }
      if (currentTexture) {
        gl.bindTexture(gl.TEXTURE_2D, currentTexture);
      }
      texture.isAlphaPremultiplied = pma;
      texture.isRenderTexture = false;
      texture.width = width;
      texture.height = height;
      texture.glIndex = 0;
      texture.glIndexCounter = -1;
      return texture;
    },
    createFramebuffer: function(width, height, renderTexture, addDepthStencilBuffer) {
      var gl = this.gl;
      var framebuffer = gl.createFramebuffer();
      var complete = 0;
      this.setFramebuffer(framebuffer);
      if (addDepthStencilBuffer) {
        var depthStencilBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);
      }
      renderTexture.isRenderTexture = true;
      renderTexture.isAlphaPremultiplied = false;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);
      complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      if (complete !== gl.FRAMEBUFFER_COMPLETE) {
        var errors = {
          36054: "Incomplete Attachment",
          36055: "Missing Attachment",
          36057: "Incomplete Dimensions",
          36061: "Framebuffer Unsupported"
        };
        throw new Error("Framebuffer status: " + errors[complete]);
      }
      framebuffer.renderTexture = renderTexture;
      this.setFramebuffer(null);
      this.resetTextures();
      return framebuffer;
    },
    createProgram: function(vertexShader, fragmentShader) {
      var gl = this.gl;
      var program = gl.createProgram();
      var vs = gl.createShader(gl.VERTEX_SHADER);
      var fs = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vs, vertexShader);
      gl.shaderSource(fs, fragmentShader);
      gl.compileShader(vs);
      gl.compileShader(fs);
      if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
        throw new Error("Vertex Shader failed:\n" + gl.getShaderInfoLog(vs));
      }
      if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
        throw new Error("Fragment Shader failed:\n" + gl.getShaderInfoLog(fs));
      }
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error("Link Program failed:\n" + gl.getProgramInfoLog(program));
      }
      gl.useProgram(program);
      return program;
    },
    createVertexBuffer: function(initialDataOrSize, bufferUsage) {
      var gl = this.gl;
      var vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, initialDataOrSize, bufferUsage);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      return vertexBuffer;
    },
    createIndexBuffer: function(initialDataOrSize, bufferUsage) {
      var gl = this.gl;
      var indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, initialDataOrSize, bufferUsage);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      return indexBuffer;
    },
    deleteTexture: function(texture, reset) {
      if (reset) {
        this.resetTextures(true);
      }
      if (texture) {
        this.gl.deleteTexture(texture);
      }
      return this;
    },
    deleteFramebuffer: function(framebuffer) {
      if (framebuffer) {
        this.gl.deleteFramebuffer(framebuffer);
        ArrayRemove(this.fboStack, framebuffer);
        if (this.currentFramebuffer === framebuffer) {
          this.currentFramebuffer = null;
        }
      }
      return this;
    },
    deleteProgram: function(program) {
      if (program) {
        this.gl.deleteProgram(program);
      }
      return this;
    },
    deleteBuffer: function(buffer) {
      this.gl.deleteBuffer(buffer);
      return this;
    },
    preRenderCamera: function(camera) {
      var cx = camera.x;
      var cy = camera.y;
      var cw = camera.width;
      var ch = camera.height;
      var color = camera.backgroundColor;
      camera.emit(CameraEvents.PRE_RENDER, camera);
      this.pipelines.preBatchCamera(camera);
      this.pushScissor(cx, cy, cw, ch);
      if (camera.mask) {
        this.currentCameraMask.mask = camera.mask;
        this.currentCameraMask.camera = camera._maskCamera;
        camera.mask.preRenderWebGL(this, camera, camera._maskCamera);
      }
      if (color.alphaGL > 0) {
        var pipeline = this.pipelines.setMulti();
        pipeline.drawFillRect(cx, cy, cw, ch, Utils.getTintFromFloats(color.blueGL, color.greenGL, color.redGL, 1), color.alphaGL);
      }
    },
    getCurrentStencilMask: function() {
      var prev = null;
      var stack = this.maskStack;
      var cameraMask = this.currentCameraMask;
      if (stack.length > 0) {
        prev = stack[stack.length - 1];
      } else if (cameraMask.mask && cameraMask.mask.isStencil) {
        prev = cameraMask;
      }
      return prev;
    },
    postRenderCamera: function(camera) {
      var flashEffect = camera.flashEffect;
      var fadeEffect = camera.fadeEffect;
      if (flashEffect.isRunning || (fadeEffect.isRunning || fadeEffect.isComplete)) {
        var pipeline = this.pipelines.setMulti();
        flashEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
        fadeEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);
      }
      camera.dirty = false;
      this.popScissor();
      if (camera.mask) {
        this.currentCameraMask.mask = null;
        camera.mask.postRenderWebGL(this, camera._maskCamera);
      }
      this.pipelines.postBatchCamera(camera);
      camera.emit(CameraEvents.POST_RENDER, camera);
    },
    preRender: function() {
      if (this.contextLost) {
        return;
      }
      var gl = this.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      if (this.config.clearBeforeRender) {
        var clearColor = this.config.backgroundColor;
        gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
      }
      gl.enable(gl.SCISSOR_TEST);
      this.currentScissor = this.defaultScissor;
      this.scissorStack.length = 0;
      this.scissorStack.push(this.currentScissor);
      if (this.game.scene.customViewports) {
        gl.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height);
      }
      this.currentMask.mask = null;
      this.currentCameraMask.mask = null;
      this.maskStack.length = 0;
      this.textureFlush = 0;
      this.emit(Events.PRE_RENDER);
    },
    render: function(scene, children, camera) {
      if (this.contextLost) {
        return;
      }
      var childCount = children.length;
      this.emit(Events.RENDER, scene, camera);
      this.preRenderCamera(camera);
      if (childCount === 0) {
        this.setBlendMode(CONST.BlendModes.NORMAL);
        this.postRenderCamera(camera);
        return;
      }
      this.currentType = "";
      var current = this.currentMask;
      for (var i = 0; i < childCount; i++) {
        this.finalType = i === childCount - 1;
        var child = children[i];
        var mask = child.mask;
        current = this.currentMask;
        if (current.mask && current.mask !== mask) {
          current.mask.postRenderWebGL(this, current.camera);
        }
        if (mask && current.mask !== mask) {
          mask.preRenderWebGL(this, child, camera);
        }
        if (child.blendMode !== this.currentBlendMode) {
          this.setBlendMode(child.blendMode);
        }
        var type = child.type;
        if (type !== this.currentType) {
          this.newType = true;
          this.currentType = type;
        }
        if (!this.finalType) {
          this.nextTypeMatch = children[i + 1].type === this.currentType;
        } else {
          this.nextTypeMatch = false;
        }
        child.renderWebGL(this, child, camera);
        this.newType = false;
      }
      current = this.currentMask;
      if (current.mask) {
        current.mask.postRenderWebGL(this, current.camera);
      }
      this.setBlendMode(CONST.BlendModes.NORMAL);
      this.postRenderCamera(camera);
    },
    postRender: function() {
      if (this.contextLost) {
        return;
      }
      this.flush();
      this.emit(Events.POST_RENDER);
      var state = this.snapshotState;
      if (state.callback) {
        WebGLSnapshot(this.canvas, state);
        state.callback = null;
      }
      if (this.textureFlush > 0) {
        this.startActiveTexture++;
        this.currentActiveTexture = 1;
      }
    },
    snapshot: function(callback, type, encoderOptions) {
      return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);
    },
    snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
      var state = this.snapshotState;
      state.callback = callback;
      state.type = type;
      state.encoder = encoderOptions;
      state.getPixel = false;
      state.x = x;
      state.y = y;
      state.width = Math.min(width, this.gl.drawingBufferWidth);
      state.height = Math.min(height, this.gl.drawingBufferHeight);
      return this;
    },
    snapshotPixel: function(x, y, callback) {
      this.snapshotArea(x, y, 1, 1, callback);
      this.snapshotState.getPixel = true;
      return this;
    },
    snapshotFramebuffer: function(framebuffer, bufferWidth, bufferHeight, callback, getPixel, x, y, width, height, type, encoderOptions) {
      if (getPixel === void 0) {
        getPixel = false;
      }
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = bufferWidth;
      }
      if (height === void 0) {
        height = bufferHeight;
      }
      var currentFramebuffer = this.currentFramebuffer;
      this.snapshotArea(x, y, width, height, callback, type, encoderOptions);
      var state = this.snapshotState;
      state.getPixel = getPixel;
      state.isFramebuffer = true;
      state.bufferWidth = bufferWidth;
      state.bufferHeight = bufferHeight;
      this.setFramebuffer(framebuffer);
      WebGLSnapshot(this.canvas, state);
      this.setFramebuffer(currentFramebuffer);
      state.callback = null;
      state.isFramebuffer = false;
      return this;
    },
    canvasToTexture: function(srcCanvas, dstTexture, noRepeat, flipY) {
      if (noRepeat === void 0) {
        noRepeat = false;
      }
      if (flipY === void 0) {
        flipY = false;
      }
      if (!dstTexture) {
        return this.createCanvasTexture(srcCanvas, noRepeat, flipY);
      } else {
        return this.updateCanvasTexture(srcCanvas, dstTexture, flipY);
      }
    },
    createCanvasTexture: function(srcCanvas, noRepeat, flipY) {
      if (noRepeat === void 0) {
        noRepeat = false;
      }
      if (flipY === void 0) {
        flipY = false;
      }
      var gl = this.gl;
      var minFilter = gl.NEAREST;
      var magFilter = gl.NEAREST;
      var width = srcCanvas.width;
      var height = srcCanvas.height;
      var wrapping = gl.CLAMP_TO_EDGE;
      var pow = IsSizePowerOfTwo(width, height);
      if (!noRepeat && pow) {
        wrapping = gl.REPEAT;
      }
      if (this.config.antialias) {
        minFilter = pow ? this.mipmapFilter : gl.LINEAR;
        magFilter = gl.LINEAR;
      }
      return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcCanvas, width, height, true, false, flipY);
    },
    updateCanvasTexture: function(srcCanvas, dstTexture, flipY) {
      if (flipY === void 0) {
        flipY = false;
      }
      var gl = this.gl;
      var width = srcCanvas.width;
      var height = srcCanvas.height;
      if (width > 0 && height > 0) {
        gl.activeTexture(gl.TEXTURE0);
        var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
        gl.bindTexture(gl.TEXTURE_2D, dstTexture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
        dstTexture.width = width;
        dstTexture.height = height;
        if (currentTexture) {
          gl.bindTexture(gl.TEXTURE_2D, currentTexture);
        }
      }
      return dstTexture;
    },
    createVideoTexture: function(srcVideo, noRepeat, flipY) {
      if (noRepeat === void 0) {
        noRepeat = false;
      }
      if (flipY === void 0) {
        flipY = false;
      }
      var gl = this.gl;
      var minFilter = gl.NEAREST;
      var magFilter = gl.NEAREST;
      var width = srcVideo.videoWidth;
      var height = srcVideo.videoHeight;
      var wrapping = gl.CLAMP_TO_EDGE;
      var pow = IsSizePowerOfTwo(width, height);
      if (!noRepeat && pow) {
        wrapping = gl.REPEAT;
      }
      if (this.config.antialias) {
        minFilter = pow ? this.mipmapFilter : gl.LINEAR;
        magFilter = gl.LINEAR;
      }
      return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcVideo, width, height, true, true, flipY);
    },
    updateVideoTexture: function(srcVideo, dstTexture, flipY) {
      if (flipY === void 0) {
        flipY = false;
      }
      var gl = this.gl;
      var width = srcVideo.videoWidth;
      var height = srcVideo.videoHeight;
      if (width > 0 && height > 0) {
        gl.activeTexture(gl.TEXTURE0);
        var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
        gl.bindTexture(gl.TEXTURE_2D, dstTexture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcVideo);
        dstTexture.width = width;
        dstTexture.height = height;
        if (currentTexture) {
          gl.bindTexture(gl.TEXTURE_2D, currentTexture);
        }
      }
      return dstTexture;
    },
    setTextureFilter: function(texture, filter) {
      var gl = this.gl;
      var glFilter = [gl.LINEAR, gl.NEAREST][filter];
      gl.activeTexture(gl.TEXTURE0);
      var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);
      if (currentTexture) {
        gl.bindTexture(gl.TEXTURE_2D, currentTexture);
      }
      return this;
    },
    getMaxTextureSize: function() {
      return this.config.maxTextureSize;
    },
    destroy: function() {
      this.canvas.removeEventListener("webglcontextlost", this.contextLostHandler, false);
      this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredHandler, false);
      var gl = this.gl;
      var temp = this.tempTextures;
      for (var i = 0; i < temp.length; i++) {
        gl.deleteTexture(temp[i]);
      }
      this.pipelines.destroy();
      this.removeAllListeners();
      this.fboStack = [];
      this.maskStack = [];
      this.extensions = {};
      this.textureIndexes = [];
      this.gl = null;
      this.game = null;
      this.canvas = null;
      this.contextLost = true;
      this.currentMask = null;
      this.currentCameraMask = null;
    }
  });
  module2.exports = WebGLRenderer;
});

// node_modules/phaser/src/core/CreateRenderer.js
var require_CreateRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CanvasInterpolation = require_CanvasInterpolation();
  var CanvasPool = require_CanvasPool();
  var CONST = require_const();
  var Features = require_Features();
  var CreateRenderer = function(game2) {
    var config2 = game2.config;
    if ((config2.customEnvironment || config2.canvas) && config2.renderType === CONST.AUTO) {
      throw new Error("Must set explicit renderType in custom environment");
    }
    if (!config2.customEnvironment && !config2.canvas && config2.renderType !== CONST.HEADLESS) {
      if (config2.renderType === CONST.CANVAS || config2.renderType !== CONST.CANVAS && !Features.webGL) {
        if (Features.canvas) {
          config2.renderType = CONST.CANVAS;
        } else {
          throw new Error("Cannot create Canvas or WebGL context, aborting.");
        }
      } else {
        config2.renderType = CONST.WEBGL;
      }
    }
    if (!config2.antialias) {
      CanvasPool.disableSmoothing();
    }
    var baseSize = game2.scale.baseSize;
    var width = baseSize.width;
    var height = baseSize.height;
    if (config2.canvas) {
      game2.canvas = config2.canvas;
      game2.canvas.width = width;
      game2.canvas.height = height;
    } else {
      game2.canvas = CanvasPool.create(game2, width, height, config2.renderType);
    }
    if (config2.canvasStyle) {
      game2.canvas.style = config2.canvasStyle;
    }
    if (!config2.antialias) {
      CanvasInterpolation.setCrisp(game2.canvas);
    }
    if (config2.renderType === CONST.HEADLESS) {
      return;
    }
    var CanvasRenderer;
    var WebGLRenderer;
    if (typeof WEBGL_RENDERER && typeof CANVAS_RENDERER) {
      CanvasRenderer = require_CanvasRenderer();
      WebGLRenderer = require_WebGLRenderer();
      if (config2.renderType === CONST.WEBGL) {
        game2.renderer = new WebGLRenderer(game2);
      } else {
        game2.renderer = new CanvasRenderer(game2);
        game2.context = game2.renderer.gameContext;
      }
    }
    if (typeof WEBGL_RENDERER && !typeof CANVAS_RENDERER) {
      WebGLRenderer = null;
      config2.renderType = CONST.WEBGL;
      game2.renderer = new WebGLRenderer(game2);
    }
    if (!typeof WEBGL_RENDERER) {
      CanvasRenderer = null;
      config2.renderType = CONST.CANVAS;
      game2.renderer = new CanvasRenderer(game2);
      game2.context = game2.renderer.gameContext;
    }
  };
  module2.exports = CreateRenderer;
});

// node_modules/phaser/src/core/DebugHeader.js
var require_DebugHeader = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const();
  var DebugHeader = function(game2) {
    var config2 = game2.config;
    if (config2.hideBanner) {
      return;
    }
    var renderType = "WebGL";
    if (config2.renderType === CONST.CANVAS) {
      renderType = "Canvas";
    } else if (config2.renderType === CONST.HEADLESS) {
      renderType = "Headless";
    }
    var audioConfig = config2.audio;
    var deviceAudio = game2.device.audio;
    var audioType;
    if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
      audioType = "Web Audio";
    } else if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
      audioType = "No Audio";
    } else {
      audioType = "HTML5 Audio";
    }
    if (!game2.device.browser.ie) {
      var c = "";
      var args = [c];
      if (Array.isArray(config2.bannerBackgroundColor)) {
        var lastColor;
        config2.bannerBackgroundColor.forEach(function(color) {
          c = c.concat("%c ");
          args.push("background: " + color);
          lastColor = color;
        });
        args[args.length - 1] = "color: " + config2.bannerTextColor + "; background: " + lastColor;
      } else {
        c = c.concat("%c ");
        args.push("color: " + config2.bannerTextColor + "; background: " + config2.bannerBackgroundColor);
      }
      args.push("background: transparent");
      if (config2.gameTitle) {
        c = c.concat(config2.gameTitle);
        if (config2.gameVersion) {
          c = c.concat(" v" + config2.gameVersion);
        }
        if (!config2.hidePhaser) {
          c = c.concat(" / ");
        }
      }
      var fb = typeof PLUGIN_FBINSTANT ? "-FB" : "";
      if (!config2.hidePhaser) {
        c = c.concat("Phaser v" + CONST.VERSION + fb + " (" + renderType + " | " + audioType + ")");
      }
      c = c.concat(" %c " + config2.gameURL);
      args[0] = c;
      console.log.apply(console, args);
    } else if (window["console"]) {
      console.log("Phaser v" + CONST.VERSION + " / https://phaser.io");
    }
  };
  module2.exports = DebugHeader;
});

// node_modules/phaser/src/dom/RequestAnimationFrame.js
var require_RequestAnimationFrame = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var NOOP = require_NOOP();
  var RequestAnimationFrame = new Class({
    initialize: function RequestAnimationFrame2() {
      this.isRunning = false;
      this.callback = NOOP;
      this.tick = 0;
      this.isSetTimeOut = false;
      this.timeOutID = null;
      this.lastTime = 0;
      this.target = 0;
      var _this = this;
      this.step = function step() {
        var timestamp = window.performance.now();
        _this.lastTime = _this.tick;
        _this.tick = timestamp;
        _this.callback(timestamp);
        _this.timeOutID = window.requestAnimationFrame(step);
      };
      this.stepTimeout = function stepTimeout() {
        var d = Date.now();
        var delay = Math.min(Math.max(_this.target * 2 + _this.tick - d, 0), _this.target);
        _this.lastTime = _this.tick;
        _this.tick = d;
        _this.callback(d);
        _this.timeOutID = window.setTimeout(stepTimeout, delay);
      };
    },
    start: function(callback, forceSetTimeOut, targetFPS) {
      if (this.isRunning) {
        return;
      }
      this.callback = callback;
      this.isSetTimeOut = forceSetTimeOut;
      this.target = targetFPS;
      this.isRunning = true;
      this.timeOutID = forceSetTimeOut ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step);
    },
    stop: function() {
      this.isRunning = false;
      if (this.isSetTimeOut) {
        clearTimeout(this.timeOutID);
      } else {
        window.cancelAnimationFrame(this.timeOutID);
      }
    },
    destroy: function() {
      this.stop();
      this.callback = NOOP;
    }
  });
  module2.exports = RequestAnimationFrame;
});

// node_modules/phaser/src/core/TimeStep.js
var require_TimeStep = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetValue = require_GetValue();
  var NOOP = require_NOOP();
  var RequestAnimationFrame = require_RequestAnimationFrame();
  var TimeStep = new Class({
    initialize: function TimeStep2(game2, config2) {
      this.game = game2;
      this.raf = new RequestAnimationFrame();
      this.started = false;
      this.running = false;
      this.minFps = GetValue(config2, "min", 5);
      this.targetFps = GetValue(config2, "target", 60);
      this._min = 1e3 / this.minFps;
      this._target = 1e3 / this.targetFps;
      this.actualFps = this.targetFps;
      this.nextFpsUpdate = 0;
      this.framesThisSecond = 0;
      this.callback = NOOP;
      this.forceSetTimeOut = GetValue(config2, "forceSetTimeOut", false);
      this.time = 0;
      this.startTime = 0;
      this.lastTime = 0;
      this.frame = 0;
      this.inFocus = true;
      this._pauseTime = 0;
      this._coolDown = 0;
      this.delta = 0;
      this.deltaIndex = 0;
      this.deltaHistory = [];
      this.deltaSmoothingMax = GetValue(config2, "deltaHistory", 10);
      this.panicMax = GetValue(config2, "panicMax", 120);
      this.rawDelta = 0;
      this.now = 0;
      this.smoothStep = GetValue(config2, "smoothStep", true);
    },
    blur: function() {
      this.inFocus = false;
    },
    focus: function() {
      this.inFocus = true;
      this.resetDelta();
    },
    pause: function() {
      this._pauseTime = window.performance.now();
    },
    resume: function() {
      this.resetDelta();
      this.startTime += this.time - this._pauseTime;
    },
    resetDelta: function() {
      var now = window.performance.now();
      this.time = now;
      this.lastTime = now;
      this.nextFpsUpdate = now + 1e3;
      this.framesThisSecond = 0;
      for (var i = 0; i < this.deltaSmoothingMax; i++) {
        this.deltaHistory[i] = Math.min(this._target, this.deltaHistory[i]);
      }
      this.delta = 0;
      this.deltaIndex = 0;
      this._coolDown = this.panicMax;
    },
    start: function(callback) {
      if (this.started) {
        return this;
      }
      this.started = true;
      this.running = true;
      for (var i = 0; i < this.deltaSmoothingMax; i++) {
        this.deltaHistory[i] = this._target;
      }
      this.resetDelta();
      this.startTime = window.performance.now();
      this.callback = callback;
      this.raf.start(this.step.bind(this), this.forceSetTimeOut, this._target);
    },
    step: function() {
      var time = window.performance.now();
      this.now = time;
      var before = time - this.lastTime;
      if (before < 0) {
        before = 0;
      }
      this.rawDelta = before;
      var idx = this.deltaIndex;
      var history = this.deltaHistory;
      var max = this.deltaSmoothingMax;
      var dt = before;
      var avg = before;
      if (this.smoothStep) {
        if (this._coolDown > 0 || !this.inFocus) {
          this._coolDown--;
          dt = Math.min(dt, this._target);
        }
        if (dt > this._min) {
          dt = history[idx];
          dt = Math.min(dt, this._min);
        }
        history[idx] = dt;
        this.deltaIndex++;
        if (this.deltaIndex > max) {
          this.deltaIndex = 0;
        }
        avg = 0;
        for (var i = 0; i < max; i++) {
          avg += history[i];
        }
        avg /= max;
      }
      this.delta = avg;
      this.time += this.rawDelta;
      if (time > this.nextFpsUpdate) {
        this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps;
        this.nextFpsUpdate = time + 1e3;
        this.framesThisSecond = 0;
      }
      this.framesThisSecond++;
      var interpolation = avg / this._target;
      this.callback(time, avg, interpolation);
      this.lastTime = time;
      this.frame++;
    },
    tick: function() {
      this.step();
    },
    sleep: function() {
      if (this.running) {
        this.raf.stop();
        this.running = false;
      }
    },
    wake: function(seamless) {
      if (this.running) {
        return;
      } else if (seamless) {
        this.startTime += -this.lastTime + (this.lastTime + window.performance.now());
      }
      this.raf.start(this.step.bind(this), this.useRAF);
      this.running = true;
      this.step();
    },
    getDuration: function() {
      return Math.round(this.lastTime - this.startTime) / 1e3;
    },
    getDurationMS: function() {
      return Math.round(this.lastTime - this.startTime);
    },
    stop: function() {
      this.running = false;
      this.started = false;
      this.raf.stop();
      return this;
    },
    destroy: function() {
      this.stop();
      this.callback = NOOP;
      this.raf = null;
      this.game = null;
    }
  });
  module2.exports = TimeStep;
});

// node_modules/phaser/src/core/VisibilityHandler.js
var require_VisibilityHandler = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Events = require_events();
  var VisibilityHandler = function(game2) {
    var hiddenVar;
    var eventEmitter = game2.events;
    if (document.hidden !== void 0) {
      hiddenVar = "visibilitychange";
    } else {
      var vendors = ["webkit", "moz", "ms"];
      vendors.forEach(function(prefix) {
        if (document[prefix + "Hidden"] !== void 0) {
          document.hidden = function() {
            return document[prefix + "Hidden"];
          };
          hiddenVar = prefix + "visibilitychange";
        }
      });
    }
    var onChange = function(event) {
      if (document.hidden || event.type === "pause") {
        eventEmitter.emit(Events.HIDDEN);
      } else {
        eventEmitter.emit(Events.VISIBLE);
      }
    };
    if (hiddenVar) {
      document.addEventListener(hiddenVar, onChange, false);
    }
    window.onblur = function() {
      eventEmitter.emit(Events.BLUR);
    };
    window.onfocus = function() {
      eventEmitter.emit(Events.FOCUS);
    };
    if (window.focus && game2.config.autoFocus) {
      window.focus();
    }
  };
  module2.exports = VisibilityHandler;
});

// node_modules/phaser/src/core/index.js
var require_core = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Config: require_Config(),
    CreateRenderer: require_CreateRenderer(),
    DebugHeader: require_DebugHeader(),
    Events: require_events(),
    TimeStep: require_TimeStep(),
    VisibilityHandler: require_VisibilityHandler()
  };
});

// node_modules/phaser/src/create/palettes/Arne16.js
var require_Arne16 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    0: "#000",
    1: "#9D9D9D",
    2: "#FFF",
    3: "#BE2633",
    4: "#E06F8B",
    5: "#493C2B",
    6: "#A46422",
    7: "#EB8931",
    8: "#F7E26B",
    9: "#2F484E",
    A: "#44891A",
    B: "#A3CE27",
    C: "#1B2632",
    D: "#005784",
    E: "#31A2F2",
    F: "#B2DCEF"
  };
});

// node_modules/phaser/src/create/GenerateTexture.js
var require_GenerateTexture = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Arne16 = require_Arne16();
  var CanvasPool = require_CanvasPool();
  var GetValue = require_GetValue();
  var GenerateTexture = function(config2) {
    var data = GetValue(config2, "data", []);
    var canvas = GetValue(config2, "canvas", null);
    var palette = GetValue(config2, "palette", Arne16);
    var pixelWidth = GetValue(config2, "pixelWidth", 1);
    var pixelHeight = GetValue(config2, "pixelHeight", pixelWidth);
    var resizeCanvas = GetValue(config2, "resizeCanvas", true);
    var clearCanvas = GetValue(config2, "clearCanvas", true);
    var preRender = GetValue(config2, "preRender", null);
    var postRender = GetValue(config2, "postRender", null);
    var width = Math.floor(Math.abs(data[0].length * pixelWidth));
    var height = Math.floor(Math.abs(data.length * pixelHeight));
    if (!canvas) {
      canvas = CanvasPool.create2D(this, width, height);
      resizeCanvas = false;
      clearCanvas = false;
    }
    if (resizeCanvas) {
      canvas.width = width;
      canvas.height = height;
    }
    var ctx = canvas.getContext("2d");
    if (clearCanvas) {
      ctx.clearRect(0, 0, width, height);
    }
    if (preRender) {
      preRender(canvas, ctx);
    }
    for (var y = 0; y < data.length; y++) {
      var row = data[y];
      for (var x = 0; x < row.length; x++) {
        var d = row[x];
        if (d !== "." && d !== " ") {
          ctx.fillStyle = palette[d];
          ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight);
        }
      }
    }
    if (postRender) {
      postRender(canvas, ctx);
    }
    return canvas;
  };
  module2.exports = GenerateTexture;
});

// node_modules/phaser/src/create/palettes/C64.js
var require_C64 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    0: "#000",
    1: "#fff",
    2: "#8b4131",
    3: "#7bbdc5",
    4: "#8b41ac",
    5: "#6aac41",
    6: "#3931a4",
    7: "#d5de73",
    8: "#945a20",
    9: "#5a4100",
    A: "#bd736a",
    B: "#525252",
    C: "#838383",
    D: "#acee8b",
    E: "#7b73de",
    F: "#acacac"
  };
});

// node_modules/phaser/src/create/palettes/CGA.js
var require_CGA = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    0: "#000",
    1: "#2234d1",
    2: "#0c7e45",
    3: "#44aacc",
    4: "#8a3622",
    5: "#5c2e78",
    6: "#aa5c3d",
    7: "#b5b5b5",
    8: "#5e606e",
    9: "#4c81fb",
    A: "#6cd947",
    B: "#7be2f9",
    C: "#eb8a60",
    D: "#e23d69",
    E: "#ffd93f",
    F: "#fff"
  };
});

// node_modules/phaser/src/create/palettes/JMP.js
var require_JMP = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    0: "#000",
    1: "#191028",
    2: "#46af45",
    3: "#a1d685",
    4: "#453e78",
    5: "#7664fe",
    6: "#833129",
    7: "#9ec2e8",
    8: "#dc534b",
    9: "#e18d79",
    A: "#d6b97b",
    B: "#e9d8a1",
    C: "#216c4b",
    D: "#d365c8",
    E: "#afaab9",
    F: "#f5f4eb"
  };
});

// node_modules/phaser/src/create/palettes/MSX.js
var require_MSX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    0: "#000",
    1: "#191028",
    2: "#46af45",
    3: "#a1d685",
    4: "#453e78",
    5: "#7664fe",
    6: "#833129",
    7: "#9ec2e8",
    8: "#dc534b",
    9: "#e18d79",
    A: "#d6b97b",
    B: "#e9d8a1",
    C: "#216c4b",
    D: "#d365c8",
    E: "#afaab9",
    F: "#fff"
  };
});

// node_modules/phaser/src/create/palettes/index.js
var require_palettes = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ARNE16: require_Arne16(),
    C64: require_C64(),
    CGA: require_CGA(),
    JMP: require_JMP(),
    MSX: require_MSX()
  };
});

// node_modules/phaser/src/create/index.js
var require_create = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    GenerateTexture: require_GenerateTexture(),
    Palettes: require_palettes()
  };
});

// node_modules/phaser/src/geom/rectangle/FromPoints.js
var require_FromPoints = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  var MATH_CONST = require_const4();
  var FromPoints = function(points, out) {
    if (out === void 0) {
      out = new Rectangle();
    }
    if (points.length === 0) {
      return out;
    }
    var minX = Number.MAX_VALUE;
    var minY = Number.MAX_VALUE;
    var maxX = MATH_CONST.MIN_SAFE_INTEGER;
    var maxY = MATH_CONST.MIN_SAFE_INTEGER;
    var p;
    var px;
    var py;
    for (var i = 0; i < points.length; i++) {
      p = points[i];
      if (Array.isArray(p)) {
        px = p[0];
        py = p[1];
      } else {
        px = p.x;
        py = p.y;
      }
      minX = Math.min(minX, px);
      minY = Math.min(minY, py);
      maxX = Math.max(maxX, px);
      maxY = Math.max(maxY, py);
    }
    out.x = minX;
    out.y = minY;
    out.width = maxX - minX;
    out.height = maxY - minY;
    return out;
  };
  module2.exports = FromPoints;
});

// node_modules/phaser/src/curves/Curve.js
var require_Curve = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FromPoints = require_FromPoints();
  var Rectangle = require_Rectangle();
  var Vector2 = require_Vector2();
  var Curve = new Class({
    initialize: function Curve2(type) {
      this.type = type;
      this.defaultDivisions = 5;
      this.arcLengthDivisions = 100;
      this.cacheArcLengths = [];
      this.needsUpdate = true;
      this.active = true;
      this._tmpVec2A = new Vector2();
      this._tmpVec2B = new Vector2();
    },
    draw: function(graphics, pointsTotal) {
      if (pointsTotal === void 0) {
        pointsTotal = 32;
      }
      return graphics.strokePoints(this.getPoints(pointsTotal));
    },
    getBounds: function(out, accuracy) {
      if (!out) {
        out = new Rectangle();
      }
      if (accuracy === void 0) {
        accuracy = 16;
      }
      var len = this.getLength();
      if (accuracy > len) {
        accuracy = len / 2;
      }
      var spaced = Math.max(1, Math.round(len / accuracy));
      return FromPoints(this.getSpacedPoints(spaced), out);
    },
    getDistancePoints: function(distance) {
      var len = this.getLength();
      var spaced = Math.max(1, len / distance);
      return this.getSpacedPoints(spaced);
    },
    getEndPoint: function(out) {
      if (out === void 0) {
        out = new Vector2();
      }
      return this.getPointAt(1, out);
    },
    getLength: function() {
      var lengths = this.getLengths();
      return lengths[lengths.length - 1];
    },
    getLengths: function(divisions) {
      if (divisions === void 0) {
        divisions = this.arcLengthDivisions;
      }
      if (this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
        return this.cacheArcLengths;
      }
      this.needsUpdate = false;
      var cache = [];
      var current;
      var last = this.getPoint(0, this._tmpVec2A);
      var sum = 0;
      cache.push(0);
      for (var p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions, this._tmpVec2B);
        sum += current.distance(last);
        cache.push(sum);
        last.copy(current);
      }
      this.cacheArcLengths = cache;
      return cache;
    },
    getPointAt: function(u, out) {
      var t = this.getUtoTmapping(u);
      return this.getPoint(t, out);
    },
    getPoints: function(divisions, stepRate, out) {
      if (out === void 0) {
        out = [];
      }
      if (!divisions) {
        if (!stepRate) {
          divisions = this.defaultDivisions;
        } else {
          divisions = this.getLength() / stepRate;
        }
      }
      for (var d = 0; d <= divisions; d++) {
        out.push(this.getPoint(d / divisions));
      }
      return out;
    },
    getRandomPoint: function(out) {
      if (out === void 0) {
        out = new Vector2();
      }
      return this.getPoint(Math.random(), out);
    },
    getSpacedPoints: function(divisions, stepRate, out) {
      if (out === void 0) {
        out = [];
      }
      if (!divisions) {
        if (!stepRate) {
          divisions = this.defaultDivisions;
        } else {
          divisions = this.getLength() / stepRate;
        }
      }
      for (var d = 0; d <= divisions; d++) {
        var t = this.getUtoTmapping(d / divisions, null, divisions);
        out.push(this.getPoint(t));
      }
      return out;
    },
    getStartPoint: function(out) {
      if (out === void 0) {
        out = new Vector2();
      }
      return this.getPointAt(0, out);
    },
    getTangent: function(t, out) {
      if (out === void 0) {
        out = new Vector2();
      }
      var delta = 1e-4;
      var t1 = t - delta;
      var t2 = t + delta;
      if (t1 < 0) {
        t1 = 0;
      }
      if (t2 > 1) {
        t2 = 1;
      }
      this.getPoint(t1, this._tmpVec2A);
      this.getPoint(t2, out);
      return out.subtract(this._tmpVec2A).normalize();
    },
    getTangentAt: function(u, out) {
      var t = this.getUtoTmapping(u);
      return this.getTangent(t, out);
    },
    getTFromDistance: function(distance, divisions) {
      if (distance <= 0) {
        return 0;
      }
      return this.getUtoTmapping(0, distance, divisions);
    },
    getUtoTmapping: function(u, distance, divisions) {
      var arcLengths = this.getLengths(divisions);
      var i = 0;
      var il = arcLengths.length;
      var targetArcLength;
      if (distance) {
        targetArcLength = Math.min(distance, arcLengths[il - 1]);
      } else {
        targetArcLength = u * arcLengths[il - 1];
      }
      var low = 0;
      var high = il - 1;
      var comparison;
      while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
          low = i + 1;
        } else if (comparison > 0) {
          high = i - 1;
        } else {
          high = i;
          break;
        }
      }
      i = high;
      if (arcLengths[i] === targetArcLength) {
        return i / (il - 1);
      }
      var lengthBefore = arcLengths[i];
      var lengthAfter = arcLengths[i + 1];
      var segmentLength = lengthAfter - lengthBefore;
      var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      return (i + segmentFraction) / (il - 1);
    },
    updateArcLengths: function() {
      this.needsUpdate = true;
      this.getLengths();
    }
  });
  module2.exports = Curve;
});

// node_modules/phaser/src/curves/CubicBezierCurve.js
var require_CubicBezierCurve = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CubicBezier = require_CubicBezierInterpolation();
  var Curve = require_Curve();
  var Vector2 = require_Vector2();
  var CubicBezierCurve = new Class({
    Extends: Curve,
    initialize: function CubicBezierCurve2(p0, p1, p2, p3) {
      Curve.call(this, "CubicBezierCurve");
      if (Array.isArray(p0)) {
        p3 = new Vector2(p0[6], p0[7]);
        p2 = new Vector2(p0[4], p0[5]);
        p1 = new Vector2(p0[2], p0[3]);
        p0 = new Vector2(p0[0], p0[1]);
      }
      this.p0 = p0;
      this.p1 = p1;
      this.p2 = p2;
      this.p3 = p3;
    },
    getStartPoint: function(out) {
      if (out === void 0) {
        out = new Vector2();
      }
      return out.copy(this.p0);
    },
    getResolution: function(divisions) {
      return divisions;
    },
    getPoint: function(t, out) {
      if (out === void 0) {
        out = new Vector2();
      }
      var p0 = this.p0;
      var p1 = this.p1;
      var p2 = this.p2;
      var p3 = this.p3;
      return out.set(CubicBezier(t, p0.x, p1.x, p2.x, p3.x), CubicBezier(t, p0.y, p1.y, p2.y, p3.y));
    },
    draw: function(graphics, pointsTotal) {
      if (pointsTotal === void 0) {
        pointsTotal = 32;
      }
      var points = this.getPoints(pointsTotal);
      graphics.beginPath();
      graphics.moveTo(this.p0.x, this.p0.y);
      for (var i = 1; i < points.length; i++) {
        graphics.lineTo(points[i].x, points[i].y);
      }
      graphics.strokePath();
      return graphics;
    },
    toJSON: function() {
      return {
        type: this.type,
        points: [
          this.p0.x,
          this.p0.y,
          this.p1.x,
          this.p1.y,
          this.p2.x,
          this.p2.y,
          this.p3.x,
          this.p3.y
        ]
      };
    }
  });
  CubicBezierCurve.fromJSON = function(data) {
    var points = data.points;
    var p0 = new Vector2(points[0], points[1]);
    var p1 = new Vector2(points[2], points[3]);
    var p2 = new Vector2(points[4], points[5]);
    var p3 = new Vector2(points[6], points[7]);
    return new CubicBezierCurve(p0, p1, p2, p3);
  };
  module2.exports = CubicBezierCurve;
});

// node_modules/phaser/src/curves/EllipseCurve.js
var require_EllipseCurve = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Curve = require_Curve();
  var DegToRad = require_DegToRad();
  var GetValue = require_GetValue();
  var RadToDeg = require_RadToDeg();
  var Vector2 = require_Vector2();
  var EllipseCurve = new Class({
    Extends: Curve,
    initialize: function EllipseCurve2(x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
      if (typeof x === "object") {
        var config2 = x;
        x = GetValue(config2, "x", 0);
        y = GetValue(config2, "y", 0);
        xRadius = GetValue(config2, "xRadius", 0);
        yRadius = GetValue(config2, "yRadius", xRadius);
        startAngle = GetValue(config2, "startAngle", 0);
        endAngle = GetValue(config2, "endAngle", 360);
        clockwise = GetValue(config2, "clockwise", false);
        rotation = GetValue(config2, "rotation", 0);
      } else {
        if (yRadius === void 0) {
          yRadius = xRadius;
        }
        if (startAngle === void 0) {
          startAngle = 0;
        }
        if (endAngle === void 0) {
          endAngle = 360;
        }
        if (clockwise === void 0) {
          clockwise = false;
        }
        if (rotation === void 0) {
          rotation = 0;
        }
      }
      Curve.call(this, "EllipseCurve");
      this.p0 = new Vector2(x, y);
      this._xRadius = xRadius;
      this._yRadius = yRadius;
      this._startAngle = DegToRad(startAngle);
      this._endAngle = DegToRad(endAngle);
      this._clockwise = clockwise;
      this._rotation = DegToRad(rotation);
    },
    getStartPoint: function(out) {
      if (out === void 0) {
        out = new Vector2();
      }
      return this.getPoint(0, out);
    },
    getResolution: function(divisions) {
      return divisions * 2;
    },
    getPoint: function(t, out) {
      if (out === void 0) {
        out = new Vector2();
      }
      var twoPi = Math.PI * 2;
      var deltaAngle = this._endAngle - this._startAngle;
      var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
      while (deltaAngle < 0) {
        deltaAngle += twoPi;
      }
      while (deltaAngle > twoPi) {
        deltaAngle -= twoPi;
      }
      if (deltaAngle < Number.EPSILON) {
        if (samePoints) {
          deltaAngle = 0;
        } else {
          deltaAngle = twoPi;
        }
      }
      if (this._clockwise && !samePoints) {
        if (deltaAngle === twoPi) {
          deltaAngle = -twoPi;
        } else {
          deltaAngle = deltaAngle - twoPi;
        }
      }
      var angle = this._startAngle + t * deltaAngle;
      var x = this.p0.x + this._xRadius * Math.cos(angle);
      var y = this.p0.y + this._yRadius * Math.sin(angle);
      if (this._rotation !== 0) {
        var cos = Math.cos(this._rotation);
        var sin = Math.sin(this._rotation);
        var tx = x - this.p0.x;
        var ty = y - this.p0.y;
        x = tx * cos - ty * sin + this.p0.x;
        y = tx * sin + ty * cos + this.p0.y;
      }
      return out.set(x, y);
    },
    setXRadius: function(value) {
      this.xRadius = value;
      return this;
    },
    setYRadius: function(value) {
      this.yRadius = value;
      return this;
    },
    setWidth: function(value) {
      this.xRadius = value / 2;
      return this;
    },
    setHeight: function(value) {
      this.yRadius = value / 2;
      return this;
    },
    setStartAngle: function(value) {
      this.startAngle = value;
      return this;
    },
    setEndAngle: function(value) {
      this.endAngle = value;
      return this;
    },
    setClockwise: function(value) {
      this.clockwise = value;
      return this;
    },
    setRotation: function(value) {
      this.rotation = value;
      return this;
    },
    x: {
      get: function() {
        return this.p0.x;
      },
      set: function(value) {
        this.p0.x = value;
      }
    },
    y: {
      get: function() {
        return this.p0.y;
      },
      set: function(value) {
        this.p0.y = value;
      }
    },
    xRadius: {
      get: function() {
        return this._xRadius;
      },
      set: function(value) {
        this._xRadius = value;
      }
    },
    yRadius: {
      get: function() {
        return this._yRadius;
      },
      set: function(value) {
        this._yRadius = value;
      }
    },
    startAngle: {
      get: function() {
        return RadToDeg(this._startAngle);
      },
      set: function(value) {
        this._startAngle = DegToRad(value);
      }
    },
    endAngle: {
      get: function() {
        return RadToDeg(this._endAngle);
      },
      set: function(value) {
        this._endAngle = DegToRad(value);
      }
    },
    clockwise: {
      get: function() {
        return this._clockwise;
      },
      set: function(value) {
        this._clockwise = value;
      }
    },
    angle: {
      get: function() {
        return RadToDeg(this._rotation);
      },
      set: function(value) {
        this._rotation = DegToRad(value);
      }
    },
    rotation: {
      get: function() {
        return this._rotation;
      },
      set: function(value) {
        this._rotation = value;
      }
    },
    toJSON: function() {
      return {
        type: this.type,
        x: this.p0.x,
        y: this.p0.y,
        xRadius: this._xRadius,
        yRadius: this._yRadius,
        startAngle: RadToDeg(this._startAngle),
        endAngle: RadToDeg(this._endAngle),
        clockwise: this._clockwise,
        rotation: RadToDeg(this._rotation)
      };
    }
  });
  EllipseCurve.fromJSON = function(data) {
    return new EllipseCurve(data);
  };
  module2.exports = EllipseCurve;
});

// node_modules/phaser/src/gameobjects/GameObjectFactory.js
var require_GameObjectFactory = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var PluginCache = require_PluginCache();
  var SceneEvents = require_events5();
  var GameObjectFactory = new Class({
    initialize: function GameObjectFactory2(scene) {
      this.scene = scene;
      this.systems = scene.sys;
      this.events = scene.sys.events;
      this.displayList;
      this.updateList;
      this.events.once(SceneEvents.BOOT, this.boot, this);
      this.events.on(SceneEvents.START, this.start, this);
    },
    boot: function() {
      this.displayList = this.systems.displayList;
      this.updateList = this.systems.updateList;
      this.events.once(SceneEvents.DESTROY, this.destroy, this);
    },
    start: function() {
      this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    existing: function(child) {
      if (child.renderCanvas || child.renderWebGL) {
        this.displayList.add(child);
      }
      if (child.preUpdate) {
        this.updateList.add(child);
      }
      return child;
    },
    shutdown: function() {
      this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    destroy: function() {
      this.shutdown();
      this.events.off(SceneEvents.START, this.start, this);
      this.scene = null;
      this.systems = null;
      this.events = null;
      this.displayList = null;
      this.updateList = null;
    }
  });
  GameObjectFactory.register = function(factoryType, factoryFunction) {
    if (!GameObjectFactory.prototype.hasOwnProperty(factoryType)) {
      GameObjectFactory.prototype[factoryType] = factoryFunction;
    }
  };
  GameObjectFactory.remove = function(factoryType) {
    if (GameObjectFactory.prototype.hasOwnProperty(factoryType)) {
      delete GameObjectFactory.prototype[factoryType];
    }
  };
  PluginCache.register("GameObjectFactory", GameObjectFactory, "add");
  module2.exports = GameObjectFactory;
});

// node_modules/phaser/src/curves/LineCurve.js
var require_LineCurve = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Curve = require_Curve();
  var FromPoints = require_FromPoints();
  var Rectangle = require_Rectangle();
  var Vector2 = require_Vector2();
  var LineCurve = new Class({
    Extends: Curve,
    initialize: function LineCurve2(p0, p1) {
      Curve.call(this, "LineCurve");
      if (Array.isArray(p0)) {
        p1 = new Vector2(p0[2], p0[3]);
        p0 = new Vector2(p0[0], p0[1]);
      }
      this.p0 = p0;
      this.p1 = p1;
      this.arcLengthDivisions = 1;
    },
    getBounds: function(out) {
      if (out === void 0) {
        out = new Rectangle();
      }
      return FromPoints([this.p0, this.p1], out);
    },
    getStartPoint: function(out) {
      if (out === void 0) {
        out = new Vector2();
      }
      return out.copy(this.p0);
    },
    getResolution: function(divisions) {
      if (divisions === void 0) {
        divisions = 1;
      }
      return divisions;
    },
    getPoint: function(t, out) {
      if (out === void 0) {
        out = new Vector2();
      }
      if (t === 1) {
        return out.copy(this.p1);
      }
      out.copy(this.p1).subtract(this.p0).scale(t).add(this.p0);
      return out;
    },
    getPointAt: function(u, out) {
      return this.getPoint(u, out);
    },
    getTangent: function(t, out) {
      if (out === void 0) {
        out = new Vector2();
      }
      out.copy(this.p1).subtract(this.p0).normalize();
      return out;
    },
    getUtoTmapping: function(u, distance, divisions) {
      var t;
      if (distance) {
        var arcLengths = this.getLengths(divisions);
        var lineLength = arcLengths[arcLengths.length - 1];
        var targetLineLength = Math.min(distance, lineLength);
        t = targetLineLength / lineLength;
      } else {
        t = u;
      }
      return t;
    },
    draw: function(graphics) {
      graphics.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y);
      return graphics;
    },
    toJSON: function() {
      return {
        type: this.type,
        points: [
          this.p0.x,
          this.p0.y,
          this.p1.x,
          this.p1.y
        ]
      };
    }
  });
  LineCurve.fromJSON = function(data) {
    var points = data.points;
    var p0 = new Vector2(points[0], points[1]);
    var p1 = new Vector2(points[2], points[3]);
    return new LineCurve(p0, p1);
  };
  module2.exports = LineCurve;
});

// node_modules/phaser/src/curves/path/MoveTo.js
var require_MoveTo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Vector2 = require_Vector2();
  var MoveTo = new Class({
    initialize: function MoveTo2(x, y) {
      this.active = false;
      this.p0 = new Vector2(x, y);
    },
    getPoint: function(t, out) {
      if (out === void 0) {
        out = new Vector2();
      }
      return out.copy(this.p0);
    },
    getPointAt: function(u, out) {
      return this.getPoint(u, out);
    },
    getResolution: function() {
      return 1;
    },
    getLength: function() {
      return 0;
    },
    toJSON: function() {
      return {
        type: "MoveTo",
        points: [
          this.p0.x,
          this.p0.y
        ]
      };
    }
  });
  module2.exports = MoveTo;
});

// node_modules/phaser/src/curves/QuadraticBezierCurve.js
var require_QuadraticBezierCurve = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Curve = require_Curve();
  var QuadraticBezierInterpolation = require_QuadraticBezierInterpolation();
  var Vector2 = require_Vector2();
  var QuadraticBezier = new Class({
    Extends: Curve,
    initialize: function QuadraticBezier2(p0, p1, p2) {
      Curve.call(this, "QuadraticBezier");
      if (Array.isArray(p0)) {
        p2 = new Vector2(p0[4], p0[5]);
        p1 = new Vector2(p0[2], p0[3]);
        p0 = new Vector2(p0[0], p0[1]);
      }
      this.p0 = p0;
      this.p1 = p1;
      this.p2 = p2;
    },
    getStartPoint: function(out) {
      if (out === void 0) {
        out = new Vector2();
      }
      return out.copy(this.p0);
    },
    getResolution: function(divisions) {
      return divisions;
    },
    getPoint: function(t, out) {
      if (out === void 0) {
        out = new Vector2();
      }
      var p0 = this.p0;
      var p1 = this.p1;
      var p2 = this.p2;
      return out.set(QuadraticBezierInterpolation(t, p0.x, p1.x, p2.x), QuadraticBezierInterpolation(t, p0.y, p1.y, p2.y));
    },
    draw: function(graphics, pointsTotal) {
      if (pointsTotal === void 0) {
        pointsTotal = 32;
      }
      var points = this.getPoints(pointsTotal);
      graphics.beginPath();
      graphics.moveTo(this.p0.x, this.p0.y);
      for (var i = 1; i < points.length; i++) {
        graphics.lineTo(points[i].x, points[i].y);
      }
      graphics.strokePath();
      return graphics;
    },
    toJSON: function() {
      return {
        type: this.type,
        points: [
          this.p0.x,
          this.p0.y,
          this.p1.x,
          this.p1.y,
          this.p2.x,
          this.p2.y
        ]
      };
    }
  });
  QuadraticBezier.fromJSON = function(data) {
    var points = data.points;
    var p0 = new Vector2(points[0], points[1]);
    var p1 = new Vector2(points[2], points[3]);
    var p2 = new Vector2(points[4], points[5]);
    return new QuadraticBezier(p0, p1, p2);
  };
  module2.exports = QuadraticBezier;
});

// node_modules/phaser/src/curves/SplineCurve.js
var require_SplineCurve = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CatmullRom = require_CatmullRom();
  var Class = require_Class();
  var Curve = require_Curve();
  var Vector2 = require_Vector2();
  var SplineCurve = new Class({
    Extends: Curve,
    initialize: function SplineCurve2(points) {
      if (points === void 0) {
        points = [];
      }
      Curve.call(this, "SplineCurve");
      this.points = [];
      this.addPoints(points);
    },
    addPoints: function(points) {
      for (var i = 0; i < points.length; i++) {
        var p = new Vector2();
        if (typeof points[i] === "number") {
          p.x = points[i];
          p.y = points[i + 1];
          i++;
        } else if (Array.isArray(points[i])) {
          p.x = points[i][0];
          p.y = points[i][1];
        } else {
          p.x = points[i].x;
          p.y = points[i].y;
        }
        this.points.push(p);
      }
      return this;
    },
    addPoint: function(x, y) {
      var vec = new Vector2(x, y);
      this.points.push(vec);
      return vec;
    },
    getStartPoint: function(out) {
      if (out === void 0) {
        out = new Vector2();
      }
      return out.copy(this.points[0]);
    },
    getResolution: function(divisions) {
      return divisions * this.points.length;
    },
    getPoint: function(t, out) {
      if (out === void 0) {
        out = new Vector2();
      }
      var points = this.points;
      var point = (points.length - 1) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
      var p1 = points[intPoint];
      var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      return out.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
    },
    toJSON: function() {
      var points = [];
      for (var i = 0; i < this.points.length; i++) {
        points.push(this.points[i].x);
        points.push(this.points[i].y);
      }
      return {
        type: this.type,
        points
      };
    }
  });
  SplineCurve.fromJSON = function(data) {
    return new SplineCurve(data.points);
  };
  module2.exports = SplineCurve;
});

// node_modules/phaser/src/curves/path/Path.js
var require_Path = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CubicBezierCurve = require_CubicBezierCurve();
  var EllipseCurve = require_EllipseCurve();
  var GameObjectFactory = require_GameObjectFactory();
  var LineCurve = require_LineCurve();
  var MovePathTo = require_MoveTo();
  var QuadraticBezierCurve = require_QuadraticBezierCurve();
  var Rectangle = require_Rectangle();
  var SplineCurve = require_SplineCurve();
  var Vector2 = require_Vector2();
  var MATH_CONST = require_const4();
  var Path = new Class({
    initialize: function Path2(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      this.name = "";
      this.curves = [];
      this.cacheLengths = [];
      this.autoClose = false;
      this.startPoint = new Vector2();
      this._tmpVec2A = new Vector2();
      this._tmpVec2B = new Vector2();
      if (typeof x === "object") {
        this.fromJSON(x);
      } else {
        this.startPoint.set(x, y);
      }
    },
    add: function(curve) {
      this.curves.push(curve);
      return this;
    },
    circleTo: function(radius, clockwise, rotation) {
      if (clockwise === void 0) {
        clockwise = false;
      }
      return this.ellipseTo(radius, radius, 0, 360, clockwise, rotation);
    },
    closePath: function() {
      var startPoint = this.curves[0].getPoint(0);
      var endPoint = this.curves[this.curves.length - 1].getPoint(1);
      if (!startPoint.equals(endPoint)) {
        this.curves.push(new LineCurve(endPoint, startPoint));
      }
      return this;
    },
    cubicBezierTo: function(x, y, control1X, control1Y, control2X, control2Y) {
      var p0 = this.getEndPoint();
      var p1;
      var p2;
      var p3;
      if (x instanceof Vector2) {
        p1 = x;
        p2 = y;
        p3 = control1X;
      } else {
        p1 = new Vector2(control1X, control1Y);
        p2 = new Vector2(control2X, control2Y);
        p3 = new Vector2(x, y);
      }
      return this.add(new CubicBezierCurve(p0, p1, p2, p3));
    },
    quadraticBezierTo: function(x, y, controlX, controlY) {
      var p0 = this.getEndPoint();
      var p1;
      var p2;
      if (x instanceof Vector2) {
        p1 = x;
        p2 = y;
      } else {
        p1 = new Vector2(controlX, controlY);
        p2 = new Vector2(x, y);
      }
      return this.add(new QuadraticBezierCurve(p0, p1, p2));
    },
    draw: function(graphics, pointsTotal) {
      for (var i = 0; i < this.curves.length; i++) {
        var curve = this.curves[i];
        if (!curve.active) {
          continue;
        }
        curve.draw(graphics, pointsTotal);
      }
      return graphics;
    },
    ellipseTo: function(xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {
      var ellipse = new EllipseCurve(0, 0, xRadius, yRadius, startAngle, endAngle, clockwise, rotation);
      var end = this.getEndPoint(this._tmpVec2A);
      var start = ellipse.getStartPoint(this._tmpVec2B);
      end.subtract(start);
      ellipse.x = end.x;
      ellipse.y = end.y;
      return this.add(ellipse);
    },
    fromJSON: function(data) {
      this.curves = [];
      this.cacheLengths = [];
      this.startPoint.set(data.x, data.y);
      this.autoClose = data.autoClose;
      for (var i = 0; i < data.curves.length; i++) {
        var curve = data.curves[i];
        switch (curve.type) {
          case "LineCurve":
            this.add(LineCurve.fromJSON(curve));
            break;
          case "EllipseCurve":
            this.add(EllipseCurve.fromJSON(curve));
            break;
          case "SplineCurve":
            this.add(SplineCurve.fromJSON(curve));
            break;
          case "CubicBezierCurve":
            this.add(CubicBezierCurve.fromJSON(curve));
            break;
          case "QuadraticBezierCurve":
            this.add(QuadraticBezierCurve.fromJSON(curve));
            break;
        }
      }
      return this;
    },
    getBounds: function(out, accuracy) {
      if (out === void 0) {
        out = new Rectangle();
      }
      if (accuracy === void 0) {
        accuracy = 16;
      }
      out.x = Number.MAX_VALUE;
      out.y = Number.MAX_VALUE;
      var bounds = new Rectangle();
      var maxRight = MATH_CONST.MIN_SAFE_INTEGER;
      var maxBottom = MATH_CONST.MIN_SAFE_INTEGER;
      for (var i = 0; i < this.curves.length; i++) {
        var curve = this.curves[i];
        if (!curve.active) {
          continue;
        }
        curve.getBounds(bounds, accuracy);
        out.x = Math.min(out.x, bounds.x);
        out.y = Math.min(out.y, bounds.y);
        maxRight = Math.max(maxRight, bounds.right);
        maxBottom = Math.max(maxBottom, bounds.bottom);
      }
      out.right = maxRight;
      out.bottom = maxBottom;
      return out;
    },
    getCurveLengths: function() {
      if (this.cacheLengths.length === this.curves.length) {
        return this.cacheLengths;
      }
      var lengths = [];
      var sums = 0;
      for (var i = 0; i < this.curves.length; i++) {
        sums += this.curves[i].getLength();
        lengths.push(sums);
      }
      this.cacheLengths = lengths;
      return lengths;
    },
    getEndPoint: function(out) {
      if (out === void 0) {
        out = new Vector2();
      }
      if (this.curves.length > 0) {
        this.curves[this.curves.length - 1].getPoint(1, out);
      } else {
        out.copy(this.startPoint);
      }
      return out;
    },
    getLength: function() {
      var lens = this.getCurveLengths();
      return lens[lens.length - 1];
    },
    getPoint: function(t, out) {
      if (out === void 0) {
        out = new Vector2();
      }
      var d = t * this.getLength();
      var curveLengths = this.getCurveLengths();
      var i = 0;
      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          var diff = curveLengths[i] - d;
          var curve = this.curves[i];
          var segmentLength = curve.getLength();
          var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
          return curve.getPointAt(u, out);
        }
        i++;
      }
      return null;
    },
    getPoints: function(divisions) {
      if (divisions === void 0) {
        divisions = 12;
      }
      var points = [];
      var last;
      for (var i = 0; i < this.curves.length; i++) {
        var curve = this.curves[i];
        if (!curve.active) {
          continue;
        }
        var resolution = curve.getResolution(divisions);
        var pts = curve.getPoints(resolution);
        for (var j = 0; j < pts.length; j++) {
          var point = pts[j];
          if (last && last.equals(point)) {
            continue;
          }
          points.push(point);
          last = point;
        }
      }
      if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
        points.push(points[0]);
      }
      return points;
    },
    getRandomPoint: function(out) {
      if (out === void 0) {
        out = new Vector2();
      }
      return this.getPoint(Math.random(), out);
    },
    getSpacedPoints: function(divisions) {
      if (divisions === void 0) {
        divisions = 40;
      }
      var points = [];
      for (var i = 0; i <= divisions; i++) {
        points.push(this.getPoint(i / divisions));
      }
      if (this.autoClose) {
        points.push(points[0]);
      }
      return points;
    },
    getStartPoint: function(out) {
      if (out === void 0) {
        out = new Vector2();
      }
      return out.copy(this.startPoint);
    },
    getTangent: function(t, out) {
      if (out === void 0) {
        out = new Vector2();
      }
      var d = t * this.getLength();
      var curveLengths = this.getCurveLengths();
      var i = 0;
      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          var diff = curveLengths[i] - d;
          var curve = this.curves[i];
          var segmentLength = curve.getLength();
          var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
          return curve.getTangentAt(u, out);
        }
        i++;
      }
      return null;
    },
    lineTo: function(x, y) {
      if (x instanceof Vector2) {
        this._tmpVec2B.copy(x);
      } else {
        this._tmpVec2B.set(x, y);
      }
      var end = this.getEndPoint(this._tmpVec2A);
      return this.add(new LineCurve([end.x, end.y, this._tmpVec2B.x, this._tmpVec2B.y]));
    },
    splineTo: function(points) {
      points.unshift(this.getEndPoint());
      return this.add(new SplineCurve(points));
    },
    moveTo: function(x, y) {
      if (x instanceof Vector2) {
        return this.add(new MovePathTo(x.x, x.y));
      } else {
        return this.add(new MovePathTo(x, y));
      }
    },
    toJSON: function() {
      var out = [];
      for (var i = 0; i < this.curves.length; i++) {
        out.push(this.curves[i].toJSON());
      }
      return {
        type: "Path",
        x: this.startPoint.x,
        y: this.startPoint.y,
        autoClose: this.autoClose,
        curves: out
      };
    },
    updateArcLengths: function() {
      this.cacheLengths = [];
      this.getCurveLengths();
    },
    destroy: function() {
      this.curves.length = 0;
      this.cacheLengths.length = 0;
      this.startPoint = void 0;
    }
  });
  GameObjectFactory.register("path", function(x, y) {
    return new Path(x, y);
  });
  module2.exports = Path;
});

// node_modules/phaser/src/curves/index.js
var require_curves = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Path: require_Path(),
    MoveTo: require_MoveTo(),
    CubicBezier: require_CubicBezierCurve(),
    Curve: require_Curve(),
    Ellipse: require_EllipseCurve(),
    Line: require_LineCurve(),
    QuadraticBezier: require_QuadraticBezierCurve(),
    Spline: require_SplineCurve()
  };
});

// node_modules/phaser/src/data/DataManagerPlugin.js
var require_DataManagerPlugin = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var DataManager = require_DataManager();
  var PluginCache = require_PluginCache();
  var SceneEvents = require_events5();
  var DataManagerPlugin = new Class({
    Extends: DataManager,
    initialize: function DataManagerPlugin2(scene) {
      DataManager.call(this, scene, scene.sys.events);
      this.scene = scene;
      this.systems = scene.sys;
      scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
      scene.sys.events.on(SceneEvents.START, this.start, this);
    },
    boot: function() {
      this.events = this.systems.events;
      this.events.once(SceneEvents.DESTROY, this.destroy, this);
    },
    start: function() {
      this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    shutdown: function() {
      this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    destroy: function() {
      DataManager.prototype.destroy.call(this);
      this.events.off(SceneEvents.START, this.start, this);
      this.scene = null;
      this.systems = null;
    }
  });
  PluginCache.register("DataManagerPlugin", DataManagerPlugin, "data");
  module2.exports = DataManagerPlugin;
});

// node_modules/phaser/src/data/index.js
var require_data = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    DataManager: require_DataManager(),
    DataManagerPlugin: require_DataManagerPlugin(),
    Events: require_events3()
  };
});

// node_modules/phaser/src/display/align/in/index.js
var require_in = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    BottomCenter: require_BottomCenter2(),
    BottomLeft: require_BottomLeft2(),
    BottomRight: require_BottomRight2(),
    Center: require_Center(),
    LeftCenter: require_LeftCenter2(),
    QuickSet: require_QuickSet2(),
    RightCenter: require_RightCenter2(),
    TopCenter: require_TopCenter2(),
    TopLeft: require_TopLeft2(),
    TopRight: require_TopRight2()
  };
});

// node_modules/phaser/src/display/align/to/index.js
var require_to = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    BottomCenter: require_BottomCenter(),
    BottomLeft: require_BottomLeft(),
    BottomRight: require_BottomRight(),
    LeftBottom: require_LeftBottom(),
    LeftCenter: require_LeftCenter(),
    LeftTop: require_LeftTop(),
    QuickSet: require_QuickSet(),
    RightBottom: require_RightBottom(),
    RightCenter: require_RightCenter(),
    RightTop: require_RightTop(),
    TopCenter: require_TopCenter(),
    TopLeft: require_TopLeft(),
    TopRight: require_TopRight()
  };
});

// node_modules/phaser/src/display/align/index.js
var require_align = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const2();
  var Extend = require_Extend();
  var Align = {
    In: require_in(),
    To: require_to()
  };
  Align = Extend(false, Align, CONST);
  module2.exports = Align;
});

// node_modules/phaser/src/display/shader/BaseShader.js
var require_BaseShader = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var BaseShader = new Class({
    initialize: function BaseShader2(key, fragmentSrc, vertexSrc, uniforms) {
      if (!fragmentSrc || fragmentSrc === "") {
        fragmentSrc = [
          "precision mediump float;",
          "uniform vec2 resolution;",
          "varying vec2 fragCoord;",
          "void main () {",
          "    vec2 uv = fragCoord / resolution.xy;",
          "    gl_FragColor = vec4(uv.xyx, 1.0);",
          "}"
        ].join("\n");
      }
      if (!vertexSrc || vertexSrc === "") {
        vertexSrc = [
          "precision mediump float;",
          "uniform mat4 uProjectionMatrix;",
          "uniform mat4 uViewMatrix;",
          "uniform vec2 uResolution;",
          "attribute vec2 inPosition;",
          "varying vec2 fragCoord;",
          "varying vec2 outTexCoord;",
          "void main () {",
          "   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);",
          "   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);",
          "   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);",
          "}"
        ].join("\n");
      }
      if (uniforms === void 0) {
        uniforms = null;
      }
      this.key = key;
      this.fragmentSrc = fragmentSrc;
      this.vertexSrc = vertexSrc;
      this.uniforms = uniforms;
    }
  });
  module2.exports = BaseShader;
});

// node_modules/phaser/src/display/bounds/GetBounds.js
var require_GetBounds2 = __commonJS((exports2, module2) => {
  /**
   * @author       samme
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetBottom = require_GetBottom();
  var GetLeft = require_GetLeft();
  var GetRight = require_GetRight();
  var GetTop = require_GetTop();
  var GetBounds = function(gameObject, output) {
    if (output === void 0) {
      output = {};
    }
    var left = GetLeft(gameObject);
    var top = GetTop(gameObject);
    output.x = left;
    output.y = top;
    output.width = GetRight(gameObject) - left;
    output.height = GetBottom(gameObject) - top;
    return output;
  };
  module2.exports = GetBounds;
});

// node_modules/phaser/src/display/bounds/GetOffsetX.js
var require_GetOffsetX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetOffsetX = function(gameObject) {
    return gameObject.width * gameObject.originX;
  };
  module2.exports = GetOffsetX;
});

// node_modules/phaser/src/display/bounds/GetOffsetY.js
var require_GetOffsetY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetOffsetY = function(gameObject) {
    return gameObject.height * gameObject.originY;
  };
  module2.exports = GetOffsetY;
});

// node_modules/phaser/src/display/bounds/index.js
var require_bounds = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    CenterOn: require_CenterOn(),
    GetBottom: require_GetBottom(),
    GetBounds: require_GetBounds2(),
    GetCenterX: require_GetCenterX(),
    GetCenterY: require_GetCenterY(),
    GetLeft: require_GetLeft(),
    GetOffsetX: require_GetOffsetX(),
    GetOffsetY: require_GetOffsetY(),
    GetRight: require_GetRight(),
    GetTop: require_GetTop(),
    SetBottom: require_SetBottom(),
    SetCenterX: require_SetCenterX(),
    SetCenterY: require_SetCenterY(),
    SetLeft: require_SetLeft(),
    SetRight: require_SetRight(),
    SetTop: require_SetTop()
  };
});

// node_modules/phaser/src/display/canvas/TouchAction.js
var require_TouchAction = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TouchAction = function(canvas, value) {
    if (value === void 0) {
      value = "none";
    }
    canvas.style["msTouchAction"] = value;
    canvas.style["ms-touch-action"] = value;
    canvas.style["touch-action"] = value;
    return canvas;
  };
  module2.exports = TouchAction;
});

// node_modules/phaser/src/display/canvas/UserSelect.js
var require_UserSelect = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var UserSelect = function(canvas, value) {
    if (value === void 0) {
      value = "none";
    }
    var vendors = [
      "-webkit-",
      "-khtml-",
      "-moz-",
      "-ms-",
      ""
    ];
    vendors.forEach(function(vendor) {
      canvas.style[vendor + "user-select"] = value;
    });
    canvas.style["-webkit-touch-callout"] = value;
    canvas.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
    return canvas;
  };
  module2.exports = UserSelect;
});

// node_modules/phaser/src/display/canvas/index.js
var require_canvas = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    CanvasInterpolation: require_CanvasInterpolation(),
    CanvasPool: require_CanvasPool(),
    Smoothing: require_Smoothing(),
    TouchAction: require_TouchAction(),
    UserSelect: require_UserSelect()
  };
});

// node_modules/phaser/src/display/color/ColorSpectrum.js
var require_ColorSpectrum = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetColor = require_GetColor();
  var ColorSpectrum = function(limit) {
    if (limit === void 0) {
      limit = 1024;
    }
    var colors = [];
    var range = 255;
    var i;
    var r = 255;
    var g = 0;
    var b = 0;
    for (i = 0; i <= range; i++) {
      colors.push({r, g: i, b, color: GetColor(r, i, b)});
    }
    g = 255;
    for (i = range; i >= 0; i--) {
      colors.push({r: i, g, b, color: GetColor(i, g, b)});
    }
    r = 0;
    for (i = 0; i <= range; i++, g--) {
      colors.push({r, g, b: i, color: GetColor(r, g, i)});
    }
    g = 0;
    b = 255;
    for (i = 0; i <= range; i++, b--, r++) {
      colors.push({r, g, b, color: GetColor(r, g, b)});
    }
    if (limit === 1024) {
      return colors;
    } else {
      var out = [];
      var t = 0;
      var inc = 1024 / limit;
      for (i = 0; i < limit; i++) {
        out.push(colors[Math.floor(t)]);
        t += inc;
      }
      return out;
    }
  };
  module2.exports = ColorSpectrum;
});

// node_modules/phaser/src/display/color/ColorToRGBA.js
var require_ColorToRGBA = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ColorToRGBA = function(color) {
    var output = {
      r: color >> 16 & 255,
      g: color >> 8 & 255,
      b: color & 255,
      a: 255
    };
    if (color > 16777215) {
      output.a = color >>> 24;
    }
    return output;
  };
  module2.exports = ColorToRGBA;
});

// node_modules/phaser/src/display/color/ComponentToHex.js
var require_ComponentToHex = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ComponentToHex = function(color) {
    var hex = color.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  };
  module2.exports = ComponentToHex;
});

// node_modules/phaser/src/display/color/HueToComponent.js
var require_HueToComponent = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var HueToComponent = function(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  };
  module2.exports = HueToComponent;
});

// node_modules/phaser/src/display/color/HSLToColor.js
var require_HSLToColor = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Color = require_Color();
  var HueToComponent = require_HueToComponent();
  var HSLToColor = function(h, s, l) {
    var r = l;
    var g = l;
    var b = l;
    if (s !== 0) {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = HueToComponent(p, q, h + 1 / 3);
      g = HueToComponent(p, q, h);
      b = HueToComponent(p, q, h - 1 / 3);
    }
    var color = new Color();
    return color.setGLTo(r, g, b, 1);
  };
  module2.exports = HSLToColor;
});

// node_modules/phaser/src/display/color/HSVColorWheel.js
var require_HSVColorWheel = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var HSVToRGB = require_HSVToRGB();
  var HSVColorWheel = function(s, v) {
    if (s === void 0) {
      s = 1;
    }
    if (v === void 0) {
      v = 1;
    }
    var colors = [];
    for (var c = 0; c <= 359; c++) {
      colors.push(HSVToRGB(c / 359, s, v));
    }
    return colors;
  };
  module2.exports = HSVColorWheel;
});

// node_modules/phaser/src/display/color/Interpolate.js
var require_Interpolate = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Linear = require_Linear2();
  var RGBWithRGB = function(r1, g1, b1, r2, g2, b2, length, index) {
    if (length === void 0) {
      length = 100;
    }
    if (index === void 0) {
      index = 0;
    }
    var t = index / length;
    return {
      r: Linear(r1, r2, t),
      g: Linear(g1, g2, t),
      b: Linear(b1, b2, t)
    };
  };
  var ColorWithColor = function(color1, color2, length, index) {
    if (length === void 0) {
      length = 100;
    }
    if (index === void 0) {
      index = 0;
    }
    return RGBWithRGB(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b, length, index);
  };
  var ColorWithRGB = function(color, r, g, b, length, index) {
    if (length === void 0) {
      length = 100;
    }
    if (index === void 0) {
      index = 0;
    }
    return RGBWithRGB(color.r, color.g, color.b, r, g, b, length, index);
  };
  module2.exports = {
    RGBWithRGB,
    ColorWithRGB,
    ColorWithColor
  };
});

// node_modules/phaser/src/display/color/RandomRGB.js
var require_RandomRGB = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Between = require_Between2();
  var Color = require_Color();
  var RandomRGB = function(min, max) {
    if (min === void 0) {
      min = 0;
    }
    if (max === void 0) {
      max = 255;
    }
    return new Color(Between(min, max), Between(min, max), Between(min, max));
  };
  module2.exports = RandomRGB;
});

// node_modules/phaser/src/display/color/RGBToString.js
var require_RGBToString = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ComponentToHex = require_ComponentToHex();
  var RGBToString = function(r, g, b, a, prefix) {
    if (a === void 0) {
      a = 255;
    }
    if (prefix === void 0) {
      prefix = "#";
    }
    if (prefix === "#") {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);
    } else {
      return "0x" + ComponentToHex(a) + ComponentToHex(r) + ComponentToHex(g) + ComponentToHex(b);
    }
  };
  module2.exports = RGBToString;
});

// node_modules/phaser/src/display/color/index.js
var require_color = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Color = require_Color();
  Color.ColorSpectrum = require_ColorSpectrum();
  Color.ColorToRGBA = require_ColorToRGBA();
  Color.ComponentToHex = require_ComponentToHex();
  Color.GetColor = require_GetColor();
  Color.GetColor32 = require_GetColor32();
  Color.HexStringToColor = require_HexStringToColor();
  Color.HSLToColor = require_HSLToColor();
  Color.HSVColorWheel = require_HSVColorWheel();
  Color.HSVToRGB = require_HSVToRGB();
  Color.HueToComponent = require_HueToComponent();
  Color.IntegerToColor = require_IntegerToColor();
  Color.IntegerToRGB = require_IntegerToRGB();
  Color.Interpolate = require_Interpolate();
  Color.ObjectToColor = require_ObjectToColor();
  Color.RandomRGB = require_RandomRGB();
  Color.RGBStringToColor = require_RGBStringToColor();
  Color.RGBToHSV = require_RGBToHSV();
  Color.RGBToString = require_RGBToString();
  Color.ValueToColor = require_ValueToColor();
  module2.exports = Color;
});

// node_modules/phaser/src/display/mask/index.js
var require_mask = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    BitmapMask: require_BitmapMask(),
    GeometryMask: require_GeometryMask()
  };
});

// node_modules/phaser/src/display/RGB.js
var require_RGB = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var NOOP = require_NOOP();
  var RGB = new Class({
    initialize: function RGB2(red, green, blue) {
      this._rgb = [0, 0, 0];
      this.onChangeCallback = NOOP;
      this.dirty = false;
      this.set(red, green, blue);
    },
    set: function(red, green, blue) {
      if (red === void 0) {
        red = 0;
      }
      if (green === void 0) {
        green = 0;
      }
      if (blue === void 0) {
        blue = 0;
      }
      this._rgb = [red, green, blue];
      this.onChange();
      return this;
    },
    equals: function(red, green, blue) {
      var rgb = this._rgb;
      return rgb.r === red && rgb.g === green && rgb.b === blue;
    },
    onChange: function() {
      this.dirty = true;
      var rgb = this._rgb;
      this.onChangeCallback.call(this, rgb[0], rgb[1], rgb[2]);
    },
    r: {
      get: function() {
        return this._rgb[0];
      },
      set: function(value) {
        this._rgb[0] = value;
        this.onChange();
      }
    },
    g: {
      get: function() {
        return this._rgb[1];
      },
      set: function(value) {
        this._rgb[1] = value;
        this.onChange();
      }
    },
    b: {
      get: function() {
        return this._rgb[2];
      },
      set: function(value) {
        this._rgb[2] = value;
        this.onChange();
      }
    },
    destroy: function() {
      this.onChangeCallback = null;
    }
  });
  module2.exports = RGB;
});

// node_modules/phaser/src/display/index.js
var require_display = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Align: require_align(),
    BaseShader: require_BaseShader(),
    Bounds: require_bounds(),
    Canvas: require_canvas(),
    Color: require_color(),
    ColorMatrix: require_ColorMatrix(),
    Masks: require_mask(),
    RGB: require_RGB()
  };
});

// node_modules/phaser/src/dom/AddToDOM.js
var require_AddToDOM = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AddToDOM = function(element, parent) {
    var target;
    if (parent) {
      if (typeof parent === "string") {
        target = document.getElementById(parent);
      } else if (typeof parent === "object" && parent.nodeType === 1) {
        target = parent;
      }
    } else if (element.parentElement || parent === null) {
      return element;
    }
    if (!target) {
      target = document.body;
    }
    target.appendChild(element);
    return element;
  };
  module2.exports = AddToDOM;
});

// node_modules/phaser/src/dom/DOMContentLoaded.js
var require_DOMContentLoaded = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var OS = require_OS();
  var DOMContentLoaded = function(callback) {
    if (document.readyState === "complete" || document.readyState === "interactive") {
      callback();
      return;
    }
    var check = function() {
      document.removeEventListener("deviceready", check, true);
      document.removeEventListener("DOMContentLoaded", check, true);
      window.removeEventListener("load", check, true);
      callback();
    };
    if (!document.body) {
      window.setTimeout(check, 20);
    } else if (OS.cordova) {
      document.addEventListener("deviceready", check, false);
    } else {
      document.addEventListener("DOMContentLoaded", check, true);
      window.addEventListener("load", check, true);
    }
  };
  module2.exports = DOMContentLoaded;
});

// node_modules/phaser/src/dom/GetInnerHeight.js
var require_GetInnerHeight = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetInnerHeight = function(iOS) {
    if (!iOS) {
      return window.innerHeight;
    }
    var axis = Math.abs(window.orientation);
    var size = {w: 0, h: 0};
    var ruler = document.createElement("div");
    ruler.setAttribute("style", "position: fixed; height: 100vh; width: 0; top: 0");
    document.documentElement.appendChild(ruler);
    size.w = axis === 90 ? ruler.offsetHeight : window.innerWidth;
    size.h = axis === 90 ? window.innerWidth : ruler.offsetHeight;
    document.documentElement.removeChild(ruler);
    ruler = null;
    if (Math.abs(window.orientation) !== 90) {
      return size.h;
    } else {
      return size.w;
    }
  };
  module2.exports = GetInnerHeight;
});

// node_modules/phaser/src/scale/const/CENTER_CONST.js
var require_CENTER_CONST = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    NO_CENTER: 0,
    CENTER_BOTH: 1,
    CENTER_HORIZONTALLY: 2,
    CENTER_VERTICALLY: 3
  };
});

// node_modules/phaser/src/scale/const/ORIENTATION_CONST.js
var require_ORIENTATION_CONST = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    LANDSCAPE: "landscape-primary",
    PORTRAIT: "portrait-primary"
  };
});

// node_modules/phaser/src/scale/const/SCALE_MODE_CONST.js
var require_SCALE_MODE_CONST = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    NONE: 0,
    WIDTH_CONTROLS_HEIGHT: 1,
    HEIGHT_CONTROLS_WIDTH: 2,
    FIT: 3,
    ENVELOP: 4,
    RESIZE: 5
  };
});

// node_modules/phaser/src/scale/const/ZOOM_CONST.js
var require_ZOOM_CONST = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    NO_ZOOM: 1,
    ZOOM_2X: 2,
    ZOOM_4X: 4,
    MAX_ZOOM: -1
  };
});

// node_modules/phaser/src/scale/const/index.js
var require_const8 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = {
    CENTER: require_CENTER_CONST(),
    ORIENTATION: require_ORIENTATION_CONST(),
    SCALE_MODE: require_SCALE_MODE_CONST(),
    ZOOM: require_ZOOM_CONST()
  };
  module2.exports = CONST;
});

// node_modules/phaser/src/dom/GetScreenOrientation.js
var require_GetScreenOrientation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const8();
  var GetScreenOrientation = function(width, height) {
    var screen2 = window.screen;
    var orientation = screen2 ? screen2.orientation || screen2.mozOrientation || screen2.msOrientation : false;
    if (orientation && typeof orientation.type === "string") {
      return orientation.type;
    } else if (typeof orientation === "string") {
      return orientation;
    }
    if (typeof window.orientation === "number") {
      return window.orientation === 0 || window.orientation === 180 ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
    } else if (window.matchMedia) {
      if (window.matchMedia("(orientation: portrait)").matches) {
        return CONST.ORIENTATION.PORTRAIT;
      } else if (window.matchMedia("(orientation: landscape)").matches) {
        return CONST.ORIENTATION.LANDSCAPE;
      }
    } else {
      return height > width ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;
    }
  };
  module2.exports = GetScreenOrientation;
});

// node_modules/phaser/src/dom/GetTarget.js
var require_GetTarget = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTarget = function(element) {
    var target;
    if (element !== "") {
      if (typeof element === "string") {
        target = document.getElementById(element);
      } else if (element && element.nodeType === 1) {
        target = element;
      }
    }
    if (!target) {
      target = document.body;
    }
    return target;
  };
  module2.exports = GetTarget;
});

// node_modules/phaser/src/dom/ParseXML.js
var require_ParseXML = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ParseXML = function(data) {
    var xml = "";
    try {
      if (window["DOMParser"]) {
        var domparser = new DOMParser();
        xml = domparser.parseFromString(data, "text/xml");
      } else {
        xml = new ActiveXObject("Microsoft.XMLDOM");
        xml.loadXML(data);
      }
    } catch (e) {
      xml = null;
    }
    if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
      return null;
    } else {
      return xml;
    }
  };
  module2.exports = ParseXML;
});

// node_modules/phaser/src/dom/RemoveFromDOM.js
var require_RemoveFromDOM = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RemoveFromDOM = function(element) {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  };
  module2.exports = RemoveFromDOM;
});

// node_modules/phaser/src/dom/index.js
var require_dom = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Dom = {
    AddToDOM: require_AddToDOM(),
    DOMContentLoaded: require_DOMContentLoaded(),
    GetInnerHeight: require_GetInnerHeight(),
    GetScreenOrientation: require_GetScreenOrientation(),
    GetTarget: require_GetTarget(),
    ParseXML: require_ParseXML(),
    RemoveFromDOM: require_RemoveFromDOM(),
    RequestAnimationFrame: require_RequestAnimationFrame()
  };
  module2.exports = Dom;
});

// node_modules/phaser/src/events/EventEmitter.js
var require_EventEmitter = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var EE = require_eventemitter3();
  var PluginCache = require_PluginCache();
  var EventEmitter = new Class({
    Extends: EE,
    initialize: function EventEmitter2() {
      EE.call(this);
    },
    shutdown: function() {
      this.removeAllListeners();
    },
    destroy: function() {
      this.removeAllListeners();
    }
  });
  PluginCache.register("EventEmitter", EventEmitter, "events");
  module2.exports = EventEmitter;
});

// node_modules/phaser/src/events/index.js
var require_events12 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {EventEmitter: require_EventEmitter()};
});

// node_modules/phaser/src/dom/CreateDOMContainer.js
var require_CreateDOMContainer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AddToDOM = require_AddToDOM();
  var CreateDOMContainer = function(game2) {
    var config2 = game2.config;
    if (!config2.parent || !config2.domCreateContainer) {
      return;
    }
    var div = document.createElement("div");
    div.style.cssText = [
      "display: block;",
      "width: " + game2.scale.width + "px;",
      "height: " + game2.scale.height + "px;",
      "padding: 0; margin: 0;",
      "position: absolute;",
      "overflow: hidden;",
      "pointer-events: " + config2.domPointerEvents + ";",
      "transform: scale(1);",
      "transform-origin: left top;"
    ].join(" ");
    game2.domContainer = div;
    AddToDOM(div, config2.parent);
  };
  module2.exports = CreateDOMContainer;
});

// node_modules/phaser/src/input/const.js
var require_const9 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var INPUT_CONST = {
    MOUSE_DOWN: 0,
    MOUSE_MOVE: 1,
    MOUSE_UP: 2,
    TOUCH_START: 3,
    TOUCH_MOVE: 4,
    TOUCH_END: 5,
    POINTER_LOCK_CHANGE: 6,
    TOUCH_CANCEL: 7,
    MOUSE_WHEEL: 8
  };
  module2.exports = INPUT_CONST;
});

// node_modules/phaser/src/input/events/BOOT_EVENT.js
var require_BOOT_EVENT4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "boot";
});

// node_modules/phaser/src/input/events/DESTROY_EVENT.js
var require_DESTROY_EVENT7 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "destroy";
});

// node_modules/phaser/src/input/events/DRAG_END_EVENT.js
var require_DRAG_END_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "dragend";
});

// node_modules/phaser/src/input/events/DRAG_ENTER_EVENT.js
var require_DRAG_ENTER_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "dragenter";
});

// node_modules/phaser/src/input/events/DRAG_EVENT.js
var require_DRAG_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "drag";
});

// node_modules/phaser/src/input/events/DRAG_LEAVE_EVENT.js
var require_DRAG_LEAVE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "dragleave";
});

// node_modules/phaser/src/input/events/DRAG_OVER_EVENT.js
var require_DRAG_OVER_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "dragover";
});

// node_modules/phaser/src/input/events/DRAG_START_EVENT.js
var require_DRAG_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "dragstart";
});

// node_modules/phaser/src/input/events/DROP_EVENT.js
var require_DROP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "drop";
});

// node_modules/phaser/src/input/events/GAME_OUT_EVENT.js
var require_GAME_OUT_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "gameout";
});

// node_modules/phaser/src/input/events/GAME_OVER_EVENT.js
var require_GAME_OVER_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "gameover";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_DOWN_EVENT.js
var require_GAMEOBJECT_DOWN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "gameobjectdown";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_END_EVENT.js
var require_GAMEOBJECT_DRAG_END_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "dragend";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_ENTER_EVENT.js
var require_GAMEOBJECT_DRAG_ENTER_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "dragenter";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_EVENT.js
var require_GAMEOBJECT_DRAG_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "drag";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_LEAVE_EVENT.js
var require_GAMEOBJECT_DRAG_LEAVE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "dragleave";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_OVER_EVENT.js
var require_GAMEOBJECT_DRAG_OVER_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "dragover";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_DRAG_START_EVENT.js
var require_GAMEOBJECT_DRAG_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "dragstart";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_DROP_EVENT.js
var require_GAMEOBJECT_DROP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "drop";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_MOVE_EVENT.js
var require_GAMEOBJECT_MOVE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "gameobjectmove";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_OUT_EVENT.js
var require_GAMEOBJECT_OUT_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "gameobjectout";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_OVER_EVENT.js
var require_GAMEOBJECT_OVER_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "gameobjectover";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_DOWN_EVENT.js
var require_GAMEOBJECT_POINTER_DOWN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointerdown";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_MOVE_EVENT.js
var require_GAMEOBJECT_POINTER_MOVE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointermove";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_OUT_EVENT.js
var require_GAMEOBJECT_POINTER_OUT_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointerout";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_OVER_EVENT.js
var require_GAMEOBJECT_POINTER_OVER_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointerover";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_UP_EVENT.js
var require_GAMEOBJECT_POINTER_UP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointerup";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_POINTER_WHEEL_EVENT.js
var require_GAMEOBJECT_POINTER_WHEEL_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "wheel";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_UP_EVENT.js
var require_GAMEOBJECT_UP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "gameobjectup";
});

// node_modules/phaser/src/input/events/GAMEOBJECT_WHEEL_EVENT.js
var require_GAMEOBJECT_WHEEL_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "gameobjectwheel";
});

// node_modules/phaser/src/input/events/MANAGER_BOOT_EVENT.js
var require_MANAGER_BOOT_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "boot";
});

// node_modules/phaser/src/input/events/MANAGER_PROCESS_EVENT.js
var require_MANAGER_PROCESS_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "process";
});

// node_modules/phaser/src/input/events/MANAGER_UPDATE_EVENT.js
var require_MANAGER_UPDATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "update";
});

// node_modules/phaser/src/input/events/POINTER_DOWN_EVENT.js
var require_POINTER_DOWN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointerdown";
});

// node_modules/phaser/src/input/events/POINTER_DOWN_OUTSIDE_EVENT.js
var require_POINTER_DOWN_OUTSIDE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointerdownoutside";
});

// node_modules/phaser/src/input/events/POINTER_MOVE_EVENT.js
var require_POINTER_MOVE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointermove";
});

// node_modules/phaser/src/input/events/POINTER_OUT_EVENT.js
var require_POINTER_OUT_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointerout";
});

// node_modules/phaser/src/input/events/POINTER_OVER_EVENT.js
var require_POINTER_OVER_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointerover";
});

// node_modules/phaser/src/input/events/POINTER_UP_EVENT.js
var require_POINTER_UP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointerup";
});

// node_modules/phaser/src/input/events/POINTER_UP_OUTSIDE_EVENT.js
var require_POINTER_UP_OUTSIDE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointerupoutside";
});

// node_modules/phaser/src/input/events/POINTER_WHEEL_EVENT.js
var require_POINTER_WHEEL_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "wheel";
});

// node_modules/phaser/src/input/events/POINTERLOCK_CHANGE_EVENT.js
var require_POINTERLOCK_CHANGE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pointerlockchange";
});

// node_modules/phaser/src/input/events/PRE_UPDATE_EVENT.js
var require_PRE_UPDATE_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "preupdate";
});

// node_modules/phaser/src/input/events/SHUTDOWN_EVENT.js
var require_SHUTDOWN_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "shutdown";
});

// node_modules/phaser/src/input/events/START_EVENT.js
var require_START_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "start";
});

// node_modules/phaser/src/input/events/UPDATE_EVENT.js
var require_UPDATE_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "update";
});

// node_modules/phaser/src/input/events/index.js
var require_events13 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    BOOT: require_BOOT_EVENT4(),
    DESTROY: require_DESTROY_EVENT7(),
    DRAG_END: require_DRAG_END_EVENT(),
    DRAG_ENTER: require_DRAG_ENTER_EVENT(),
    DRAG: require_DRAG_EVENT(),
    DRAG_LEAVE: require_DRAG_LEAVE_EVENT(),
    DRAG_OVER: require_DRAG_OVER_EVENT(),
    DRAG_START: require_DRAG_START_EVENT(),
    DROP: require_DROP_EVENT(),
    GAME_OUT: require_GAME_OUT_EVENT(),
    GAME_OVER: require_GAME_OVER_EVENT(),
    GAMEOBJECT_DOWN: require_GAMEOBJECT_DOWN_EVENT(),
    GAMEOBJECT_DRAG_END: require_GAMEOBJECT_DRAG_END_EVENT(),
    GAMEOBJECT_DRAG_ENTER: require_GAMEOBJECT_DRAG_ENTER_EVENT(),
    GAMEOBJECT_DRAG: require_GAMEOBJECT_DRAG_EVENT(),
    GAMEOBJECT_DRAG_LEAVE: require_GAMEOBJECT_DRAG_LEAVE_EVENT(),
    GAMEOBJECT_DRAG_OVER: require_GAMEOBJECT_DRAG_OVER_EVENT(),
    GAMEOBJECT_DRAG_START: require_GAMEOBJECT_DRAG_START_EVENT(),
    GAMEOBJECT_DROP: require_GAMEOBJECT_DROP_EVENT(),
    GAMEOBJECT_MOVE: require_GAMEOBJECT_MOVE_EVENT(),
    GAMEOBJECT_OUT: require_GAMEOBJECT_OUT_EVENT(),
    GAMEOBJECT_OVER: require_GAMEOBJECT_OVER_EVENT(),
    GAMEOBJECT_POINTER_DOWN: require_GAMEOBJECT_POINTER_DOWN_EVENT(),
    GAMEOBJECT_POINTER_MOVE: require_GAMEOBJECT_POINTER_MOVE_EVENT(),
    GAMEOBJECT_POINTER_OUT: require_GAMEOBJECT_POINTER_OUT_EVENT(),
    GAMEOBJECT_POINTER_OVER: require_GAMEOBJECT_POINTER_OVER_EVENT(),
    GAMEOBJECT_POINTER_UP: require_GAMEOBJECT_POINTER_UP_EVENT(),
    GAMEOBJECT_POINTER_WHEEL: require_GAMEOBJECT_POINTER_WHEEL_EVENT(),
    GAMEOBJECT_UP: require_GAMEOBJECT_UP_EVENT(),
    GAMEOBJECT_WHEEL: require_GAMEOBJECT_WHEEL_EVENT(),
    MANAGER_BOOT: require_MANAGER_BOOT_EVENT(),
    MANAGER_PROCESS: require_MANAGER_PROCESS_EVENT(),
    MANAGER_UPDATE: require_MANAGER_UPDATE_EVENT(),
    POINTER_DOWN: require_POINTER_DOWN_EVENT(),
    POINTER_DOWN_OUTSIDE: require_POINTER_DOWN_OUTSIDE_EVENT(),
    POINTER_MOVE: require_POINTER_MOVE_EVENT(),
    POINTER_OUT: require_POINTER_OUT_EVENT(),
    POINTER_OVER: require_POINTER_OVER_EVENT(),
    POINTER_UP: require_POINTER_UP_EVENT(),
    POINTER_UP_OUTSIDE: require_POINTER_UP_OUTSIDE_EVENT(),
    POINTER_WHEEL: require_POINTER_WHEEL_EVENT(),
    POINTERLOCK_CHANGE: require_POINTERLOCK_CHANGE_EVENT(),
    PRE_UPDATE: require_PRE_UPDATE_EVENT2(),
    SHUTDOWN: require_SHUTDOWN_EVENT2(),
    START: require_START_EVENT2(),
    UPDATE: require_UPDATE_EVENT2()
  };
});

// node_modules/phaser/src/input/keyboard/keys/KeyCodes.js
var require_KeyCodes = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var KeyCodes = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    PRINT_SCREEN: 42,
    INSERT: 45,
    DELETE: 46,
    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,
    NUMPAD_ZERO: 96,
    NUMPAD_ONE: 97,
    NUMPAD_TWO: 98,
    NUMPAD_THREE: 99,
    NUMPAD_FOUR: 100,
    NUMPAD_FIVE: 101,
    NUMPAD_SIX: 102,
    NUMPAD_SEVEN: 103,
    NUMPAD_EIGHT: 104,
    NUMPAD_NINE: 105,
    NUMPAD_ADD: 107,
    NUMPAD_SUBTRACT: 109,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    SEMICOLON: 186,
    PLUS: 187,
    COMMA: 188,
    MINUS: 189,
    PERIOD: 190,
    FORWARD_SLASH: 191,
    BACK_SLASH: 220,
    QUOTES: 222,
    BACKTICK: 192,
    OPEN_BRACKET: 219,
    CLOSED_BRACKET: 221,
    SEMICOLON_FIREFOX: 59,
    COLON: 58,
    COMMA_FIREFOX_WINDOWS: 60,
    COMMA_FIREFOX: 62,
    BRACKET_RIGHT_FIREFOX: 174,
    BRACKET_LEFT_FIREFOX: 175
  };
  module2.exports = KeyCodes;
});

// node_modules/phaser/src/input/keyboard/KeyboardManager.js
var require_KeyboardManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ArrayRemove = require_Remove();
  var Class = require_Class();
  var GameEvents = require_events();
  var InputEvents = require_events13();
  var KeyCodes = require_KeyCodes();
  var NOOP = require_NOOP();
  var KeyboardManager = new Class({
    initialize: function KeyboardManager2(inputManager) {
      this.manager = inputManager;
      this.queue = [];
      this.preventDefault = true;
      this.captures = [];
      this.enabled = false;
      this.target;
      this.onKeyDown = NOOP;
      this.onKeyUp = NOOP;
      inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
    },
    boot: function() {
      var config2 = this.manager.config;
      this.enabled = config2.inputKeyboard;
      this.target = config2.inputKeyboardEventTarget;
      this.addCapture(config2.inputKeyboardCapture);
      if (!this.target && window) {
        this.target = window;
      }
      if (this.enabled && this.target) {
        this.startListeners();
      }
      this.manager.game.events.on(GameEvents.POST_STEP, this.postUpdate, this);
    },
    startListeners: function() {
      var _this = this;
      this.onKeyDown = function(event) {
        if (event.defaultPrevented || !_this.enabled || !_this.manager) {
          return;
        }
        _this.queue.push(event);
        _this.manager.events.emit(InputEvents.MANAGER_PROCESS);
        var modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey;
        if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1) {
          event.preventDefault();
        }
      };
      this.onKeyUp = function(event) {
        if (event.defaultPrevented || !_this.enabled || !_this.manager) {
          return;
        }
        _this.queue.push(event);
        _this.manager.events.emit(InputEvents.MANAGER_PROCESS);
        var modified = event.altKey || event.ctrlKey || event.shiftKey || event.metaKey;
        if (_this.preventDefault && !modified && _this.captures.indexOf(event.keyCode) > -1) {
          event.preventDefault();
        }
      };
      var target = this.target;
      if (target) {
        target.addEventListener("keydown", this.onKeyDown, false);
        target.addEventListener("keyup", this.onKeyUp, false);
        this.enabled = true;
      }
    },
    stopListeners: function() {
      var target = this.target;
      target.removeEventListener("keydown", this.onKeyDown, false);
      target.removeEventListener("keyup", this.onKeyUp, false);
      this.enabled = false;
    },
    postUpdate: function() {
      this.queue = [];
    },
    addCapture: function(keycode) {
      if (typeof keycode === "string") {
        keycode = keycode.split(",");
      }
      if (!Array.isArray(keycode)) {
        keycode = [keycode];
      }
      var captures = this.captures;
      for (var i = 0; i < keycode.length; i++) {
        var code = keycode[i];
        if (typeof code === "string") {
          code = KeyCodes[code.trim().toUpperCase()];
        }
        if (captures.indexOf(code) === -1) {
          captures.push(code);
        }
      }
      this.preventDefault = captures.length > 0;
    },
    removeCapture: function(keycode) {
      if (typeof keycode === "string") {
        keycode = keycode.split(",");
      }
      if (!Array.isArray(keycode)) {
        keycode = [keycode];
      }
      var captures = this.captures;
      for (var i = 0; i < keycode.length; i++) {
        var code = keycode[i];
        if (typeof code === "string") {
          code = KeyCodes[code.toUpperCase()];
        }
        ArrayRemove(captures, code);
      }
      this.preventDefault = captures.length > 0;
    },
    clearCaptures: function() {
      this.captures = [];
      this.preventDefault = false;
    },
    destroy: function() {
      this.stopListeners();
      this.clearCaptures();
      this.queue = [];
      this.manager.game.events.off(GameEvents.POST_RENDER, this.postUpdate, this);
      this.target = null;
      this.enabled = false;
      this.manager = null;
    }
  });
  module2.exports = KeyboardManager;
});

// node_modules/phaser/src/input/mouse/MouseManager.js
var require_MouseManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Features = require_Features();
  var InputEvents = require_events13();
  var NOOP = require_NOOP();
  var MouseManager = new Class({
    initialize: function MouseManager2(inputManager) {
      this.manager = inputManager;
      this.preventDefaultDown = true;
      this.preventDefaultUp = true;
      this.preventDefaultMove = true;
      this.preventDefaultWheel = false;
      this.enabled = false;
      this.target;
      this.locked = false;
      this.onMouseMove = NOOP;
      this.onMouseDown = NOOP;
      this.onMouseUp = NOOP;
      this.onMouseDownWindow = NOOP;
      this.onMouseUpWindow = NOOP;
      this.onMouseOver = NOOP;
      this.onMouseOut = NOOP;
      this.onMouseWheel = NOOP;
      this.pointerLockChange = NOOP;
      this.isTop = true;
      inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
    },
    boot: function() {
      var config2 = this.manager.config;
      this.enabled = config2.inputMouse;
      this.target = config2.inputMouseEventTarget;
      this.passive = config2.inputMousePassive;
      this.preventDefaultDown = config2.inputMousePreventDefaultDown;
      this.preventDefaultUp = config2.inputMousePreventDefaultUp;
      this.preventDefaultMove = config2.inputMousePreventDefaultMove;
      this.preventDefaultWheel = config2.inputMousePreventDefaultWheel;
      if (!this.target) {
        this.target = this.manager.game.canvas;
      } else if (typeof this.target === "string") {
        this.target = document.getElementById(this.target);
      }
      if (config2.disableContextMenu) {
        this.disableContextMenu();
      }
      if (this.enabled && this.target) {
        this.startListeners();
      }
    },
    disableContextMenu: function() {
      document.body.addEventListener("contextmenu", function(event) {
        event.preventDefault();
        return false;
      });
      return this;
    },
    requestPointerLock: function() {
      if (Features.pointerLock) {
        var element = this.target;
        element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
        element.requestPointerLock();
      }
    },
    releasePointerLock: function() {
      if (Features.pointerLock) {
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
        document.exitPointerLock();
      }
    },
    startListeners: function() {
      var target = this.target;
      if (!target) {
        return;
      }
      var _this = this;
      var manager = this.manager;
      var canvas = manager.canvas;
      var autoFocus = window && window.focus && manager.game.config.autoFocus;
      this.onMouseMove = function(event) {
        if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
          manager.onMouseMove(event);
          if (_this.preventDefaultMove) {
            event.preventDefault();
          }
        }
      };
      this.onMouseDown = function(event) {
        if (autoFocus) {
          window.focus();
        }
        if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
          manager.onMouseDown(event);
          if (_this.preventDefaultDown && event.target === canvas) {
            event.preventDefault();
          }
        }
      };
      this.onMouseDownWindow = function(event) {
        if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
          manager.onMouseDown(event);
        }
      };
      this.onMouseUp = function(event) {
        if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
          manager.onMouseUp(event);
          if (_this.preventDefaultUp && event.target === canvas) {
            event.preventDefault();
          }
        }
      };
      this.onMouseUpWindow = function(event) {
        if (!event.defaultPrevented && _this.enabled && manager && manager.enabled && event.target !== canvas) {
          manager.onMouseUp(event);
        }
      };
      this.onMouseOver = function(event) {
        if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
          manager.setCanvasOver(event);
        }
      };
      this.onMouseOut = function(event) {
        if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
          manager.setCanvasOut(event);
        }
      };
      this.onMouseWheel = function(event) {
        if (!event.defaultPrevented && _this.enabled && manager && manager.enabled) {
          manager.onMouseWheel(event);
        }
        if (_this.preventDefaultWheel && event.target === canvas) {
          event.preventDefault();
        }
      };
      var passive = {passive: true};
      target.addEventListener("mousemove", this.onMouseMove);
      target.addEventListener("mousedown", this.onMouseDown);
      target.addEventListener("mouseup", this.onMouseUp);
      target.addEventListener("mouseover", this.onMouseOver, passive);
      target.addEventListener("mouseout", this.onMouseOut, passive);
      if (this.preventDefaultWheel) {
        target.addEventListener("wheel", this.onMouseWheel, {passive: false});
      } else {
        target.addEventListener("wheel", this.onMouseWheel, passive);
      }
      if (window && manager.game.config.inputWindowEvents) {
        try {
          window.top.addEventListener("mousedown", this.onMouseDownWindow, passive);
          window.top.addEventListener("mouseup", this.onMouseUpWindow, passive);
        } catch (exception) {
          window.addEventListener("mousedown", this.onMouseDownWindow, passive);
          window.addEventListener("mouseup", this.onMouseUpWindow, passive);
          this.isTop = false;
        }
      }
      if (Features.pointerLock) {
        this.pointerLockChange = function(event) {
          var element = _this.target;
          _this.locked = document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ? true : false;
          manager.onPointerLockChange(event);
        };
        document.addEventListener("pointerlockchange", this.pointerLockChange, true);
        document.addEventListener("mozpointerlockchange", this.pointerLockChange, true);
        document.addEventListener("webkitpointerlockchange", this.pointerLockChange, true);
      }
      this.enabled = true;
    },
    stopListeners: function() {
      var target = this.target;
      target.removeEventListener("mousemove", this.onMouseMove);
      target.removeEventListener("mousedown", this.onMouseDown);
      target.removeEventListener("mouseup", this.onMouseUp);
      target.removeEventListener("mouseover", this.onMouseOver);
      target.removeEventListener("mouseout", this.onMouseOut);
      if (window) {
        target = this.isTop ? window.top : window;
        target.removeEventListener("mousedown", this.onMouseDownWindow);
        target.removeEventListener("mouseup", this.onMouseUpWindow);
      }
      if (Features.pointerLock) {
        document.removeEventListener("pointerlockchange", this.pointerLockChange, true);
        document.removeEventListener("mozpointerlockchange", this.pointerLockChange, true);
        document.removeEventListener("webkitpointerlockchange", this.pointerLockChange, true);
      }
    },
    destroy: function() {
      this.stopListeners();
      this.target = null;
      this.enabled = false;
      this.manager = null;
    }
  });
  module2.exports = MouseManager;
});

// node_modules/phaser/src/input/Pointer.js
var require_Pointer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Angle = require_Between();
  var Class = require_Class();
  var Distance = require_DistanceBetween();
  var FuzzyEqual = require_Equal();
  var SmoothStepInterpolation = require_SmoothStepInterpolation();
  var Vector2 = require_Vector2();
  var OS = require_OS();
  var Pointer = new Class({
    initialize: function Pointer2(manager, id) {
      this.manager = manager;
      this.id = id;
      this.event;
      this.downElement;
      this.upElement;
      this.camera = null;
      this.button = 0;
      this.buttons = 0;
      this.position = new Vector2();
      this.prevPosition = new Vector2();
      this.midPoint = new Vector2(-1, -1);
      this.velocity = new Vector2();
      this.angle = 0;
      this.distance = 0;
      this.smoothFactor = 0;
      this.motionFactor = 0.2;
      this.worldX = 0;
      this.worldY = 0;
      this.moveTime = 0;
      this.downX = 0;
      this.downY = 0;
      this.downTime = 0;
      this.upX = 0;
      this.upY = 0;
      this.upTime = 0;
      this.primaryDown = false;
      this.isDown = false;
      this.wasTouch = false;
      this.wasCanceled = false;
      this.movementX = 0;
      this.movementY = 0;
      this.identifier = 0;
      this.pointerId = null;
      this.active = id === 0 ? true : false;
      this.locked = false;
      this.deltaX = 0;
      this.deltaY = 0;
      this.deltaZ = 0;
    },
    updateWorldPoint: function(camera) {
      var temp = camera.getWorldPoint(this.x, this.y);
      this.worldX = temp.x;
      this.worldY = temp.y;
      return this;
    },
    positionToCamera: function(camera, output) {
      return camera.getWorldPoint(this.x, this.y, output);
    },
    updateMotion: function() {
      var cx = this.position.x;
      var cy = this.position.y;
      var mx = this.midPoint.x;
      var my = this.midPoint.y;
      if (cx === mx && cy === my) {
        return;
      }
      var vx = SmoothStepInterpolation(this.motionFactor, mx, cx);
      var vy = SmoothStepInterpolation(this.motionFactor, my, cy);
      if (FuzzyEqual(vx, cx, 0.1)) {
        vx = cx;
      }
      if (FuzzyEqual(vy, cy, 0.1)) {
        vy = cy;
      }
      this.midPoint.set(vx, vy);
      var dx = cx - vx;
      var dy = cy - vy;
      this.velocity.set(dx, dy);
      this.angle = Angle(vx, vy, cx, cy);
      this.distance = Math.sqrt(dx * dx + dy * dy);
    },
    up: function(event) {
      if ("buttons" in event) {
        this.buttons = event.buttons;
      }
      this.event = event;
      this.button = event.button;
      this.upElement = event.target;
      this.manager.transformPointer(this, event.pageX, event.pageY, false);
      if (event.button === 0) {
        this.primaryDown = false;
        this.upX = this.x;
        this.upY = this.y;
      }
      if (this.buttons === 0) {
        this.isDown = false;
        this.upTime = event.timeStamp;
        this.wasTouch = false;
      }
    },
    down: function(event) {
      if ("buttons" in event) {
        this.buttons = event.buttons;
      }
      this.event = event;
      this.button = event.button;
      this.downElement = event.target;
      this.manager.transformPointer(this, event.pageX, event.pageY, false);
      if (event.button === 0) {
        this.primaryDown = true;
        this.downX = this.x;
        this.downY = this.y;
      }
      if (OS.macOS && event.ctrlKey) {
        this.buttons = 2;
        this.primaryDown = false;
      }
      if (!this.isDown) {
        this.isDown = true;
        this.downTime = event.timeStamp;
      }
      this.wasTouch = false;
    },
    move: function(event) {
      if ("buttons" in event) {
        this.buttons = event.buttons;
      }
      this.event = event;
      this.manager.transformPointer(this, event.pageX, event.pageY, true);
      if (this.locked) {
        this.movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
        this.movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
      }
      this.moveTime = event.timeStamp;
      this.wasTouch = false;
    },
    wheel: function(event) {
      if ("buttons" in event) {
        this.buttons = event.buttons;
      }
      this.event = event;
      this.manager.transformPointer(this, event.pageX, event.pageY, false);
      this.deltaX = event.deltaX;
      this.deltaY = event.deltaY;
      this.deltaZ = event.deltaZ;
      this.wasTouch = false;
    },
    touchstart: function(touch, event) {
      if (touch["pointerId"]) {
        this.pointerId = touch.pointerId;
      }
      this.identifier = touch.identifier;
      this.target = touch.target;
      this.active = true;
      this.buttons = 1;
      this.event = event;
      this.downElement = touch.target;
      this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
      this.primaryDown = true;
      this.downX = this.x;
      this.downY = this.y;
      this.downTime = event.timeStamp;
      this.isDown = true;
      this.wasTouch = true;
      this.wasCanceled = false;
      this.updateMotion();
    },
    touchmove: function(touch, event) {
      this.event = event;
      this.manager.transformPointer(this, touch.pageX, touch.pageY, true);
      this.moveTime = event.timeStamp;
      this.wasTouch = true;
      this.updateMotion();
    },
    touchend: function(touch, event) {
      this.buttons = 0;
      this.event = event;
      this.upElement = touch.target;
      this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
      this.primaryDown = false;
      this.upX = this.x;
      this.upY = this.y;
      this.upTime = event.timeStamp;
      this.isDown = false;
      this.wasTouch = true;
      this.wasCanceled = false;
      this.active = false;
      this.updateMotion();
    },
    touchcancel: function(touch, event) {
      this.buttons = 0;
      this.event = event;
      this.upElement = touch.target;
      this.manager.transformPointer(this, touch.pageX, touch.pageY, false);
      this.primaryDown = false;
      this.upX = this.x;
      this.upY = this.y;
      this.upTime = event.timeStamp;
      this.isDown = false;
      this.wasTouch = true;
      this.wasCanceled = true;
      this.active = false;
    },
    noButtonDown: function() {
      return this.buttons === 0;
    },
    leftButtonDown: function() {
      return this.buttons & 1 ? true : false;
    },
    rightButtonDown: function() {
      return this.buttons & 2 ? true : false;
    },
    middleButtonDown: function() {
      return this.buttons & 4 ? true : false;
    },
    backButtonDown: function() {
      return this.buttons & 8 ? true : false;
    },
    forwardButtonDown: function() {
      return this.buttons & 16 ? true : false;
    },
    leftButtonReleased: function() {
      return this.button === 0 && !this.isDown;
    },
    rightButtonReleased: function() {
      return this.button === 2 && !this.isDown;
    },
    middleButtonReleased: function() {
      return this.button === 1 && !this.isDown;
    },
    backButtonReleased: function() {
      return this.button === 3 && !this.isDown;
    },
    forwardButtonReleased: function() {
      return this.button === 4 && !this.isDown;
    },
    getDistance: function() {
      if (this.isDown) {
        return Distance(this.downX, this.downY, this.x, this.y);
      } else {
        return Distance(this.downX, this.downY, this.upX, this.upY);
      }
    },
    getDistanceX: function() {
      if (this.isDown) {
        return Math.abs(this.downX - this.x);
      } else {
        return Math.abs(this.downX - this.upX);
      }
    },
    getDistanceY: function() {
      if (this.isDown) {
        return Math.abs(this.downY - this.y);
      } else {
        return Math.abs(this.downY - this.upY);
      }
    },
    getDuration: function() {
      if (this.isDown) {
        return this.manager.time - this.downTime;
      } else {
        return this.upTime - this.downTime;
      }
    },
    getAngle: function() {
      if (this.isDown) {
        return Angle(this.downX, this.downY, this.x, this.y);
      } else {
        return Angle(this.downX, this.downY, this.upX, this.upY);
      }
    },
    getInterpolatedPosition: function(steps, out) {
      if (steps === void 0) {
        steps = 10;
      }
      if (out === void 0) {
        out = [];
      }
      var prevX = this.prevPosition.x;
      var prevY = this.prevPosition.y;
      var curX = this.position.x;
      var curY = this.position.y;
      for (var i = 0; i < steps; i++) {
        var t = 1 / steps * i;
        out[i] = {x: SmoothStepInterpolation(t, prevX, curX), y: SmoothStepInterpolation(t, prevY, curY)};
      }
      return out;
    },
    destroy: function() {
      this.camera = null;
      this.manager = null;
      this.position = null;
    },
    x: {
      get: function() {
        return this.position.x;
      },
      set: function(value) {
        this.position.x = value;
      }
    },
    y: {
      get: function() {
        return this.position.y;
      },
      set: function(value) {
        this.position.y = value;
      }
    },
    time: {
      get: function() {
        return this.event ? this.event.timeStamp : 0;
      }
    }
  });
  module2.exports = Pointer;
});

// node_modules/phaser/src/input/touch/TouchManager.js
var require_TouchManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var InputEvents = require_events13();
  var NOOP = require_NOOP();
  var TouchManager = new Class({
    initialize: function TouchManager2(inputManager) {
      this.manager = inputManager;
      this.capture = true;
      this.enabled = false;
      this.target;
      this.onTouchStart = NOOP;
      this.onTouchStartWindow = NOOP;
      this.onTouchMove = NOOP;
      this.onTouchEnd = NOOP;
      this.onTouchEndWindow = NOOP;
      this.onTouchCancel = NOOP;
      this.onTouchCancelWindow = NOOP;
      this.onTouchOver = NOOP;
      this.onTouchOut = NOOP;
      inputManager.events.once(InputEvents.MANAGER_BOOT, this.boot, this);
    },
    boot: function() {
      var config2 = this.manager.config;
      this.enabled = config2.inputTouch;
      this.target = config2.inputTouchEventTarget;
      this.capture = config2.inputTouchCapture;
      if (!this.target) {
        this.target = this.manager.game.canvas;
      }
      if (config2.disableContextMenu) {
        this.disableContextMenu();
      }
      if (this.enabled && this.target) {
        this.startListeners();
      }
    },
    disableContextMenu: function() {
      document.body.addEventListener("contextmenu", function(event) {
        event.preventDefault();
        return false;
      });
      return this;
    },
    startListeners: function() {
      var _this = this;
      var canvas = this.manager.canvas;
      var autoFocus = window && window.focus && this.manager.game.config.autoFocus;
      this.onTouchStart = function(event) {
        if (autoFocus) {
          window.focus();
        }
        if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
          _this.manager.onTouchStart(event);
          if (_this.capture && event.cancelable && event.target === canvas) {
            event.preventDefault();
          }
        }
      };
      this.onTouchStartWindow = function(event) {
        if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && event.target !== canvas) {
          _this.manager.onTouchStart(event);
        }
      };
      this.onTouchMove = function(event) {
        if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
          _this.manager.onTouchMove(event);
          if (_this.capture && event.cancelable) {
            event.preventDefault();
          }
        }
      };
      this.onTouchEnd = function(event) {
        if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
          _this.manager.onTouchEnd(event);
          if (_this.capture && event.cancelable && event.target === canvas) {
            event.preventDefault();
          }
        }
      };
      this.onTouchEndWindow = function(event) {
        if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled && event.target !== canvas) {
          _this.manager.onTouchEnd(event);
        }
      };
      this.onTouchCancel = function(event) {
        if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
          _this.manager.onTouchCancel(event);
          if (_this.capture) {
            event.preventDefault();
          }
        }
      };
      this.onTouchCancelWindow = function(event) {
        if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
          _this.manager.onTouchCancel(event);
        }
      };
      this.onTouchOver = function(event) {
        if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
          _this.manager.setCanvasOver(event);
        }
      };
      this.onTouchOut = function(event) {
        if (!event.defaultPrevented && _this.enabled && _this.manager && _this.manager.enabled) {
          _this.manager.setCanvasOut(event);
        }
      };
      var target = this.target;
      if (!target) {
        return;
      }
      var passive = {passive: true};
      var nonPassive = {passive: false};
      target.addEventListener("touchstart", this.onTouchStart, this.capture ? nonPassive : passive);
      target.addEventListener("touchmove", this.onTouchMove, this.capture ? nonPassive : passive);
      target.addEventListener("touchend", this.onTouchEnd, this.capture ? nonPassive : passive);
      target.addEventListener("touchcancel", this.onTouchCancel, this.capture ? nonPassive : passive);
      target.addEventListener("touchover", this.onTouchOver, this.capture ? nonPassive : passive);
      target.addEventListener("touchout", this.onTouchOut, this.capture ? nonPassive : passive);
      if (window && this.manager.game.config.inputWindowEvents) {
        window.addEventListener("touchstart", this.onTouchStartWindow, nonPassive);
        window.addEventListener("touchend", this.onTouchEndWindow, nonPassive);
        window.addEventListener("touchcancel", this.onTouchCancelWindow, nonPassive);
      }
      this.enabled = true;
    },
    stopListeners: function() {
      var target = this.target;
      target.removeEventListener("touchstart", this.onTouchStart);
      target.removeEventListener("touchmove", this.onTouchMove);
      target.removeEventListener("touchend", this.onTouchEnd);
      target.removeEventListener("touchcancel", this.onTouchCancel);
      target.removeEventListener("touchover", this.onTouchOver);
      target.removeEventListener("touchout", this.onTouchOut);
      if (window) {
        window.removeEventListener("touchstart", this.onTouchStartWindow);
        window.removeEventListener("touchend", this.onTouchEndWindow);
      }
    },
    destroy: function() {
      this.stopListeners();
      this.target = null;
      this.enabled = false;
      this.manager = null;
    }
  });
  module2.exports = TouchManager;
});

// node_modules/phaser/src/input/InputManager.js
var require_InputManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const9();
  var EventEmitter = require_eventemitter3();
  var Events = require_events13();
  var GameEvents = require_events();
  var Keyboard = require_KeyboardManager();
  var Mouse = require_MouseManager();
  var Pointer = require_Pointer();
  var Touch = require_TouchManager();
  var TransformMatrix = require_TransformMatrix();
  var TransformXY = require_TransformXY();
  var InputManager = new Class({
    initialize: function InputManager2(game2, config2) {
      this.game = game2;
      this.scaleManager;
      this.canvas;
      this.config = config2;
      this.enabled = true;
      this.events = new EventEmitter();
      this.isOver = true;
      this.defaultCursor = "";
      this.keyboard = config2.inputKeyboard ? new Keyboard(this) : null;
      this.mouse = config2.inputMouse ? new Mouse(this) : null;
      this.touch = config2.inputTouch ? new Touch(this) : null;
      this.pointers = [];
      this.pointersTotal = config2.inputActivePointers;
      if (config2.inputTouch && this.pointersTotal === 1) {
        this.pointersTotal = 2;
      }
      for (var i = 0; i <= this.pointersTotal; i++) {
        var pointer = new Pointer(this, i);
        pointer.smoothFactor = config2.inputSmoothFactor;
        this.pointers.push(pointer);
      }
      this.mousePointer = config2.inputMouse ? this.pointers[0] : null;
      this.activePointer = this.pointers[0];
      this.globalTopOnly = true;
      this.time = 0;
      this._tempPoint = {x: 0, y: 0};
      this._tempHitTest = [];
      this._tempMatrix = new TransformMatrix();
      this._tempMatrix2 = new TransformMatrix();
      this._tempSkip = false;
      this.mousePointerContainer = [this.mousePointer];
      game2.events.once(GameEvents.BOOT, this.boot, this);
    },
    boot: function() {
      this.canvas = this.game.canvas;
      this.scaleManager = this.game.scale;
      this.events.emit(Events.MANAGER_BOOT);
      this.game.events.on(GameEvents.PRE_RENDER, this.preRender, this);
      this.game.events.once(GameEvents.DESTROY, this.destroy, this);
    },
    setCanvasOver: function(event) {
      this.isOver = true;
      this.events.emit(Events.GAME_OVER, event);
    },
    setCanvasOut: function(event) {
      this.isOver = false;
      this.events.emit(Events.GAME_OUT, event);
    },
    preRender: function() {
      var time = this.game.loop.now;
      var delta = this.game.loop.delta;
      var scenes = this.game.scene.getScenes(true, true);
      this.time = time;
      this.events.emit(Events.MANAGER_UPDATE);
      for (var i = 0; i < scenes.length; i++) {
        var scene = scenes[i];
        if (scene.sys.input && scene.sys.input.updatePoll(time, delta) && this.globalTopOnly) {
          return;
        }
      }
    },
    setDefaultCursor: function(cursor) {
      this.defaultCursor = cursor;
      if (this.canvas.style.cursor !== cursor) {
        this.canvas.style.cursor = cursor;
      }
    },
    setCursor: function(interactiveObject) {
      if (interactiveObject.cursor) {
        this.canvas.style.cursor = interactiveObject.cursor;
      }
    },
    resetCursor: function(interactiveObject) {
      if (interactiveObject.cursor && this.canvas) {
        this.canvas.style.cursor = this.defaultCursor;
      }
    },
    addPointer: function(quantity) {
      if (quantity === void 0) {
        quantity = 1;
      }
      var output = [];
      if (this.pointersTotal + quantity > 10) {
        quantity = 10 - this.pointersTotal;
      }
      for (var i = 0; i < quantity; i++) {
        var id = this.pointers.length;
        var pointer = new Pointer(this, id);
        pointer.smoothFactor = this.config.inputSmoothFactor;
        this.pointers.push(pointer);
        this.pointersTotal++;
        output.push(pointer);
      }
      return output;
    },
    updateInputPlugins: function(type, pointers) {
      var scenes = this.game.scene.getScenes(true, true);
      this._tempSkip = false;
      for (var i = 0; i < scenes.length; i++) {
        var scene = scenes[i];
        if (scene.sys.input) {
          var capture = scene.sys.input.update(type, pointers);
          if (capture && this.globalTopOnly || this._tempSkip) {
            return;
          }
        }
      }
    },
    onTouchStart: function(event) {
      var pointers = this.pointers;
      var changed = [];
      for (var c = 0; c < event.changedTouches.length; c++) {
        var changedTouch = event.changedTouches[c];
        for (var i = 1; i < this.pointersTotal; i++) {
          var pointer = pointers[i];
          if (!pointer.active) {
            pointer.touchstart(changedTouch, event);
            this.activePointer = pointer;
            changed.push(pointer);
            break;
          }
        }
      }
      this.updateInputPlugins(CONST.TOUCH_START, changed);
    },
    onTouchMove: function(event) {
      var pointers = this.pointers;
      var changed = [];
      for (var c = 0; c < event.changedTouches.length; c++) {
        var changedTouch = event.changedTouches[c];
        for (var i = 1; i < this.pointersTotal; i++) {
          var pointer = pointers[i];
          if (pointer.active && pointer.identifier === changedTouch.identifier) {
            pointer.touchmove(changedTouch, event);
            this.activePointer = pointer;
            changed.push(pointer);
            break;
          }
        }
      }
      this.updateInputPlugins(CONST.TOUCH_MOVE, changed);
    },
    onTouchEnd: function(event) {
      var pointers = this.pointers;
      var changed = [];
      for (var c = 0; c < event.changedTouches.length; c++) {
        var changedTouch = event.changedTouches[c];
        for (var i = 1; i < this.pointersTotal; i++) {
          var pointer = pointers[i];
          if (pointer.active && pointer.identifier === changedTouch.identifier) {
            pointer.touchend(changedTouch, event);
            changed.push(pointer);
            break;
          }
        }
      }
      this.updateInputPlugins(CONST.TOUCH_END, changed);
    },
    onTouchCancel: function(event) {
      var pointers = this.pointers;
      var changed = [];
      for (var c = 0; c < event.changedTouches.length; c++) {
        var changedTouch = event.changedTouches[c];
        for (var i = 1; i < this.pointersTotal; i++) {
          var pointer = pointers[i];
          if (pointer.active && pointer.identifier === changedTouch.identifier) {
            pointer.touchcancel(changedTouch, event);
            changed.push(pointer);
            break;
          }
        }
      }
      this.updateInputPlugins(CONST.TOUCH_CANCEL, changed);
    },
    onMouseDown: function(event) {
      var mousePointer = this.mousePointer;
      mousePointer.down(event);
      mousePointer.updateMotion();
      this.activePointer = mousePointer;
      this.updateInputPlugins(CONST.MOUSE_DOWN, this.mousePointerContainer);
    },
    onMouseMove: function(event) {
      var mousePointer = this.mousePointer;
      mousePointer.move(event);
      mousePointer.updateMotion();
      this.activePointer = mousePointer;
      this.updateInputPlugins(CONST.MOUSE_MOVE, this.mousePointerContainer);
    },
    onMouseUp: function(event) {
      var mousePointer = this.mousePointer;
      mousePointer.up(event);
      mousePointer.updateMotion();
      this.activePointer = mousePointer;
      this.updateInputPlugins(CONST.MOUSE_UP, this.mousePointerContainer);
    },
    onMouseWheel: function(event) {
      var mousePointer = this.mousePointer;
      mousePointer.wheel(event);
      this.activePointer = mousePointer;
      this.updateInputPlugins(CONST.MOUSE_WHEEL, this.mousePointerContainer);
    },
    onPointerLockChange: function(event) {
      var isLocked = this.mouse.locked;
      this.mousePointer.locked = isLocked;
      this.events.emit(Events.POINTERLOCK_CHANGE, event, isLocked);
    },
    inputCandidate: function(gameObject, camera) {
      var input = gameObject.input;
      if (!input || !input.enabled || !input.alwaysEnabled && !gameObject.willRender(camera)) {
        return false;
      }
      var visible = true;
      var parent = gameObject.parentContainer;
      if (parent) {
        do {
          if (!parent.willRender(camera)) {
            visible = false;
            break;
          }
          parent = parent.parentContainer;
        } while (parent);
      }
      return visible;
    },
    hitTest: function(pointer, gameObjects, camera, output) {
      if (output === void 0) {
        output = this._tempHitTest;
      }
      var tempPoint = this._tempPoint;
      var csx = camera.scrollX;
      var csy = camera.scrollY;
      output.length = 0;
      var x = pointer.x;
      var y = pointer.y;
      camera.getWorldPoint(x, y, tempPoint);
      pointer.worldX = tempPoint.x;
      pointer.worldY = tempPoint.y;
      var point = {x: 0, y: 0};
      var matrix = this._tempMatrix;
      var parentMatrix = this._tempMatrix2;
      for (var i = 0; i < gameObjects.length; i++) {
        var gameObject = gameObjects[i];
        if (!this.inputCandidate(gameObject, camera)) {
          continue;
        }
        var px = tempPoint.x + csx * gameObject.scrollFactorX - csx;
        var py = tempPoint.y + csy * gameObject.scrollFactorY - csy;
        if (gameObject.parentContainer) {
          gameObject.getWorldTransformMatrix(matrix, parentMatrix);
          matrix.applyInverse(px, py, point);
        } else {
          TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, point);
        }
        if (this.pointWithinHitArea(gameObject, point.x, point.y)) {
          output.push(gameObject);
        }
      }
      return output;
    },
    pointWithinHitArea: function(gameObject, x, y) {
      x += gameObject.displayOriginX;
      y += gameObject.displayOriginY;
      var input = gameObject.input;
      if (input && input.hitAreaCallback(input.hitArea, x, y, gameObject)) {
        input.localX = x;
        input.localY = y;
        return true;
      } else {
        return false;
      }
    },
    pointWithinInteractiveObject: function(object, x, y) {
      if (!object.hitArea) {
        return false;
      }
      x += object.gameObject.displayOriginX;
      y += object.gameObject.displayOriginY;
      object.localX = x;
      object.localY = y;
      return object.hitAreaCallback(object.hitArea, x, y, object);
    },
    transformPointer: function(pointer, pageX, pageY, wasMove) {
      var p0 = pointer.position;
      var p1 = pointer.prevPosition;
      p1.x = p0.x;
      p1.y = p0.y;
      var x = this.scaleManager.transformX(pageX);
      var y = this.scaleManager.transformY(pageY);
      var a = pointer.smoothFactor;
      if (!wasMove || a === 0) {
        p0.x = x;
        p0.y = y;
      } else {
        p0.x = x * a + p1.x * (1 - a);
        p0.y = y * a + p1.y * (1 - a);
      }
    },
    destroy: function() {
      this.events.removeAllListeners();
      this.game.events.off(GameEvents.PRE_RENDER);
      if (this.keyboard) {
        this.keyboard.destroy();
      }
      if (this.mouse) {
        this.mouse.destroy();
      }
      if (this.touch) {
        this.touch.destroy();
      }
      for (var i = 0; i < this.pointers.length; i++) {
        this.pointers[i].destroy();
      }
      this.pointers = [];
      this._tempHitTest = [];
      this._tempMatrix.destroy();
      this.canvas = null;
      this.game = null;
    }
  });
  module2.exports = InputManager;
});

// node_modules/phaser/src/loader/FileTypesManager.js
var require_FileTypesManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var types = {};
  var FileTypesManager = {
    install: function(loader) {
      for (var key in types) {
        loader[key] = types[key];
      }
    },
    register: function(key, factoryFunction) {
      types[key] = factoryFunction;
    },
    destroy: function() {
      types = {};
    }
  };
  module2.exports = FileTypesManager;
});

// node_modules/phaser/src/gameobjects/GameObjectCreator.js
var require_GameObjectCreator = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var PluginCache = require_PluginCache();
  var SceneEvents = require_events5();
  var GameObjectCreator = new Class({
    initialize: function GameObjectCreator2(scene) {
      this.scene = scene;
      this.systems = scene.sys;
      this.events = scene.sys.events;
      this.displayList;
      this.updateList;
      this.events.once(SceneEvents.BOOT, this.boot, this);
      this.events.on(SceneEvents.START, this.start, this);
    },
    boot: function() {
      this.displayList = this.systems.displayList;
      this.updateList = this.systems.updateList;
      this.events.once(SceneEvents.DESTROY, this.destroy, this);
    },
    start: function() {
      this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    shutdown: function() {
      this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    destroy: function() {
      this.shutdown();
      this.events.off(SceneEvents.START, this.start, this);
      this.scene = null;
      this.systems = null;
      this.events = null;
      this.displayList = null;
      this.updateList = null;
    }
  });
  GameObjectCreator.register = function(factoryType, factoryFunction) {
    if (!GameObjectCreator.prototype.hasOwnProperty(factoryType)) {
      GameObjectCreator.prototype[factoryType] = factoryFunction;
    }
  };
  GameObjectCreator.remove = function(factoryType) {
    if (GameObjectCreator.prototype.hasOwnProperty(factoryType)) {
      delete GameObjectCreator.prototype[factoryType];
    }
  };
  PluginCache.register("GameObjectCreator", GameObjectCreator, "make");
  module2.exports = GameObjectCreator;
});

// node_modules/phaser/src/plugins/PluginManager.js
var require_PluginManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GameEvents = require_events();
  var EventEmitter = require_eventemitter3();
  var FileTypesManager = require_FileTypesManager();
  var GameObjectCreator = require_GameObjectCreator();
  var GameObjectFactory = require_GameObjectFactory();
  var GetFastValue = require_GetFastValue();
  var PluginCache = require_PluginCache();
  var Remove = require_Remove();
  var PluginManager = new Class({
    Extends: EventEmitter,
    initialize: function PluginManager2(game2) {
      EventEmitter.call(this);
      this.game = game2;
      this.plugins = [];
      this.scenePlugins = [];
      this._pendingGlobal = [];
      this._pendingScene = [];
      if (game2.isBooted) {
        this.boot();
      } else {
        game2.events.once(GameEvents.BOOT, this.boot, this);
      }
    },
    boot: function() {
      var i;
      var entry;
      var key;
      var plugin;
      var start;
      var mapping;
      var data;
      var config2 = this.game.config;
      var list = config2.installGlobalPlugins;
      list = list.concat(this._pendingGlobal);
      for (i = 0; i < list.length; i++) {
        entry = list[i];
        key = GetFastValue(entry, "key", null);
        plugin = GetFastValue(entry, "plugin", null);
        start = GetFastValue(entry, "start", false);
        mapping = GetFastValue(entry, "mapping", null);
        data = GetFastValue(entry, "data", null);
        if (key) {
          if (plugin) {
            this.install(key, plugin, start, mapping, data);
          } else {
            console.warn("Missing `plugin` for key: " + key);
          }
        }
      }
      list = config2.installScenePlugins;
      list = list.concat(this._pendingScene);
      for (i = 0; i < list.length; i++) {
        entry = list[i];
        key = GetFastValue(entry, "key", null);
        plugin = GetFastValue(entry, "plugin", null);
        mapping = GetFastValue(entry, "mapping", null);
        if (key) {
          if (plugin) {
            this.installScenePlugin(key, plugin, mapping);
          } else {
            console.warn("Missing `plugin` for key: " + key);
          }
        }
      }
      this._pendingGlobal = [];
      this._pendingScene = [];
      this.game.events.once(GameEvents.DESTROY, this.destroy, this);
    },
    addToScene: function(sys, globalPlugins, scenePlugins) {
      var i;
      var pluginKey;
      var pluginList;
      var game2 = this.game;
      var scene = sys.scene;
      var map = sys.settings.map;
      var isBooted = sys.settings.isBooted;
      for (i = 0; i < globalPlugins.length; i++) {
        pluginKey = globalPlugins[i];
        if (game2[pluginKey]) {
          sys[pluginKey] = game2[pluginKey];
          if (map.hasOwnProperty(pluginKey)) {
            scene[map[pluginKey]] = sys[pluginKey];
          }
        } else if (pluginKey === "game" && map.hasOwnProperty(pluginKey)) {
          scene[map[pluginKey]] = game2;
        }
      }
      for (var s = 0; s < scenePlugins.length; s++) {
        pluginList = scenePlugins[s];
        for (i = 0; i < pluginList.length; i++) {
          pluginKey = pluginList[i];
          if (!PluginCache.hasCore(pluginKey)) {
            continue;
          }
          var source = PluginCache.getCore(pluginKey);
          var mapKey = source.mapping;
          var plugin = new source.plugin(scene, this, mapKey);
          sys[mapKey] = plugin;
          if (source.custom) {
            scene[mapKey] = plugin;
          } else if (map.hasOwnProperty(mapKey)) {
            scene[map[mapKey]] = plugin;
          }
          if (isBooted) {
            plugin.boot();
          }
        }
      }
      pluginList = this.plugins;
      for (i = 0; i < pluginList.length; i++) {
        var entry = pluginList[i];
        if (entry.mapping) {
          scene[entry.mapping] = entry.plugin;
        }
      }
    },
    getDefaultScenePlugins: function() {
      var list = this.game.config.defaultPlugins;
      list = list.concat(this.scenePlugins);
      return list;
    },
    installScenePlugin: function(key, plugin, mapping, addToScene, fromLoader) {
      if (fromLoader === void 0) {
        fromLoader = false;
      }
      if (typeof plugin !== "function") {
        console.warn("Invalid Scene Plugin: " + key);
        return;
      }
      if (!PluginCache.hasCore(key)) {
        PluginCache.register(key, plugin, mapping, true);
        this.scenePlugins.push(key);
      } else if (!fromLoader && PluginCache.hasCore(key)) {
        console.warn("Scene Plugin key in use: " + key);
        return;
      }
      if (addToScene) {
        var instance = new plugin(addToScene, this, key);
        addToScene.sys[key] = instance;
        if (mapping && mapping !== "") {
          addToScene[mapping] = instance;
        }
        instance.boot();
      }
    },
    install: function(key, plugin, start, mapping, data) {
      if (start === void 0) {
        start = false;
      }
      if (mapping === void 0) {
        mapping = null;
      }
      if (data === void 0) {
        data = null;
      }
      if (typeof plugin !== "function") {
        console.warn("Invalid Plugin: " + key);
        return null;
      }
      if (PluginCache.hasCustom(key)) {
        console.warn("Plugin key in use: " + key);
        return null;
      }
      if (mapping !== null) {
        start = true;
      }
      if (!this.game.isBooted) {
        this._pendingGlobal.push({key, plugin, start, mapping, data});
      } else {
        PluginCache.registerCustom(key, plugin, mapping, data);
        if (start) {
          return this.start(key);
        }
      }
      return null;
    },
    getIndex: function(key) {
      var list = this.plugins;
      for (var i = 0; i < list.length; i++) {
        var entry = list[i];
        if (entry.key === key) {
          return i;
        }
      }
      return -1;
    },
    getEntry: function(key) {
      var idx = this.getIndex(key);
      if (idx !== -1) {
        return this.plugins[idx];
      }
    },
    isActive: function(key) {
      var entry = this.getEntry(key);
      return entry && entry.active;
    },
    start: function(key, runAs) {
      if (runAs === void 0) {
        runAs = key;
      }
      var entry = this.getEntry(runAs);
      if (entry && !entry.active) {
        entry.active = true;
        entry.plugin.start();
      } else if (!entry) {
        entry = this.createEntry(key, runAs);
      }
      return entry ? entry.plugin : null;
    },
    createEntry: function(key, runAs) {
      var entry = PluginCache.getCustom(key);
      if (entry) {
        var instance = new entry.plugin(this);
        entry = {
          key: runAs,
          plugin: instance,
          active: true,
          mapping: entry.mapping,
          data: entry.data
        };
        this.plugins.push(entry);
        instance.init(entry.data);
        instance.start();
      }
      return entry;
    },
    stop: function(key) {
      var entry = this.getEntry(key);
      if (entry && entry.active) {
        entry.active = false;
        entry.plugin.stop();
      }
      return this;
    },
    get: function(key, autoStart) {
      if (autoStart === void 0) {
        autoStart = true;
      }
      var entry = this.getEntry(key);
      if (entry) {
        return entry.plugin;
      } else {
        var plugin = this.getClass(key);
        if (plugin && autoStart) {
          entry = this.createEntry(key, key);
          return entry ? entry.plugin : null;
        } else if (plugin) {
          return plugin;
        }
      }
      return null;
    },
    getClass: function(key) {
      return PluginCache.getCustomClass(key);
    },
    removeGlobalPlugin: function(key) {
      var entry = this.getEntry(key);
      if (entry) {
        Remove(this.plugins, entry);
      }
      PluginCache.removeCustom(key);
    },
    removeScenePlugin: function(key) {
      Remove(this.scenePlugins, key);
      PluginCache.remove(key);
    },
    registerGameObject: function(key, factoryCallback, creatorCallback) {
      if (factoryCallback) {
        GameObjectFactory.register(key, factoryCallback);
      }
      if (creatorCallback) {
        GameObjectCreator.register(key, creatorCallback);
      }
      return this;
    },
    removeGameObject: function(key, removeFromFactory, removeFromCreator) {
      if (removeFromFactory === void 0) {
        removeFromFactory = true;
      }
      if (removeFromCreator === void 0) {
        removeFromCreator = true;
      }
      if (removeFromFactory) {
        GameObjectFactory.remove(key);
      }
      if (removeFromCreator) {
        GameObjectCreator.remove(key);
      }
      return this;
    },
    registerFileType: function(key, callback, addToScene) {
      FileTypesManager.register(key, callback);
      if (addToScene && addToScene.sys.load) {
        addToScene.sys.load[key] = callback;
      }
    },
    destroy: function() {
      for (var i = 0; i < this.plugins.length; i++) {
        this.plugins[i].plugin.destroy();
      }
      PluginCache.destroyCustomPlugins();
      if (this.game.noReturn) {
        PluginCache.destroyCorePlugins();
      }
      this.game = null;
      this.plugins = [];
      this.scenePlugins = [];
    }
  });
  module2.exports = PluginManager;
});

// node_modules/phaser/src/structs/Size.js
var require_Size2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = require_Clamp();
  var Class = require_Class();
  var SnapFloor = require_SnapFloor();
  var Vector2 = require_Vector2();
  var Size = new Class({
    initialize: function Size2(width, height, aspectMode, parent) {
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = width;
      }
      if (aspectMode === void 0) {
        aspectMode = 0;
      }
      if (parent === void 0) {
        parent = null;
      }
      this._width = width;
      this._height = height;
      this._parent = parent;
      this.aspectMode = aspectMode;
      this.aspectRatio = height === 0 ? 1 : width / height;
      this.minWidth = 0;
      this.minHeight = 0;
      this.maxWidth = Number.MAX_VALUE;
      this.maxHeight = Number.MAX_VALUE;
      this.snapTo = new Vector2();
    },
    setAspectMode: function(value) {
      if (value === void 0) {
        value = 0;
      }
      this.aspectMode = value;
      return this.setSize(this._width, this._height);
    },
    setSnap: function(snapWidth, snapHeight) {
      if (snapWidth === void 0) {
        snapWidth = 0;
      }
      if (snapHeight === void 0) {
        snapHeight = snapWidth;
      }
      this.snapTo.set(snapWidth, snapHeight);
      return this.setSize(this._width, this._height);
    },
    setParent: function(parent) {
      this._parent = parent;
      return this.setSize(this._width, this._height);
    },
    setMin: function(width, height) {
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = width;
      }
      this.minWidth = Clamp(width, 0, this.maxWidth);
      this.minHeight = Clamp(height, 0, this.maxHeight);
      return this.setSize(this._width, this._height);
    },
    setMax: function(width, height) {
      if (width === void 0) {
        width = Number.MAX_VALUE;
      }
      if (height === void 0) {
        height = width;
      }
      this.maxWidth = Clamp(width, this.minWidth, Number.MAX_VALUE);
      this.maxHeight = Clamp(height, this.minHeight, Number.MAX_VALUE);
      return this.setSize(this._width, this._height);
    },
    setSize: function(width, height) {
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = width;
      }
      switch (this.aspectMode) {
        case Size.NONE:
          this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
          this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
          this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
          break;
        case Size.WIDTH_CONTROLS_HEIGHT:
          this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
          this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), false);
          break;
        case Size.HEIGHT_CONTROLS_WIDTH:
          this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
          this._width = this.getNewWidth(this._height * this.aspectRatio, false);
          break;
        case Size.FIT:
          this.constrain(width, height, true);
          break;
        case Size.ENVELOP:
          this.constrain(width, height, false);
          break;
      }
      return this;
    },
    setAspectRatio: function(ratio) {
      this.aspectRatio = ratio;
      return this.setSize(this._width, this._height);
    },
    resize: function(width, height) {
      this._width = this.getNewWidth(SnapFloor(width, this.snapTo.x));
      this._height = this.getNewHeight(SnapFloor(height, this.snapTo.y));
      this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
      return this;
    },
    getNewWidth: function(value, checkParent) {
      if (checkParent === void 0) {
        checkParent = true;
      }
      value = Clamp(value, this.minWidth, this.maxWidth);
      if (checkParent && this._parent && value > this._parent.width) {
        value = Math.max(this.minWidth, this._parent.width);
      }
      return value;
    },
    getNewHeight: function(value, checkParent) {
      if (checkParent === void 0) {
        checkParent = true;
      }
      value = Clamp(value, this.minHeight, this.maxHeight);
      if (checkParent && this._parent && value > this._parent.height) {
        value = Math.max(this.minHeight, this._parent.height);
      }
      return value;
    },
    constrain: function(width, height, fit) {
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = width;
      }
      if (fit === void 0) {
        fit = true;
      }
      width = this.getNewWidth(width);
      height = this.getNewHeight(height);
      var snap = this.snapTo;
      var newRatio = height === 0 ? 1 : width / height;
      if (fit && this.aspectRatio > newRatio || !fit && this.aspectRatio < newRatio) {
        width = SnapFloor(width, snap.x);
        height = width / this.aspectRatio;
        if (snap.y > 0) {
          height = SnapFloor(height, snap.y);
          width = height * this.aspectRatio;
        }
      } else if (fit && this.aspectRatio < newRatio || !fit && this.aspectRatio > newRatio) {
        height = SnapFloor(height, snap.y);
        width = height * this.aspectRatio;
        if (snap.x > 0) {
          width = SnapFloor(width, snap.x);
          height = width * (1 / this.aspectRatio);
        }
      }
      this._width = width;
      this._height = height;
      return this;
    },
    fitTo: function(width, height) {
      return this.constrain(width, height, true);
    },
    envelop: function(width, height) {
      return this.constrain(width, height, false);
    },
    setWidth: function(value) {
      return this.setSize(value, this._height);
    },
    setHeight: function(value) {
      return this.setSize(this._width, value);
    },
    toString: function() {
      return "[{ Size (width=" + this._width + " height=" + this._height + " aspectRatio=" + this.aspectRatio + " aspectMode=" + this.aspectMode + ") }]";
    },
    setCSS: function(element) {
      if (element && element.style) {
        element.style.width = this._width + "px";
        element.style.height = this._height + "px";
      }
    },
    copy: function(destination) {
      destination.setAspectMode(this.aspectMode);
      destination.aspectRatio = this.aspectRatio;
      return destination.setSize(this.width, this.height);
    },
    destroy: function() {
      this._parent = null;
      this.snapTo = null;
    },
    width: {
      get: function() {
        return this._width;
      },
      set: function(value) {
        this.setSize(value, this._height);
      }
    },
    height: {
      get: function() {
        return this._height;
      },
      set: function(value) {
        this.setSize(this._width, value);
      }
    }
  });
  Size.NONE = 0;
  Size.WIDTH_CONTROLS_HEIGHT = 1;
  Size.HEIGHT_CONTROLS_WIDTH = 2;
  Size.FIT = 3;
  Size.ENVELOP = 4;
  module2.exports = Size;
});

// node_modules/phaser/src/scale/ScaleManager.js
var require_ScaleManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const8();
  var Class = require_Class();
  var EventEmitter = require_eventemitter3();
  var Events = require_events9();
  var GameEvents = require_events();
  var GetInnerHeight = require_GetInnerHeight();
  var GetTarget = require_GetTarget();
  var GetScreenOrientation = require_GetScreenOrientation();
  var NOOP = require_NOOP();
  var Rectangle = require_Rectangle();
  var Size = require_Size2();
  var SnapFloor = require_SnapFloor();
  var Vector2 = require_Vector2();
  var ScaleManager = new Class({
    Extends: EventEmitter,
    initialize: function ScaleManager2(game2) {
      EventEmitter.call(this);
      this.game = game2;
      this.canvas;
      this.canvasBounds = new Rectangle();
      this.parent = null;
      this.parentIsWindow = false;
      this.parentSize = new Size();
      this.gameSize = new Size();
      this.baseSize = new Size();
      this.displaySize = new Size();
      this.scaleMode = CONST.SCALE_MODE.NONE;
      this.zoom = 1;
      this._resetZoom = false;
      this.displayScale = new Vector2(1, 1);
      this.autoRound = false;
      this.autoCenter = CONST.CENTER.NO_CENTER;
      this.orientation = CONST.ORIENTATION.LANDSCAPE;
      this.fullscreen;
      this.fullscreenTarget = null;
      this._createdFullscreenTarget = false;
      this.dirty = false;
      this.resizeInterval = 500;
      this._lastCheck = 0;
      this._checkOrientation = false;
      this.listeners = {
        orientationChange: NOOP,
        windowResize: NOOP,
        fullScreenChange: NOOP,
        fullScreenError: NOOP
      };
    },
    preBoot: function() {
      this.parseConfig(this.game.config);
      this.game.events.once(GameEvents.BOOT, this.boot, this);
    },
    boot: function() {
      var game2 = this.game;
      this.canvas = game2.canvas;
      this.fullscreen = game2.device.fullscreen;
      if (this.scaleMode !== CONST.SCALE_MODE.RESIZE) {
        this.displaySize.setAspectMode(this.scaleMode);
      }
      if (this.scaleMode === CONST.SCALE_MODE.NONE) {
        this.resize(this.width, this.height);
      } else {
        this.getParentBounds();
        if (this.parentSize.width > 0 && this.parentSize.height > 0) {
          this.displaySize.setParent(this.parentSize);
        }
        this.refresh();
      }
      game2.events.on(GameEvents.PRE_STEP, this.step, this);
      game2.events.once(GameEvents.READY, this.refresh, this);
      game2.events.once(GameEvents.DESTROY, this.destroy, this);
      this.startListeners();
    },
    parseConfig: function(config2) {
      this.getParent(config2);
      this.getParentBounds();
      var width = config2.width;
      var height = config2.height;
      var scaleMode = config2.scaleMode;
      var zoom = config2.zoom;
      var autoRound = config2.autoRound;
      if (typeof width === "string") {
        var parentWidth = this.parentSize.width;
        if (parentWidth === 0) {
          parentWidth = window.innerWidth;
        }
        var parentScaleX = parseInt(width, 10) / 100;
        width = Math.floor(parentWidth * parentScaleX);
      }
      if (typeof height === "string") {
        var parentHeight = this.parentSize.height;
        if (parentHeight === 0) {
          parentHeight = window.innerHeight;
        }
        var parentScaleY = parseInt(height, 10) / 100;
        height = Math.floor(parentHeight * parentScaleY);
      }
      this.scaleMode = scaleMode;
      this.autoRound = autoRound;
      this.autoCenter = config2.autoCenter;
      this.resizeInterval = config2.resizeInterval;
      if (autoRound) {
        width = Math.floor(width);
        height = Math.floor(height);
      }
      this.gameSize.setSize(width, height);
      if (zoom === CONST.ZOOM.MAX_ZOOM) {
        zoom = this.getMaxZoom();
      }
      this.zoom = zoom;
      if (zoom !== 1) {
        this._resetZoom = true;
      }
      this.baseSize.setSize(width, height);
      if (autoRound) {
        this.baseSize.width = Math.floor(this.baseSize.width);
        this.baseSize.height = Math.floor(this.baseSize.height);
      }
      if (config2.minWidth > 0) {
        this.displaySize.setMin(config2.minWidth * zoom, config2.minHeight * zoom);
      }
      if (config2.maxWidth > 0) {
        this.displaySize.setMax(config2.maxWidth * zoom, config2.maxHeight * zoom);
      }
      this.displaySize.setSize(width, height);
      this.orientation = GetScreenOrientation(width, height);
    },
    getParent: function(config2) {
      var parent = config2.parent;
      if (parent === null) {
        return;
      }
      this.parent = GetTarget(parent);
      this.parentIsWindow = this.parent === document.body;
      if (config2.expandParent && config2.scaleMode !== CONST.SCALE_MODE.NONE) {
        var DOMRect = this.parent.getBoundingClientRect();
        if (this.parentIsWindow || DOMRect.height === 0) {
          document.documentElement.style.height = "100%";
          document.body.style.height = "100%";
          DOMRect = this.parent.getBoundingClientRect();
          if (!this.parentIsWindow && DOMRect.height === 0) {
            this.parent.style.overflow = "hidden";
            this.parent.style.width = "100%";
            this.parent.style.height = "100%";
          }
        }
      }
      if (config2.fullscreenTarget && !this.fullscreenTarget) {
        this.fullscreenTarget = GetTarget(config2.fullscreenTarget);
      }
    },
    getParentBounds: function() {
      if (!this.parent) {
        return false;
      }
      var parentSize = this.parentSize;
      var DOMRect = this.parent.getBoundingClientRect();
      if (this.parentIsWindow && this.game.device.os.iOS) {
        DOMRect.height = GetInnerHeight(true);
      }
      var newWidth = DOMRect.width;
      var newHeight = DOMRect.height;
      if (parentSize.width !== newWidth || parentSize.height !== newHeight) {
        parentSize.setSize(newWidth, newHeight);
        return true;
      } else {
        return false;
      }
    },
    lockOrientation: function(orientation) {
      var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
      if (lock) {
        return lock.call(screen, orientation);
      }
      return false;
    },
    setParentSize: function(width, height) {
      this.parentSize.setSize(width, height);
      return this.refresh();
    },
    setGameSize: function(width, height) {
      var autoRound = this.autoRound;
      if (autoRound) {
        width = Math.floor(width);
        height = Math.floor(height);
      }
      var previousWidth = this.width;
      var previousHeight = this.height;
      this.gameSize.resize(width, height);
      this.baseSize.resize(width, height);
      if (autoRound) {
        this.baseSize.width = Math.floor(this.baseSize.width);
        this.baseSize.height = Math.floor(this.baseSize.height);
      }
      this.displaySize.setAspectRatio(width / height);
      this.canvas.width = this.baseSize.width;
      this.canvas.height = this.baseSize.height;
      return this.refresh(previousWidth, previousHeight);
    },
    resize: function(width, height) {
      var zoom = this.zoom;
      var autoRound = this.autoRound;
      if (autoRound) {
        width = Math.floor(width);
        height = Math.floor(height);
      }
      var previousWidth = this.width;
      var previousHeight = this.height;
      this.gameSize.resize(width, height);
      this.baseSize.resize(width, height);
      if (autoRound) {
        this.baseSize.width = Math.floor(this.baseSize.width);
        this.baseSize.height = Math.floor(this.baseSize.height);
      }
      this.displaySize.setSize(width * zoom, height * zoom);
      this.canvas.width = this.baseSize.width;
      this.canvas.height = this.baseSize.height;
      var style = this.canvas.style;
      var styleWidth = width * zoom;
      var styleHeight = height * zoom;
      if (autoRound) {
        styleWidth = Math.floor(styleWidth);
        styleHeight = Math.floor(styleHeight);
      }
      if (styleWidth !== width || styleHeight !== height) {
        style.width = styleWidth + "px";
        style.height = styleHeight + "px";
      }
      return this.refresh(previousWidth, previousHeight);
    },
    setZoom: function(value) {
      this.zoom = value;
      this._resetZoom = true;
      return this.refresh();
    },
    setMaxZoom: function() {
      this.zoom = this.getMaxZoom();
      this._resetZoom = true;
      return this.refresh();
    },
    refresh: function(previousWidth, previousHeight) {
      if (previousWidth === void 0) {
        previousWidth = this.width;
      }
      if (previousHeight === void 0) {
        previousHeight = this.height;
      }
      this.updateScale();
      this.updateBounds();
      this.updateOrientation();
      this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);
      var domContainer = this.game.domContainer;
      if (domContainer) {
        this.baseSize.setCSS(domContainer);
        var canvasStyle = this.canvas.style;
        var domStyle = domContainer.style;
        domStyle.transform = "scale(" + this.displaySize.width / this.baseSize.width + "," + this.displaySize.height / this.baseSize.height + ")";
        domStyle.marginLeft = canvasStyle.marginLeft;
        domStyle.marginTop = canvasStyle.marginTop;
      }
      this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, previousWidth, previousHeight);
      return this;
    },
    updateOrientation: function() {
      if (this._checkOrientation) {
        this._checkOrientation = false;
        var newOrientation = GetScreenOrientation(this.width, this.height);
        if (newOrientation !== this.orientation) {
          this.orientation = newOrientation;
          this.emit(Events.ORIENTATION_CHANGE, newOrientation);
        }
      }
    },
    updateScale: function() {
      var style = this.canvas.style;
      var width = this.gameSize.width;
      var height = this.gameSize.height;
      var styleWidth;
      var styleHeight;
      var zoom = this.zoom;
      var autoRound = this.autoRound;
      if (this.scaleMode === CONST.SCALE_MODE.NONE) {
        this.displaySize.setSize(width * zoom, height * zoom);
        styleWidth = this.displaySize.width;
        styleHeight = this.displaySize.height;
        if (autoRound) {
          styleWidth = Math.floor(styleWidth);
          styleHeight = Math.floor(styleHeight);
        }
        if (this._resetZoom) {
          style.width = styleWidth + "px";
          style.height = styleHeight + "px";
          this._resetZoom = false;
        }
      } else if (this.scaleMode === CONST.SCALE_MODE.RESIZE) {
        this.displaySize.setSize(this.parentSize.width, this.parentSize.height);
        this.gameSize.setSize(this.displaySize.width, this.displaySize.height);
        this.baseSize.setSize(this.displaySize.width, this.displaySize.height);
        styleWidth = this.displaySize.width;
        styleHeight = this.displaySize.height;
        if (autoRound) {
          styleWidth = Math.floor(styleWidth);
          styleHeight = Math.floor(styleHeight);
        }
        this.canvas.width = styleWidth;
        this.canvas.height = styleHeight;
      } else {
        this.displaySize.setSize(this.parentSize.width, this.parentSize.height);
        styleWidth = this.displaySize.width;
        styleHeight = this.displaySize.height;
        if (autoRound) {
          styleWidth = Math.floor(styleWidth);
          styleHeight = Math.floor(styleHeight);
        }
        style.width = styleWidth + "px";
        style.height = styleHeight + "px";
      }
      this.getParentBounds();
      this.updateCenter();
    },
    getMaxZoom: function() {
      var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, true);
      var zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, true);
      return Math.max(Math.min(zoomH, zoomV), 1);
    },
    updateCenter: function() {
      var autoCenter = this.autoCenter;
      if (autoCenter === CONST.CENTER.NO_CENTER) {
        return;
      }
      var canvas = this.canvas;
      var style = canvas.style;
      var bounds = canvas.getBoundingClientRect();
      var width = bounds.width;
      var height = bounds.height;
      var offsetX = Math.floor((this.parentSize.width - width) / 2);
      var offsetY = Math.floor((this.parentSize.height - height) / 2);
      if (autoCenter === CONST.CENTER.CENTER_HORIZONTALLY) {
        offsetY = 0;
      } else if (autoCenter === CONST.CENTER.CENTER_VERTICALLY) {
        offsetX = 0;
      }
      style.marginLeft = offsetX + "px";
      style.marginTop = offsetY + "px";
    },
    updateBounds: function() {
      var bounds = this.canvasBounds;
      var clientRect = this.canvas.getBoundingClientRect();
      bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0);
      bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0);
      bounds.width = clientRect.width;
      bounds.height = clientRect.height;
    },
    transformX: function(pageX) {
      return (pageX - this.canvasBounds.left) * this.displayScale.x;
    },
    transformY: function(pageY) {
      return (pageY - this.canvasBounds.top) * this.displayScale.y;
    },
    startFullscreen: function(fullscreenOptions) {
      if (fullscreenOptions === void 0) {
        fullscreenOptions = {navigationUI: "hide"};
      }
      var fullscreen = this.fullscreen;
      if (!fullscreen.available) {
        this.emit(Events.FULLSCREEN_UNSUPPORTED);
        return;
      }
      if (!fullscreen.active) {
        var fsTarget = this.getFullscreenTarget();
        if (fullscreen.keyboard) {
          fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT);
        } else {
          fsTarget[fullscreen.request](fullscreenOptions);
        }
      }
    },
    fullscreenSuccessHandler: function() {
      this.getParentBounds();
      this.refresh();
      this.emit(Events.ENTER_FULLSCREEN);
    },
    fullscreenErrorHandler: function(error) {
      this.removeFullscreenTarget();
      this.emit(Events.FULLSCREEN_FAILED, error);
    },
    getFullscreenTarget: function() {
      if (!this.fullscreenTarget) {
        var fsTarget = document.createElement("div");
        fsTarget.style.margin = "0";
        fsTarget.style.padding = "0";
        fsTarget.style.width = "100%";
        fsTarget.style.height = "100%";
        this.fullscreenTarget = fsTarget;
        this._createdFullscreenTarget = true;
      }
      if (this._createdFullscreenTarget) {
        var canvasParent = this.canvas.parentNode;
        canvasParent.insertBefore(this.fullscreenTarget, this.canvas);
        this.fullscreenTarget.appendChild(this.canvas);
      }
      return this.fullscreenTarget;
    },
    removeFullscreenTarget: function() {
      if (this._createdFullscreenTarget) {
        var fsTarget = this.fullscreenTarget;
        if (fsTarget && fsTarget.parentNode) {
          var parent = fsTarget.parentNode;
          parent.insertBefore(this.canvas, fsTarget);
          parent.removeChild(fsTarget);
        }
      }
    },
    stopFullscreen: function() {
      var fullscreen = this.fullscreen;
      if (!fullscreen.available) {
        this.emit(Events.FULLSCREEN_UNSUPPORTED);
        return false;
      }
      if (fullscreen.active) {
        document[fullscreen.cancel]();
      }
      this.removeFullscreenTarget();
      this.getParentBounds();
      this.emit(Events.LEAVE_FULLSCREEN);
      this.refresh();
    },
    toggleFullscreen: function(fullscreenOptions) {
      if (this.fullscreen.active) {
        this.stopFullscreen();
      } else {
        this.startFullscreen(fullscreenOptions);
      }
    },
    startListeners: function() {
      var _this = this;
      var listeners = this.listeners;
      listeners.orientationChange = function() {
        _this.updateBounds();
        _this._checkOrientation = true;
        _this.dirty = true;
      };
      listeners.windowResize = function() {
        _this.updateBounds();
        _this.dirty = true;
      };
      window.addEventListener("orientationchange", listeners.orientationChange, false);
      window.addEventListener("resize", listeners.windowResize, false);
      if (this.fullscreen.available) {
        listeners.fullScreenChange = function(event) {
          return _this.onFullScreenChange(event);
        };
        listeners.fullScreenError = function(event) {
          return _this.onFullScreenError(event);
        };
        var vendors = ["webkit", "moz", ""];
        vendors.forEach(function(prefix) {
          document.addEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, false);
          document.addEventListener(prefix + "fullscreenerror", listeners.fullScreenError, false);
        });
        document.addEventListener("MSFullscreenChange", listeners.fullScreenChange, false);
        document.addEventListener("MSFullscreenError", listeners.fullScreenError, false);
      }
    },
    onFullScreenChange: function() {
      if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement) {
        this.fullscreenSuccessHandler();
      } else {
        this.stopFullscreen();
      }
    },
    onFullScreenError: function() {
      this.removeFullscreenTarget();
    },
    step: function(time, delta) {
      if (!this.parent) {
        return;
      }
      this._lastCheck += delta;
      if (this.dirty || this._lastCheck > this.resizeInterval) {
        if (this.getParentBounds()) {
          this.refresh();
        }
        this.dirty = false;
        this._lastCheck = 0;
      }
    },
    stopListeners: function() {
      var listeners = this.listeners;
      window.removeEventListener("orientationchange", listeners.orientationChange, false);
      window.removeEventListener("resize", listeners.windowResize, false);
      var vendors = ["webkit", "moz", ""];
      vendors.forEach(function(prefix) {
        document.removeEventListener(prefix + "fullscreenchange", listeners.fullScreenChange, false);
        document.removeEventListener(prefix + "fullscreenerror", listeners.fullScreenError, false);
      });
      document.removeEventListener("MSFullscreenChange", listeners.fullScreenChange, false);
      document.removeEventListener("MSFullscreenError", listeners.fullScreenError, false);
    },
    destroy: function() {
      this.removeAllListeners();
      this.stopListeners();
      this.game = null;
      this.canvas = null;
      this.canvasBounds = null;
      this.parent = null;
      this.fullscreenTarget = null;
      this.parentSize.destroy();
      this.gameSize.destroy();
      this.baseSize.destroy();
      this.displaySize.destroy();
    },
    isFullscreen: {
      get: function() {
        return this.fullscreen.active;
      }
    },
    width: {
      get: function() {
        return this.gameSize.width;
      }
    },
    height: {
      get: function() {
        return this.gameSize.height;
      }
    },
    isPortrait: {
      get: function() {
        return this.orientation === CONST.ORIENTATION.PORTRAIT;
      }
    },
    isLandscape: {
      get: function() {
        return this.orientation === CONST.ORIENTATION.LANDSCAPE;
      }
    },
    isGamePortrait: {
      get: function() {
        return this.height > this.width;
      }
    },
    isGameLandscape: {
      get: function() {
        return this.width > this.height;
      }
    }
  });
  module2.exports = ScaleManager;
});

// node_modules/phaser/src/scene/const.js
var require_const10 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = {
    PENDING: 0,
    INIT: 1,
    START: 2,
    LOADING: 3,
    CREATING: 4,
    RUNNING: 5,
    PAUSED: 6,
    SLEEPING: 7,
    SHUTDOWN: 8,
    DESTROYED: 9
  };
  module2.exports = CONST;
});

// node_modules/phaser/src/loader/events/ADD_EVENT.js
var require_ADD_EVENT3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "addfile";
});

// node_modules/phaser/src/loader/events/COMPLETE_EVENT.js
var require_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "complete";
});

// node_modules/phaser/src/loader/events/FILE_COMPLETE_EVENT.js
var require_FILE_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "filecomplete";
});

// node_modules/phaser/src/loader/events/FILE_KEY_COMPLETE_EVENT.js
var require_FILE_KEY_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "filecomplete-";
});

// node_modules/phaser/src/loader/events/FILE_LOAD_ERROR_EVENT.js
var require_FILE_LOAD_ERROR_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "loaderror";
});

// node_modules/phaser/src/loader/events/FILE_LOAD_EVENT.js
var require_FILE_LOAD_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "load";
});

// node_modules/phaser/src/loader/events/FILE_PROGRESS_EVENT.js
var require_FILE_PROGRESS_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "fileprogress";
});

// node_modules/phaser/src/loader/events/POST_PROCESS_EVENT.js
var require_POST_PROCESS_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "postprocess";
});

// node_modules/phaser/src/loader/events/PROGRESS_EVENT.js
var require_PROGRESS_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "progress";
});

// node_modules/phaser/src/loader/events/START_EVENT.js
var require_START_EVENT3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "start";
});

// node_modules/phaser/src/loader/events/index.js
var require_events14 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ADD: require_ADD_EVENT3(),
    COMPLETE: require_COMPLETE_EVENT(),
    FILE_COMPLETE: require_FILE_COMPLETE_EVENT(),
    FILE_KEY_COMPLETE: require_FILE_KEY_COMPLETE_EVENT(),
    FILE_LOAD_ERROR: require_FILE_LOAD_ERROR_EVENT(),
    FILE_LOAD: require_FILE_LOAD_EVENT(),
    FILE_PROGRESS: require_FILE_PROGRESS_EVENT(),
    POST_PROCESS: require_POST_PROCESS_EVENT(),
    PROGRESS: require_PROGRESS_EVENT(),
    START: require_START_EVENT3()
  };
});

// node_modules/phaser/src/utils/string/UppercaseFirst.js
var require_UppercaseFirst = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var UppercaseFirst = function(str) {
    return str && str[0].toUpperCase() + str.slice(1);
  };
  module2.exports = UppercaseFirst;
});

// node_modules/phaser/src/scene/GetPhysicsPlugins.js
var require_GetPhysicsPlugins = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetFastValue = require_GetFastValue();
  var UppercaseFirst = require_UppercaseFirst();
  var GetPhysicsPlugins = function(sys) {
    var defaultSystem = sys.game.config.defaultPhysicsSystem;
    var sceneSystems = GetFastValue(sys.settings, "physics", false);
    if (!defaultSystem && !sceneSystems) {
      return;
    }
    var output = [];
    if (defaultSystem) {
      output.push(UppercaseFirst(defaultSystem + "Physics"));
    }
    if (sceneSystems) {
      for (var key in sceneSystems) {
        key = UppercaseFirst(key.concat("Physics"));
        if (output.indexOf(key) === -1) {
          output.push(key);
        }
      }
    }
    return output;
  };
  module2.exports = GetPhysicsPlugins;
});

// node_modules/phaser/src/scene/GetScenePlugins.js
var require_GetScenePlugins = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetFastValue = require_GetFastValue();
  var GetScenePlugins = function(sys) {
    var defaultPlugins = sys.plugins.getDefaultScenePlugins();
    var scenePlugins = GetFastValue(sys.settings, "plugins", false);
    if (Array.isArray(scenePlugins)) {
      return scenePlugins;
    } else if (defaultPlugins) {
      return defaultPlugins;
    } else {
      return [];
    }
  };
  module2.exports = GetScenePlugins;
});

// node_modules/phaser/src/utils/object/Clone.js
var require_Clone = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clone = function(obj) {
    var clone = {};
    for (var key in obj) {
      if (Array.isArray(obj[key])) {
        clone[key] = obj[key].slice(0);
      } else {
        clone[key] = obj[key];
      }
    }
    return clone;
  };
  module2.exports = Clone;
});

// node_modules/phaser/src/utils/object/Merge.js
var require_Merge = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clone = require_Clone();
  var Merge = function(obj1, obj2) {
    var clone = Clone(obj1);
    for (var key in obj2) {
      if (!clone.hasOwnProperty(key)) {
        clone[key] = obj2[key];
      }
    }
    return clone;
  };
  module2.exports = Merge;
});

// node_modules/phaser/src/scene/InjectionMap.js
var require_InjectionMap = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var InjectionMap = {
    game: "game",
    renderer: "renderer",
    anims: "anims",
    cache: "cache",
    plugins: "plugins",
    registry: "registry",
    scale: "scale",
    sound: "sound",
    textures: "textures",
    events: "events",
    cameras: "cameras",
    add: "add",
    make: "make",
    scenePlugin: "scene",
    displayList: "children",
    lights: "lights",
    data: "data",
    input: "input",
    load: "load",
    time: "time",
    tweens: "tweens",
    arcadePhysics: "physics",
    impactPhysics: "impact",
    matterPhysics: "matter"
  };
  if (typeof PLUGIN_CAMERA3D) {
    InjectionMap.cameras3d = "cameras3d";
  }
  if (typeof PLUGIN_FBINSTANT) {
    InjectionMap.facebook = "facebook";
  }
  module2.exports = InjectionMap;
});

// node_modules/phaser/src/scene/Settings.js
var require_Settings = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const10();
  var GetValue = require_GetValue();
  var Merge = require_Merge();
  var InjectionMap = require_InjectionMap();
  var Settings = {
    create: function(config2) {
      if (typeof config2 === "string") {
        config2 = {key: config2};
      } else if (config2 === void 0) {
        config2 = {};
      }
      return {
        status: CONST.PENDING,
        key: GetValue(config2, "key", ""),
        active: GetValue(config2, "active", false),
        visible: GetValue(config2, "visible", true),
        isBooted: false,
        isTransition: false,
        transitionFrom: null,
        transitionDuration: 0,
        transitionAllowInput: true,
        data: {},
        pack: GetValue(config2, "pack", false),
        cameras: GetValue(config2, "cameras", null),
        map: GetValue(config2, "map", Merge(InjectionMap, GetValue(config2, "mapAdd", {}))),
        physics: GetValue(config2, "physics", {}),
        loader: GetValue(config2, "loader", {}),
        plugins: GetValue(config2, "plugins", false),
        input: GetValue(config2, "input", {})
      };
    }
  };
  module2.exports = Settings;
});

// node_modules/phaser/src/scene/Systems.js
var require_Systems = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const10();
  var DefaultPlugins = require_DefaultPlugins();
  var Events = require_events5();
  var GetPhysicsPlugins = require_GetPhysicsPlugins();
  var GetScenePlugins = require_GetScenePlugins();
  var GLOBAL_CONST = require_const();
  var NOOP = require_NOOP();
  var Settings = require_Settings();
  var Systems = new Class({
    initialize: function Systems2(scene, config2) {
      this.scene = scene;
      this.game;
      this.renderer;
      if (typeof PLUGIN_FBINSTANT) {
        this.facebook;
      }
      this.config = config2;
      this.settings = Settings.create(config2);
      this.canvas;
      this.context;
      this.anims;
      this.cache;
      this.plugins;
      this.registry;
      this.scale;
      this.sound;
      this.textures;
      this.add;
      this.cameras;
      this.displayList;
      this.events;
      this.make;
      this.scenePlugin;
      this.updateList;
      this.sceneUpdate = NOOP;
    },
    init: function(game2) {
      this.settings.status = CONST.INIT;
      this.sceneUpdate = NOOP;
      this.game = game2;
      this.renderer = game2.renderer;
      this.canvas = game2.canvas;
      this.context = game2.context;
      var pluginManager = game2.plugins;
      this.plugins = pluginManager;
      pluginManager.addToScene(this, DefaultPlugins.Global, [DefaultPlugins.CoreScene, GetScenePlugins(this), GetPhysicsPlugins(this)]);
      this.events.emit(Events.BOOT, this);
      this.settings.isBooted = true;
    },
    step: function(time, delta) {
      var events = this.events;
      events.emit(Events.PRE_UPDATE, time, delta);
      events.emit(Events.UPDATE, time, delta);
      this.sceneUpdate.call(this.scene, time, delta);
      events.emit(Events.POST_UPDATE, time, delta);
    },
    render: function(renderer) {
      var displayList = this.displayList;
      displayList.depthSort();
      this.events.emit(Events.PRE_RENDER, renderer);
      this.cameras.render(renderer, displayList);
      this.events.emit(Events.RENDER, renderer);
    },
    queueDepthSort: function() {
      this.displayList.queueDepthSort();
    },
    depthSort: function() {
      this.displayList.depthSort();
    },
    pause: function(data) {
      var events = this.events;
      var settings = this.settings;
      if (this.settings.active) {
        settings.status = CONST.PAUSED;
        settings.active = false;
        events.emit(Events.PAUSE, this, data);
      }
      return this;
    },
    resume: function(data) {
      var events = this.events;
      var settings = this.settings;
      if (!this.settings.active) {
        settings.status = CONST.RUNNING;
        settings.active = true;
        events.emit(Events.RESUME, this, data);
      }
      return this;
    },
    sleep: function(data) {
      var events = this.events;
      var settings = this.settings;
      settings.status = CONST.SLEEPING;
      settings.active = false;
      settings.visible = false;
      events.emit(Events.SLEEP, this, data);
      return this;
    },
    wake: function(data) {
      var events = this.events;
      var settings = this.settings;
      settings.status = CONST.RUNNING;
      settings.active = true;
      settings.visible = true;
      events.emit(Events.WAKE, this, data);
      if (settings.isTransition) {
        events.emit(Events.TRANSITION_WAKE, settings.transitionFrom, settings.transitionDuration);
      }
      return this;
    },
    getData: function() {
      return this.settings.data;
    },
    isSleeping: function() {
      return this.settings.status === CONST.SLEEPING;
    },
    isActive: function() {
      return this.settings.status === CONST.RUNNING;
    },
    isPaused: function() {
      return this.settings.status === CONST.PAUSED;
    },
    isTransitioning: function() {
      return this.settings.isTransition || this.scenePlugin._target !== null;
    },
    isTransitionOut: function() {
      return this.scenePlugin._target !== null && this.scenePlugin._duration > 0;
    },
    isTransitionIn: function() {
      return this.settings.isTransition;
    },
    isVisible: function() {
      return this.settings.visible;
    },
    setVisible: function(value) {
      this.settings.visible = value;
      return this;
    },
    setActive: function(value, data) {
      if (value) {
        return this.resume(data);
      } else {
        return this.pause(data);
      }
    },
    start: function(data) {
      var events = this.events;
      var settings = this.settings;
      if (data) {
        settings.data = data;
      }
      settings.status = CONST.START;
      settings.active = true;
      settings.visible = true;
      events.emit(Events.START, this);
      events.emit(Events.READY, this, data);
    },
    shutdown: function(data) {
      var events = this.events;
      var settings = this.settings;
      events.off(Events.TRANSITION_INIT);
      events.off(Events.TRANSITION_START);
      events.off(Events.TRANSITION_COMPLETE);
      events.off(Events.TRANSITION_OUT);
      settings.status = CONST.SHUTDOWN;
      settings.active = false;
      settings.visible = false;
      if (this.renderer === GLOBAL_CONST.WEBGL) {
        this.renderer.resetTextures(true);
      }
      events.emit(Events.SHUTDOWN, this, data);
    },
    destroy: function() {
      var events = this.events;
      var settings = this.settings;
      settings.status = CONST.DESTROYED;
      settings.active = false;
      settings.visible = false;
      events.emit(Events.DESTROY, this);
      events.removeAllListeners();
      var props = ["scene", "game", "anims", "cache", "plugins", "registry", "sound", "textures", "add", "camera", "displayList", "events", "make", "scenePlugin", "updateList"];
      for (var i = 0; i < props.length; i++) {
        this[props[i]] = null;
      }
    }
  });
  module2.exports = Systems;
});

// node_modules/phaser/src/scene/Scene.js
var require_Scene = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Systems = require_Systems();
  var Scene = new Class({
    initialize: function Scene2(config2) {
      this.sys = new Systems(this, config2);
      this.game;
      this.anims;
      this.cache;
      this.registry;
      this.sound;
      this.textures;
      this.events;
      this.cameras;
      this.add;
      this.make;
      this.scene;
      this.children;
      this.lights;
      this.data;
      this.input;
      this.load;
      this.time;
      this.tweens;
      this.physics;
      this.matter;
      if (typeof PLUGIN_FBINSTANT) {
        this.facebook;
      }
      this.scale;
      this.plugins;
      this.renderer;
    },
    update: function() {
    }
  });
  module2.exports = Scene;
});

// node_modules/phaser/src/scene/SceneManager.js
var require_SceneManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const10();
  var Events = require_events5();
  var GameEvents = require_events();
  var GetValue = require_GetValue();
  var LoaderEvents = require_events14();
  var NOOP = require_NOOP();
  var Scene = require_Scene();
  var Systems = require_Systems();
  var SceneManager = new Class({
    initialize: function SceneManager2(game2, sceneConfig) {
      this.game = game2;
      this.keys = {};
      this.scenes = [];
      this._pending = [];
      this._start = [];
      this._queue = [];
      this._data = {};
      this.isProcessing = false;
      this.isBooted = false;
      this.customViewports = 0;
      if (sceneConfig) {
        if (!Array.isArray(sceneConfig)) {
          sceneConfig = [sceneConfig];
        }
        for (var i = 0; i < sceneConfig.length; i++) {
          this._pending.push({
            key: "default",
            scene: sceneConfig[i],
            autoStart: i === 0,
            data: {}
          });
        }
      }
      game2.events.once(GameEvents.READY, this.bootQueue, this);
    },
    bootQueue: function() {
      if (this.isBooted) {
        return;
      }
      var i;
      var entry;
      var key;
      var sceneConfig;
      for (i = 0; i < this._pending.length; i++) {
        entry = this._pending[i];
        key = entry.key;
        sceneConfig = entry.scene;
        var newScene;
        if (sceneConfig instanceof Scene) {
          newScene = this.createSceneFromInstance(key, sceneConfig);
        } else if (typeof sceneConfig === "object") {
          newScene = this.createSceneFromObject(key, sceneConfig);
        } else if (typeof sceneConfig === "function") {
          newScene = this.createSceneFromFunction(key, sceneConfig);
        }
        key = newScene.sys.settings.key;
        this.keys[key] = newScene;
        this.scenes.push(newScene);
        if (this._data[key]) {
          newScene.sys.settings.data = this._data[key].data;
          if (this._data[key].autoStart) {
            entry.autoStart = true;
          }
        }
        if (entry.autoStart || newScene.sys.settings.active) {
          this._start.push(key);
        }
      }
      this._pending.length = 0;
      this._data = {};
      this.isBooted = true;
      for (i = 0; i < this._start.length; i++) {
        entry = this._start[i];
        this.start(entry);
      }
      this._start.length = 0;
    },
    processQueue: function() {
      var pendingLength = this._pending.length;
      var queueLength = this._queue.length;
      if (pendingLength === 0 && queueLength === 0) {
        return;
      }
      var i;
      var entry;
      if (pendingLength) {
        for (i = 0; i < pendingLength; i++) {
          entry = this._pending[i];
          this.add(entry.key, entry.scene, entry.autoStart, entry.data);
        }
        for (i = 0; i < this._start.length; i++) {
          entry = this._start[i];
          this.start(entry);
        }
        this._start.length = 0;
        this._pending.length = 0;
        return;
      }
      for (i = 0; i < this._queue.length; i++) {
        entry = this._queue[i];
        this[entry.op](entry.keyA, entry.keyB);
      }
      this._queue.length = 0;
    },
    add: function(key, sceneConfig, autoStart, data) {
      if (autoStart === void 0) {
        autoStart = false;
      }
      if (data === void 0) {
        data = {};
      }
      if (this.isProcessing || !this.isBooted) {
        this._pending.push({
          key,
          scene: sceneConfig,
          autoStart,
          data
        });
        if (!this.isBooted) {
          this._data[key] = {data};
        }
        return null;
      }
      key = this.getKey(key, sceneConfig);
      var newScene;
      if (sceneConfig instanceof Scene) {
        newScene = this.createSceneFromInstance(key, sceneConfig);
      } else if (typeof sceneConfig === "object") {
        sceneConfig.key = key;
        newScene = this.createSceneFromObject(key, sceneConfig);
      } else if (typeof sceneConfig === "function") {
        newScene = this.createSceneFromFunction(key, sceneConfig);
      }
      newScene.sys.settings.data = data;
      key = newScene.sys.settings.key;
      this.keys[key] = newScene;
      this.scenes.push(newScene);
      if (autoStart || newScene.sys.settings.active) {
        if (this._pending.length) {
          this._start.push(key);
        } else {
          this.start(key);
        }
      }
      return newScene;
    },
    remove: function(key) {
      if (this.isProcessing) {
        this._queue.push({op: "remove", keyA: key, keyB: null});
      } else {
        var sceneToRemove = this.getScene(key);
        if (!sceneToRemove || sceneToRemove.sys.isTransitioning()) {
          return this;
        }
        var index = this.scenes.indexOf(sceneToRemove);
        var sceneKey = sceneToRemove.sys.settings.key;
        if (index > -1) {
          delete this.keys[sceneKey];
          this.scenes.splice(index, 1);
          if (this._start.indexOf(sceneKey) > -1) {
            index = this._start.indexOf(sceneKey);
            this._start.splice(index, 1);
          }
          sceneToRemove.sys.destroy();
        }
      }
      return this;
    },
    bootScene: function(scene) {
      var sys = scene.sys;
      var settings = sys.settings;
      sys.sceneUpdate = NOOP;
      if (scene.init) {
        scene.init.call(scene, settings.data);
        settings.status = CONST.INIT;
        if (settings.isTransition) {
          sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration);
        }
      }
      var loader;
      if (sys.load) {
        loader = sys.load;
        loader.reset();
      }
      if (loader && scene.preload) {
        scene.preload.call(scene);
        if (loader.list.size === 0) {
          this.create(scene);
        } else {
          settings.status = CONST.LOADING;
          loader.once(LoaderEvents.COMPLETE, this.loadComplete, this);
          loader.start();
        }
      } else {
        this.create(scene);
      }
    },
    loadComplete: function(loader) {
      this.create(loader.scene);
    },
    payloadComplete: function(loader) {
      this.bootScene(loader.scene);
    },
    update: function(time, delta) {
      this.processQueue();
      this.isProcessing = true;
      for (var i = this.scenes.length - 1; i >= 0; i--) {
        var sys = this.scenes[i].sys;
        if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING) {
          sys.step(time, delta);
        }
      }
    },
    render: function(renderer) {
      for (var i = 0; i < this.scenes.length; i++) {
        var sys = this.scenes[i].sys;
        if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING) {
          sys.render(renderer);
        }
      }
      this.isProcessing = false;
    },
    create: function(scene) {
      var sys = scene.sys;
      var settings = sys.settings;
      if (scene.create) {
        settings.status = CONST.CREATING;
        scene.create.call(scene, settings.data);
        if (settings.status === CONST.DESTROYED) {
          return;
        }
      }
      if (settings.isTransition) {
        sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration);
      }
      if (scene.update) {
        sys.sceneUpdate = scene.update;
      }
      settings.status = CONST.RUNNING;
      sys.events.emit(Events.CREATE, scene);
    },
    createSceneFromFunction: function(key, scene) {
      var newScene = new scene();
      if (newScene instanceof Scene) {
        var configKey = newScene.sys.settings.key;
        if (configKey !== "") {
          key = configKey;
        }
        if (this.keys.hasOwnProperty(key)) {
          throw new Error("Cannot add a Scene with duplicate key: " + key);
        }
        return this.createSceneFromInstance(key, newScene);
      } else {
        newScene.sys = new Systems(newScene);
        newScene.sys.settings.key = key;
        newScene.sys.init(this.game);
        return newScene;
      }
    },
    createSceneFromInstance: function(key, newScene) {
      var configKey = newScene.sys.settings.key;
      if (configKey === "") {
        newScene.sys.settings.key = key;
      }
      newScene.sys.init(this.game);
      return newScene;
    },
    createSceneFromObject: function(key, sceneConfig) {
      var newScene = new Scene(sceneConfig);
      var configKey = newScene.sys.settings.key;
      if (configKey !== "") {
        key = configKey;
      } else {
        newScene.sys.settings.key = key;
      }
      newScene.sys.init(this.game);
      var defaults = ["init", "preload", "create", "update", "render"];
      for (var i = 0; i < defaults.length; i++) {
        var sceneCallback = GetValue(sceneConfig, defaults[i], null);
        if (sceneCallback) {
          newScene[defaults[i]] = sceneCallback;
        }
      }
      if (sceneConfig.hasOwnProperty("extend")) {
        for (var propertyKey in sceneConfig.extend) {
          if (!sceneConfig.extend.hasOwnProperty(propertyKey)) {
            continue;
          }
          var value = sceneConfig.extend[propertyKey];
          if (propertyKey === "data" && newScene.hasOwnProperty("data") && typeof value === "object") {
            newScene.data.merge(value);
          } else if (propertyKey !== "sys") {
            newScene[propertyKey] = value;
          }
        }
      }
      return newScene;
    },
    getKey: function(key, sceneConfig) {
      if (!key) {
        key = "default";
      }
      if (typeof sceneConfig === "function") {
        return key;
      } else if (sceneConfig instanceof Scene) {
        key = sceneConfig.sys.settings.key;
      } else if (typeof sceneConfig === "object" && sceneConfig.hasOwnProperty("key")) {
        key = sceneConfig.key;
      }
      if (this.keys.hasOwnProperty(key)) {
        throw new Error("Cannot add a Scene with duplicate key: " + key);
      } else {
        return key;
      }
    },
    getScenes: function(isActive, inReverse) {
      if (isActive === void 0) {
        isActive = true;
      }
      if (inReverse === void 0) {
        inReverse = false;
      }
      var out = [];
      var scenes = this.scenes;
      for (var i = 0; i < scenes.length; i++) {
        var scene = scenes[i];
        if (scene && (!isActive || isActive && scene.sys.isActive())) {
          out.push(scene);
        }
      }
      return inReverse ? out.reverse() : out;
    },
    getScene: function(key) {
      if (typeof key === "string") {
        if (this.keys[key]) {
          return this.keys[key];
        }
      } else {
        for (var i = 0; i < this.scenes.length; i++) {
          if (key === this.scenes[i]) {
            return key;
          }
        }
      }
      return null;
    },
    isActive: function(key) {
      var scene = this.getScene(key);
      if (scene) {
        return scene.sys.isActive();
      }
      return null;
    },
    isPaused: function(key) {
      var scene = this.getScene(key);
      if (scene) {
        return scene.sys.isPaused();
      }
      return null;
    },
    isVisible: function(key) {
      var scene = this.getScene(key);
      if (scene) {
        return scene.sys.isVisible();
      }
      return null;
    },
    isSleeping: function(key) {
      var scene = this.getScene(key);
      if (scene) {
        return scene.sys.isSleeping();
      }
      return null;
    },
    pause: function(key, data) {
      var scene = this.getScene(key);
      if (scene) {
        scene.sys.pause(data);
      }
      return this;
    },
    resume: function(key, data) {
      var scene = this.getScene(key);
      if (scene) {
        scene.sys.resume(data);
      }
      return this;
    },
    sleep: function(key, data) {
      var scene = this.getScene(key);
      if (scene && !scene.sys.isTransitioning()) {
        scene.sys.sleep(data);
      }
      return this;
    },
    wake: function(key, data) {
      var scene = this.getScene(key);
      if (scene) {
        scene.sys.wake(data);
      }
      return this;
    },
    run: function(key, data) {
      var scene = this.getScene(key);
      if (!scene) {
        for (var i = 0; i < this._pending.length; i++) {
          if (this._pending[i].key === key) {
            this.queueOp("start", key, data);
            break;
          }
        }
        return this;
      }
      if (scene.sys.isSleeping()) {
        scene.sys.wake(data);
      } else if (scene.sys.isPaused()) {
        scene.sys.resume(data);
      } else {
        this.start(key, data);
      }
    },
    start: function(key, data) {
      if (!this.isBooted) {
        this._data[key] = {
          autoStart: true,
          data
        };
        return this;
      }
      var scene = this.getScene(key);
      if (scene) {
        var sys = scene.sys;
        if (sys.isActive() || sys.isPaused()) {
          sys.shutdown();
          sys.sceneUpdate = NOOP;
          sys.start(data);
        } else {
          sys.sceneUpdate = NOOP;
          sys.start(data);
          var loader;
          if (sys.load) {
            loader = sys.load;
          }
          if (loader && sys.settings.hasOwnProperty("pack")) {
            loader.reset();
            if (loader.addPack({payload: sys.settings.pack})) {
              sys.settings.status = CONST.LOADING;
              loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this);
              loader.start();
              return this;
            }
          }
        }
        this.bootScene(scene);
      }
      return this;
    },
    stop: function(key, data) {
      var scene = this.getScene(key);
      if (scene && !scene.sys.isTransitioning()) {
        scene.sys.shutdown(data);
      }
      return this;
    },
    switch: function(from, to) {
      var sceneA = this.getScene(from);
      var sceneB = this.getScene(to);
      if (sceneA && sceneB && sceneA !== sceneB) {
        this.sleep(from);
        if (this.isSleeping(to)) {
          this.wake(to);
        } else {
          this.start(to);
        }
      }
      return this;
    },
    getAt: function(index) {
      return this.scenes[index];
    },
    getIndex: function(key) {
      var scene = this.getScene(key);
      return this.scenes.indexOf(scene);
    },
    bringToTop: function(key) {
      if (this.isProcessing) {
        this._queue.push({op: "bringToTop", keyA: key, keyB: null});
      } else {
        var index = this.getIndex(key);
        if (index !== -1 && index < this.scenes.length) {
          var scene = this.getScene(key);
          this.scenes.splice(index, 1);
          this.scenes.push(scene);
        }
      }
      return this;
    },
    sendToBack: function(key) {
      if (this.isProcessing) {
        this._queue.push({op: "sendToBack", keyA: key, keyB: null});
      } else {
        var index = this.getIndex(key);
        if (index !== -1 && index > 0) {
          var scene = this.getScene(key);
          this.scenes.splice(index, 1);
          this.scenes.unshift(scene);
        }
      }
      return this;
    },
    moveDown: function(key) {
      if (this.isProcessing) {
        this._queue.push({op: "moveDown", keyA: key, keyB: null});
      } else {
        var indexA = this.getIndex(key);
        if (indexA > 0) {
          var indexB = indexA - 1;
          var sceneA = this.getScene(key);
          var sceneB = this.getAt(indexB);
          this.scenes[indexA] = sceneB;
          this.scenes[indexB] = sceneA;
        }
      }
      return this;
    },
    moveUp: function(key) {
      if (this.isProcessing) {
        this._queue.push({op: "moveUp", keyA: key, keyB: null});
      } else {
        var indexA = this.getIndex(key);
        if (indexA < this.scenes.length - 1) {
          var indexB = indexA + 1;
          var sceneA = this.getScene(key);
          var sceneB = this.getAt(indexB);
          this.scenes[indexA] = sceneB;
          this.scenes[indexB] = sceneA;
        }
      }
      return this;
    },
    moveAbove: function(keyA, keyB) {
      if (keyA === keyB) {
        return this;
      }
      if (this.isProcessing) {
        this._queue.push({op: "moveAbove", keyA, keyB});
      } else {
        var indexA = this.getIndex(keyA);
        var indexB = this.getIndex(keyB);
        if (indexA !== -1 && indexB !== -1) {
          var tempScene = this.getAt(indexB);
          this.scenes.splice(indexB, 1);
          this.scenes.splice(indexA + 1, 0, tempScene);
        }
      }
      return this;
    },
    moveBelow: function(keyA, keyB) {
      if (keyA === keyB) {
        return this;
      }
      if (this.isProcessing) {
        this._queue.push({op: "moveBelow", keyA, keyB});
      } else {
        var indexA = this.getIndex(keyA);
        var indexB = this.getIndex(keyB);
        if (indexA !== -1 && indexB !== -1) {
          var tempScene = this.getAt(indexB);
          this.scenes.splice(indexB, 1);
          if (indexA === 0) {
            this.scenes.unshift(tempScene);
          } else {
            this.scenes.splice(indexA, 0, tempScene);
          }
        }
      }
      return this;
    },
    queueOp: function(op, keyA, keyB) {
      this._queue.push({op, keyA, keyB});
      return this;
    },
    swapPosition: function(keyA, keyB) {
      if (keyA === keyB) {
        return this;
      }
      if (this.isProcessing) {
        this._queue.push({op: "swapPosition", keyA, keyB});
      } else {
        var indexA = this.getIndex(keyA);
        var indexB = this.getIndex(keyB);
        if (indexA !== indexB && indexA !== -1 && indexB !== -1) {
          var tempScene = this.getAt(indexA);
          this.scenes[indexA] = this.scenes[indexB];
          this.scenes[indexB] = tempScene;
        }
      }
      return this;
    },
    dump: function() {
      var out = [];
      var map = ["pending", "init", "start", "loading", "creating", "running", "paused", "sleeping", "shutdown", "destroyed"];
      for (var i = 0; i < this.scenes.length; i++) {
        var sys = this.scenes[i].sys;
        var key = sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED) ? "[*] " : "[-] ";
        key += sys.settings.key + " (" + map[sys.settings.status] + ")";
        out.push(key);
      }
      console.log(out.join("\n"));
    },
    destroy: function() {
      for (var i = 0; i < this.scenes.length; i++) {
        var sys = this.scenes[i].sys;
        sys.destroy();
      }
      this.update = NOOP;
      this.scenes = [];
      this._pending = [];
      this._start = [];
      this._queue = [];
      this.game = null;
    }
  });
  module2.exports = SceneManager;
});

// node_modules/phaser/src/textures/Frame.js
var require_Frame = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Clamp = require_Clamp();
  var Extend = require_Extend();
  var Frame = new Class({
    initialize: function Frame2(texture, name, sourceIndex, x, y, width, height) {
      this.texture = texture;
      this.name = name;
      this.source = texture.source[sourceIndex];
      this.sourceIndex = sourceIndex;
      this.glTexture = this.source.glTexture;
      this.cutX;
      this.cutY;
      this.cutWidth;
      this.cutHeight;
      this.x = 0;
      this.y = 0;
      this.width;
      this.height;
      this.halfWidth;
      this.halfHeight;
      this.centerX;
      this.centerY;
      this.pivotX = 0;
      this.pivotY = 0;
      this.customPivot = false;
      this.rotated = false;
      this.autoRound = -1;
      this.customData = {};
      this.u0 = 0;
      this.v0 = 0;
      this.u1 = 0;
      this.v1 = 0;
      this.data = {
        cut: {
          x: 0,
          y: 0,
          w: 0,
          h: 0,
          r: 0,
          b: 0
        },
        trim: false,
        sourceSize: {
          w: 0,
          h: 0
        },
        spriteSourceSize: {
          x: 0,
          y: 0,
          w: 0,
          h: 0,
          r: 0,
          b: 0
        },
        radius: 0,
        drawImage: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }
      };
      this.setSize(width, height, x, y);
    },
    setSize: function(width, height, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      this.cutX = x;
      this.cutY = y;
      this.cutWidth = width;
      this.cutHeight = height;
      this.width = width;
      this.height = height;
      this.halfWidth = Math.floor(width * 0.5);
      this.halfHeight = Math.floor(height * 0.5);
      this.centerX = Math.floor(width / 2);
      this.centerY = Math.floor(height / 2);
      var data = this.data;
      var cut = data.cut;
      cut.x = x;
      cut.y = y;
      cut.w = width;
      cut.h = height;
      cut.r = x + width;
      cut.b = y + height;
      data.sourceSize.w = width;
      data.sourceSize.h = height;
      data.spriteSourceSize.w = width;
      data.spriteSourceSize.h = height;
      data.radius = 0.5 * Math.sqrt(width * width + height * height);
      var drawImage = data.drawImage;
      drawImage.x = x;
      drawImage.y = y;
      drawImage.width = width;
      drawImage.height = height;
      return this.updateUVs();
    },
    setTrim: function(actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
      var data = this.data;
      var ss = data.spriteSourceSize;
      data.trim = true;
      data.sourceSize.w = actualWidth;
      data.sourceSize.h = actualHeight;
      ss.x = destX;
      ss.y = destY;
      ss.w = destWidth;
      ss.h = destHeight;
      ss.r = destX + destWidth;
      ss.b = destY + destHeight;
      this.x = destX;
      this.y = destY;
      this.width = destWidth;
      this.height = destHeight;
      this.halfWidth = destWidth * 0.5;
      this.halfHeight = destHeight * 0.5;
      this.centerX = Math.floor(destWidth / 2);
      this.centerY = Math.floor(destHeight / 2);
      return this.updateUVs();
    },
    setCropUVs: function(crop, x, y, width, height, flipX, flipY) {
      var cx = this.cutX;
      var cy = this.cutY;
      var cw = this.cutWidth;
      var ch = this.cutHeight;
      var rw = this.realWidth;
      var rh = this.realHeight;
      x = Clamp(x, 0, rw);
      y = Clamp(y, 0, rh);
      width = Clamp(width, 0, rw - x);
      height = Clamp(height, 0, rh - y);
      var ox = cx + x;
      var oy = cy + y;
      var ow = width;
      var oh = height;
      var data = this.data;
      if (data.trim) {
        var ss = data.spriteSourceSize;
        width = Clamp(width, 0, cw - x);
        height = Clamp(height, 0, ch - y);
        var cropRight = x + width;
        var cropBottom = y + height;
        var intersects = !(ss.r < x || ss.b < y || ss.x > cropRight || ss.y > cropBottom);
        if (intersects) {
          var ix = Math.max(ss.x, x);
          var iy = Math.max(ss.y, y);
          var iw = Math.min(ss.r, cropRight) - ix;
          var ih = Math.min(ss.b, cropBottom) - iy;
          ow = iw;
          oh = ih;
          if (flipX) {
            ox = cx + (cw - (ix - ss.x) - iw);
          } else {
            ox = cx + (ix - ss.x);
          }
          if (flipY) {
            oy = cy + (ch - (iy - ss.y) - ih);
          } else {
            oy = cy + (iy - ss.y);
          }
          x = ix;
          y = iy;
          width = iw;
          height = ih;
        } else {
          ox = 0;
          oy = 0;
          ow = 0;
          oh = 0;
        }
      } else {
        if (flipX) {
          ox = cx + (cw - x - width);
        }
        if (flipY) {
          oy = cy + (ch - y - height);
        }
      }
      var tw = this.source.width;
      var th = this.source.height;
      crop.u0 = Math.max(0, ox / tw);
      crop.v0 = Math.max(0, oy / th);
      crop.u1 = Math.min(1, (ox + ow) / tw);
      crop.v1 = Math.min(1, (oy + oh) / th);
      crop.x = x;
      crop.y = y;
      crop.cx = ox;
      crop.cy = oy;
      crop.cw = ow;
      crop.ch = oh;
      crop.width = width;
      crop.height = height;
      crop.flipX = flipX;
      crop.flipY = flipY;
      return crop;
    },
    updateCropUVs: function(crop, flipX, flipY) {
      return this.setCropUVs(crop, crop.x, crop.y, crop.width, crop.height, flipX, flipY);
    },
    setUVs: function(width, height, u0, v0, u1, v1) {
      var cd = this.data.drawImage;
      cd.width = width;
      cd.height = height;
      this.u0 = u0;
      this.v0 = v0;
      this.u1 = u1;
      this.v1 = v1;
      return this;
    },
    updateUVs: function() {
      var cx = this.cutX;
      var cy = this.cutY;
      var cw = this.cutWidth;
      var ch = this.cutHeight;
      var cd = this.data.drawImage;
      cd.width = cw;
      cd.height = ch;
      var tw = this.source.width;
      var th = this.source.height;
      this.u0 = cx / tw;
      this.v0 = cy / th;
      this.u1 = (cx + cw) / tw;
      this.v1 = (cy + ch) / th;
      return this;
    },
    updateUVsInverted: function() {
      var tw = this.source.width;
      var th = this.source.height;
      this.u0 = (this.cutX + this.cutHeight) / tw;
      this.v0 = this.cutY / th;
      this.u1 = this.cutX / tw;
      this.v1 = (this.cutY + this.cutWidth) / th;
      return this;
    },
    clone: function() {
      var clone = new Frame(this.texture, this.name, this.sourceIndex);
      clone.cutX = this.cutX;
      clone.cutY = this.cutY;
      clone.cutWidth = this.cutWidth;
      clone.cutHeight = this.cutHeight;
      clone.x = this.x;
      clone.y = this.y;
      clone.width = this.width;
      clone.height = this.height;
      clone.halfWidth = this.halfWidth;
      clone.halfHeight = this.halfHeight;
      clone.centerX = this.centerX;
      clone.centerY = this.centerY;
      clone.rotated = this.rotated;
      clone.data = Extend(true, clone.data, this.data);
      clone.updateUVs();
      return clone;
    },
    destroy: function() {
      this.source = null;
      this.texture = null;
      this.glTexture = null;
      this.customData = null;
      this.data = null;
    },
    realWidth: {
      get: function() {
        return this.data.sourceSize.w;
      }
    },
    realHeight: {
      get: function() {
        return this.data.sourceSize.h;
      }
    },
    radius: {
      get: function() {
        return this.data.radius;
      }
    },
    trimmed: {
      get: function() {
        return this.data.trim;
      }
    },
    canvasData: {
      get: function() {
        return this.data.drawImage;
      }
    }
  });
  module2.exports = Frame;
});

// node_modules/phaser/src/textures/TextureSource.js
var require_TextureSource = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CanvasPool = require_CanvasPool();
  var Class = require_Class();
  var IsSizePowerOfTwo = require_IsSizePowerOfTwo();
  var ScaleModes = require_ScaleModes();
  var TextureSource = new Class({
    initialize: function TextureSource2(texture, source, width, height, flipY) {
      if (flipY === void 0) {
        flipY = false;
      }
      var game2 = texture.manager.game;
      this.renderer = game2.renderer;
      this.texture = texture;
      this.source = source;
      this.image = source;
      this.compressionAlgorithm = null;
      this.resolution = 1;
      this.width = width || source.naturalWidth || source.videoWidth || source.width || 0;
      this.height = height || source.naturalHeight || source.videoHeight || source.height || 0;
      this.scaleMode = ScaleModes.DEFAULT;
      this.isCanvas = source instanceof HTMLCanvasElement;
      this.isVideo = window.hasOwnProperty("HTMLVideoElement") && source instanceof HTMLVideoElement;
      this.isRenderTexture = source.type === "RenderTexture";
      this.isGLTexture = window.hasOwnProperty("WebGLTexture") && source instanceof WebGLTexture;
      this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);
      this.glTexture = null;
      this.glIndex = 0;
      this.glIndexCounter = -1;
      this.flipY = flipY;
      this.init(game2);
    },
    init: function(game2) {
      var renderer = this.renderer;
      if (renderer) {
        if (renderer.gl) {
          if (this.isCanvas) {
            this.glTexture = renderer.createCanvasTexture(this.image, false, this.flipY);
          } else if (this.isVideo) {
            this.glTexture = renderer.createVideoTexture(this.image, false, this.flipY);
          } else if (this.isRenderTexture) {
            this.image = this.source.canvas;
            this.glTexture = renderer.createTextureFromSource(null, this.width, this.height, this.scaleMode);
          } else if (this.isGLTexture) {
            this.glTexture = this.source;
          } else {
            this.glTexture = renderer.createTextureFromSource(this.image, this.width, this.height, this.scaleMode);
          }
        } else if (this.isRenderTexture) {
          this.image = this.source.canvas;
        }
      }
      if (!game2.config.antialias) {
        this.setFilter(1);
      }
    },
    setFilter: function(filterMode) {
      if (this.renderer.gl) {
        this.renderer.setTextureFilter(this.glTexture, filterMode);
      }
      this.scaleMode = filterMode;
    },
    setFlipY: function(value) {
      if (value === void 0) {
        value = true;
      }
      this.flipY = value;
      return this;
    },
    update: function() {
      var gl = this.renderer.gl;
      if (gl && this.isCanvas) {
        this.glTexture = this.renderer.updateCanvasTexture(this.image, this.glTexture, this.flipY);
      } else if (gl && this.isVideo) {
        this.glTexture = this.renderer.updateVideoTexture(this.image, this.glTexture, this.flipY);
      }
    },
    destroy: function() {
      if (this.glTexture) {
        this.renderer.deleteTexture(this.glTexture, true);
      }
      if (this.isCanvas) {
        CanvasPool.remove(this.image);
      }
      this.renderer = null;
      this.texture = null;
      this.source = null;
      this.image = null;
      this.glTexture = null;
    }
  });
  module2.exports = TextureSource;
});

// node_modules/phaser/src/textures/Texture.js
var require_Texture2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const();
  var Class = require_Class();
  var Frame = require_Frame();
  var TextureSource = require_TextureSource();
  var TEXTURE_MISSING_ERROR = "Texture.frame missing: ";
  var Texture = new Class({
    initialize: function Texture2(manager, key, source, width, height) {
      if (!Array.isArray(source)) {
        source = [source];
      }
      this.manager = manager;
      this.key = key;
      this.source = [];
      this.dataSource = [];
      this.frames = {};
      this.customData = {};
      this.firstFrame = "__BASE";
      this.frameTotal = 0;
      for (var i = 0; i < source.length; i++) {
        this.source.push(new TextureSource(this, source[i], width, height));
      }
    },
    add: function(name, sourceIndex, x, y, width, height) {
      if (this.has(name)) {
        return null;
      }
      var frame = new Frame(this, name, sourceIndex, x, y, width, height);
      this.frames[name] = frame;
      if (this.firstFrame === "__BASE") {
        this.firstFrame = name;
      }
      this.frameTotal++;
      return frame;
    },
    remove: function(name) {
      if (this.has(name)) {
        var frame = this.get(name);
        frame.destroy();
        delete this.frames[name];
        return true;
      }
      return false;
    },
    has: function(name) {
      return this.frames[name];
    },
    get: function(name) {
      if (!name) {
        name = this.firstFrame;
      }
      var frame = this.frames[name];
      if (!frame) {
        console.warn(TEXTURE_MISSING_ERROR + name);
        frame = this.frames[this.firstFrame];
      }
      return frame;
    },
    getTextureSourceIndex: function(source) {
      for (var i = 0; i < this.source.length; i++) {
        if (this.source[i] === source) {
          return i;
        }
      }
      return -1;
    },
    getFramesFromTextureSource: function(sourceIndex, includeBase) {
      if (includeBase === void 0) {
        includeBase = false;
      }
      var out = [];
      for (var frameName in this.frames) {
        if (frameName === "__BASE" && !includeBase) {
          continue;
        }
        var frame = this.frames[frameName];
        if (frame.sourceIndex === sourceIndex) {
          out.push(frame);
        }
      }
      return out;
    },
    getFrameNames: function(includeBase) {
      if (includeBase === void 0) {
        includeBase = false;
      }
      var out = Object.keys(this.frames);
      if (!includeBase) {
        var idx = out.indexOf("__BASE");
        if (idx !== -1) {
          out.splice(idx, 1);
        }
      }
      return out;
    },
    getSourceImage: function(name) {
      if (name === void 0 || name === null || this.frameTotal === 1) {
        name = "__BASE";
      }
      var frame = this.frames[name];
      if (frame) {
        return frame.source.image;
      } else {
        console.warn(TEXTURE_MISSING_ERROR + name);
        return this.frames["__BASE"].source.image;
      }
    },
    getDataSourceImage: function(name) {
      if (name === void 0 || name === null || this.frameTotal === 1) {
        name = "__BASE";
      }
      var frame = this.frames[name];
      var idx;
      if (!frame) {
        console.warn(TEXTURE_MISSING_ERROR + name);
        idx = this.frames["__BASE"].sourceIndex;
      } else {
        idx = frame.sourceIndex;
      }
      return this.dataSource[idx].image;
    },
    setDataSource: function(data) {
      if (!Array.isArray(data)) {
        data = [data];
      }
      for (var i = 0; i < data.length; i++) {
        var source = this.source[i];
        this.dataSource.push(new TextureSource(this, data[i], source.width, source.height));
      }
    },
    setFilter: function(filterMode) {
      var i;
      for (i = 0; i < this.source.length; i++) {
        this.source[i].setFilter(filterMode);
      }
      for (i = 0; i < this.dataSource.length; i++) {
        this.dataSource[i].setFilter(filterMode);
      }
    },
    destroy: function() {
      var i;
      for (i = 0; i < this.source.length; i++) {
        this.source[i].destroy();
      }
      for (i = 0; i < this.dataSource.length; i++) {
        this.dataSource[i].destroy();
      }
      for (var frameName in this.frames) {
        var frame = this.frames[frameName];
        frame.destroy();
      }
      this.source = [];
      this.dataSource = [];
      this.frames = {};
      this.manager.removeKey(this.key);
      var renderer = this.manager.game.renderer;
      if (renderer && renderer.type === CONST.WEBGL) {
        renderer.resetTextures(true);
      }
      this.manager = null;
    }
  });
  module2.exports = Texture;
});

// node_modules/phaser/src/textures/CanvasTexture.js
var require_CanvasTexture = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Clamp = require_Clamp();
  var Color = require_Color();
  var CONST = require_const();
  var IsSizePowerOfTwo = require_IsSizePowerOfTwo();
  var Texture = require_Texture2();
  var CanvasTexture = new Class({
    Extends: Texture,
    initialize: function CanvasTexture2(manager, key, source, width, height) {
      Texture.call(this, manager, key, source, width, height);
      this.add("__BASE", 0, 0, 0, width, height);
      this._source = this.frames["__BASE"].source;
      this.canvas = this._source.image;
      this.context = this.canvas.getContext("2d");
      this.width = width;
      this.height = height;
      this.imageData = this.context.getImageData(0, 0, width, height);
      this.data = null;
      if (this.imageData) {
        this.data = this.imageData.data;
      }
      this.pixels = null;
      this.buffer;
      if (this.data) {
        if (this.imageData.data.buffer) {
          this.buffer = this.imageData.data.buffer;
          this.pixels = new Uint32Array(this.buffer);
        } else if (window.ArrayBuffer) {
          this.buffer = new ArrayBuffer(this.imageData.data.length);
          this.pixels = new Uint32Array(this.buffer);
        } else {
          this.pixels = this.imageData.data;
        }
      }
    },
    update: function() {
      this.imageData = this.context.getImageData(0, 0, this.width, this.height);
      this.data = this.imageData.data;
      if (this.imageData.data.buffer) {
        this.buffer = this.imageData.data.buffer;
        this.pixels = new Uint32Array(this.buffer);
      } else if (window.ArrayBuffer) {
        this.buffer = new ArrayBuffer(this.imageData.data.length);
        this.pixels = new Uint32Array(this.buffer);
      } else {
        this.pixels = this.imageData.data;
      }
      if (this.manager.game.config.renderType === CONST.WEBGL) {
        this.refresh();
      }
      return this;
    },
    draw: function(x, y, source) {
      this.context.drawImage(source, x, y);
      return this.update();
    },
    drawFrame: function(key, frame, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      var textureFrame = this.manager.getFrame(key, frame);
      if (textureFrame) {
        var cd = textureFrame.canvasData;
        var width = textureFrame.cutWidth;
        var height = textureFrame.cutHeight;
        var res = textureFrame.source.resolution;
        this.context.drawImage(textureFrame.source.image, cd.x, cd.y, width, height, x, y, width / res, height / res);
        return this.update();
      } else {
        return this;
      }
    },
    setPixel: function(x, y, red, green, blue, alpha) {
      if (alpha === void 0) {
        alpha = 255;
      }
      x = Math.abs(Math.floor(x));
      y = Math.abs(Math.floor(y));
      var index = this.getIndex(x, y);
      if (index > -1) {
        var imageData = this.context.getImageData(x, y, 1, 1);
        imageData.data[0] = red;
        imageData.data[1] = green;
        imageData.data[2] = blue;
        imageData.data[3] = alpha;
        this.context.putImageData(imageData, x, y);
      }
      return this;
    },
    putData: function(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
      if (dirtyX === void 0) {
        dirtyX = 0;
      }
      if (dirtyY === void 0) {
        dirtyY = 0;
      }
      if (dirtyWidth === void 0) {
        dirtyWidth = imageData.width;
      }
      if (dirtyHeight === void 0) {
        dirtyHeight = imageData.height;
      }
      this.context.putImageData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
      return this;
    },
    getData: function(x, y, width, height) {
      x = Clamp(Math.floor(x), 0, this.width - 1);
      y = Clamp(Math.floor(y), 0, this.height - 1);
      width = Clamp(width, 1, this.width - x);
      height = Clamp(height, 1, this.height - y);
      var imageData = this.context.getImageData(x, y, width, height);
      return imageData;
    },
    getPixel: function(x, y, out) {
      if (!out) {
        out = new Color();
      }
      var index = this.getIndex(x, y);
      if (index > -1) {
        var data = this.data;
        var r = data[index + 0];
        var g = data[index + 1];
        var b = data[index + 2];
        var a = data[index + 3];
        out.setTo(r, g, b, a);
      }
      return out;
    },
    getPixels: function(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = this.width;
      }
      if (height === void 0) {
        height = width;
      }
      x = Math.abs(Math.round(x));
      y = Math.abs(Math.round(y));
      var left = Clamp(x, 0, this.width);
      var right = Clamp(x + width, 0, this.width);
      var top = Clamp(y, 0, this.height);
      var bottom = Clamp(y + height, 0, this.height);
      var pixel = new Color();
      var out = [];
      for (var py = top; py < bottom; py++) {
        var row = [];
        for (var px = left; px < right; px++) {
          pixel = this.getPixel(px, py, pixel);
          row.push({x: px, y: py, color: pixel.color, alpha: pixel.alphaGL});
        }
        out.push(row);
      }
      return out;
    },
    getIndex: function(x, y) {
      x = Math.abs(Math.round(x));
      y = Math.abs(Math.round(y));
      if (x < this.width && y < this.height) {
        return (x + y * this.width) * 4;
      } else {
        return -1;
      }
    },
    refresh: function() {
      this._source.update();
      return this;
    },
    getCanvas: function() {
      return this.canvas;
    },
    getContext: function() {
      return this.context;
    },
    clear: function(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = this.width;
      }
      if (height === void 0) {
        height = this.height;
      }
      this.context.clearRect(x, y, width, height);
      return this.update();
    },
    setSize: function(width, height) {
      if (height === void 0) {
        height = width;
      }
      if (width !== this.width || height !== this.height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this._source.width = width;
        this._source.height = height;
        this._source.isPowerOf2 = IsSizePowerOfTwo(width, height);
        this.frames["__BASE"].setSize(width, height, 0, 0);
        this.width = width;
        this.height = height;
        this.refresh();
      }
      return this;
    },
    destroy: function() {
      Texture.prototype.destroy.call(this);
      this._source = null;
      this.canvas = null;
      this.context = null;
      this.imageData = null;
      this.data = null;
      this.pixels = null;
      this.buffer = null;
    }
  });
  module2.exports = CanvasTexture;
});

// node_modules/phaser/src/textures/parsers/AtlasXML.js
var require_AtlasXML = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AtlasXML = function(texture, sourceIndex, xml) {
    if (!xml.getElementsByTagName("TextureAtlas")) {
      console.warn("Invalid Texture Atlas XML given");
      return;
    }
    var source = texture.source[sourceIndex];
    texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
    var frames = xml.getElementsByTagName("SubTexture");
    var newFrame;
    for (var i = 0; i < frames.length; i++) {
      var frame = frames[i].attributes;
      var name = frame.name.value;
      var x = parseInt(frame.x.value, 10);
      var y = parseInt(frame.y.value, 10);
      var width = parseInt(frame.width.value, 10);
      var height = parseInt(frame.height.value, 10);
      newFrame = texture.add(name, sourceIndex, x, y, width, height);
      if (frame.frameX) {
        var frameX = Math.abs(parseInt(frame.frameX.value, 10));
        var frameY = Math.abs(parseInt(frame.frameY.value, 10));
        var frameWidth = parseInt(frame.frameWidth.value, 10);
        var frameHeight = parseInt(frame.frameHeight.value, 10);
        newFrame.setTrim(width, height, frameX, frameY, frameWidth, frameHeight);
      }
    }
    return texture;
  };
  module2.exports = AtlasXML;
});

// node_modules/phaser/src/textures/parsers/Canvas.js
var require_Canvas = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Canvas = function(texture, sourceIndex) {
    var source = texture.source[sourceIndex];
    texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
    return texture;
  };
  module2.exports = Canvas;
});

// node_modules/phaser/src/textures/parsers/Image.js
var require_Image = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Image2 = function(texture, sourceIndex) {
    var source = texture.source[sourceIndex];
    texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
    return texture;
  };
  module2.exports = Image2;
});

// node_modules/phaser/src/textures/parsers/JSONArray.js
var require_JSONArray = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clone = require_Clone();
  var JSONArray = function(texture, sourceIndex, json) {
    if (!json["frames"] && !json["textures"]) {
      console.warn("Invalid Texture Atlas JSON Array");
      return;
    }
    var source = texture.source[sourceIndex];
    texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
    var frames = Array.isArray(json.textures) ? json.textures[sourceIndex].frames : json.frames;
    var newFrame;
    for (var i = 0; i < frames.length; i++) {
      var src = frames[i];
      newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
      if (src.trimmed) {
        newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);
      }
      if (src.rotated) {
        newFrame.rotated = true;
        newFrame.updateUVsInverted();
      }
      var pivot = src.anchor || src.pivot;
      if (pivot) {
        newFrame.customPivot = true;
        newFrame.pivotX = pivot.x;
        newFrame.pivotY = pivot.y;
      }
      newFrame.customData = Clone(src);
    }
    for (var dataKey in json) {
      if (dataKey === "frames") {
        continue;
      }
      if (Array.isArray(json[dataKey])) {
        texture.customData[dataKey] = json[dataKey].slice(0);
      } else {
        texture.customData[dataKey] = json[dataKey];
      }
    }
    return texture;
  };
  module2.exports = JSONArray;
});

// node_modules/phaser/src/textures/parsers/JSONHash.js
var require_JSONHash = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clone = require_Clone();
  var JSONHash = function(texture, sourceIndex, json) {
    if (!json["frames"]) {
      console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object");
      return;
    }
    var source = texture.source[sourceIndex];
    texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
    var frames = json.frames;
    var newFrame;
    for (var key in frames) {
      if (!frames.hasOwnProperty(key)) {
        continue;
      }
      var src = frames[key];
      newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);
      if (src.trimmed) {
        newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);
      }
      if (src.rotated) {
        newFrame.rotated = true;
        newFrame.updateUVsInverted();
      }
      var pivot = src.anchor || src.pivot;
      if (pivot) {
        newFrame.customPivot = true;
        newFrame.pivotX = pivot.x;
        newFrame.pivotY = pivot.y;
      }
      newFrame.customData = Clone(src);
    }
    for (var dataKey in json) {
      if (dataKey === "frames") {
        continue;
      }
      if (Array.isArray(json[dataKey])) {
        texture.customData[dataKey] = json[dataKey].slice(0);
      } else {
        texture.customData[dataKey] = json[dataKey];
      }
    }
    return texture;
  };
  module2.exports = JSONHash;
});

// node_modules/phaser/src/textures/parsers/SpriteSheet.js
var require_SpriteSheet = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetFastValue = require_GetFastValue();
  var SpriteSheet = function(texture, sourceIndex, x, y, width, height, config2) {
    var frameWidth = GetFastValue(config2, "frameWidth", null);
    var frameHeight = GetFastValue(config2, "frameHeight", frameWidth);
    if (frameWidth === null) {
      throw new Error("TextureManager.SpriteSheet: Invalid frameWidth given.");
    }
    var source = texture.source[sourceIndex];
    texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
    var startFrame = GetFastValue(config2, "startFrame", 0);
    var endFrame = GetFastValue(config2, "endFrame", -1);
    var margin = GetFastValue(config2, "margin", 0);
    var spacing = GetFastValue(config2, "spacing", 0);
    var row = Math.floor((width - margin + spacing) / (frameWidth + spacing));
    var column = Math.floor((height - margin + spacing) / (frameHeight + spacing));
    var total = row * column;
    if (total === 0) {
      console.warn("SpriteSheet frame dimensions will result in zero frames for texture:", texture.key);
    }
    if (startFrame > total || startFrame < -total) {
      startFrame = 0;
    }
    if (startFrame < 0) {
      startFrame = total + startFrame;
    }
    if (endFrame !== -1) {
      total = startFrame + (endFrame + 1);
    }
    var fx = margin;
    var fy = margin;
    var ax = 0;
    var ay = 0;
    for (var i = 0; i < total; i++) {
      ax = 0;
      ay = 0;
      var w = fx + frameWidth;
      var h = fy + frameHeight;
      if (w > width) {
        ax = w - width;
      }
      if (h > height) {
        ay = h - height;
      }
      texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);
      fx += frameWidth + spacing;
      if (fx + frameWidth > width) {
        fx = margin;
        fy += frameHeight + spacing;
      }
    }
    return texture;
  };
  module2.exports = SpriteSheet;
});

// node_modules/phaser/src/textures/parsers/SpriteSheetFromAtlas.js
var require_SpriteSheetFromAtlas = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetFastValue = require_GetFastValue();
  var SpriteSheetFromAtlas = function(texture, frame, config2) {
    var frameWidth = GetFastValue(config2, "frameWidth", null);
    var frameHeight = GetFastValue(config2, "frameHeight", frameWidth);
    if (!frameWidth) {
      throw new Error("TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.");
    }
    var source = texture.source[0];
    texture.add("__BASE", 0, 0, 0, source.width, source.height);
    var startFrame = GetFastValue(config2, "startFrame", 0);
    var endFrame = GetFastValue(config2, "endFrame", -1);
    var margin = GetFastValue(config2, "margin", 0);
    var spacing = GetFastValue(config2, "spacing", 0);
    var x = frame.cutX;
    var y = frame.cutY;
    var cutWidth = frame.cutWidth;
    var cutHeight = frame.cutHeight;
    var sheetWidth = frame.realWidth;
    var sheetHeight = frame.realHeight;
    var row = Math.floor((sheetWidth - margin + spacing) / (frameWidth + spacing));
    var column = Math.floor((sheetHeight - margin + spacing) / (frameHeight + spacing));
    var total = row * column;
    var leftPad = frame.x;
    var leftWidth = frameWidth - leftPad;
    var rightWidth = frameWidth - (sheetWidth - cutWidth - leftPad);
    var topPad = frame.y;
    var topHeight = frameHeight - topPad;
    var bottomHeight = frameHeight - (sheetHeight - cutHeight - topPad);
    if (startFrame > total || startFrame < -total) {
      startFrame = 0;
    }
    if (startFrame < 0) {
      startFrame = total + startFrame;
    }
    if (endFrame !== -1) {
      total = startFrame + (endFrame + 1);
    }
    var sheetFrame;
    var frameX = margin;
    var frameY = margin;
    var frameIndex = 0;
    var sourceIndex = frame.sourceIndex;
    for (var sheetY = 0; sheetY < column; sheetY++) {
      var topRow = sheetY === 0;
      var bottomRow = sheetY === column - 1;
      for (var sheetX = 0; sheetX < row; sheetX++) {
        var leftRow = sheetX === 0;
        var rightRow = sheetX === row - 1;
        sheetFrame = texture.add(frameIndex, sourceIndex, x + frameX, y + frameY, frameWidth, frameHeight);
        if (leftRow || topRow || rightRow || bottomRow) {
          var destX = leftRow ? leftPad : 0;
          var destY = topRow ? topPad : 0;
          var trimWidth = 0;
          var trimHeight = 0;
          if (leftRow) {
            trimWidth += frameWidth - leftWidth;
          }
          if (rightRow) {
            trimWidth += frameWidth - rightWidth;
          }
          if (topRow) {
            trimHeight += frameHeight - topHeight;
          }
          if (bottomRow) {
            trimHeight += frameHeight - bottomHeight;
          }
          var destWidth = frameWidth - trimWidth;
          var destHeight = frameHeight - trimHeight;
          sheetFrame.cutWidth = destWidth;
          sheetFrame.cutHeight = destHeight;
          sheetFrame.setTrim(frameWidth, frameHeight, destX, destY, destWidth, destHeight);
        }
        frameX += spacing;
        if (leftRow) {
          frameX += leftWidth;
        } else if (rightRow) {
          frameX += rightWidth;
        } else {
          frameX += frameWidth;
        }
        frameIndex++;
      }
      frameX = margin;
      frameY += spacing;
      if (topRow) {
        frameY += topHeight;
      } else if (bottomRow) {
        frameY += bottomHeight;
      } else {
        frameY += frameHeight;
      }
    }
    return texture;
  };
  module2.exports = SpriteSheetFromAtlas;
});

// node_modules/phaser/src/textures/parsers/UnityYAML.js
var require_UnityYAML = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var imageHeight = 0;
  var addFrame = function(texture, sourceIndex, name, frame) {
    var y = imageHeight - frame.y - frame.height;
    texture.add(name, sourceIndex, frame.x, y, frame.width, frame.height);
  };
  var UnityYAML = function(texture, sourceIndex, yaml) {
    var source = texture.source[sourceIndex];
    texture.add("__BASE", sourceIndex, 0, 0, source.width, source.height);
    imageHeight = source.height;
    var data = yaml.split("\n");
    var lineRegExp = /^[ ]*(- )*(\w+)+[: ]+(.*)/;
    var prevSprite = "";
    var currentSprite = "";
    var rect = {x: 0, y: 0, width: 0, height: 0};
    for (var i = 0; i < data.length; i++) {
      var results = data[i].match(lineRegExp);
      if (!results) {
        continue;
      }
      var isList = results[1] === "- ";
      var key = results[2];
      var value = results[3];
      if (isList) {
        if (currentSprite !== prevSprite) {
          addFrame(texture, sourceIndex, currentSprite, rect);
          prevSprite = currentSprite;
        }
        rect = {x: 0, y: 0, width: 0, height: 0};
      }
      if (key === "name") {
        currentSprite = value;
        continue;
      }
      switch (key) {
        case "x":
        case "y":
        case "width":
        case "height":
          rect[key] = parseInt(value, 10);
          break;
      }
    }
    if (currentSprite !== prevSprite) {
      addFrame(texture, sourceIndex, currentSprite, rect);
    }
    return texture;
  };
  module2.exports = UnityYAML;
});

// node_modules/phaser/src/textures/parsers/index.js
var require_parsers = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    AtlasXML: require_AtlasXML(),
    Canvas: require_Canvas(),
    Image: require_Image(),
    JSONArray: require_JSONArray(),
    JSONHash: require_JSONHash(),
    SpriteSheet: require_SpriteSheet(),
    SpriteSheetFromAtlas: require_SpriteSheetFromAtlas(),
    UnityYAML: require_UnityYAML()
  };
});

// node_modules/phaser/src/textures/TextureManager.js
var require_TextureManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CanvasPool = require_CanvasPool();
  var CanvasTexture = require_CanvasTexture();
  var Class = require_Class();
  var Color = require_Color();
  var CONST = require_const();
  var EventEmitter = require_eventemitter3();
  var Events = require_events10();
  var GameEvents = require_events();
  var GenerateTexture = require_GenerateTexture();
  var GetValue = require_GetValue();
  var Parser = require_parsers();
  var Texture = require_Texture2();
  var TextureManager = new Class({
    Extends: EventEmitter,
    initialize: function TextureManager2(game2) {
      EventEmitter.call(this);
      this.game = game2;
      this.name = "TextureManager";
      this.list = {};
      this._tempCanvas = CanvasPool.create2D(this, 1, 1);
      this._tempContext = this._tempCanvas.getContext("2d");
      this._pending = 0;
      game2.events.once(GameEvents.BOOT, this.boot, this);
    },
    boot: function() {
      this._pending = 3;
      this.on(Events.LOAD, this.updatePending, this);
      this.on(Events.ERROR, this.updatePending, this);
      var config2 = this.game.config;
      this.addBase64("__DEFAULT", config2.defaultImage);
      this.addBase64("__MISSING", config2.missingImage);
      this.addBase64("__WHITE", config2.whiteImage);
      this.game.events.once(GameEvents.DESTROY, this.destroy, this);
    },
    updatePending: function() {
      this._pending--;
      if (this._pending === 0) {
        this.off(Events.LOAD);
        this.off(Events.ERROR);
        this.emit(Events.READY);
      }
    },
    checkKey: function(key) {
      if (this.exists(key)) {
        console.error("Texture key already in use: " + key);
        return false;
      }
      return true;
    },
    remove: function(key) {
      if (typeof key === "string") {
        if (this.exists(key)) {
          key = this.get(key);
        } else {
          console.warn("No texture found matching key: " + key);
          return this;
        }
      }
      if (this.list.hasOwnProperty(key.key)) {
        key.destroy();
        this.emit(Events.REMOVE, key.key);
      }
      return this;
    },
    removeKey: function(key) {
      if (this.list.hasOwnProperty(key)) {
        delete this.list[key];
      }
      return this;
    },
    addBase64: function(key, data) {
      if (this.checkKey(key)) {
        var _this = this;
        var image = new Image();
        image.onerror = function() {
          _this.emit(Events.ERROR, key);
        };
        image.onload = function() {
          var texture = _this.create(key, image);
          Parser.Image(texture, 0);
          _this.emit(Events.ADD, key, texture);
          _this.emit(Events.LOAD, key, texture);
        };
        image.src = data;
      }
      return this;
    },
    getBase64: function(key, frame, type, encoderOptions) {
      if (type === void 0) {
        type = "image/png";
      }
      if (encoderOptions === void 0) {
        encoderOptions = 0.92;
      }
      var data = "";
      var textureFrame = this.getFrame(key, frame);
      if (textureFrame && (textureFrame.source.isRenderTexture || textureFrame.source.isGLTexture)) {
        console.warn("Cannot getBase64 from WebGL Texture");
      } else if (textureFrame) {
        var cd = textureFrame.canvasData;
        var canvas = CanvasPool.create2D(this, cd.width, cd.height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(textureFrame.source.image, cd.x, cd.y, cd.width, cd.height, 0, 0, cd.width, cd.height);
        data = canvas.toDataURL(type, encoderOptions);
        CanvasPool.remove(canvas);
      }
      return data;
    },
    addImage: function(key, source, dataSource) {
      var texture = null;
      if (this.checkKey(key)) {
        texture = this.create(key, source);
        Parser.Image(texture, 0);
        if (dataSource) {
          texture.setDataSource(dataSource);
        }
        this.emit(Events.ADD, key, texture);
      }
      return texture;
    },
    addGLTexture: function(key, glTexture, width, height) {
      var texture = null;
      if (this.checkKey(key)) {
        if (width === void 0) {
          width = glTexture.width;
        }
        if (height === void 0) {
          height = glTexture.height;
        }
        texture = this.create(key, glTexture, width, height);
        texture.add("__BASE", 0, 0, 0, width, height);
        this.emit(Events.ADD, key, texture);
      }
      return texture;
    },
    addRenderTexture: function(key, renderTexture) {
      var texture = null;
      if (this.checkKey(key)) {
        texture = this.create(key, renderTexture);
        texture.add("__BASE", 0, 0, 0, renderTexture.width, renderTexture.height);
        this.emit(Events.ADD, key, texture);
      }
      return texture;
    },
    generate: function(key, config2) {
      if (this.checkKey(key)) {
        var canvas = CanvasPool.create(this, 1, 1);
        config2.canvas = canvas;
        GenerateTexture(config2);
        return this.addCanvas(key, canvas);
      } else {
        return null;
      }
    },
    createCanvas: function(key, width, height) {
      if (width === void 0) {
        width = 256;
      }
      if (height === void 0) {
        height = 256;
      }
      if (this.checkKey(key)) {
        var canvas = CanvasPool.create(this, width, height, CONST.CANVAS, true);
        return this.addCanvas(key, canvas);
      }
      return null;
    },
    addCanvas: function(key, source, skipCache) {
      if (skipCache === void 0) {
        skipCache = false;
      }
      var texture = null;
      if (skipCache) {
        texture = new CanvasTexture(this, key, source, source.width, source.height);
      } else if (this.checkKey(key)) {
        texture = new CanvasTexture(this, key, source, source.width, source.height);
        this.list[key] = texture;
        this.emit(Events.ADD, key, texture);
      }
      return texture;
    },
    addAtlas: function(key, source, data, dataSource) {
      if (Array.isArray(data.textures) || Array.isArray(data.frames)) {
        return this.addAtlasJSONArray(key, source, data, dataSource);
      } else {
        return this.addAtlasJSONHash(key, source, data, dataSource);
      }
    },
    addAtlasJSONArray: function(key, source, data, dataSource) {
      var texture = null;
      if (this.checkKey(key)) {
        texture = this.create(key, source);
        if (Array.isArray(data)) {
          var singleAtlasFile = data.length === 1;
          for (var i = 0; i < texture.source.length; i++) {
            var atlasData = singleAtlasFile ? data[0] : data[i];
            Parser.JSONArray(texture, i, atlasData);
          }
        } else {
          Parser.JSONArray(texture, 0, data);
        }
        if (dataSource) {
          texture.setDataSource(dataSource);
        }
        this.emit(Events.ADD, key, texture);
      }
      return texture;
    },
    addAtlasJSONHash: function(key, source, data, dataSource) {
      var texture = null;
      if (this.checkKey(key)) {
        texture = this.create(key, source);
        if (Array.isArray(data)) {
          for (var i = 0; i < data.length; i++) {
            Parser.JSONHash(texture, i, data[i]);
          }
        } else {
          Parser.JSONHash(texture, 0, data);
        }
        if (dataSource) {
          texture.setDataSource(dataSource);
        }
        this.emit(Events.ADD, key, texture);
      }
      return texture;
    },
    addAtlasXML: function(key, source, data, dataSource) {
      var texture = null;
      if (this.checkKey(key)) {
        texture = this.create(key, source);
        Parser.AtlasXML(texture, 0, data);
        if (dataSource) {
          texture.setDataSource(dataSource);
        }
        this.emit(Events.ADD, key, texture);
      }
      return texture;
    },
    addUnityAtlas: function(key, source, data, dataSource) {
      var texture = null;
      if (this.checkKey(key)) {
        texture = this.create(key, source);
        Parser.UnityYAML(texture, 0, data);
        if (dataSource) {
          texture.setDataSource(dataSource);
        }
        this.emit(Events.ADD, key, texture);
      }
      return texture;
    },
    addSpriteSheet: function(key, source, config2) {
      var texture = null;
      if (this.checkKey(key)) {
        texture = this.create(key, source);
        var width = texture.source[0].width;
        var height = texture.source[0].height;
        Parser.SpriteSheet(texture, 0, 0, 0, width, height, config2);
        this.emit(Events.ADD, key, texture);
      }
      return texture;
    },
    addSpriteSheetFromAtlas: function(key, config2) {
      if (!this.checkKey(key)) {
        return null;
      }
      var atlasKey = GetValue(config2, "atlas", null);
      var atlasFrame = GetValue(config2, "frame", null);
      if (!atlasKey || !atlasFrame) {
        return;
      }
      var atlas = this.get(atlasKey);
      var sheet = atlas.get(atlasFrame);
      if (sheet) {
        var texture = this.create(key, sheet.source.image);
        if (sheet.trimmed) {
          Parser.SpriteSheetFromAtlas(texture, sheet, config2);
        } else {
          Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config2);
        }
        this.emit(Events.ADD, key, texture);
        return texture;
      }
    },
    create: function(key, source, width, height) {
      var texture = null;
      if (this.checkKey(key)) {
        texture = new Texture(this, key, source, width, height);
        this.list[key] = texture;
      }
      return texture;
    },
    exists: function(key) {
      return this.list.hasOwnProperty(key);
    },
    get: function(key) {
      if (key === void 0) {
        key = "__DEFAULT";
      }
      if (this.list[key]) {
        return this.list[key];
      } else if (key instanceof Texture) {
        return key;
      } else {
        return this.list["__MISSING"];
      }
    },
    cloneFrame: function(key, frame) {
      if (this.list[key]) {
        return this.list[key].get(frame).clone();
      }
    },
    getFrame: function(key, frame) {
      if (this.list[key]) {
        return this.list[key].get(frame);
      }
    },
    getTextureKeys: function() {
      var output = [];
      for (var key in this.list) {
        if (key !== "__DEFAULT" && key !== "__MISSING") {
          output.push(key);
        }
      }
      return output;
    },
    getPixel: function(x, y, key, frame) {
      var textureFrame = this.getFrame(key, frame);
      if (textureFrame) {
        x -= textureFrame.x;
        y -= textureFrame.y;
        var data = textureFrame.data.cut;
        x += data.x;
        y += data.y;
        if (x >= data.x && x < data.r && y >= data.y && y < data.b) {
          var ctx = this._tempContext;
          ctx.clearRect(0, 0, 1, 1);
          ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);
          var rgb = ctx.getImageData(0, 0, 1, 1);
          return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
        }
      }
      return null;
    },
    getPixelAlpha: function(x, y, key, frame) {
      var textureFrame = this.getFrame(key, frame);
      if (textureFrame) {
        x -= textureFrame.x;
        y -= textureFrame.y;
        var data = textureFrame.data.cut;
        x += data.x;
        y += data.y;
        if (x >= data.x && x < data.r && y >= data.y && y < data.b) {
          var ctx = this._tempContext;
          ctx.clearRect(0, 0, 1, 1);
          ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);
          var rgb = ctx.getImageData(0, 0, 1, 1);
          return rgb.data[3];
        }
      }
      return null;
    },
    setTexture: function(gameObject, key, frame) {
      if (this.list[key]) {
        gameObject.texture = this.list[key];
        gameObject.frame = gameObject.texture.get(frame);
      }
      return gameObject;
    },
    renameTexture: function(currentKey, newKey) {
      var texture = this.get(currentKey);
      if (texture && currentKey !== newKey) {
        texture.key = newKey;
        this.list[newKey] = texture;
        delete this.list[currentKey];
        return true;
      }
      return false;
    },
    each: function(callback, scope) {
      var args = [null];
      for (var i = 1; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      for (var texture in this.list) {
        args[0] = this.list[texture];
        callback.apply(scope, args);
      }
    },
    destroy: function() {
      for (var texture in this.list) {
        this.list[texture].destroy();
      }
      this.list = {};
      this.game = null;
      CanvasPool.remove(this._tempCanvas);
    }
  });
  module2.exports = TextureManager;
});

// node_modules/phaser/src/sound/events/COMPLETE_EVENT.js
var require_COMPLETE_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "complete";
});

// node_modules/phaser/src/sound/events/DECODED_EVENT.js
var require_DECODED_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "decoded";
});

// node_modules/phaser/src/sound/events/DECODED_ALL_EVENT.js
var require_DECODED_ALL_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "decodedall";
});

// node_modules/phaser/src/sound/events/DESTROY_EVENT.js
var require_DESTROY_EVENT8 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "destroy";
});

// node_modules/phaser/src/sound/events/DETUNE_EVENT.js
var require_DETUNE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "detune";
});

// node_modules/phaser/src/sound/events/GLOBAL_DETUNE_EVENT.js
var require_GLOBAL_DETUNE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "detune";
});

// node_modules/phaser/src/sound/events/GLOBAL_MUTE_EVENT.js
var require_GLOBAL_MUTE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "mute";
});

// node_modules/phaser/src/sound/events/GLOBAL_RATE_EVENT.js
var require_GLOBAL_RATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "rate";
});

// node_modules/phaser/src/sound/events/GLOBAL_VOLUME_EVENT.js
var require_GLOBAL_VOLUME_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "volume";
});

// node_modules/phaser/src/sound/events/LOOP_EVENT.js
var require_LOOP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "loop";
});

// node_modules/phaser/src/sound/events/LOOPED_EVENT.js
var require_LOOPED_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "looped";
});

// node_modules/phaser/src/sound/events/MUTE_EVENT.js
var require_MUTE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "mute";
});

// node_modules/phaser/src/sound/events/PAN_EVENT.js
var require_PAN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       pi-kei
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pan";
});

// node_modules/phaser/src/sound/events/PAUSE_ALL_EVENT.js
var require_PAUSE_ALL_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pauseall";
});

// node_modules/phaser/src/sound/events/PAUSE_EVENT.js
var require_PAUSE_EVENT3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pause";
});

// node_modules/phaser/src/sound/events/PLAY_EVENT.js
var require_PLAY_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "play";
});

// node_modules/phaser/src/sound/events/RATE_EVENT.js
var require_RATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "rate";
});

// node_modules/phaser/src/sound/events/RESUME_ALL_EVENT.js
var require_RESUME_ALL_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "resumeall";
});

// node_modules/phaser/src/sound/events/RESUME_EVENT.js
var require_RESUME_EVENT3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "resume";
});

// node_modules/phaser/src/sound/events/SEEK_EVENT.js
var require_SEEK_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "seek";
});

// node_modules/phaser/src/sound/events/STOP_ALL_EVENT.js
var require_STOP_ALL_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "stopall";
});

// node_modules/phaser/src/sound/events/STOP_EVENT.js
var require_STOP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "stop";
});

// node_modules/phaser/src/sound/events/UNLOCKED_EVENT.js
var require_UNLOCKED_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "unlocked";
});

// node_modules/phaser/src/sound/events/VOLUME_EVENT.js
var require_VOLUME_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "volume";
});

// node_modules/phaser/src/sound/events/index.js
var require_events15 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    COMPLETE: require_COMPLETE_EVENT2(),
    DECODED: require_DECODED_EVENT(),
    DECODED_ALL: require_DECODED_ALL_EVENT(),
    DESTROY: require_DESTROY_EVENT8(),
    DETUNE: require_DETUNE_EVENT(),
    GLOBAL_DETUNE: require_GLOBAL_DETUNE_EVENT(),
    GLOBAL_MUTE: require_GLOBAL_MUTE_EVENT(),
    GLOBAL_RATE: require_GLOBAL_RATE_EVENT(),
    GLOBAL_VOLUME: require_GLOBAL_VOLUME_EVENT(),
    LOOP: require_LOOP_EVENT(),
    LOOPED: require_LOOPED_EVENT(),
    MUTE: require_MUTE_EVENT(),
    PAN: require_PAN_EVENT(),
    PAUSE_ALL: require_PAUSE_ALL_EVENT2(),
    PAUSE: require_PAUSE_EVENT3(),
    PLAY: require_PLAY_EVENT(),
    RATE: require_RATE_EVENT(),
    RESUME_ALL: require_RESUME_ALL_EVENT2(),
    RESUME: require_RESUME_EVENT3(),
    SEEK: require_SEEK_EVENT(),
    STOP_ALL: require_STOP_ALL_EVENT(),
    STOP: require_STOP_EVENT(),
    UNLOCKED: require_UNLOCKED_EVENT(),
    VOLUME: require_VOLUME_EVENT()
  };
});

// node_modules/phaser/src/utils/array/SafeRange.js
var require_SafeRange = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SafeRange = function(array, startIndex, endIndex, throwError) {
    var len = array.length;
    if (startIndex < 0 || startIndex > len || startIndex >= endIndex || endIndex > len || startIndex + endIndex > len) {
      if (throwError) {
        throw new Error("Range Error: Values outside acceptable range");
      }
      return false;
    } else {
      return true;
    }
  };
  module2.exports = SafeRange;
});

// node_modules/phaser/src/utils/array/GetAll.js
var require_GetAll = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SafeRange = require_SafeRange();
  var GetAll = function(array, property, value, startIndex, endIndex) {
    if (startIndex === void 0) {
      startIndex = 0;
    }
    if (endIndex === void 0) {
      endIndex = array.length;
    }
    var output = [];
    if (SafeRange(array, startIndex, endIndex)) {
      for (var i = startIndex; i < endIndex; i++) {
        var child = array[i];
        if (!property || property && value === void 0 && child.hasOwnProperty(property) || property && value !== void 0 && child[property] === value) {
          output.push(child);
        }
      }
    }
    return output;
  };
  module2.exports = GetAll;
});

// node_modules/phaser/src/utils/array/GetFirst.js
var require_GetFirst2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SafeRange = require_SafeRange();
  var GetFirst = function(array, property, value, startIndex, endIndex) {
    if (startIndex === void 0) {
      startIndex = 0;
    }
    if (endIndex === void 0) {
      endIndex = array.length;
    }
    if (SafeRange(array, startIndex, endIndex)) {
      for (var i = startIndex; i < endIndex; i++) {
        var child = array[i];
        if (!property || property && value === void 0 && child.hasOwnProperty(property) || property && value !== void 0 && child[property] === value) {
          return child;
        }
      }
    }
    return null;
  };
  module2.exports = GetFirst;
});

// node_modules/phaser/src/sound/BaseSoundManager.js
var require_BaseSoundManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Clone = require_Clone();
  var EventEmitter = require_eventemitter3();
  var Events = require_events15();
  var GameEvents = require_events();
  var NOOP = require_NOOP();
  var GetAll = require_GetAll();
  var GetFirst = require_GetFirst2();
  var BaseSoundManager = new Class({
    Extends: EventEmitter,
    initialize: function BaseSoundManager2(game2) {
      EventEmitter.call(this);
      this.game = game2;
      this.jsonCache = game2.cache.json;
      this.sounds = [];
      this.mute = false;
      this.volume = 1;
      this.pauseOnBlur = true;
      this._rate = 1;
      this._detune = 0;
      this.locked = this.locked || false;
      this.unlocked = false;
      game2.events.on(GameEvents.BLUR, this.onGameBlur, this);
      game2.events.on(GameEvents.FOCUS, this.onGameFocus, this);
      game2.events.on(GameEvents.PRE_STEP, this.update, this);
      game2.events.once(GameEvents.DESTROY, this.destroy, this);
    },
    add: NOOP,
    addAudioSprite: function(key, config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      var sound = this.add(key, config2);
      sound.spritemap = this.jsonCache.get(key).spritemap;
      for (var markerName in sound.spritemap) {
        if (!sound.spritemap.hasOwnProperty(markerName)) {
          continue;
        }
        var markerConfig = Clone(config2);
        var marker = sound.spritemap[markerName];
        markerConfig.loop = marker.hasOwnProperty("loop") ? marker.loop : false;
        sound.addMarker({
          name: markerName,
          start: marker.start,
          duration: marker.end - marker.start,
          config: markerConfig
        });
      }
      return sound;
    },
    get: function(key) {
      return GetFirst(this.sounds, "key", key);
    },
    getAll: function(key) {
      return GetAll(this.sounds, "key", key);
    },
    play: function(key, extra) {
      var sound = this.add(key);
      sound.once(Events.COMPLETE, sound.destroy, sound);
      if (extra) {
        if (extra.name) {
          sound.addMarker(extra);
          return sound.play(extra.name);
        } else {
          return sound.play(extra);
        }
      } else {
        return sound.play();
      }
    },
    playAudioSprite: function(key, spriteName, config2) {
      var sound = this.addAudioSprite(key);
      sound.once(Events.COMPLETE, sound.destroy, sound);
      return sound.play(spriteName, config2);
    },
    remove: function(sound) {
      var index = this.sounds.indexOf(sound);
      if (index !== -1) {
        sound.destroy();
        this.sounds.splice(index, 1);
        return true;
      }
      return false;
    },
    removeAll: function() {
      this.sounds.forEach(function(sound) {
        sound.destroy();
      });
      this.sounds.length = 0;
    },
    removeByKey: function(key) {
      var removed = 0;
      for (var i = this.sounds.length - 1; i >= 0; i--) {
        var sound = this.sounds[i];
        if (sound.key === key) {
          sound.destroy();
          this.sounds.splice(i, 1);
          removed++;
        }
      }
      return removed;
    },
    pauseAll: function() {
      this.forEachActiveSound(function(sound) {
        sound.pause();
      });
      this.emit(Events.PAUSE_ALL, this);
    },
    resumeAll: function() {
      this.forEachActiveSound(function(sound) {
        sound.resume();
      });
      this.emit(Events.RESUME_ALL, this);
    },
    stopAll: function() {
      this.forEachActiveSound(function(sound) {
        sound.stop();
      });
      this.emit(Events.STOP_ALL, this);
    },
    stopByKey: function(key) {
      var stopped = 0;
      this.getAll(key).forEach(function(sound) {
        if (sound.stop()) {
          stopped++;
        }
      });
      return stopped;
    },
    unlock: NOOP,
    onBlur: NOOP,
    onFocus: NOOP,
    onGameBlur: function() {
      if (this.pauseOnBlur) {
        this.onBlur();
      }
    },
    onGameFocus: function() {
      if (this.pauseOnBlur) {
        this.onFocus();
      }
    },
    update: function(time, delta) {
      if (this.unlocked) {
        this.unlocked = false;
        this.locked = false;
        this.emit(Events.UNLOCKED, this);
      }
      for (var i = this.sounds.length - 1; i >= 0; i--) {
        if (this.sounds[i].pendingRemove) {
          this.sounds.splice(i, 1);
        }
      }
      this.sounds.forEach(function(sound) {
        sound.update(time, delta);
      });
    },
    destroy: function() {
      this.game.events.off(GameEvents.BLUR, this.onGameBlur, this);
      this.game.events.off(GameEvents.FOCUS, this.onGameFocus, this);
      this.game.events.off(GameEvents.PRE_STEP, this.update, this);
      this.removeAllListeners();
      this.removeAll();
      this.sounds.length = 0;
      this.sounds = null;
      this.game = null;
    },
    forEachActiveSound: function(callback, scope) {
      var _this = this;
      this.sounds.forEach(function(sound, index) {
        if (sound && !sound.pendingRemove) {
          callback.call(scope || _this, sound, index, _this.sounds);
        }
      });
    },
    setRate: function(value) {
      this.rate = value;
      return this;
    },
    rate: {
      get: function() {
        return this._rate;
      },
      set: function(value) {
        this._rate = value;
        this.forEachActiveSound(function(sound) {
          sound.calculateRate();
        });
        this.emit(Events.GLOBAL_RATE, this, value);
      }
    },
    setDetune: function(value) {
      this.detune = value;
      return this;
    },
    detune: {
      get: function() {
        return this._detune;
      },
      set: function(value) {
        this._detune = value;
        this.forEachActiveSound(function(sound) {
          sound.calculateRate();
        });
        this.emit(Events.GLOBAL_DETUNE, this, value);
      }
    }
  });
  module2.exports = BaseSoundManager;
});

// node_modules/phaser/src/sound/BaseSound.js
var require_BaseSound = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var EventEmitter = require_eventemitter3();
  var Events = require_events15();
  var Extend = require_Extend();
  var NOOP = require_NOOP();
  var BaseSound = new Class({
    Extends: EventEmitter,
    initialize: function BaseSound2(manager, key, config2) {
      EventEmitter.call(this);
      this.manager = manager;
      this.key = key;
      this.isPlaying = false;
      this.isPaused = false;
      this.totalRate = 1;
      this.duration = this.duration || 0;
      this.totalDuration = this.totalDuration || 0;
      this.config = {
        mute: false,
        volume: 1,
        rate: 1,
        detune: 0,
        seek: 0,
        loop: false,
        delay: 0,
        pan: 0
      };
      this.currentConfig = this.config;
      this.config = Extend(this.config, config2);
      this.markers = {};
      this.currentMarker = null;
      this.pendingRemove = false;
    },
    addMarker: function(marker) {
      if (!marker || !marker.name || typeof marker.name !== "string") {
        return false;
      }
      if (this.markers[marker.name]) {
        console.error("addMarker " + marker.name + " already exists in Sound");
        return false;
      }
      marker = Extend(true, {
        name: "",
        start: 0,
        duration: this.totalDuration - (marker.start || 0),
        config: {
          mute: false,
          volume: 1,
          rate: 1,
          detune: 0,
          seek: 0,
          loop: false,
          delay: 0,
          pan: 0
        }
      }, marker);
      this.markers[marker.name] = marker;
      return true;
    },
    updateMarker: function(marker) {
      if (!marker || !marker.name || typeof marker.name !== "string") {
        return false;
      }
      if (!this.markers[marker.name]) {
        console.warn("Audio Marker: " + marker.name + " missing in Sound: " + this.key);
        return false;
      }
      this.markers[marker.name] = Extend(true, this.markers[marker.name], marker);
      return true;
    },
    removeMarker: function(markerName) {
      var marker = this.markers[markerName];
      if (!marker) {
        return null;
      }
      this.markers[markerName] = null;
      return marker;
    },
    play: function(markerName, config2) {
      if (markerName === void 0) {
        markerName = "";
      }
      if (typeof markerName === "object") {
        config2 = markerName;
        markerName = "";
      }
      if (typeof markerName !== "string") {
        return false;
      }
      if (!markerName) {
        this.currentMarker = null;
        this.currentConfig = this.config;
        this.duration = this.totalDuration;
      } else {
        if (!this.markers[markerName]) {
          console.warn("Marker: " + markerName + " missing in Sound: " + this.key);
          return false;
        }
        this.currentMarker = this.markers[markerName];
        this.currentConfig = this.currentMarker.config;
        this.duration = this.currentMarker.duration;
      }
      this.resetConfig();
      this.currentConfig = Extend(this.currentConfig, config2);
      this.isPlaying = true;
      this.isPaused = false;
      return true;
    },
    pause: function() {
      if (this.isPaused || !this.isPlaying) {
        return false;
      }
      this.isPlaying = false;
      this.isPaused = true;
      return true;
    },
    resume: function() {
      if (!this.isPaused || this.isPlaying) {
        return false;
      }
      this.isPlaying = true;
      this.isPaused = false;
      return true;
    },
    stop: function() {
      if (!this.isPaused && !this.isPlaying) {
        return false;
      }
      this.isPlaying = false;
      this.isPaused = false;
      this.resetConfig();
      return true;
    },
    applyConfig: function() {
      this.mute = this.currentConfig.mute;
      this.volume = this.currentConfig.volume;
      this.rate = this.currentConfig.rate;
      this.detune = this.currentConfig.detune;
      this.loop = this.currentConfig.loop;
      this.pan = this.currentConfig.pan;
    },
    resetConfig: function() {
      this.currentConfig.seek = 0;
      this.currentConfig.delay = 0;
    },
    update: NOOP,
    calculateRate: function() {
      var cent = 1.0005777895065548;
      var totalDetune = this.currentConfig.detune + this.manager.detune;
      var detuneRate = Math.pow(cent, totalDetune);
      this.totalRate = this.currentConfig.rate * this.manager.rate * detuneRate;
    },
    destroy: function() {
      if (this.pendingRemove) {
        return;
      }
      this.emit(Events.DESTROY, this);
      this.pendingRemove = true;
      this.manager = null;
      this.key = "";
      this.removeAllListeners();
      this.isPlaying = false;
      this.isPaused = false;
      this.config = null;
      this.currentConfig = null;
      this.markers = null;
      this.currentMarker = null;
    }
  });
  module2.exports = BaseSound;
});

// node_modules/phaser/src/sound/html5/HTML5AudioSound.js
var require_HTML5AudioSound = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BaseSound = require_BaseSound();
  var Class = require_Class();
  var Events = require_events15();
  var Clamp = require_Clamp();
  var HTML5AudioSound = new Class({
    Extends: BaseSound,
    initialize: function HTML5AudioSound2(manager, key, config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      this.tags = manager.game.cache.audio.get(key);
      if (!this.tags) {
        throw new Error('There is no audio asset with key "' + key + '" in the audio cache');
      }
      this.audio = null;
      this.startTime = 0;
      this.previousTime = 0;
      this.duration = this.tags[0].duration;
      this.totalDuration = this.tags[0].duration;
      BaseSound.call(this, manager, key, config2);
    },
    play: function(markerName, config2) {
      if (this.manager.isLocked(this, "play", [markerName, config2])) {
        return false;
      }
      if (!BaseSound.prototype.play.call(this, markerName, config2)) {
        return false;
      }
      if (!this.pickAndPlayAudioTag()) {
        return false;
      }
      this.emit(Events.PLAY, this);
      return true;
    },
    pause: function() {
      if (this.manager.isLocked(this, "pause")) {
        return false;
      }
      if (this.startTime > 0) {
        return false;
      }
      if (!BaseSound.prototype.pause.call(this)) {
        return false;
      }
      this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
      this.stopAndReleaseAudioTag();
      this.emit(Events.PAUSE, this);
      return true;
    },
    resume: function() {
      if (this.manager.isLocked(this, "resume")) {
        return false;
      }
      if (this.startTime > 0) {
        return false;
      }
      if (!BaseSound.prototype.resume.call(this)) {
        return false;
      }
      if (!this.pickAndPlayAudioTag()) {
        return false;
      }
      this.emit(Events.RESUME, this);
      return true;
    },
    stop: function() {
      if (this.manager.isLocked(this, "stop")) {
        return false;
      }
      if (!BaseSound.prototype.stop.call(this)) {
        return false;
      }
      this.stopAndReleaseAudioTag();
      this.emit(Events.STOP, this);
      return true;
    },
    pickAndPlayAudioTag: function() {
      if (!this.pickAudioTag()) {
        this.reset();
        return false;
      }
      var seek = this.currentConfig.seek;
      var delay = this.currentConfig.delay;
      var offset = (this.currentMarker ? this.currentMarker.start : 0) + seek;
      this.previousTime = offset;
      this.audio.currentTime = offset;
      this.applyConfig();
      if (delay === 0) {
        this.startTime = 0;
        if (this.audio.paused) {
          this.playCatchPromise();
        }
      } else {
        this.startTime = window.performance.now() + delay * 1e3;
        if (!this.audio.paused) {
          this.audio.pause();
        }
      }
      this.resetConfig();
      return true;
    },
    pickAudioTag: function() {
      if (this.audio) {
        return true;
      }
      for (var i = 0; i < this.tags.length; i++) {
        var audio = this.tags[i];
        if (audio.dataset.used === "false") {
          audio.dataset.used = "true";
          this.audio = audio;
          return true;
        }
      }
      if (!this.manager.override) {
        return false;
      }
      var otherSounds = [];
      this.manager.forEachActiveSound(function(sound) {
        if (sound.key === this.key && sound.audio) {
          otherSounds.push(sound);
        }
      }, this);
      otherSounds.sort(function(a1, a2) {
        if (a1.loop === a2.loop) {
          return a2.seek / a2.duration - a1.seek / a1.duration;
        }
        return a1.loop ? 1 : -1;
      });
      var selectedSound = otherSounds[0];
      this.audio = selectedSound.audio;
      selectedSound.reset();
      selectedSound.audio = null;
      selectedSound.startTime = 0;
      selectedSound.previousTime = 0;
      return true;
    },
    playCatchPromise: function() {
      var playPromise = this.audio.play();
      if (playPromise) {
        playPromise.catch(function(reason) {
          console.warn(reason);
        });
      }
    },
    stopAndReleaseAudioTag: function() {
      this.startTime = 0;
      this.previousTime = 0;
      if (this.audio) {
        this.audio.pause();
        this.audio.dataset.used = "false";
        this.audio = null;
      }
    },
    reset: function() {
      BaseSound.prototype.stop.call(this);
    },
    onBlur: function() {
      this.isPlaying = false;
      this.isPaused = true;
      this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
      this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3);
      this.stopAndReleaseAudioTag();
    },
    onFocus: function() {
      this.isPlaying = true;
      this.isPaused = false;
      this.pickAndPlayAudioTag();
    },
    update: function(time) {
      if (!this.isPlaying) {
        return;
      }
      if (this.startTime > 0) {
        if (this.startTime < time - this.manager.audioPlayDelay) {
          this.audio.currentTime += Math.max(0, time - this.startTime) / 1e3;
          this.startTime = 0;
          this.previousTime = this.audio.currentTime;
          this.playCatchPromise();
        }
        return;
      }
      var startTime = this.currentMarker ? this.currentMarker.start : 0;
      var endTime = startTime + this.duration;
      var currentTime = this.audio.currentTime;
      if (this.currentConfig.loop) {
        if (currentTime >= endTime - this.manager.loopEndOffset) {
          this.audio.currentTime = startTime + Math.max(0, currentTime - endTime);
          currentTime = this.audio.currentTime;
        } else if (currentTime < startTime) {
          this.audio.currentTime += startTime;
          currentTime = this.audio.currentTime;
        }
        if (currentTime < this.previousTime) {
          this.emit(Events.LOOPED, this);
        }
      } else if (currentTime >= endTime) {
        this.reset();
        this.stopAndReleaseAudioTag();
        this.emit(Events.COMPLETE, this);
        return;
      }
      this.previousTime = currentTime;
    },
    destroy: function() {
      BaseSound.prototype.destroy.call(this);
      this.tags = null;
      if (this.audio) {
        this.stopAndReleaseAudioTag();
      }
    },
    updateMute: function() {
      if (this.audio) {
        this.audio.muted = this.currentConfig.mute || this.manager.mute;
      }
    },
    updateVolume: function() {
      if (this.audio) {
        this.audio.volume = Clamp(this.currentConfig.volume * this.manager.volume, 0, 1);
      }
    },
    calculateRate: function() {
      BaseSound.prototype.calculateRate.call(this);
      if (this.audio) {
        this.audio.playbackRate = this.totalRate;
      }
    },
    mute: {
      get: function() {
        return this.currentConfig.mute;
      },
      set: function(value) {
        this.currentConfig.mute = value;
        if (this.manager.isLocked(this, "mute", value)) {
          return;
        }
        this.updateMute();
        this.emit(Events.MUTE, this, value);
      }
    },
    setMute: function(value) {
      this.mute = value;
      return this;
    },
    volume: {
      get: function() {
        return this.currentConfig.volume;
      },
      set: function(value) {
        this.currentConfig.volume = value;
        if (this.manager.isLocked(this, "volume", value)) {
          return;
        }
        this.updateVolume();
        this.emit(Events.VOLUME, this, value);
      }
    },
    setVolume: function(value) {
      this.volume = value;
      return this;
    },
    rate: {
      get: function() {
        return this.currentConfig.rate;
      },
      set: function(value) {
        this.currentConfig.rate = value;
        if (this.manager.isLocked(this, Events.RATE, value)) {
          return;
        } else {
          this.calculateRate();
          this.emit(Events.RATE, this, value);
        }
      }
    },
    setRate: function(value) {
      this.rate = value;
      return this;
    },
    detune: {
      get: function() {
        return this.currentConfig.detune;
      },
      set: function(value) {
        this.currentConfig.detune = value;
        if (this.manager.isLocked(this, Events.DETUNE, value)) {
          return;
        } else {
          this.calculateRate();
          this.emit(Events.DETUNE, this, value);
        }
      }
    },
    setDetune: function(value) {
      this.detune = value;
      return this;
    },
    seek: {
      get: function() {
        if (this.isPlaying) {
          return this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
        } else if (this.isPaused) {
          return this.currentConfig.seek;
        } else {
          return 0;
        }
      },
      set: function(value) {
        if (this.manager.isLocked(this, "seek", value)) {
          return;
        }
        if (this.startTime > 0) {
          return;
        }
        if (this.isPlaying || this.isPaused) {
          value = Math.min(Math.max(0, value), this.duration);
          if (this.isPlaying) {
            this.previousTime = value;
            this.audio.currentTime = value;
          } else if (this.isPaused) {
            this.currentConfig.seek = value;
          }
          this.emit(Events.SEEK, this, value);
        }
      }
    },
    setSeek: function(value) {
      this.seek = value;
      return this;
    },
    loop: {
      get: function() {
        return this.currentConfig.loop;
      },
      set: function(value) {
        this.currentConfig.loop = value;
        if (this.manager.isLocked(this, "loop", value)) {
          return;
        }
        if (this.audio) {
          this.audio.loop = value;
        }
        this.emit(Events.LOOP, this, value);
      }
    },
    setLoop: function(value) {
      this.loop = value;
      return this;
    },
    pan: {
      get: function() {
        return this.currentConfig.pan;
      },
      set: function(value) {
        this.currentConfig.pan = value;
        this.emit(Events.PAN, this, value);
      }
    },
    setPan: function(value) {
      this.pan = value;
      return this;
    }
  });
  module2.exports = HTML5AudioSound;
});

// node_modules/phaser/src/sound/html5/HTML5AudioSoundManager.js
var require_HTML5AudioSoundManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BaseSoundManager = require_BaseSoundManager();
  var Class = require_Class();
  var Events = require_events15();
  var HTML5AudioSound = require_HTML5AudioSound();
  var HTML5AudioSoundManager = new Class({
    Extends: BaseSoundManager,
    initialize: function HTML5AudioSoundManager2(game2) {
      this.override = true;
      this.audioPlayDelay = 0.1;
      this.loopEndOffset = 0.05;
      this.onBlurPausedSounds = [];
      this.locked = "ontouchstart" in window;
      this.lockedActionsQueue = this.locked ? [] : null;
      this._mute = false;
      this._volume = 1;
      BaseSoundManager.call(this, game2);
    },
    add: function(key, config2) {
      var sound = new HTML5AudioSound(this, key, config2);
      this.sounds.push(sound);
      return sound;
    },
    unlock: function() {
      this.locked = false;
      var _this = this;
      this.game.cache.audio.entries.each(function(key, tags) {
        for (var i = 0; i < tags.length; i++) {
          if (tags[i].dataset.locked === "true") {
            _this.locked = true;
            return false;
          }
        }
        return true;
      });
      if (!this.locked) {
        return;
      }
      var moved = false;
      var detectMove = function() {
        moved = true;
      };
      var unlock = function() {
        if (moved) {
          moved = false;
          return;
        }
        document.body.removeEventListener("touchmove", detectMove);
        document.body.removeEventListener("touchend", unlock);
        var lockedTags = [];
        _this.game.cache.audio.entries.each(function(key, tags) {
          for (var i = 0; i < tags.length; i++) {
            var tag = tags[i];
            if (tag.dataset.locked === "true") {
              lockedTags.push(tag);
            }
          }
          return true;
        });
        if (lockedTags.length === 0) {
          return;
        }
        var lastTag = lockedTags[lockedTags.length - 1];
        lastTag.oncanplaythrough = function() {
          lastTag.oncanplaythrough = null;
          lockedTags.forEach(function(tag) {
            tag.dataset.locked = "false";
          });
          _this.unlocked = true;
        };
        lockedTags.forEach(function(tag) {
          tag.load();
        });
      };
      this.once(Events.UNLOCKED, function() {
        this.forEachActiveSound(function(sound) {
          if (sound.currentMarker === null && sound.duration === 0) {
            sound.duration = sound.tags[0].duration;
          }
          sound.totalDuration = sound.tags[0].duration;
        });
        while (this.lockedActionsQueue.length) {
          var lockedAction = this.lockedActionsQueue.shift();
          if (lockedAction.sound[lockedAction.prop].apply) {
            lockedAction.sound[lockedAction.prop].apply(lockedAction.sound, lockedAction.value || []);
          } else {
            lockedAction.sound[lockedAction.prop] = lockedAction.value;
          }
        }
      }, this);
      document.body.addEventListener("touchmove", detectMove, false);
      document.body.addEventListener("touchend", unlock, false);
    },
    onBlur: function() {
      this.forEachActiveSound(function(sound) {
        if (sound.isPlaying) {
          this.onBlurPausedSounds.push(sound);
          sound.onBlur();
        }
      });
    },
    onFocus: function() {
      this.onBlurPausedSounds.forEach(function(sound) {
        sound.onFocus();
      });
      this.onBlurPausedSounds.length = 0;
    },
    destroy: function() {
      BaseSoundManager.prototype.destroy.call(this);
      this.onBlurPausedSounds.length = 0;
      this.onBlurPausedSounds = null;
    },
    isLocked: function(sound, prop, value) {
      if (sound.tags[0].dataset.locked === "true") {
        this.lockedActionsQueue.push({
          sound,
          prop,
          value
        });
        return true;
      }
      return false;
    },
    setMute: function(value) {
      this.mute = value;
      return this;
    },
    mute: {
      get: function() {
        return this._mute;
      },
      set: function(value) {
        this._mute = value;
        this.forEachActiveSound(function(sound) {
          sound.updateMute();
        });
        this.emit(Events.GLOBAL_MUTE, this, value);
      }
    },
    setVolume: function(value) {
      this.volume = value;
      return this;
    },
    volume: {
      get: function() {
        return this._volume;
      },
      set: function(value) {
        this._volume = value;
        this.forEachActiveSound(function(sound) {
          sound.updateVolume();
        });
        this.emit(Events.GLOBAL_VOLUME, this, value);
      }
    }
  });
  module2.exports = HTML5AudioSoundManager;
});

// node_modules/phaser/src/sound/noaudio/NoAudioSound.js
var require_NoAudioSound = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BaseSound = require_BaseSound();
  var Class = require_Class();
  var EventEmitter = require_eventemitter3();
  var Extend = require_Extend();
  var returnFalse = function() {
    return false;
  };
  var returnNull = function() {
    return null;
  };
  var returnThis = function() {
    return this;
  };
  var NoAudioSound = new Class({
    Extends: EventEmitter,
    initialize: function NoAudioSound2(manager, key, config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      EventEmitter.call(this);
      this.manager = manager;
      this.key = key;
      this.isPlaying = false;
      this.isPaused = false;
      this.totalRate = 1;
      this.duration = 0;
      this.totalDuration = 0;
      this.config = Extend({
        mute: false,
        volume: 1,
        rate: 1,
        detune: 0,
        seek: 0,
        loop: false,
        delay: 0,
        pan: 0
      }, config2);
      this.currentConfig = this.config;
      this.mute = false;
      this.volume = 1;
      this.rate = 1;
      this.detune = 0;
      this.seek = 0;
      this.loop = false;
      this.pan = 0;
      this.markers = {};
      this.currentMarker = null;
      this.pendingRemove = false;
    },
    addMarker: returnFalse,
    updateMarker: returnFalse,
    removeMarker: returnNull,
    play: returnFalse,
    pause: returnFalse,
    resume: returnFalse,
    stop: returnFalse,
    destroy: function() {
      BaseSound.prototype.destroy.call(this);
    },
    setMute: returnThis,
    setVolume: returnThis,
    setRate: returnThis,
    setDetune: returnThis,
    setSeek: returnThis,
    setLoop: returnThis,
    setPan: returnThis
  });
  module2.exports = NoAudioSound;
});

// node_modules/phaser/src/sound/noaudio/NoAudioSoundManager.js
var require_NoAudioSoundManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BaseSoundManager = require_BaseSoundManager();
  var Class = require_Class();
  var EventEmitter = require_eventemitter3();
  var NoAudioSound = require_NoAudioSound();
  var NOOP = require_NOOP();
  var NoAudioSoundManager = new Class({
    Extends: EventEmitter,
    initialize: function NoAudioSoundManager2(game2) {
      EventEmitter.call(this);
      this.game = game2;
      this.sounds = [];
      this.mute = false;
      this.volume = 1;
      this.rate = 1;
      this.detune = 0;
      this.pauseOnBlur = true;
      this.locked = false;
    },
    add: function(key, config2) {
      var sound = new NoAudioSound(this, key, config2);
      this.sounds.push(sound);
      return sound;
    },
    addAudioSprite: function(key, config2) {
      var sound = this.add(key, config2);
      sound.spritemap = {};
      return sound;
    },
    play: function(key, extra) {
      return false;
    },
    playAudioSprite: function(key, spriteName, config2) {
      return false;
    },
    remove: function(sound) {
      return BaseSoundManager.prototype.remove.call(this, sound);
    },
    removeByKey: function(key) {
      return BaseSoundManager.prototype.removeByKey.call(this, key);
    },
    pauseAll: NOOP,
    resumeAll: NOOP,
    stopAll: NOOP,
    update: NOOP,
    setRate: NOOP,
    setDetune: NOOP,
    setMute: NOOP,
    setVolume: NOOP,
    forEachActiveSound: function(callbackfn, scope) {
      BaseSoundManager.prototype.forEachActiveSound.call(this, callbackfn, scope);
    },
    destroy: function() {
      BaseSoundManager.prototype.destroy.call(this);
    }
  });
  module2.exports = NoAudioSoundManager;
});

// node_modules/phaser/src/utils/base64/Base64ToArrayBuffer.js
var require_Base64ToArrayBuffer = __commonJS((exports2, module2) => {
  /**
   * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }
  var Base64ToArrayBuffer = function(base64) {
    base64 = base64.substr(base64.indexOf(",") + 1);
    var len = base64.length;
    var bufferLength = len * 0.75;
    var p = 0;
    var encoded1;
    var encoded2;
    var encoded3;
    var encoded4;
    if (base64[len - 1] === "=") {
      bufferLength--;
      if (base64[len - 2] === "=") {
        bufferLength--;
      }
    }
    var arrayBuffer = new ArrayBuffer(bufferLength);
    var bytes = new Uint8Array(arrayBuffer);
    for (var i2 = 0; i2 < len; i2 += 4) {
      encoded1 = lookup[base64.charCodeAt(i2)];
      encoded2 = lookup[base64.charCodeAt(i2 + 1)];
      encoded3 = lookup[base64.charCodeAt(i2 + 2)];
      encoded4 = lookup[base64.charCodeAt(i2 + 3)];
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return arrayBuffer;
  };
  module2.exports = Base64ToArrayBuffer;
});

// node_modules/phaser/src/sound/webaudio/WebAudioSound.js
var require_WebAudioSound = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BaseSound = require_BaseSound();
  var Class = require_Class();
  var Events = require_events15();
  var WebAudioSound = new Class({
    Extends: BaseSound,
    initialize: function WebAudioSound2(manager, key, config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      this.audioBuffer = manager.game.cache.audio.get(key);
      if (!this.audioBuffer) {
        throw new Error('Audio key "' + key + '" missing from cache');
      }
      this.source = null;
      this.loopSource = null;
      this.muteNode = manager.context.createGain();
      this.volumeNode = manager.context.createGain();
      this.pannerNode = null;
      this.playTime = 0;
      this.startTime = 0;
      this.loopTime = 0;
      this.rateUpdates = [];
      this.hasEnded = false;
      this.hasLooped = false;
      this.muteNode.connect(this.volumeNode);
      if (manager.context.createStereoPanner) {
        this.pannerNode = manager.context.createStereoPanner();
        this.volumeNode.connect(this.pannerNode);
        this.pannerNode.connect(manager.destination);
      } else {
        this.volumeNode.connect(manager.destination);
      }
      this.duration = this.audioBuffer.duration;
      this.totalDuration = this.audioBuffer.duration;
      BaseSound.call(this, manager, key, config2);
    },
    play: function(markerName, config2) {
      if (!BaseSound.prototype.play.call(this, markerName, config2)) {
        return false;
      }
      this.stopAndRemoveBufferSource();
      this.createAndStartBufferSource();
      this.emit(Events.PLAY, this);
      return true;
    },
    pause: function() {
      if (this.manager.context.currentTime < this.startTime) {
        return false;
      }
      if (!BaseSound.prototype.pause.call(this)) {
        return false;
      }
      this.currentConfig.seek = this.getCurrentTime();
      this.stopAndRemoveBufferSource();
      this.emit(Events.PAUSE, this);
      return true;
    },
    resume: function() {
      if (this.manager.context.currentTime < this.startTime) {
        return false;
      }
      if (!BaseSound.prototype.resume.call(this)) {
        return false;
      }
      this.createAndStartBufferSource();
      this.emit(Events.RESUME, this);
      return true;
    },
    stop: function() {
      if (!BaseSound.prototype.stop.call(this)) {
        return false;
      }
      this.stopAndRemoveBufferSource();
      this.emit(Events.STOP, this);
      return true;
    },
    createAndStartBufferSource: function() {
      var seek = this.currentConfig.seek;
      var delay = this.currentConfig.delay;
      var when = this.manager.context.currentTime + delay;
      var offset = (this.currentMarker ? this.currentMarker.start : 0) + seek;
      var duration = this.duration - seek;
      this.playTime = when - seek;
      this.startTime = when;
      this.source = this.createBufferSource();
      this.applyConfig();
      this.source.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
      this.resetConfig();
    },
    createAndStartLoopBufferSource: function() {
      var when = this.getLoopTime();
      var offset = this.currentMarker ? this.currentMarker.start : 0;
      var duration = this.duration;
      this.loopTime = when;
      this.loopSource = this.createBufferSource();
      this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0);
      this.loopSource.start(Math.max(0, when), Math.max(0, offset), Math.max(0, duration));
    },
    createBufferSource: function() {
      var _this = this;
      var source = this.manager.context.createBufferSource();
      source.buffer = this.audioBuffer;
      source.connect(this.muteNode);
      source.onended = function(ev) {
        if (ev.target === _this.source) {
          if (_this.currentConfig.loop) {
            _this.hasLooped = true;
          } else {
            _this.hasEnded = true;
          }
        }
      };
      return source;
    },
    stopAndRemoveBufferSource: function() {
      if (this.source) {
        this.source.stop();
        this.source.disconnect();
        this.source = null;
      }
      this.playTime = 0;
      this.startTime = 0;
      this.stopAndRemoveLoopBufferSource();
    },
    stopAndRemoveLoopBufferSource: function() {
      if (this.loopSource) {
        this.loopSource.stop();
        this.loopSource.disconnect();
        this.loopSource = null;
      }
      this.loopTime = 0;
    },
    applyConfig: function() {
      this.rateUpdates.length = 0;
      this.rateUpdates.push({
        time: 0,
        rate: 1
      });
      BaseSound.prototype.applyConfig.call(this);
    },
    update: function() {
      if (this.hasEnded) {
        this.hasEnded = false;
        BaseSound.prototype.stop.call(this);
        this.stopAndRemoveBufferSource();
        this.emit(Events.COMPLETE, this);
      } else if (this.hasLooped) {
        this.hasLooped = false;
        this.source = this.loopSource;
        this.loopSource = null;
        this.playTime = this.startTime = this.loopTime;
        this.rateUpdates.length = 0;
        this.rateUpdates.push({
          time: 0,
          rate: this.totalRate
        });
        this.createAndStartLoopBufferSource();
        this.emit(Events.LOOPED, this);
      }
    },
    destroy: function() {
      BaseSound.prototype.destroy.call(this);
      this.audioBuffer = null;
      this.stopAndRemoveBufferSource();
      this.muteNode.disconnect();
      this.muteNode = null;
      this.volumeNode.disconnect();
      this.volumeNode = null;
      if (this.pannerNode) {
        this.pannerNode.disconnect();
        this.pannerNode = null;
      }
      this.rateUpdates.length = 0;
      this.rateUpdates = null;
    },
    calculateRate: function() {
      BaseSound.prototype.calculateRate.call(this);
      var now = this.manager.context.currentTime;
      if (this.source && typeof this.totalRate === "number") {
        this.source.playbackRate.setValueAtTime(this.totalRate, now);
      }
      if (this.isPlaying) {
        this.rateUpdates.push({
          time: Math.max(this.startTime, now) - this.playTime,
          rate: this.totalRate
        });
        if (this.loopSource) {
          this.stopAndRemoveLoopBufferSource();
          this.createAndStartLoopBufferSource();
        }
      }
    },
    getCurrentTime: function() {
      var currentTime = 0;
      for (var i = 0; i < this.rateUpdates.length; i++) {
        var nextTime = 0;
        if (i < this.rateUpdates.length - 1) {
          nextTime = this.rateUpdates[i + 1].time;
        } else {
          nextTime = this.manager.context.currentTime - this.playTime;
        }
        currentTime += (nextTime - this.rateUpdates[i].time) * this.rateUpdates[i].rate;
      }
      return currentTime;
    },
    getLoopTime: function() {
      var lastRateUpdateCurrentTime = 0;
      for (var i = 0; i < this.rateUpdates.length - 1; i++) {
        lastRateUpdateCurrentTime += (this.rateUpdates[i + 1].time - this.rateUpdates[i].time) * this.rateUpdates[i].rate;
      }
      var lastRateUpdate = this.rateUpdates[this.rateUpdates.length - 1];
      return this.playTime + lastRateUpdate.time + (this.duration - lastRateUpdateCurrentTime) / lastRateUpdate.rate;
    },
    rate: {
      get: function() {
        return this.currentConfig.rate;
      },
      set: function(value) {
        this.currentConfig.rate = value;
        this.calculateRate();
        this.emit(Events.RATE, this, value);
      }
    },
    setRate: function(value) {
      this.rate = value;
      return this;
    },
    detune: {
      get: function() {
        return this.currentConfig.detune;
      },
      set: function(value) {
        this.currentConfig.detune = value;
        this.calculateRate();
        this.emit(Events.DETUNE, this, value);
      }
    },
    setDetune: function(value) {
      this.detune = value;
      return this;
    },
    mute: {
      get: function() {
        return this.muteNode.gain.value === 0;
      },
      set: function(value) {
        this.currentConfig.mute = value;
        this.muteNode.gain.setValueAtTime(value ? 0 : 1, 0);
        this.emit(Events.MUTE, this, value);
      }
    },
    setMute: function(value) {
      this.mute = value;
      return this;
    },
    volume: {
      get: function() {
        return this.volumeNode.gain.value;
      },
      set: function(value) {
        this.currentConfig.volume = value;
        this.volumeNode.gain.setValueAtTime(value, 0);
        this.emit(Events.VOLUME, this, value);
      }
    },
    setVolume: function(value) {
      this.volume = value;
      return this;
    },
    seek: {
      get: function() {
        if (this.isPlaying) {
          if (this.manager.context.currentTime < this.startTime) {
            return this.startTime - this.playTime;
          }
          return this.getCurrentTime();
        } else if (this.isPaused) {
          return this.currentConfig.seek;
        } else {
          return 0;
        }
      },
      set: function(value) {
        if (this.manager.context.currentTime < this.startTime) {
          return;
        }
        if (this.isPlaying || this.isPaused) {
          value = Math.min(Math.max(0, value), this.duration);
          this.currentConfig.seek = value;
          if (this.isPlaying) {
            this.stopAndRemoveBufferSource();
            this.createAndStartBufferSource();
          }
          this.emit(Events.SEEK, this, value);
        }
      }
    },
    setSeek: function(value) {
      this.seek = value;
      return this;
    },
    loop: {
      get: function() {
        return this.currentConfig.loop;
      },
      set: function(value) {
        this.currentConfig.loop = value;
        if (this.isPlaying) {
          this.stopAndRemoveLoopBufferSource();
          if (value) {
            this.createAndStartLoopBufferSource();
          }
        }
        this.emit(Events.LOOP, this, value);
      }
    },
    setLoop: function(value) {
      this.loop = value;
      return this;
    },
    pan: {
      get: function() {
        if (this.pannerNode) {
          return this.pannerNode.pan.value;
        } else {
          return 0;
        }
      },
      set: function(value) {
        this.currentConfig.pan = value;
        if (this.pannerNode) {
          this.pannerNode.pan.setValueAtTime(value, this.manager.context.currentTime);
        }
        this.emit(Events.PAN, this, value);
      }
    },
    setPan: function(value) {
      this.pan = value;
      return this;
    }
  });
  module2.exports = WebAudioSound;
});

// node_modules/phaser/src/sound/webaudio/WebAudioSoundManager.js
var require_WebAudioSoundManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Base64ToArrayBuffer = require_Base64ToArrayBuffer();
  var BaseSoundManager = require_BaseSoundManager();
  var Class = require_Class();
  var Events = require_events15();
  var GameEvents = require_events();
  var WebAudioSound = require_WebAudioSound();
  var WebAudioSoundManager = new Class({
    Extends: BaseSoundManager,
    initialize: function WebAudioSoundManager2(game2) {
      this.context = this.createAudioContext(game2);
      this.masterMuteNode = this.context.createGain();
      this.masterVolumeNode = this.context.createGain();
      this.masterMuteNode.connect(this.masterVolumeNode);
      this.masterVolumeNode.connect(this.context.destination);
      this.destination = this.masterMuteNode;
      this.locked = this.context.state === "suspended" && ("ontouchstart" in window || "onclick" in window);
      BaseSoundManager.call(this, game2);
      if (this.locked && game2.isBooted) {
        this.unlock();
      } else {
        game2.events.once(GameEvents.BOOT, this.unlock, this);
      }
    },
    createAudioContext: function(game2) {
      var audioConfig = game2.config.audio;
      if (audioConfig.context) {
        audioConfig.context.resume();
        return audioConfig.context;
      }
      if (window.hasOwnProperty("AudioContext")) {
        return new AudioContext();
      } else if (window.hasOwnProperty("webkitAudioContext")) {
        return new window.webkitAudioContext();
      }
    },
    setAudioContext: function(context) {
      if (this.context) {
        this.context.close();
      }
      if (this.masterMuteNode) {
        this.masterMuteNode.disconnect();
      }
      if (this.masterVolumeNode) {
        this.masterVolumeNode.disconnect();
      }
      this.context = context;
      this.masterMuteNode = context.createGain();
      this.masterVolumeNode = context.createGain();
      this.masterMuteNode.connect(this.masterVolumeNode);
      this.masterVolumeNode.connect(context.destination);
      this.destination = this.masterMuteNode;
      return this;
    },
    add: function(key, config2) {
      var sound = new WebAudioSound(this, key, config2);
      this.sounds.push(sound);
      return sound;
    },
    decodeAudio: function(audioKey, audioData) {
      var audioFiles;
      if (!Array.isArray(audioKey)) {
        audioFiles = [{key: audioKey, data: audioData}];
      } else {
        audioFiles = audioKey;
      }
      var cache = this.game.cache.audio;
      var remaining = audioFiles.length;
      for (var i = 0; i < audioFiles.length; i++) {
        var entry = audioFiles[i];
        var key = entry.key;
        var data = entry.data;
        if (typeof data === "string") {
          data = Base64ToArrayBuffer(data);
        }
        var success = function(key2, audioBuffer) {
          cache.add(key2, audioBuffer);
          this.emit(Events.DECODED, key2);
          remaining--;
          if (remaining === 0) {
            this.emit(Events.DECODED_ALL);
          }
        }.bind(this, key);
        var failure = function(key2, error) {
          console.error("Error decoding audio: " + key2 + " - ", error ? error.message : "");
          remaining--;
          if (remaining === 0) {
            this.emit(Events.DECODED_ALL);
          }
        }.bind(this, key);
        this.context.decodeAudioData(data, success, failure);
      }
    },
    unlock: function() {
      var _this = this;
      var body = document.body;
      var unlockHandler = function unlockHandler2() {
        if (_this.context && body) {
          var bodyRemove = body.removeEventListener;
          _this.context.resume().then(function() {
            bodyRemove("touchstart", unlockHandler2);
            bodyRemove("touchend", unlockHandler2);
            bodyRemove("click", unlockHandler2);
            bodyRemove("keydown", unlockHandler2);
            _this.unlocked = true;
          }, function() {
            bodyRemove("touchstart", unlockHandler2);
            bodyRemove("touchend", unlockHandler2);
            bodyRemove("click", unlockHandler2);
            bodyRemove("keydown", unlockHandler2);
          });
        }
      };
      if (body) {
        body.addEventListener("touchstart", unlockHandler, false);
        body.addEventListener("touchend", unlockHandler, false);
        body.addEventListener("click", unlockHandler, false);
        body.addEventListener("keydown", unlockHandler, false);
      }
    },
    onBlur: function() {
      if (!this.locked) {
        this.context.suspend();
      }
    },
    onFocus: function() {
      var context = this.context;
      if ((context.state === "suspended" || context.state === "interrupted") && !this.locked) {
        context.resume();
      }
    },
    update: function(time, delta) {
      BaseSoundManager.prototype.update.call(this, time, delta);
      var context = this.context;
      if (context && context.state === "interrupted") {
        context.resume();
      }
    },
    destroy: function() {
      this.destination = null;
      this.masterVolumeNode.disconnect();
      this.masterVolumeNode = null;
      this.masterMuteNode.disconnect();
      this.masterMuteNode = null;
      if (this.game.config.audio.context) {
        this.context.suspend();
      } else {
        var _this = this;
        this.context.close().then(function() {
          _this.context = null;
        });
      }
      BaseSoundManager.prototype.destroy.call(this);
    },
    setMute: function(value) {
      this.mute = value;
      return this;
    },
    mute: {
      get: function() {
        return this.masterMuteNode.gain.value === 0;
      },
      set: function(value) {
        this.masterMuteNode.gain.setValueAtTime(value ? 0 : 1, 0);
        this.emit(Events.GLOBAL_MUTE, this, value);
      }
    },
    setVolume: function(value) {
      this.volume = value;
      return this;
    },
    volume: {
      get: function() {
        return this.masterVolumeNode.gain.value;
      },
      set: function(value) {
        this.masterVolumeNode.gain.setValueAtTime(value, 0);
        this.emit(Events.GLOBAL_VOLUME, this, value);
      }
    }
  });
  module2.exports = WebAudioSoundManager;
});

// node_modules/phaser/src/sound/SoundManagerCreator.js
var require_SoundManagerCreator = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var HTML5AudioSoundManager = require_HTML5AudioSoundManager();
  var NoAudioSoundManager = require_NoAudioSoundManager();
  var WebAudioSoundManager = require_WebAudioSoundManager();
  var SoundManagerCreator = {
    create: function(game2) {
      var audioConfig = game2.config.audio;
      var deviceAudio = game2.device.audio;
      if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
        return new NoAudioSoundManager(game2);
      }
      if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
        return new WebAudioSoundManager(game2);
      }
      return new HTML5AudioSoundManager(game2);
    }
  };
  module2.exports = SoundManagerCreator;
});

// node_modules/phaser/plugins/fbinstant/src/AdInstance.js
var require_AdInstance = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var AdInstance = function(placementID, instance, video) {
    return {
      instance,
      placementID,
      shown: false,
      video
    };
  };
  module2.exports = AdInstance;
});

// node_modules/phaser/plugins/fbinstant/src/LeaderboardScore.js
var require_LeaderboardScore = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var LeaderboardScore = function(entry) {
    return {
      score: entry.getScore(),
      scoreFormatted: entry.getFormattedScore(),
      timestamp: entry.getTimestamp(),
      rank: entry.getRank(),
      data: entry.getExtraData(),
      playerName: entry.getPlayer().getName(),
      playerPhotoURL: entry.getPlayer().getPhoto(),
      playerID: entry.getPlayer().getID()
    };
  };
  module2.exports = LeaderboardScore;
});

// node_modules/phaser/plugins/fbinstant/src/Leaderboard.js
var require_Leaderboard = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var Class = require_Class();
  var EventEmitter = require_eventemitter3();
  var LeaderboardScore = require_LeaderboardScore();
  var Leaderboard = new Class({
    Extends: EventEmitter,
    initialize: function Leaderboard2(plugin, data) {
      EventEmitter.call(this);
      this.plugin = plugin;
      this.ref = data;
      this.name = data.getName();
      this.contextID = data.getContextID();
      this.entryCount = 0;
      this.playerScore = null;
      this.scores = [];
      this.getEntryCount();
    },
    getEntryCount: function() {
      var _this = this;
      this.ref.getEntryCountAsync().then(function(count) {
        _this.entryCount = count;
        _this.emit("getentrycount", count, _this.name);
      }).catch(function(e) {
        console.warn(e);
      });
      return this;
    },
    setScore: function(score, data) {
      if (data === void 0) {
        data = "";
      }
      if (typeof data === "object") {
        data = JSON.stringify(data);
      }
      var _this = this;
      this.ref.setScoreAsync(score, data).then(function(entry) {
        if (entry) {
          var score2 = LeaderboardScore(entry);
          _this.playerScore = score2;
          _this.emit("setscore", score2, _this.name);
        } else {
          _this.emit("setscore", null, _this.name);
        }
      }).catch(function(e) {
        console.warn(e);
      });
      return this;
    },
    getPlayerScore: function() {
      var _this = this;
      this.ref.getPlayerEntryAsync().then(function(entry) {
        if (entry) {
          var score = LeaderboardScore(entry);
          _this.playerScore = score;
          _this.emit("getplayerscore", score, _this.name);
        } else {
          _this.emit("getplayerscore", null, _this.name);
        }
      }).catch(function(e) {
        console.warn(e);
      });
      return this;
    },
    getScores: function(count, offset) {
      if (count === void 0) {
        count = 10;
      }
      if (offset === void 0) {
        offset = 0;
      }
      var _this = this;
      this.ref.getEntriesAsync(count, offset).then(function(entries) {
        _this.scores = [];
        entries.forEach(function(entry) {
          _this.scores.push(LeaderboardScore(entry));
        });
        _this.emit("getscores", _this.scores, _this.name);
      }).catch(function(e) {
        console.warn(e);
      });
      return this;
    },
    getConnectedScores: function() {
      var _this = this;
      this.ref.getConnectedPlayerEntriesAsync().then(function(entries) {
        _this.scores = [];
        entries.forEach(function(entry) {
          _this.scores.push(LeaderboardScore(entry));
        });
        _this.emit("getconnectedscores", _this.scores, _this.name);
      }).catch(function(e) {
        console.warn(e);
      });
      return this;
    }
  });
  module2.exports = Leaderboard;
});

// node_modules/phaser/plugins/fbinstant/src/Product.js
var require_Product = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var GetFastValue = require_GetFastValue();
  var Product = function(data) {
    return {
      title: GetFastValue(data, "title", ""),
      productID: GetFastValue(data, "productID", ""),
      description: GetFastValue(data, "description", ""),
      imageURI: GetFastValue(data, "imageURI", ""),
      price: GetFastValue(data, "price", ""),
      priceCurrencyCode: GetFastValue(data, "priceCurrencyCode", "")
    };
  };
  module2.exports = Product;
});

// node_modules/phaser/plugins/fbinstant/src/Purchase.js
var require_Purchase = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var GetFastValue = require_GetFastValue();
  var Purchase = function(data) {
    return {
      developerPayload: GetFastValue(data, "developerPayload", ""),
      paymentID: GetFastValue(data, "paymentID", ""),
      productID: GetFastValue(data, "productID", ""),
      purchaseTime: GetFastValue(data, "purchaseTime", ""),
      purchaseToken: GetFastValue(data, "purchaseToken", ""),
      signedRequest: GetFastValue(data, "signedRequest", "")
    };
  };
  module2.exports = Purchase;
});

// node_modules/phaser/plugins/fbinstant/src/FacebookInstantGamesPlugin.js
var require_FacebookInstantGamesPlugin = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var AdInstance = require_AdInstance();
  var Class = require_Class();
  var DataManager = require_DataManager();
  var EventEmitter = require_eventemitter3();
  var Leaderboard = require_Leaderboard();
  var Product = require_Product();
  var Purchase = require_Purchase();
  var FacebookInstantGamesPlugin = new Class({
    Extends: EventEmitter,
    initialize: function FacebookInstantGamesPlugin2(game2) {
      EventEmitter.call(this);
      this.game = game2;
      this.data = new DataManager(this);
      this.on("setdata", this.setDataHandler, this);
      this.on("changedata", this.changeDataHandler, this);
      this.hasLoaded = false;
      this.dataLocked = false;
      this.supportedAPIs = [];
      this.entryPoint = "";
      this.entryPointData = null;
      this.contextID = null;
      this.contextType = null;
      this.locale = null;
      this.platform = null;
      this.version = null;
      this.playerID = null;
      this.playerName = null;
      this.playerPhotoURL = null;
      this.playerCanSubscribeBot = false;
      this.paymentsReady = false;
      this.catalog = [];
      this.purchases = [];
      this.leaderboards = {};
      this.ads = [];
    },
    setDataHandler: function(parent, key, value) {
      if (this.dataLocked) {
        return;
      }
      var data = {};
      data[key] = value;
      var _this = this;
      FBInstant.player.setDataAsync(data).then(function() {
        _this.emit("savedata", data);
      });
    },
    changeDataHandler: function(parent, key, value) {
      if (this.dataLocked) {
        return;
      }
      var data = {};
      data[key] = value;
      var _this = this;
      FBInstant.player.setDataAsync(data).then(function() {
        _this.emit("savedata", data);
      });
    },
    showLoadProgress: function(scene) {
      scene.load.on("progress", function(value) {
        if (!this.hasLoaded) {
          FBInstant.setLoadingProgress(value * 100);
        }
      }, this);
      scene.load.on("complete", function() {
        if (!this.hasLoaded) {
          this.hasLoaded = true;
          FBInstant.startGameAsync().then(this.gameStartedHandler.bind(this));
        }
      }, this);
      return this;
    },
    gameStarted: function() {
      if (!this.hasLoaded) {
        this.hasLoaded = true;
        FBInstant.startGameAsync().then(this.gameStartedHandler.bind(this));
      } else {
        this.gameStartedHandler();
      }
    },
    gameStartedHandler: function() {
      var APIs = FBInstant.getSupportedAPIs();
      var supported = {};
      var dotToUpper = function(match) {
        return match[1].toUpperCase();
      };
      APIs.forEach(function(api) {
        api = api.replace(/\../g, dotToUpper);
        supported[api] = true;
      });
      this.supportedAPIs = supported;
      this.getID();
      this.getType();
      this.getLocale();
      this.getPlatform();
      this.getSDKVersion();
      this.getPlayerID();
      this.getPlayerName();
      this.getPlayerPhotoURL();
      var _this = this;
      FBInstant.onPause(function() {
        _this.emit("pause");
      });
      FBInstant.getEntryPointAsync().then(function(entrypoint) {
        _this.entryPoint = entrypoint;
        _this.entryPointData = FBInstant.getEntryPointData();
        _this.emit("startgame");
      }).catch(function(e) {
        console.warn(e);
      });
      if (this.supportedAPIs.paymentsPurchaseAsync) {
        FBInstant.payments.onReady(function() {
          _this.paymentsReady = true;
        }).catch(function(e) {
          console.warn(e);
        });
      }
    },
    checkAPI: function(api) {
      if (!this.supportedAPIs[api]) {
        return false;
      } else {
        return true;
      }
    },
    getID: function() {
      if (!this.contextID && this.supportedAPIs.contextGetID) {
        this.contextID = FBInstant.context.getID();
      }
      return this.contextID;
    },
    getType: function() {
      if (!this.contextType && this.supportedAPIs.contextGetType) {
        this.contextType = FBInstant.context.getType();
      }
      return this.contextType;
    },
    getLocale: function() {
      if (!this.locale && this.supportedAPIs.getLocale) {
        this.locale = FBInstant.getLocale();
      }
      return this.locale;
    },
    getPlatform: function() {
      if (!this.platform && this.supportedAPIs.getPlatform) {
        this.platform = FBInstant.getPlatform();
      }
      return this.platform;
    },
    getSDKVersion: function() {
      if (!this.version && this.supportedAPIs.getSDKVersion) {
        this.version = FBInstant.getSDKVersion();
      }
      return this.version;
    },
    getPlayerID: function() {
      if (!this.playerID && this.supportedAPIs.playerGetID) {
        this.playerID = FBInstant.player.getID();
      }
      return this.playerID;
    },
    getPlayerName: function() {
      if (!this.playerName && this.supportedAPIs.playerGetName) {
        this.playerName = FBInstant.player.getName();
      }
      return this.playerName;
    },
    getPlayerPhotoURL: function() {
      if (!this.playerPhotoURL && this.supportedAPIs.playerGetPhoto) {
        this.playerPhotoURL = FBInstant.player.getPhoto();
      }
      return this.playerPhotoURL;
    },
    loadPlayerPhoto: function(scene, key) {
      if (this.playerPhotoURL) {
        scene.load.setCORS("anonymous");
        scene.load.image(key, this.playerPhotoURL);
        scene.load.once("filecomplete-image-" + key, function() {
          this.emit("photocomplete", key);
        }, this);
        scene.load.start();
      }
      return this;
    },
    canSubscribeBot: function() {
      if (this.supportedAPIs.playerCanSubscribeBotAsync) {
        var _this = this;
        FBInstant.player.canSubscribeBotAsync().then(function() {
          _this.playerCanSubscribeBot = true;
          _this.emit("cansubscribebot");
        }).catch(function(e) {
          _this.emit("cansubscribebotfail", e);
        });
      } else {
        this.emit("cansubscribebotfail");
      }
      return this;
    },
    subscribeBot: function() {
      if (this.playerCanSubscribeBot) {
        var _this = this;
        FBInstant.player.subscribeBotAsync().then(function() {
          _this.emit("subscribebot");
        }).catch(function(e) {
          _this.emit("subscribebotfail", e);
        });
      } else {
        this.emit("subscribebotfail");
      }
      return this;
    },
    getData: function(keys) {
      if (!this.checkAPI("playerGetDataAsync")) {
        return this;
      }
      if (!Array.isArray(keys)) {
        keys = [keys];
      }
      var _this = this;
      FBInstant.player.getDataAsync(keys).then(function(data) {
        _this.dataLocked = true;
        for (var key in data) {
          _this.data.set(key, data[key]);
        }
        _this.dataLocked = false;
        _this.emit("getdata", data);
      });
      return this;
    },
    saveData: function(data) {
      if (!this.checkAPI("playerSetDataAsync")) {
        return this;
      }
      var _this = this;
      FBInstant.player.setDataAsync(data).then(function() {
        _this.emit("savedata", data);
      }).catch(function(e) {
        _this.emit("savedatafail", e);
      });
      return this;
    },
    flushData: function() {
      if (!this.checkAPI("playerFlushDataAsync")) {
        return this;
      }
      var _this = this;
      FBInstant.player.flushDataAsync().then(function() {
        _this.emit("flushdata");
      }).catch(function(e) {
        _this.emit("flushdatafail", e);
      });
      return this;
    },
    getStats: function(keys) {
      if (!this.checkAPI("playerGetStatsAsync")) {
        return this;
      }
      var _this = this;
      FBInstant.player.getStatsAsync(keys).then(function(data) {
        _this.emit("getstats", data);
      }).catch(function(e) {
        _this.emit("getstatsfail", e);
      });
      return this;
    },
    saveStats: function(data) {
      if (!this.checkAPI("playerSetStatsAsync")) {
        return this;
      }
      var output = {};
      for (var key in data) {
        if (typeof data[key] === "number") {
          output[key] = data[key];
        }
      }
      var _this = this;
      FBInstant.player.setStatsAsync(output).then(function() {
        _this.emit("savestats", output);
      }).catch(function(e) {
        _this.emit("savestatsfail", e);
      });
      return this;
    },
    incStats: function(data) {
      if (!this.checkAPI("playerIncrementStatsAsync")) {
        return this;
      }
      var output = {};
      for (var key in data) {
        if (typeof data[key] === "number") {
          output[key] = data[key];
        }
      }
      var _this = this;
      FBInstant.player.incrementStatsAsync(output).then(function(stats) {
        _this.emit("incstats", stats);
      }).catch(function(e) {
        _this.emit("incstatsfail", e);
      });
      return this;
    },
    saveSession: function(data) {
      if (!this.checkAPI("setSessionData")) {
        return this;
      }
      var test = JSON.stringify(data);
      if (test.length <= 1e3) {
        FBInstant.setSessionData(data);
      } else {
        console.warn("Session data too long. Max 1000 chars.");
      }
      return this;
    },
    openShare: function(text, key, frame, sessionData) {
      return this._share("SHARE", text, key, frame, sessionData);
    },
    openInvite: function(text, key, frame, sessionData) {
      return this._share("INVITE", text, key, frame, sessionData);
    },
    openRequest: function(text, key, frame, sessionData) {
      return this._share("REQUEST", text, key, frame, sessionData);
    },
    openChallenge: function(text, key, frame, sessionData) {
      return this._share("CHALLENGE", text, key, frame, sessionData);
    },
    _share: function(intent, text, key, frame, sessionData) {
      if (!this.checkAPI("shareAsync")) {
        return this;
      }
      if (sessionData === void 0) {
        sessionData = {};
      }
      if (key) {
        var imageData = this.game.textures.getBase64(key, frame);
      }
      var payload = {
        intent,
        image: imageData,
        text,
        data: sessionData
      };
      var _this = this;
      FBInstant.shareAsync(payload).then(function() {
        _this.emit("resume");
      });
      return this;
    },
    isSizeBetween: function(min, max) {
      if (!this.checkAPI("contextIsSizeBetween")) {
        return this;
      }
      return FBInstant.context.isSizeBetween(min, max);
    },
    switchContext: function(contextID) {
      if (!this.checkAPI("contextSwitchAsync")) {
        return this;
      }
      if (contextID !== this.contextID) {
        var _this = this;
        FBInstant.context.switchAsync(contextID).then(function() {
          _this.contextID = FBInstant.context.getID();
          _this.emit("switch", _this.contextID);
        }).catch(function(e) {
          _this.emit("switchfail", e);
        });
      }
      return this;
    },
    chooseContext: function(options) {
      if (!this.checkAPI("contextChooseAsync")) {
        return this;
      }
      var _this = this;
      FBInstant.context.chooseAsync(options).then(function() {
        _this.contextID = FBInstant.context.getID();
        _this.emit("choose", _this.contextID);
      }).catch(function(e) {
        _this.emit("choosefail", e);
      });
      return this;
    },
    createContext: function(playerID) {
      if (!this.checkAPI("contextCreateAsync")) {
        return this;
      }
      var _this = this;
      FBInstant.context.createAsync(playerID).then(function() {
        _this.contextID = FBInstant.context.getID();
        _this.emit("create", _this.contextID);
      }).catch(function(e) {
        _this.emit("createfail", e);
      });
      return this;
    },
    getPlayers: function() {
      if (!this.checkAPI("playerGetConnectedPlayersAsync")) {
        return this;
      }
      var _this = this;
      FBInstant.player.getConnectedPlayersAsync().then(function(players) {
        _this.emit("players", players);
      }).catch(function(e) {
        _this.emit("playersfail", e);
      });
      return this;
    },
    getCatalog: function() {
      if (!this.paymentsReady) {
        return this;
      }
      var _this = this;
      var catalog = this.catalog;
      FBInstant.payments.getCatalogAsync().then(function(data) {
        catalog = [];
        data.forEach(function(item) {
          catalog.push(Product(item));
        });
        _this.emit("getcatalog", catalog);
      }).catch(function(e) {
        _this.emit("getcatalogfail", e);
      });
      return this;
    },
    getProduct: function(productID) {
      for (var i = 0; i < this.catalog.length; i++) {
        if (this.catalog[i].productID === productID) {
          return this.catalog[i];
        }
      }
      return null;
    },
    purchase: function(productID, developerPayload) {
      if (!this.paymentsReady) {
        return this;
      }
      var config2 = {productID};
      if (developerPayload) {
        config2.developerPayload = developerPayload;
      }
      var _this = this;
      FBInstant.payments.purchaseAsync(config2).then(function(data) {
        var purchase = Purchase(data);
        _this.emit("purchase", purchase);
      }).catch(function(e) {
        _this.emit("purchasefail", e);
      });
      return this;
    },
    getPurchases: function() {
      if (!this.paymentsReady) {
        return this;
      }
      var _this = this;
      var purchases = this.purchases;
      FBInstant.payments.getPurchasesAsync().then(function(data) {
        purchases = [];
        data.forEach(function(item) {
          purchases.push(Purchase(item));
        });
        _this.emit("getpurchases", purchases);
      }).catch(function(e) {
        _this.emit("getpurchasesfail", e);
      });
      return this;
    },
    consumePurchase: function(purchaseToken) {
      if (!this.paymentsReady) {
        return this;
      }
      var _this = this;
      FBInstant.payments.consumePurchaseAsync(purchaseToken).then(function() {
        _this.emit("consumepurchase", purchaseToken);
      }).catch(function(e) {
        _this.emit("consumepurchasefail", e);
      });
      return this;
    },
    update: function(cta, text, key, frame, template, updateData) {
      return this._update("CUSTOM", cta, text, key, frame, template, updateData);
    },
    updateLeaderboard: function(cta, text, key, frame, template, updateData) {
      return this._update("LEADERBOARD", cta, text, key, frame, template, updateData);
    },
    _update: function(action, cta, text, key, frame, template, updateData) {
      if (!this.checkAPI("shareAsync")) {
        return this;
      }
      if (cta === void 0) {
        cta = "";
      }
      if (typeof text === "string") {
        text = {default: text};
      }
      if (updateData === void 0) {
        updateData = {};
      }
      if (key) {
        var imageData = this.game.textures.getBase64(key, frame);
      }
      var payload = {
        action,
        cta,
        image: imageData,
        text,
        template,
        data: updateData,
        strategy: "IMMEDIATE",
        notification: "NO_PUSH"
      };
      var _this = this;
      FBInstant.updateAsync(payload).then(function() {
        _this.emit("update");
      }).catch(function(e) {
        _this.emit("updatefail", e);
      });
      return this;
    },
    switchGame: function(appID, data) {
      if (!this.checkAPI("switchGameAsync")) {
        return this;
      }
      if (data) {
        var test = JSON.stringify(data);
        if (test.length > 1e3) {
          console.warn("Switch Game data too long. Max 1000 chars.");
          return this;
        }
      }
      var _this = this;
      FBInstant.switchGameAsync(appID, data).then(function() {
        _this.emit("switchgame", appID);
      }).catch(function(e) {
        _this.emit("switchgamefail", e);
      });
      return this;
    },
    createShortcut: function() {
      var _this = this;
      FBInstant.canCreateShortcutAsync().then(function(canCreateShortcut) {
        if (canCreateShortcut) {
          FBInstant.createShortcutAsync().then(function() {
            _this.emit("shortcutcreated");
          }).catch(function(e) {
            _this.emit("shortcutfailed", e);
          });
        }
      });
      return this;
    },
    quit: function() {
      FBInstant.quit();
    },
    log: function(name, value, params) {
      if (!this.checkAPI("logEvent")) {
        return this;
      }
      if (params === void 0) {
        params = {};
      }
      if (name.length >= 2 && name.length <= 40) {
        FBInstant.logEvent(name, parseFloat(value), params);
      }
      return this;
    },
    preloadAds: function(placementID) {
      if (!this.checkAPI("getInterstitialAdAsync")) {
        return this;
      }
      if (!Array.isArray(placementID)) {
        placementID = [placementID];
      }
      var i;
      var _this = this;
      var total = 0;
      for (i = 0; i < this.ads.length; i++) {
        if (!this.ads[i].shown) {
          total++;
        }
      }
      if (total + placementID.length >= 3) {
        console.warn("Too many AdInstances. Show an ad before loading more");
        return this;
      }
      for (i = 0; i < placementID.length; i++) {
        var id = placementID[i];
        var data;
        FBInstant.getInterstitialAdAsync(id).then(function(interstitial) {
          data = interstitial;
          return interstitial.loadAsync();
        }).then(function() {
          var ad = AdInstance(id, data, false);
          _this.ads.push(ad);
          _this.emit("adloaded", ad);
        }).catch(function(e) {
          if (e.code === "ADS_NO_FILL") {
            _this.emit("adsnofill", id);
          } else if (e.code === "ADS_FREQUENT_LOAD") {
            _this.emit("adsfrequentload", id);
          } else {
            console.warn(e);
          }
        });
      }
      return this;
    },
    preloadVideoAds: function(placementID) {
      if (!this.checkAPI("getRewardedVideoAsync")) {
        return this;
      }
      if (!Array.isArray(placementID)) {
        placementID = [placementID];
      }
      var i;
      var _this = this;
      var total = 0;
      for (i = 0; i < this.ads.length; i++) {
        if (!this.ads[i].shown) {
          total++;
        }
      }
      if (total + placementID.length >= 3) {
        console.warn("Too many AdInstances. Show an ad before loading more");
        return this;
      }
      for (i = 0; i < placementID.length; i++) {
        var id = placementID[i];
        var data;
        FBInstant.getRewardedVideoAsync(id).then(function(reward) {
          data = reward;
          return reward.loadAsync();
        }).then(function() {
          var ad = AdInstance(id, data, true);
          _this.ads.push(ad);
          _this.emit("adloaded", ad);
        }).catch(function(e) {
          if (e.code === "ADS_NO_FILL") {
            _this.emit("adsnofill", id);
          } else if (e.code === "ADS_FREQUENT_LOAD") {
            _this.emit("adsfrequentload", id);
          } else {
            console.warn(e);
          }
        });
      }
      return this;
    },
    showAd: function(placementID) {
      var _this = this;
      for (var i = 0; i < this.ads.length; i++) {
        var ad = this.ads[i];
        if (ad.placementID === placementID && !ad.shown) {
          ad.instance.showAsync().then(function() {
            ad.shown = true;
            _this.emit("adfinished", ad);
          }).catch(function(e) {
            if (e.code === "ADS_NOT_LOADED") {
              _this.emit("adsnotloaded", ad);
            } else if (e.code === "RATE_LIMITED") {
              _this.emit("adratelimited", ad);
            }
            _this.emit("adshowerror", e, ad);
          });
          break;
        }
      }
      return this;
    },
    showVideo: function(placementID) {
      var _this = this;
      for (var i = 0; i < this.ads.length; i++) {
        var ad = this.ads[i];
        if (ad.placementID === placementID && ad.video && !ad.shown) {
          ad.instance.showAsync().then(function() {
            ad.shown = true;
            _this.emit("adfinished", ad);
          }).catch(function(e) {
            if (e.code === "ADS_NOT_LOADED") {
              _this.emit("adsnotloaded", ad);
            } else if (e.code === "RATE_LIMITED") {
              _this.emit("adratelimited", ad);
            }
            _this.emit("adshowerror", e, ad);
          });
          break;
        }
      }
      return this;
    },
    matchPlayer: function(matchTag, switchImmediately) {
      if (matchTag === void 0) {
        matchTag = null;
      }
      if (switchImmediately === void 0) {
        switchImmediately = false;
      }
      if (!this.checkAPI("matchPlayerAsync")) {
        return this;
      }
      var _this = this;
      FBInstant.matchPlayerAsync(matchTag, switchImmediately).then(function() {
        _this.getID();
        _this.getType();
        _this.emit("matchplayer", _this.contextID, _this.contextType);
      });
      return this;
    },
    getLeaderboard: function(name) {
      if (!this.checkAPI("getLeaderboardAsync")) {
        return this;
      }
      var _this = this;
      FBInstant.getLeaderboardAsync(name).then(function(data) {
        var leaderboard = new Leaderboard(_this, data);
        _this.leaderboards[name] = leaderboard;
        _this.emit("getleaderboard", leaderboard);
      }).catch(function(e) {
        console.warn(e);
      });
      return this;
    },
    destroy: function() {
      FBInstant.quit();
      this.data.destroy();
      this.removeAllListeners();
      this.catalog = [];
      this.purchases = [];
      this.leaderboards = [];
      this.ads = [];
      this.game = null;
    }
  });
  module2.exports = FacebookInstantGamesPlugin;
});

// node_modules/phaser/src/core/Game.js
var require_Game = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AddToDOM = require_AddToDOM();
  var AnimationManager = require_AnimationManager();
  var CacheManager = require_CacheManager();
  var CanvasPool = require_CanvasPool();
  var Class = require_Class();
  var Config = require_Config();
  var CreateDOMContainer = require_CreateDOMContainer();
  var CreateRenderer = require_CreateRenderer();
  var DataManager = require_DataManager();
  var DebugHeader = require_DebugHeader();
  var Device = require_device();
  var DOMContentLoaded = require_DOMContentLoaded();
  var EventEmitter = require_eventemitter3();
  var Events = require_events();
  var InputManager = require_InputManager();
  var PluginCache = require_PluginCache();
  var PluginManager = require_PluginManager();
  var ScaleManager = require_ScaleManager();
  var SceneManager = require_SceneManager();
  var TextureEvents = require_events10();
  var TextureManager = require_TextureManager();
  var TimeStep = require_TimeStep();
  var VisibilityHandler = require_VisibilityHandler();
  if (typeof FEATURE_SOUND) {
    SoundManagerCreator = require_SoundManagerCreator();
  }
  var SoundManagerCreator;
  if (typeof PLUGIN_FBINSTANT) {
    FacebookInstantGamesPlugin = require_FacebookInstantGamesPlugin();
  }
  var FacebookInstantGamesPlugin;
  var Game = new Class({
    initialize: function Game2(config2) {
      this.config = new Config(config2);
      this.renderer = null;
      this.domContainer = null;
      this.canvas = null;
      this.context = null;
      this.isBooted = false;
      this.isRunning = false;
      this.events = new EventEmitter();
      this.anims = new AnimationManager(this);
      this.textures = new TextureManager(this);
      this.cache = new CacheManager(this);
      this.registry = new DataManager(this);
      this.input = new InputManager(this, this.config);
      this.scene = new SceneManager(this, this.config.sceneConfig);
      this.device = Device;
      this.scale = new ScaleManager(this, this.config);
      this.sound = null;
      if (typeof FEATURE_SOUND) {
        this.sound = SoundManagerCreator.create(this);
      }
      this.loop = new TimeStep(this, this.config.fps);
      this.plugins = new PluginManager(this, this.config);
      if (typeof PLUGIN_FBINSTANT) {
        this.facebook = new FacebookInstantGamesPlugin(this);
      }
      this.pendingDestroy = false;
      this.removeCanvas = false;
      this.noReturn = false;
      this.hasFocus = false;
      DOMContentLoaded(this.boot.bind(this));
    },
    boot: function() {
      if (!PluginCache.hasCore("EventEmitter")) {
        console.warn("Aborting. Core Plugins missing.");
        return;
      }
      this.isBooted = true;
      this.config.preBoot(this);
      this.scale.preBoot();
      CreateRenderer(this);
      CreateDOMContainer(this);
      DebugHeader(this);
      AddToDOM(this.canvas, this.config.parent);
      this.textures.once(TextureEvents.READY, this.texturesReady, this);
      this.events.emit(Events.BOOT);
    },
    texturesReady: function() {
      this.events.emit(Events.READY);
      this.start();
    },
    start: function() {
      this.isRunning = true;
      this.config.postBoot(this);
      if (this.renderer) {
        this.loop.start(this.step.bind(this));
      } else {
        this.loop.start(this.headlessStep.bind(this));
      }
      VisibilityHandler(this);
      var eventEmitter = this.events;
      eventEmitter.on(Events.HIDDEN, this.onHidden, this);
      eventEmitter.on(Events.VISIBLE, this.onVisible, this);
      eventEmitter.on(Events.BLUR, this.onBlur, this);
      eventEmitter.on(Events.FOCUS, this.onFocus, this);
    },
    step: function(time, delta) {
      if (this.pendingDestroy) {
        return this.runDestroy();
      }
      var eventEmitter = this.events;
      eventEmitter.emit(Events.PRE_STEP, time, delta);
      eventEmitter.emit(Events.STEP, time, delta);
      this.scene.update(time, delta);
      eventEmitter.emit(Events.POST_STEP, time, delta);
      var renderer = this.renderer;
      renderer.preRender();
      eventEmitter.emit(Events.PRE_RENDER, renderer, time, delta);
      this.scene.render(renderer);
      renderer.postRender();
      eventEmitter.emit(Events.POST_RENDER, renderer, time, delta);
    },
    headlessStep: function(time, delta) {
      if (this.pendingDestroy) {
        return this.runDestroy();
      }
      var eventEmitter = this.events;
      eventEmitter.emit(Events.PRE_STEP, time, delta);
      eventEmitter.emit(Events.STEP, time, delta);
      this.scene.update(time, delta);
      eventEmitter.emit(Events.POST_STEP, time, delta);
      eventEmitter.emit(Events.PRE_RENDER);
      eventEmitter.emit(Events.POST_RENDER);
    },
    onHidden: function() {
      this.loop.pause();
      this.events.emit(Events.PAUSE);
    },
    onVisible: function() {
      this.loop.resume();
      this.events.emit(Events.RESUME);
    },
    onBlur: function() {
      this.hasFocus = false;
      this.loop.blur();
    },
    onFocus: function() {
      this.hasFocus = true;
      this.loop.focus();
    },
    getFrame: function() {
      return this.loop.frame;
    },
    getTime: function() {
      return this.loop.now;
    },
    destroy: function(removeCanvas, noReturn) {
      if (noReturn === void 0) {
        noReturn = false;
      }
      this.pendingDestroy = true;
      this.removeCanvas = removeCanvas;
      this.noReturn = noReturn;
    },
    runDestroy: function() {
      this.scene.destroy();
      this.events.emit(Events.DESTROY);
      this.events.removeAllListeners();
      if (this.renderer) {
        this.renderer.destroy();
      }
      if (this.removeCanvas && this.canvas) {
        CanvasPool.remove(this.canvas);
        if (this.canvas.parentNode) {
          this.canvas.parentNode.removeChild(this.canvas);
        }
      }
      if (this.domContainer) {
        this.domContainer.parentNode.removeChild(this.domContainer);
      }
      this.loop.destroy();
      this.pendingDestroy = false;
    }
  });
  module2.exports = Game;
});

// node_modules/phaser/src/utils/array/matrix/CheckMatrix.js
var require_CheckMatrix = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CheckMatrix = function(matrix) {
    if (!Array.isArray(matrix) || matrix.length < 2 || !Array.isArray(matrix[0])) {
      return false;
    }
    var size = matrix[0].length;
    for (var i = 1; i < matrix.length; i++) {
      if (matrix[i].length !== size) {
        return false;
      }
    }
    return true;
  };
  module2.exports = CheckMatrix;
});

// node_modules/phaser/src/utils/array/matrix/MatrixToString.js
var require_MatrixToString = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Pad = require_Pad();
  var CheckMatrix = require_CheckMatrix();
  var MatrixToString = function(matrix) {
    var str = "";
    if (!CheckMatrix(matrix)) {
      return str;
    }
    for (var r = 0; r < matrix.length; r++) {
      for (var c = 0; c < matrix[r].length; c++) {
        var cell = matrix[r][c].toString();
        if (cell !== "undefined") {
          str += Pad(cell, 2);
        } else {
          str += "?";
        }
        if (c < matrix[r].length - 1) {
          str += " |";
        }
      }
      if (r < matrix.length - 1) {
        str += "\n";
        for (var i = 0; i < matrix[r].length; i++) {
          str += "---";
          if (i < matrix[r].length - 1) {
            str += "+";
          }
        }
        str += "\n";
      }
    }
    return str;
  };
  module2.exports = MatrixToString;
});

// node_modules/phaser/src/utils/array/matrix/ReverseColumns.js
var require_ReverseColumns = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ReverseColumns = function(matrix) {
    return matrix.reverse();
  };
  module2.exports = ReverseColumns;
});

// node_modules/phaser/src/utils/array/matrix/ReverseRows.js
var require_ReverseRows = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ReverseRows = function(matrix) {
    for (var i = 0; i < matrix.length; i++) {
      matrix[i].reverse();
    }
    return matrix;
  };
  module2.exports = ReverseRows;
});

// node_modules/phaser/src/utils/array/matrix/TransposeMatrix.js
var require_TransposeMatrix = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TransposeMatrix = function(array) {
    var sourceRowCount = array.length;
    var sourceColCount = array[0].length;
    var result = new Array(sourceColCount);
    for (var i = 0; i < sourceColCount; i++) {
      result[i] = new Array(sourceRowCount);
      for (var j = sourceRowCount - 1; j > -1; j--) {
        result[i][j] = array[j][i];
      }
    }
    return result;
  };
  module2.exports = TransposeMatrix;
});

// node_modules/phaser/src/utils/array/matrix/RotateMatrix.js
var require_RotateMatrix = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CheckMatrix = require_CheckMatrix();
  var TransposeMatrix = require_TransposeMatrix();
  var RotateMatrix = function(matrix, direction) {
    if (direction === void 0) {
      direction = 90;
    }
    if (!CheckMatrix(matrix)) {
      return null;
    }
    if (typeof direction !== "string") {
      direction = (direction % 360 + 360) % 360;
    }
    if (direction === 90 || direction === -270 || direction === "rotateLeft") {
      matrix = TransposeMatrix(matrix);
      matrix.reverse();
    } else if (direction === -90 || direction === 270 || direction === "rotateRight") {
      matrix.reverse();
      matrix = TransposeMatrix(matrix);
    } else if (Math.abs(direction) === 180 || direction === "rotate180") {
      for (var i = 0; i < matrix.length; i++) {
        matrix[i].reverse();
      }
      matrix.reverse();
    }
    return matrix;
  };
  module2.exports = RotateMatrix;
});

// node_modules/phaser/src/utils/array/matrix/Rotate180.js
var require_Rotate180 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateMatrix = require_RotateMatrix();
  var Rotate180 = function(matrix) {
    return RotateMatrix(matrix, 180);
  };
  module2.exports = Rotate180;
});

// node_modules/phaser/src/utils/array/matrix/RotateLeft.js
var require_RotateLeft2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateMatrix = require_RotateMatrix();
  var RotateLeft = function(matrix) {
    return RotateMatrix(matrix, 90);
  };
  module2.exports = RotateLeft;
});

// node_modules/phaser/src/utils/array/matrix/RotateRight.js
var require_RotateRight2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateMatrix = require_RotateMatrix();
  var RotateRight = function(matrix) {
    return RotateMatrix(matrix, -90);
  };
  module2.exports = RotateRight;
});

// node_modules/phaser/src/utils/array/matrix/TranslateMatrix.js
var require_TranslateMatrix = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateLeft = require_RotateLeft();
  var RotateRight = require_RotateRight();
  var TranslateMatrix = function(matrix, x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (y !== 0) {
      if (y < 0) {
        RotateLeft(matrix, Math.abs(y));
      } else {
        RotateRight(matrix, y);
      }
    }
    if (x !== 0) {
      for (var i = 0; i < matrix.length; i++) {
        var row = matrix[i];
        if (x < 0) {
          RotateLeft(row, Math.abs(x));
        } else {
          RotateRight(row, x);
        }
      }
    }
    return matrix;
  };
  module2.exports = TranslateMatrix;
});

// node_modules/phaser/src/utils/array/matrix/index.js
var require_matrix = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    CheckMatrix: require_CheckMatrix(),
    MatrixToString: require_MatrixToString(),
    ReverseColumns: require_ReverseColumns(),
    ReverseRows: require_ReverseRows(),
    Rotate180: require_Rotate180(),
    RotateLeft: require_RotateLeft2(),
    RotateMatrix: require_RotateMatrix(),
    RotateRight: require_RotateRight2(),
    Translate: require_TranslateMatrix(),
    TransposeMatrix: require_TransposeMatrix()
  };
});

// node_modules/phaser/src/utils/array/Add.js
var require_Add = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Add = function(array, item, limit, callback, context) {
    if (context === void 0) {
      context = array;
    }
    if (limit > 0) {
      var remaining = limit - array.length;
      if (remaining <= 0) {
        return null;
      }
    }
    if (!Array.isArray(item)) {
      if (array.indexOf(item) === -1) {
        array.push(item);
        if (callback) {
          callback.call(context, item);
        }
        return item;
      } else {
        return null;
      }
    }
    var itemLength = item.length - 1;
    while (itemLength >= 0) {
      if (array.indexOf(item[itemLength]) !== -1) {
        item.splice(itemLength, 1);
      }
      itemLength--;
    }
    itemLength = item.length;
    if (itemLength === 0) {
      return null;
    }
    if (limit > 0 && itemLength > remaining) {
      item.splice(remaining);
      itemLength = remaining;
    }
    for (var i = 0; i < itemLength; i++) {
      var entry = item[i];
      array.push(entry);
      if (callback) {
        callback.call(context, entry);
      }
    }
    return item;
  };
  module2.exports = Add;
});

// node_modules/phaser/src/utils/array/AddAt.js
var require_AddAt = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AddAt = function(array, item, index, limit, callback, context) {
    if (index === void 0) {
      index = 0;
    }
    if (context === void 0) {
      context = array;
    }
    if (limit > 0) {
      var remaining = limit - array.length;
      if (remaining <= 0) {
        return null;
      }
    }
    if (!Array.isArray(item)) {
      if (array.indexOf(item) === -1) {
        array.splice(index, 0, item);
        if (callback) {
          callback.call(context, item);
        }
        return item;
      } else {
        return null;
      }
    }
    var itemLength = item.length - 1;
    while (itemLength >= 0) {
      if (array.indexOf(item[itemLength]) !== -1) {
        item.pop();
      }
      itemLength--;
    }
    itemLength = item.length;
    if (itemLength === 0) {
      return null;
    }
    if (limit > 0 && itemLength > remaining) {
      item.splice(remaining);
      itemLength = remaining;
    }
    for (var i = itemLength - 1; i >= 0; i--) {
      var entry = item[i];
      array.splice(index, 0, entry);
      if (callback) {
        callback.call(context, entry);
      }
    }
    return item;
  };
  module2.exports = AddAt;
});

// node_modules/phaser/src/utils/array/BringToTop.js
var require_BringToTop = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BringToTop = function(array, item) {
    var currentIndex = array.indexOf(item);
    if (currentIndex !== -1 && currentIndex < array.length) {
      array.splice(currentIndex, 1);
      array.push(item);
    }
    return item;
  };
  module2.exports = BringToTop;
});

// node_modules/phaser/src/utils/array/CountAllMatching.js
var require_CountAllMatching = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SafeRange = require_SafeRange();
  var CountAllMatching = function(array, property, value, startIndex, endIndex) {
    if (startIndex === void 0) {
      startIndex = 0;
    }
    if (endIndex === void 0) {
      endIndex = array.length;
    }
    var total = 0;
    if (SafeRange(array, startIndex, endIndex)) {
      for (var i = startIndex; i < endIndex; i++) {
        var child = array[i];
        if (child[property] === value) {
          total++;
        }
      }
    }
    return total;
  };
  module2.exports = CountAllMatching;
});

// node_modules/phaser/src/utils/array/Each.js
var require_Each = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Each = function(array, callback, context) {
    var i;
    var args = [null];
    for (i = 3; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    for (i = 0; i < array.length; i++) {
      args[0] = array[i];
      callback.apply(context, args);
    }
    return array;
  };
  module2.exports = Each;
});

// node_modules/phaser/src/utils/array/EachInRange.js
var require_EachInRange = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SafeRange = require_SafeRange();
  var EachInRange = function(array, callback, context, startIndex, endIndex) {
    if (startIndex === void 0) {
      startIndex = 0;
    }
    if (endIndex === void 0) {
      endIndex = array.length;
    }
    if (SafeRange(array, startIndex, endIndex)) {
      var i;
      var args = [null];
      for (i = 5; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      for (i = startIndex; i < endIndex; i++) {
        args[0] = array[i];
        callback.apply(context, args);
      }
    }
    return array;
  };
  module2.exports = EachInRange;
});

// node_modules/phaser/src/utils/array/GetRandom.js
var require_GetRandom = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetRandom = function(array, startIndex, length) {
    if (startIndex === void 0) {
      startIndex = 0;
    }
    if (length === void 0) {
      length = array.length;
    }
    var randomIndex = startIndex + Math.floor(Math.random() * length);
    return array[randomIndex] === void 0 ? null : array[randomIndex];
  };
  module2.exports = GetRandom;
});

// node_modules/phaser/src/utils/array/MoveDown.js
var require_MoveDown = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MoveDown = function(array, item) {
    var currentIndex = array.indexOf(item);
    if (currentIndex > 0) {
      var item2 = array[currentIndex - 1];
      var index2 = array.indexOf(item2);
      array[currentIndex] = item2;
      array[index2] = item;
    }
    return array;
  };
  module2.exports = MoveDown;
});

// node_modules/phaser/src/utils/array/MoveTo.js
var require_MoveTo2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MoveTo = function(array, item, index) {
    var currentIndex = array.indexOf(item);
    if (currentIndex === -1 || index < 0 || index >= array.length) {
      throw new Error("Supplied index out of bounds");
    }
    if (currentIndex !== index) {
      array.splice(currentIndex, 1);
      array.splice(index, 0, item);
    }
    return item;
  };
  module2.exports = MoveTo;
});

// node_modules/phaser/src/utils/array/MoveUp.js
var require_MoveUp = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MoveUp = function(array, item) {
    var currentIndex = array.indexOf(item);
    if (currentIndex !== -1 && currentIndex < array.length - 1) {
      var item2 = array[currentIndex + 1];
      var index2 = array.indexOf(item2);
      array[currentIndex] = item2;
      array[index2] = item;
    }
    return array;
  };
  module2.exports = MoveUp;
});

// node_modules/phaser/src/utils/array/MoveAbove.js
var require_MoveAbove = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MoveAbove = function(array, item1, item2) {
    if (item1 === item2) {
      return array;
    }
    var currentIndex = array.indexOf(item1);
    var baseIndex = array.indexOf(item2);
    if (currentIndex < 0 || baseIndex < 0) {
      throw new Error("Supplied items must be elements of the same array");
    }
    if (currentIndex > baseIndex) {
      return array;
    }
    array.splice(currentIndex, 1);
    if (baseIndex === array.length - 1) {
      array.push(item1);
    } else {
      array.splice(baseIndex, 0, item1);
    }
    return array;
  };
  module2.exports = MoveAbove;
});

// node_modules/phaser/src/utils/array/MoveBelow.js
var require_MoveBelow = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MoveBelow = function(array, item1, item2) {
    if (item1 === item2) {
      return array;
    }
    var currentIndex = array.indexOf(item1);
    var baseIndex = array.indexOf(item2);
    if (currentIndex < 0 || baseIndex < 0) {
      throw new Error("Supplied items must be elements of the same array");
    }
    if (currentIndex < baseIndex) {
      return array;
    }
    array.splice(currentIndex, 1);
    if (baseIndex === 0) {
      array.unshift(item1);
    } else {
      array.splice(baseIndex, 0, item1);
    }
    return array;
  };
  module2.exports = MoveBelow;
});

// node_modules/phaser/src/utils/array/NumberArrayStep.js
var require_NumberArrayStep = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RoundAwayFromZero = require_RoundAwayFromZero();
  var NumberArrayStep = function(start, end, step) {
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = null;
    }
    if (step === void 0) {
      step = 1;
    }
    if (end === null) {
      end = start;
      start = 0;
    }
    var result = [];
    var total = Math.max(RoundAwayFromZero((end - start) / (step || 1)), 0);
    for (var i = 0; i < total; i++) {
      result.push(start);
      start += step;
    }
    return result;
  };
  module2.exports = NumberArrayStep;
});

// node_modules/phaser/src/utils/array/QuickSelect.js
var require_QuickSelect = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  var QuickSelect = function(arr, k, left, right, compare) {
    if (left === void 0) {
      left = 0;
    }
    if (right === void 0) {
      right = arr.length - 1;
    }
    if (compare === void 0) {
      compare = defaultCompare;
    }
    while (right > left) {
      if (right - left > 600) {
        var n = right - left + 1;
        var m = k - left + 1;
        var z = Math.log(n);
        var s = 0.5 * Math.exp(2 * z / 3);
        var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
        var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
        var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
        QuickSelect(arr, k, newLeft, newRight, compare);
      }
      var t = arr[k];
      var i = left;
      var j = right;
      swap(arr, left, k);
      if (compare(arr[right], t) > 0) {
        swap(arr, left, right);
      }
      while (i < j) {
        swap(arr, i, j);
        i++;
        j--;
        while (compare(arr[i], t) < 0) {
          i++;
        }
        while (compare(arr[j], t) > 0) {
          j--;
        }
      }
      if (compare(arr[left], t) === 0) {
        swap(arr, left, j);
      } else {
        j++;
        swap(arr, j, right);
      }
      if (j <= k) {
        left = j + 1;
      }
      if (k <= j) {
        right = j - 1;
      }
    }
  };
  module2.exports = QuickSelect;
});

// node_modules/phaser/src/utils/array/Range.js
var require_Range = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetValue = require_GetValue();
  var Shuffle = require_Shuffle();
  var BuildChunk = function(a, b, qty) {
    var out = [];
    for (var aIndex = 0; aIndex < a.length; aIndex++) {
      for (var bIndex = 0; bIndex < b.length; bIndex++) {
        for (var i = 0; i < qty; i++) {
          out.push({a: a[aIndex], b: b[bIndex]});
        }
      }
    }
    return out;
  };
  var Range = function(a, b, options) {
    var max = GetValue(options, "max", 0);
    var qty = GetValue(options, "qty", 1);
    var random = GetValue(options, "random", false);
    var randomB = GetValue(options, "randomB", false);
    var repeat = GetValue(options, "repeat", 0);
    var yoyo = GetValue(options, "yoyo", false);
    var out = [];
    if (randomB) {
      Shuffle(b);
    }
    if (repeat === -1) {
      if (max === 0) {
        repeat = 0;
      } else {
        var total = a.length * b.length * qty;
        if (yoyo) {
          total *= 2;
        }
        repeat = Math.ceil(max / total);
      }
    }
    for (var i = 0; i <= repeat; i++) {
      var chunk = BuildChunk(a, b, qty);
      if (random) {
        Shuffle(chunk);
      }
      out = out.concat(chunk);
      if (yoyo) {
        chunk.reverse();
        out = out.concat(chunk);
      }
    }
    if (max) {
      out.splice(max);
    }
    return out;
  };
  module2.exports = Range;
});

// node_modules/phaser/src/utils/array/RemoveAt.js
var require_RemoveAt = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SpliceOne = require_SpliceOne();
  var RemoveAt = function(array, index, callback, context) {
    if (context === void 0) {
      context = array;
    }
    if (index < 0 || index > array.length - 1) {
      throw new Error("Index out of bounds");
    }
    var item = SpliceOne(array, index);
    if (callback) {
      callback.call(context, item);
    }
    return item;
  };
  module2.exports = RemoveAt;
});

// node_modules/phaser/src/utils/array/RemoveBetween.js
var require_RemoveBetween = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SafeRange = require_SafeRange();
  var RemoveBetween = function(array, startIndex, endIndex, callback, context) {
    if (startIndex === void 0) {
      startIndex = 0;
    }
    if (endIndex === void 0) {
      endIndex = array.length;
    }
    if (context === void 0) {
      context = array;
    }
    if (SafeRange(array, startIndex, endIndex)) {
      var size = endIndex - startIndex;
      var removed = array.splice(startIndex, size);
      if (callback) {
        for (var i = 0; i < removed.length; i++) {
          var entry = removed[i];
          callback.call(context, entry);
        }
      }
      return removed;
    } else {
      return [];
    }
  };
  module2.exports = RemoveBetween;
});

// node_modules/phaser/src/utils/array/RemoveRandomElement.js
var require_RemoveRandomElement = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SpliceOne = require_SpliceOne();
  var RemoveRandomElement = function(array, start, length) {
    if (start === void 0) {
      start = 0;
    }
    if (length === void 0) {
      length = array.length;
    }
    var randomIndex = start + Math.floor(Math.random() * length);
    return SpliceOne(array, randomIndex);
  };
  module2.exports = RemoveRandomElement;
});

// node_modules/phaser/src/utils/array/Replace.js
var require_Replace = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Replace = function(array, oldChild, newChild) {
    var index1 = array.indexOf(oldChild);
    var index2 = array.indexOf(newChild);
    if (index1 !== -1 && index2 === -1) {
      array[index1] = newChild;
      return true;
    } else {
      return false;
    }
  };
  module2.exports = Replace;
});

// node_modules/phaser/src/utils/array/SendToBack.js
var require_SendToBack = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SendToBack = function(array, item) {
    var currentIndex = array.indexOf(item);
    if (currentIndex !== -1 && currentIndex > 0) {
      array.splice(currentIndex, 1);
      array.unshift(item);
    }
    return item;
  };
  module2.exports = SendToBack;
});

// node_modules/phaser/src/utils/array/SetAll.js
var require_SetAll = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SafeRange = require_SafeRange();
  var SetAll = function(array, property, value, startIndex, endIndex) {
    if (startIndex === void 0) {
      startIndex = 0;
    }
    if (endIndex === void 0) {
      endIndex = array.length;
    }
    if (SafeRange(array, startIndex, endIndex)) {
      for (var i = startIndex; i < endIndex; i++) {
        var entry = array[i];
        if (entry.hasOwnProperty(property)) {
          entry[property] = value;
        }
      }
    }
    return array;
  };
  module2.exports = SetAll;
});

// node_modules/phaser/src/utils/array/StableSort.js
var require_StableSort = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Angry Bytes (and contributors)
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  function Compare(a, b) {
    return String(a).localeCompare(b);
  }
  function Process(array, compare) {
    var len = array.length;
    if (len <= 1) {
      return array;
    }
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
      RunPass(array, compare, chk, buffer);
      var tmp = array;
      array = buffer;
      buffer = tmp;
    }
    return array;
  }
  function RunPass(arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    var dbl = chk * 2;
    var l, r, e;
    var li, ri;
    for (l = 0; l < len; l += dbl) {
      r = l + chk;
      e = r + chk;
      if (r > len) {
        r = len;
      }
      if (e > len) {
        e = len;
      }
      li = l;
      ri = r;
      while (true) {
        if (li < r && ri < e) {
          if (comp(arr[li], arr[ri]) <= 0) {
            result[i++] = arr[li++];
          } else {
            result[i++] = arr[ri++];
          }
        } else if (li < r) {
          result[i++] = arr[li++];
        } else if (ri < e) {
          result[i++] = arr[ri++];
        } else {
          break;
        }
      }
    }
  }
  var StableSort = function(array, compare) {
    if (compare === void 0) {
      compare = Compare;
    }
    var result = Process(array, compare);
    if (result !== array) {
      RunPass(result, null, array.length, array);
    }
    return array;
  };
  module2.exports = StableSort;
});

// node_modules/phaser/src/utils/array/Swap.js
var require_Swap = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Swap = function(array, item1, item2) {
    if (item1 === item2) {
      return array;
    }
    var index1 = array.indexOf(item1);
    var index2 = array.indexOf(item2);
    if (index1 < 0 || index2 < 0) {
      throw new Error("Supplied items must be elements of the same array");
    }
    array[index1] = item2;
    array[index2] = item1;
    return array;
  };
  module2.exports = Swap;
});

// node_modules/phaser/src/utils/array/index.js
var require_array = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Matrix: require_matrix(),
    Add: require_Add(),
    AddAt: require_AddAt(),
    BringToTop: require_BringToTop(),
    CountAllMatching: require_CountAllMatching(),
    Each: require_Each(),
    EachInRange: require_EachInRange(),
    FindClosestInSorted: require_FindClosestInSorted(),
    GetAll: require_GetAll(),
    GetFirst: require_GetFirst2(),
    GetRandom: require_GetRandom(),
    MoveDown: require_MoveDown(),
    MoveTo: require_MoveTo2(),
    MoveUp: require_MoveUp(),
    MoveAbove: require_MoveAbove(),
    MoveBelow: require_MoveBelow(),
    NumberArray: require_NumberArray(),
    NumberArrayStep: require_NumberArrayStep(),
    QuickSelect: require_QuickSelect(),
    Range: require_Range(),
    Remove: require_Remove(),
    RemoveAt: require_RemoveAt(),
    RemoveBetween: require_RemoveBetween(),
    RemoveRandomElement: require_RemoveRandomElement(),
    Replace: require_Replace(),
    RotateLeft: require_RotateLeft(),
    RotateRight: require_RotateRight(),
    SafeRange: require_SafeRange(),
    SendToBack: require_SendToBack(),
    SetAll: require_SetAll(),
    Shuffle: require_Shuffle(),
    SortByDigits: require_SortByDigits(),
    SpliceOne: require_SpliceOne(),
    StableSort: require_StableSort(),
    Swap: require_Swap()
  };
});

// node_modules/phaser/src/structs/List.js
var require_List = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ArrayUtils = require_array();
  var Class = require_Class();
  var NOOP = require_NOOP();
  var StableSort = require_StableSort();
  var List = new Class({
    initialize: function List2(parent) {
      this.parent = parent;
      this.list = [];
      this.position = 0;
      this.addCallback = NOOP;
      this.removeCallback = NOOP;
      this._sortKey = "";
    },
    add: function(child, skipCallback) {
      if (skipCallback) {
        return ArrayUtils.Add(this.list, child);
      } else {
        return ArrayUtils.Add(this.list, child, 0, this.addCallback, this);
      }
    },
    addAt: function(child, index, skipCallback) {
      if (skipCallback) {
        return ArrayUtils.AddAt(this.list, child, index);
      } else {
        return ArrayUtils.AddAt(this.list, child, index, 0, this.addCallback, this);
      }
    },
    getAt: function(index) {
      return this.list[index];
    },
    getIndex: function(child) {
      return this.list.indexOf(child);
    },
    sort: function(property, handler) {
      if (!property) {
        return this;
      }
      if (handler === void 0) {
        handler = function(childA, childB) {
          return childA[property] - childB[property];
        };
      }
      StableSort(this.list, handler);
      return this;
    },
    getByName: function(name) {
      return ArrayUtils.GetFirst(this.list, "name", name);
    },
    getRandom: function(startIndex, length) {
      return ArrayUtils.GetRandom(this.list, startIndex, length);
    },
    getFirst: function(property, value, startIndex, endIndex) {
      return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
    },
    getAll: function(property, value, startIndex, endIndex) {
      return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
    },
    count: function(property, value) {
      return ArrayUtils.CountAllMatching(this.list, property, value);
    },
    swap: function(child1, child2) {
      ArrayUtils.Swap(this.list, child1, child2);
    },
    moveTo: function(child, index) {
      return ArrayUtils.MoveTo(this.list, child, index);
    },
    moveAbove: function(child1, child2) {
      return ArrayUtils.MoveAbove(this.list, child1, child2);
    },
    moveBelow: function(child1, child2) {
      return ArrayUtils.MoveBelow(this.list, child1, child2);
    },
    remove: function(child, skipCallback) {
      if (skipCallback) {
        return ArrayUtils.Remove(this.list, child);
      } else {
        return ArrayUtils.Remove(this.list, child, this.removeCallback, this);
      }
    },
    removeAt: function(index, skipCallback) {
      if (skipCallback) {
        return ArrayUtils.RemoveAt(this.list, index);
      } else {
        return ArrayUtils.RemoveAt(this.list, index, this.removeCallback, this);
      }
    },
    removeBetween: function(startIndex, endIndex, skipCallback) {
      if (skipCallback) {
        return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex);
      } else {
        return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeCallback, this);
      }
    },
    removeAll: function(skipCallback) {
      var i = this.list.length;
      while (i--) {
        this.remove(this.list[i], skipCallback);
      }
      return this;
    },
    bringToTop: function(child) {
      return ArrayUtils.BringToTop(this.list, child);
    },
    sendToBack: function(child) {
      return ArrayUtils.SendToBack(this.list, child);
    },
    moveUp: function(child) {
      ArrayUtils.MoveUp(this.list, child);
      return child;
    },
    moveDown: function(child) {
      ArrayUtils.MoveDown(this.list, child);
      return child;
    },
    reverse: function() {
      this.list.reverse();
      return this;
    },
    shuffle: function() {
      ArrayUtils.Shuffle(this.list);
      return this;
    },
    replace: function(oldChild, newChild) {
      return ArrayUtils.Replace(this.list, oldChild, newChild);
    },
    exists: function(child) {
      return this.list.indexOf(child) > -1;
    },
    setAll: function(property, value, startIndex, endIndex) {
      ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
      return this;
    },
    each: function(callback, context) {
      var args = [null];
      for (var i = 2; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      for (i = 0; i < this.list.length; i++) {
        args[0] = this.list[i];
        callback.apply(context, args);
      }
    },
    shutdown: function() {
      this.removeAll();
      this.list = [];
    },
    destroy: function() {
      this.removeAll();
      this.parent = null;
      this.addCallback = null;
      this.removeCallback = null;
    },
    length: {
      get: function() {
        return this.list.length;
      }
    },
    first: {
      get: function() {
        this.position = 0;
        if (this.list.length > 0) {
          return this.list[0];
        } else {
          return null;
        }
      }
    },
    last: {
      get: function() {
        if (this.list.length > 0) {
          this.position = this.list.length - 1;
          return this.list[this.position];
        } else {
          return null;
        }
      }
    },
    next: {
      get: function() {
        if (this.position < this.list.length) {
          this.position++;
          return this.list[this.position];
        } else {
          return null;
        }
      }
    },
    previous: {
      get: function() {
        if (this.position > 0) {
          this.position--;
          return this.list[this.position];
        } else {
          return null;
        }
      }
    }
  });
  module2.exports = List;
});

// node_modules/phaser/src/gameobjects/DisplayList.js
var require_DisplayList = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var List = require_List();
  var PluginCache = require_PluginCache();
  var GameObjectEvents = require_events4();
  var SceneEvents = require_events5();
  var StableSort = require_StableSort();
  var DisplayList = new Class({
    Extends: List,
    initialize: function DisplayList2(scene) {
      List.call(this, scene);
      this.sortChildrenFlag = false;
      this.scene = scene;
      this.systems = scene.sys;
      this.events = scene.sys.events;
      this.addCallback = this.addChildCallback;
      this.removeCallback = this.removeChildCallback;
      this.events.once(SceneEvents.BOOT, this.boot, this);
      this.events.on(SceneEvents.START, this.start, this);
    },
    boot: function() {
      this.events.once(SceneEvents.DESTROY, this.destroy, this);
    },
    addChildCallback: function(gameObject) {
      if (gameObject.displayList && gameObject.displayList !== this) {
        gameObject.removeFromDisplayList();
      }
      if (!gameObject.displayList) {
        this.queueDepthSort();
        gameObject.displayList = this;
        gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);
        this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
      }
    },
    removeChildCallback: function(gameObject) {
      this.queueDepthSort();
      gameObject.displayList = null;
      gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
      this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
    },
    start: function() {
      this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    queueDepthSort: function() {
      this.sortChildrenFlag = true;
    },
    depthSort: function() {
      if (this.sortChildrenFlag) {
        StableSort(this.list, this.sortByDepth);
        this.sortChildrenFlag = false;
      }
    },
    sortByDepth: function(childA, childB) {
      return childA._depth - childB._depth;
    },
    getChildren: function() {
      return this.list;
    },
    shutdown: function() {
      var list = this.list;
      var i = list.length;
      while (i--) {
        list[i].destroy(true);
      }
      list.length = 0;
      this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    destroy: function() {
      this.shutdown();
      this.events.off(SceneEvents.START, this.start, this);
      this.scene = null;
      this.systems = null;
      this.events = null;
    }
  });
  PluginCache.register("DisplayList", DisplayList, "displayList");
  module2.exports = DisplayList;
});

// node_modules/phaser/src/structs/events/PROCESS_QUEUE_ADD_EVENT.js
var require_PROCESS_QUEUE_ADD_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "add";
});

// node_modules/phaser/src/structs/events/PROCESS_QUEUE_REMOVE_EVENT.js
var require_PROCESS_QUEUE_REMOVE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "remove";
});

// node_modules/phaser/src/structs/events/index.js
var require_events16 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    PROCESS_QUEUE_ADD: require_PROCESS_QUEUE_ADD_EVENT(),
    PROCESS_QUEUE_REMOVE: require_PROCESS_QUEUE_REMOVE_EVENT()
  };
});

// node_modules/phaser/src/structs/ProcessQueue.js
var require_ProcessQueue = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var EventEmitter = require_eventemitter3();
  var Events = require_events16();
  var ProcessQueue = new Class({
    Extends: EventEmitter,
    initialize: function ProcessQueue2() {
      EventEmitter.call(this);
      this._pending = [];
      this._active = [];
      this._destroy = [];
      this._toProcess = 0;
      this.checkQueue = false;
    },
    add: function(item) {
      this._pending.push(item);
      this._toProcess++;
      return item;
    },
    remove: function(item) {
      this._destroy.push(item);
      this._toProcess++;
      return item;
    },
    removeAll: function() {
      var list = this._active;
      var destroy = this._destroy;
      var i = list.length;
      while (i--) {
        destroy.push(list[i]);
        this._toProcess++;
      }
      return this;
    },
    update: function() {
      if (this._toProcess === 0) {
        return this._active;
      }
      var list = this._destroy;
      var active = this._active;
      var i;
      var item;
      for (i = 0; i < list.length; i++) {
        item = list[i];
        var idx = active.indexOf(item);
        if (idx !== -1) {
          active.splice(idx, 1);
          this.emit(Events.PROCESS_QUEUE_REMOVE, item);
        }
      }
      list.length = 0;
      list = this._pending;
      for (i = 0; i < list.length; i++) {
        item = list[i];
        if (!this.checkQueue || this.checkQueue && active.indexOf(item) === -1) {
          active.push(item);
          this.emit(Events.PROCESS_QUEUE_ADD, item);
        }
      }
      list.length = 0;
      this._toProcess = 0;
      return active;
    },
    getActive: function() {
      return this._active;
    },
    length: {
      get: function() {
        return this._active.length;
      }
    },
    destroy: function() {
      this._toProcess = 0;
      this._pending = [];
      this._active = [];
      this._destroy = [];
    }
  });
  module2.exports = ProcessQueue;
});

// node_modules/phaser/src/gameobjects/UpdateList.js
var require_UpdateList = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var ProcessQueue = require_ProcessQueue();
  var PluginCache = require_PluginCache();
  var SceneEvents = require_events5();
  var UpdateList = new Class({
    Extends: ProcessQueue,
    initialize: function UpdateList2(scene) {
      ProcessQueue.call(this);
      this.checkQueue = true;
      this.scene = scene;
      this.systems = scene.sys;
      scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
      scene.sys.events.on(SceneEvents.START, this.start, this);
    },
    boot: function() {
      this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
    },
    start: function() {
      var eventEmitter = this.systems.events;
      eventEmitter.on(SceneEvents.PRE_UPDATE, this.update, this);
      eventEmitter.on(SceneEvents.UPDATE, this.sceneUpdate, this);
      eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    sceneUpdate: function(time, delta) {
      var list = this._active;
      var length = list.length;
      for (var i = 0; i < length; i++) {
        var gameObject = list[i];
        if (gameObject.active) {
          gameObject.preUpdate.call(gameObject, time, delta);
        }
      }
    },
    shutdown: function() {
      var i = this._active.length;
      while (i--) {
        this._active[i].destroy(true);
      }
      i = this._pending.length;
      while (i--) {
        this._pending[i].destroy(true);
      }
      i = this._destroy.length;
      while (i--) {
        this._destroy[i].destroy(true);
      }
      this._toProcess = 0;
      this._pending = [];
      this._active = [];
      this._destroy = [];
      this.removeAllListeners();
      var eventEmitter = this.systems.events;
      eventEmitter.off(SceneEvents.PRE_UPDATE, this.update, this);
      eventEmitter.off(SceneEvents.UPDATE, this.sceneUpdate, this);
      eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    destroy: function() {
      this.shutdown();
      this.systems.events.off(SceneEvents.START, this.start, this);
      this.scene = null;
      this.systems = null;
    }
  });
  PluginCache.register("UpdateList", UpdateList, "updateList");
  module2.exports = UpdateList;
});

// node_modules/phaser/src/gameobjects/GetCalcMatrix.js
var require_GetCalcMatrix = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TransformMatrix = require_TransformMatrix();
  var tempMatrix1 = new TransformMatrix();
  var tempMatrix2 = new TransformMatrix();
  var tempMatrix3 = new TransformMatrix();
  var result = {camera: tempMatrix1, sprite: tempMatrix2, calc: tempMatrix3};
  var GetCalcMatrix = function(src, camera, parentMatrix) {
    var camMatrix = tempMatrix1;
    var spriteMatrix = tempMatrix2;
    var calcMatrix = tempMatrix3;
    spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);
    camMatrix.copyFrom(camera.matrix);
    if (parentMatrix) {
      camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
      spriteMatrix.e = src.x;
      spriteMatrix.f = src.y;
    } else {
      spriteMatrix.e -= camera.scrollX * src.scrollFactorX;
      spriteMatrix.f -= camera.scrollY * src.scrollFactorY;
    }
    camMatrix.multiply(spriteMatrix, calcMatrix);
    return result;
  };
  module2.exports = GetCalcMatrix;
});

// node_modules/phaser/src/utils/object/GetAdvancedValue.js
var require_GetAdvancedValue = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MATH = require_math();
  var GetValue = require_GetValue();
  var GetAdvancedValue = function(source, key, defaultValue) {
    var value = GetValue(source, key, null);
    if (value === null) {
      return defaultValue;
    } else if (Array.isArray(value)) {
      return MATH.RND.pick(value);
    } else if (typeof value === "object") {
      if (value.hasOwnProperty("randInt")) {
        return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);
      } else if (value.hasOwnProperty("randFloat")) {
        return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);
      }
    } else if (typeof value === "function") {
      return value(key);
    }
    return value;
  };
  module2.exports = GetAdvancedValue;
});

// node_modules/phaser/src/gameobjects/BuildGameObject.js
var require_BuildGameObject = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BlendModes = require_BlendModes();
  var GetAdvancedValue = require_GetAdvancedValue();
  var BuildGameObject = function(scene, gameObject, config2) {
    gameObject.x = GetAdvancedValue(config2, "x", 0);
    gameObject.y = GetAdvancedValue(config2, "y", 0);
    gameObject.depth = GetAdvancedValue(config2, "depth", 0);
    gameObject.flipX = GetAdvancedValue(config2, "flipX", false);
    gameObject.flipY = GetAdvancedValue(config2, "flipY", false);
    var scale = GetAdvancedValue(config2, "scale", null);
    if (typeof scale === "number") {
      gameObject.setScale(scale);
    } else if (scale !== null) {
      gameObject.scaleX = GetAdvancedValue(scale, "x", 1);
      gameObject.scaleY = GetAdvancedValue(scale, "y", 1);
    }
    var scrollFactor = GetAdvancedValue(config2, "scrollFactor", null);
    if (typeof scrollFactor === "number") {
      gameObject.setScrollFactor(scrollFactor);
    } else if (scrollFactor !== null) {
      gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, "x", 1);
      gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, "y", 1);
    }
    gameObject.rotation = GetAdvancedValue(config2, "rotation", 0);
    var angle = GetAdvancedValue(config2, "angle", null);
    if (angle !== null) {
      gameObject.angle = angle;
    }
    gameObject.alpha = GetAdvancedValue(config2, "alpha", 1);
    var origin = GetAdvancedValue(config2, "origin", null);
    if (typeof origin === "number") {
      gameObject.setOrigin(origin);
    } else if (origin !== null) {
      var ox = GetAdvancedValue(origin, "x", 0.5);
      var oy = GetAdvancedValue(origin, "y", 0.5);
      gameObject.setOrigin(ox, oy);
    }
    gameObject.blendMode = GetAdvancedValue(config2, "blendMode", BlendModes.NORMAL);
    gameObject.visible = GetAdvancedValue(config2, "visible", true);
    var add = GetAdvancedValue(config2, "add", true);
    if (add) {
      scene.sys.displayList.add(gameObject);
    }
    if (gameObject.preUpdate) {
      scene.sys.updateList.add(gameObject);
    }
    return gameObject;
  };
  module2.exports = BuildGameObject;
});

// node_modules/phaser/src/gameobjects/BuildGameObjectAnimation.js
var require_BuildGameObjectAnimation = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetAdvancedValue = require_GetAdvancedValue();
  var BuildGameObjectAnimation = function(sprite, config2) {
    var animConfig = GetAdvancedValue(config2, "anims", null);
    if (animConfig === null) {
      return sprite;
    }
    if (typeof animConfig === "string") {
      sprite.anims.play(animConfig);
    } else if (typeof animConfig === "object") {
      var anims = sprite.anims;
      var key = GetAdvancedValue(animConfig, "key", void 0);
      if (key) {
        var startFrame = GetAdvancedValue(animConfig, "startFrame", void 0);
        var delay = GetAdvancedValue(animConfig, "delay", 0);
        var repeat = GetAdvancedValue(animConfig, "repeat", 0);
        var repeatDelay = GetAdvancedValue(animConfig, "repeatDelay", 0);
        var yoyo = GetAdvancedValue(animConfig, "yoyo", false);
        var play = GetAdvancedValue(animConfig, "play", false);
        var delayedPlay = GetAdvancedValue(animConfig, "delayedPlay", 0);
        var playConfig = {
          key,
          delay,
          repeat,
          repeatDelay,
          yoyo,
          startFrame
        };
        if (play) {
          anims.play(playConfig);
        } else if (delayedPlay > 0) {
          anims.playAfterDelay(playConfig, delayedPlay);
        } else {
          anims.load(playConfig);
        }
      }
    }
    return sprite;
  };
  module2.exports = BuildGameObjectAnimation;
});

// node_modules/phaser/src/gameobjects/bitmaptext/GetBitmapTextSize.js
var require_GetBitmapTextSize = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetBitmapTextSize = function(src, round, updateOrigin, out) {
    if (updateOrigin === void 0) {
      updateOrigin = false;
    }
    if (out === void 0) {
      out = {
        local: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        global: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        lines: {
          shortest: 0,
          longest: 0,
          lengths: null,
          height: 0
        },
        wrappedText: "",
        words: [],
        characters: [],
        scaleX: 0,
        scaleY: 0
      };
      return out;
    }
    var text = src.text;
    var textLength = text.length;
    var maxWidth = src.maxWidth;
    var wordWrapCharCode = src.wordWrapCharCode;
    var bx = Number.MAX_VALUE;
    var by = Number.MAX_VALUE;
    var bw = 0;
    var bh = 0;
    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;
    var letterSpacing = src.letterSpacing;
    var xAdvance = 0;
    var yAdvance = 0;
    var charCode = 0;
    var glyph = null;
    var align = src._align;
    var x = 0;
    var y = 0;
    var scale = src.fontSize / src.fontData.size;
    var sx = scale * src.scaleX;
    var sy = scale * src.scaleY;
    var lastGlyph = null;
    var lastCharCode = 0;
    var lineWidths = [];
    var shortestLine = Number.MAX_VALUE;
    var longestLine = 0;
    var currentLine = 0;
    var currentLineWidth = 0;
    var i;
    var words = [];
    var characters = [];
    var current = null;
    if (maxWidth > 0) {
      for (i = 0; i < textLength; i++) {
        charCode = text.charCodeAt(i);
        if (charCode === 10) {
          if (current !== null) {
            words.push({
              word: current.word,
              i: current.i,
              x: current.x * sx,
              y: current.y * sy,
              w: current.w * sx,
              h: current.h * sy,
              cr: true
            });
            current = null;
          }
          xAdvance = 0;
          yAdvance += lineHeight;
          lastGlyph = null;
          continue;
        }
        glyph = chars[charCode];
        if (!glyph) {
          continue;
        }
        if (lastGlyph !== null) {
          var glyphKerningOffset = glyph.kerning[lastCharCode];
        }
        if (charCode === wordWrapCharCode) {
          if (current !== null) {
            words.push({
              word: current.word,
              i: current.i,
              x: current.x * sx,
              y: current.y * sy,
              w: current.w * sx,
              h: current.h * sy,
              cr: false
            });
            current = null;
          }
        } else {
          if (current === null) {
            current = {word: "", i, x: xAdvance, y: yAdvance, w: 0, h: lineHeight, cr: false};
          }
          current.word = current.word.concat(text[i]);
          current.w += glyph.xOffset + glyph.xAdvance + (glyphKerningOffset !== void 0 ? glyphKerningOffset : 0);
        }
        xAdvance += glyph.xAdvance + letterSpacing;
        lastGlyph = glyph;
        lastCharCode = charCode;
      }
      if (current !== null) {
        words.push({
          word: current.word,
          i: current.i,
          x: current.x * sx,
          y: current.y * sy,
          w: current.w * sx,
          h: current.h * sy,
          cr: false
        });
      }
      xAdvance = 0;
      yAdvance = 0;
      lastGlyph = null;
      lastCharCode = 0;
      var prev;
      var offset = 0;
      var crs = [];
      for (i = 0; i < words.length; i++) {
        var entry = words[i];
        var left = entry.x;
        var right = entry.x + entry.w;
        if (prev) {
          var diff = left - (prev.x + prev.w);
          offset = left - (diff + prev.w);
          prev = null;
        }
        var checkLeft = left - offset;
        var checkRight = right - offset;
        if (checkLeft > maxWidth || checkRight > maxWidth) {
          crs.push(entry.i - 1);
          if (entry.cr) {
            crs.push(entry.i + entry.word.length);
            offset = 0;
            prev = null;
          } else {
            prev = entry;
          }
        } else if (entry.cr) {
          crs.push(entry.i + entry.word.length);
          offset = 0;
          prev = null;
        }
      }
      var stringInsert = function(str, index, value) {
        return str.substr(0, index) + value + str.substr(index + 1);
      };
      for (i = crs.length - 1; i >= 0; i--) {
        text = stringInsert(text, crs[i], "\n");
      }
      out.wrappedText = text;
      textLength = text.length;
      words = [];
      current = null;
    }
    var charIndex = 0;
    for (i = 0; i < textLength; i++) {
      charCode = text.charCodeAt(i);
      if (charCode === 10) {
        if (current !== null) {
          words.push({
            word: current.word,
            i: current.i,
            x: current.x * sx,
            y: current.y * sy,
            w: current.w * sx,
            h: current.h * sy
          });
          current = null;
        }
        xAdvance = 0;
        yAdvance += lineHeight;
        lastGlyph = null;
        lineWidths[currentLine] = currentLineWidth;
        if (currentLineWidth > longestLine) {
          longestLine = currentLineWidth;
        }
        if (currentLineWidth < shortestLine) {
          shortestLine = currentLineWidth;
        }
        currentLine++;
        currentLineWidth = 0;
        continue;
      }
      glyph = chars[charCode];
      if (!glyph) {
        continue;
      }
      x = xAdvance;
      y = yAdvance;
      if (lastGlyph !== null) {
        var kerningOffset = glyph.kerning[lastCharCode];
        x += kerningOffset !== void 0 ? kerningOffset : 0;
      }
      if (bx > x) {
        bx = x;
      }
      if (by > y) {
        by = y;
      }
      var gw = x + glyph.xAdvance;
      var gh = y + lineHeight;
      if (bw < gw) {
        bw = gw;
      }
      if (bh < gh) {
        bh = gh;
      }
      var charWidth = glyph.xOffset + glyph.xAdvance + (kerningOffset !== void 0 ? kerningOffset : 0);
      if (charCode === wordWrapCharCode) {
        if (current !== null) {
          words.push({
            word: current.word,
            i: current.i,
            x: current.x * sx,
            y: current.y * sy,
            w: current.w * sx,
            h: current.h * sy
          });
          current = null;
        }
      } else {
        if (current === null) {
          current = {word: "", i: charIndex, x: xAdvance, y: yAdvance, w: 0, h: lineHeight};
        }
        current.word = current.word.concat(text[i]);
        current.w += charWidth;
      }
      characters.push({
        i: charIndex,
        char: text[i],
        code: charCode,
        x: (glyph.xOffset + xAdvance) * scale,
        y: (glyph.yOffset + yAdvance) * scale,
        w: glyph.width * scale,
        h: glyph.height * scale,
        t: yAdvance * scale,
        r: gw * scale,
        b: lineHeight * scale,
        line: currentLine,
        glyph
      });
      xAdvance += glyph.xAdvance + letterSpacing;
      lastGlyph = glyph;
      lastCharCode = charCode;
      currentLineWidth = gw * scale;
      charIndex++;
    }
    if (current !== null) {
      words.push({
        word: current.word,
        i: current.i,
        x: current.x * sx,
        y: current.y * sy,
        w: current.w * sx,
        h: current.h * sy
      });
    }
    lineWidths[currentLine] = currentLineWidth;
    if (currentLineWidth > longestLine) {
      longestLine = currentLineWidth;
    }
    if (currentLineWidth < shortestLine) {
      shortestLine = currentLineWidth;
    }
    if (align > 0) {
      for (var c = 0; c < characters.length; c++) {
        var currentChar = characters[c];
        if (align === 1) {
          var ax1 = (longestLine - lineWidths[currentChar.line]) / 2;
          currentChar.x += ax1;
          currentChar.r += ax1;
        } else if (align === 2) {
          var ax2 = longestLine - lineWidths[currentChar.line];
          currentChar.x += ax2;
          currentChar.r += ax2;
        }
      }
    }
    var local = out.local;
    var global2 = out.global;
    var lines = out.lines;
    local.x = bx * scale;
    local.y = by * scale;
    local.width = bw * scale;
    local.height = bh * scale;
    global2.x = src.x - src._displayOriginX + bx * sx;
    global2.y = src.y - src._displayOriginY + by * sy;
    global2.width = bw * sx;
    global2.height = bh * sy;
    lines.shortest = shortestLine;
    lines.longest = longestLine;
    lines.lengths = lineWidths;
    if (round) {
      local.x = Math.ceil(local.x);
      local.y = Math.ceil(local.y);
      local.width = Math.ceil(local.width);
      local.height = Math.ceil(local.height);
      global2.x = Math.ceil(global2.x);
      global2.y = Math.ceil(global2.y);
      global2.width = Math.ceil(global2.width);
      global2.height = Math.ceil(global2.height);
      lines.shortest = Math.ceil(shortestLine);
      lines.longest = Math.ceil(longestLine);
    }
    if (updateOrigin) {
      src._displayOriginX = src.originX * local.width;
      src._displayOriginY = src.originY * local.height;
      global2.x = src.x - src._displayOriginX * src.scaleX;
      global2.y = src.y - src._displayOriginY * src.scaleY;
      if (round) {
        global2.x = Math.ceil(global2.x);
        global2.y = Math.ceil(global2.y);
      }
    }
    out.words = words;
    out.characters = characters;
    out.lines.height = lineHeight;
    out.scale = scale;
    out.scaleX = src.scaleX;
    out.scaleY = src.scaleY;
    return out;
  };
  module2.exports = GetBitmapTextSize;
});

// node_modules/phaser/src/gameobjects/bitmaptext/ParseXMLBitmapFont.js
var require_ParseXMLBitmapFont = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  function getValue(node, attribute) {
    return parseInt(node.getAttribute(attribute), 10);
  }
  var ParseXMLBitmapFont = function(xml, frame, xSpacing, ySpacing, texture) {
    if (xSpacing === void 0) {
      xSpacing = 0;
    }
    if (ySpacing === void 0) {
      ySpacing = 0;
    }
    var textureX = frame.cutX;
    var textureY = frame.cutY;
    var textureWidth = frame.source.width;
    var textureHeight = frame.source.height;
    var sourceIndex = frame.sourceIndex;
    var data = {};
    var info = xml.getElementsByTagName("info")[0];
    var common = xml.getElementsByTagName("common")[0];
    data.font = info.getAttribute("face");
    data.size = getValue(info, "size");
    data.lineHeight = getValue(common, "lineHeight") + ySpacing;
    data.chars = {};
    var letters = xml.getElementsByTagName("char");
    var adjustForTrim = frame !== void 0 && frame.trimmed;
    if (adjustForTrim) {
      var top = frame.height;
      var left = frame.width;
    }
    for (var i = 0; i < letters.length; i++) {
      var node = letters[i];
      var charCode = getValue(node, "id");
      var letter = String.fromCharCode(charCode);
      var gx = getValue(node, "x");
      var gy = getValue(node, "y");
      var gw = getValue(node, "width");
      var gh = getValue(node, "height");
      if (adjustForTrim) {
        if (gx < left) {
          left = gx;
        }
        if (gy < top) {
          top = gy;
        }
      }
      if (adjustForTrim && top !== 0 && left !== 0) {
        gx -= frame.x;
        gy -= frame.y;
      }
      var u0 = (textureX + gx) / textureWidth;
      var v0 = (textureY + gy) / textureHeight;
      var u1 = (textureX + gx + gw) / textureWidth;
      var v1 = (textureY + gy + gh) / textureHeight;
      data.chars[charCode] = {
        x: gx,
        y: gy,
        width: gw,
        height: gh,
        centerX: Math.floor(gw / 2),
        centerY: Math.floor(gh / 2),
        xOffset: getValue(node, "xoffset"),
        yOffset: getValue(node, "yoffset"),
        xAdvance: getValue(node, "xadvance") + xSpacing,
        data: {},
        kerning: {},
        u0,
        v0,
        u1,
        v1
      };
      if (texture && gw !== 0 && gh !== 0) {
        var charFrame = texture.add(letter, sourceIndex, gx, gy, gw, gh);
        if (charFrame) {
          charFrame.setUVs(gw, gh, u0, v0, u1, v1);
        }
      }
    }
    var kernings = xml.getElementsByTagName("kerning");
    for (i = 0; i < kernings.length; i++) {
      var kern = kernings[i];
      var first = getValue(kern, "first");
      var second = getValue(kern, "second");
      var amount = getValue(kern, "amount");
      data.chars[second].kerning[first] = amount;
    }
    return data;
  };
  module2.exports = ParseXMLBitmapFont;
});

// node_modules/phaser/src/gameobjects/bitmaptext/ParseFromAtlas.js
var require_ParseFromAtlas = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ParseXMLBitmapFont = require_ParseXMLBitmapFont();
  var ParseFromAtlas = function(scene, fontName, textureKey, frameKey, xmlKey, xSpacing, ySpacing) {
    var texture = scene.sys.textures.get(textureKey);
    var frame = texture.get(frameKey);
    var xml = scene.sys.cache.xml.get(xmlKey);
    if (frame && xml) {
      var data = ParseXMLBitmapFont(xml, frame, xSpacing, ySpacing, texture);
      scene.sys.cache.bitmapFont.add(fontName, {data, texture: textureKey, frame: frameKey, fromAtlas: true});
      return true;
    } else {
      return false;
    }
  };
  module2.exports = ParseFromAtlas;
});

// node_modules/phaser/src/gameobjects/bitmaptext/BatchChar.js
var require_BatchChar = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BatchChar = function(pipeline, src, char, glyph, offsetX, offsetY, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit) {
    var x = char.x - src.displayOriginX + offsetX;
    var y = char.y - src.displayOriginY + offsetY;
    var xw = x + char.w;
    var yh = y + char.h;
    var tx0 = calcMatrix.getXRound(x, y, roundPixels);
    var ty0 = calcMatrix.getYRound(x, y, roundPixels);
    var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
    var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
    var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
    var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
    var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
    var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
    pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, glyph.u0, glyph.v0, glyph.u1, glyph.v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
  };
  module2.exports = BatchChar;
});

// node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextWebGLRenderer.js
var require_BitmapTextWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BatchChar = require_BatchChar();
  var GetCalcMatrix = require_GetCalcMatrix();
  var Utils = require_Utils();
  var BitmapTextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    var text = src._text;
    var textLength = text.length;
    if (textLength === 0) {
      return;
    }
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
    var roundPixels = camera.roundPixels;
    var cameraAlpha = camera.alpha;
    var charColors = src.charColors;
    var tintEffect = src.tintFill;
    var getTint = Utils.getTintAppendFloatAlpha;
    var tintTL = getTint(src.tintTopLeft, cameraAlpha * src._alphaTL);
    var tintTR = getTint(src.tintTopRight, cameraAlpha * src._alphaTR);
    var tintBL = getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL);
    var tintBR = getTint(src.tintBottomRight, cameraAlpha * src._alphaBR);
    var texture = src.frame.glTexture;
    var textureUnit = pipeline.setGameObject(src);
    var bounds = src.getTextBounds(false);
    var i;
    var char;
    var glyph;
    var characters = bounds.characters;
    var dropShadowX = src.dropShadowX;
    var dropShadowY = src.dropShadowY;
    var dropShadow = dropShadowX !== 0 || dropShadowY !== 0;
    renderer.pipelines.preBatch(src);
    if (dropShadow) {
      var srcShadowColor = src.dropShadowColor;
      var srcShadowAlpha = src.dropShadowAlpha;
      var shadowTL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTL);
      var shadowTR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTR);
      var shadowBL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBL);
      var shadowBR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBR);
      for (i = 0; i < characters.length; i++) {
        char = characters[i];
        glyph = char.glyph;
        if (char.code === 32 || glyph.width === 0 || glyph.height === 0) {
          continue;
        }
        BatchChar(pipeline, src, char, glyph, dropShadowX, dropShadowY, calcMatrix, roundPixels, shadowTL, shadowTR, shadowBL, shadowBR, 1, texture, textureUnit);
      }
    }
    for (i = 0; i < characters.length; i++) {
      char = characters[i];
      glyph = char.glyph;
      if (char.code === 32 || glyph.width === 0 || glyph.height === 0) {
        continue;
      }
      if (charColors[char.i]) {
        var color = charColors[char.i];
        var charTintEffect = color.tintEffect;
        var charTintTL = getTint(color.tintTL, cameraAlpha * src._alphaTL);
        var charTintTR = getTint(color.tintTR, cameraAlpha * src._alphaTR);
        var charTintBL = getTint(color.tintBL, cameraAlpha * src._alphaBL);
        var charTintBR = getTint(color.tintBR, cameraAlpha * src._alphaBR);
        BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, charTintTL, charTintTR, charTintBL, charTintBR, charTintEffect, texture, textureUnit);
      } else {
        BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
      }
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = BitmapTextWebGLRenderer;
});

// node_modules/phaser/src/renderer/canvas/utils/SetTransform.js
var require_SetTransform = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var SetTransform = function(renderer, ctx, src, camera, parentMatrix) {
    var alpha = camera.alpha * src.alpha;
    if (alpha <= 0) {
      return false;
    }
    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
    ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    ctx.globalAlpha = alpha;
    ctx.save();
    calcMatrix.setToContext(ctx);
    ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame && src.frame.source.scaleMode);
    return true;
  };
  module2.exports = SetTransform;
});

// node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextCanvasRenderer.js
var require_BitmapTextCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetTransform = require_SetTransform();
  var BitmapTextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    var text = src._text;
    var textLength = text.length;
    var ctx = renderer.currentContext;
    if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      return;
    }
    camera.addToRenderList(src);
    var textureFrame = src.fromAtlas ? src.frame : src.texture.frames["__BASE"];
    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;
    var letterSpacing = src._letterSpacing;
    var xAdvance = 0;
    var yAdvance = 0;
    var charCode = 0;
    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;
    var x = 0;
    var y = 0;
    var lastGlyph = null;
    var lastCharCode = 0;
    var image = textureFrame.source.image;
    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;
    var scale = src._fontSize / src.fontData.size;
    var align = src._align;
    var currentLine = 0;
    var lineOffsetX = 0;
    var bounds = src.getTextBounds(false);
    if (src.maxWidth > 0) {
      text = bounds.wrappedText;
      textLength = text.length;
    }
    var lineData = src._bounds.lines;
    if (align === 1) {
      lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
    } else if (align === 2) {
      lineOffsetX = lineData.longest - lineData.lengths[0];
    }
    ctx.translate(-src.displayOriginX, -src.displayOriginY);
    var roundPixels = camera.roundPixels;
    for (var i = 0; i < textLength; i++) {
      charCode = text.charCodeAt(i);
      if (charCode === 10) {
        currentLine++;
        if (align === 1) {
          lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
        } else if (align === 2) {
          lineOffsetX = lineData.longest - lineData.lengths[currentLine];
        }
        xAdvance = 0;
        yAdvance += lineHeight;
        lastGlyph = null;
        continue;
      }
      glyph = chars[charCode];
      if (!glyph) {
        continue;
      }
      glyphX = textureX + glyph.x;
      glyphY = textureY + glyph.y;
      glyphW = glyph.width;
      glyphH = glyph.height;
      x = glyph.xOffset + xAdvance;
      y = glyph.yOffset + yAdvance;
      if (lastGlyph !== null) {
        var kerningOffset = glyph.kerning[lastCharCode];
        x += kerningOffset !== void 0 ? kerningOffset : 0;
      }
      x *= scale;
      y *= scale;
      x += lineOffsetX;
      xAdvance += glyph.xAdvance + letterSpacing;
      lastGlyph = glyph;
      lastCharCode = charCode;
      if (glyphW === 0 || glyphH === 0 || charCode === 32) {
        continue;
      }
      if (roundPixels) {
        x = Math.round(x);
        y = Math.round(y);
      }
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
      ctx.restore();
    }
    ctx.restore();
  };
  module2.exports = BitmapTextCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextRender.js
var require_BitmapTextRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_BitmapTextWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_BitmapTextCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapText.js
var require_BitmapText = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Clamp = require_Clamp();
  var Components = require_components();
  var GameObject = require_GameObject();
  var GetBitmapTextSize = require_GetBitmapTextSize();
  var ParseFromAtlas = require_ParseFromAtlas();
  var ParseXMLBitmapFont = require_ParseXMLBitmapFont();
  var Rectangle = require_Rectangle();
  var Render = require_BitmapTextRender();
  var BitmapText = new Class({
    Extends: GameObject,
    Mixins: [
      Components.Alpha,
      Components.BlendMode,
      Components.Depth,
      Components.Mask,
      Components.Origin,
      Components.Pipeline,
      Components.ScrollFactor,
      Components.Texture,
      Components.Tint,
      Components.Transform,
      Components.Visible,
      Render
    ],
    initialize: function BitmapText2(scene, x, y, font, text, size, align) {
      if (text === void 0) {
        text = "";
      }
      if (align === void 0) {
        align = 0;
      }
      GameObject.call(this, scene, "BitmapText");
      this.font = font;
      var entry = this.scene.sys.cache.bitmapFont.get(font);
      if (!entry) {
        console.warn("Invalid BitmapText key: " + font);
      }
      this.fontData = entry.data;
      this._text = "";
      this._fontSize = size || this.fontData.size;
      this._letterSpacing = 0;
      this._align = align;
      this._bounds = GetBitmapTextSize();
      this._dirty = true;
      this._maxWidth = 0;
      this.wordWrapCharCode = 32;
      this.charColors = [];
      this.dropShadowX = 0;
      this.dropShadowY = 0;
      this.dropShadowColor = 0;
      this.dropShadowAlpha = 0.5;
      this.fromAtlas = entry.fromAtlas;
      this.setTexture(entry.texture, entry.frame);
      this.setPosition(x, y);
      this.setOrigin(0, 0);
      this.initPipeline();
      this.setText(text);
    },
    setLeftAlign: function() {
      this._align = BitmapText.ALIGN_LEFT;
      this._dirty = true;
      return this;
    },
    setCenterAlign: function() {
      this._align = BitmapText.ALIGN_CENTER;
      this._dirty = true;
      return this;
    },
    setRightAlign: function() {
      this._align = BitmapText.ALIGN_RIGHT;
      this._dirty = true;
      return this;
    },
    setFontSize: function(size) {
      this._fontSize = size;
      this._dirty = true;
      return this;
    },
    setLetterSpacing: function(spacing) {
      if (spacing === void 0) {
        spacing = 0;
      }
      this._letterSpacing = spacing;
      this._dirty = true;
      return this;
    },
    setText: function(value) {
      if (!value && value !== 0) {
        value = "";
      }
      if (Array.isArray(value)) {
        value = value.join("\n");
      }
      if (value !== this.text) {
        this._text = value.toString();
        this._dirty = true;
        this.updateDisplayOrigin();
      }
      return this;
    },
    setDropShadow: function(x, y, color, alpha) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (color === void 0) {
        color = 0;
      }
      if (alpha === void 0) {
        alpha = 0.5;
      }
      this.dropShadowX = x;
      this.dropShadowY = y;
      this.dropShadowColor = color;
      this.dropShadowAlpha = alpha;
      return this;
    },
    setCharacterTint: function(start, length, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
      if (start === void 0) {
        start = 0;
      }
      if (length === void 0) {
        length = 1;
      }
      if (tintFill === void 0) {
        tintFill = false;
      }
      if (topLeft === void 0) {
        topLeft = -1;
      }
      if (topRight === void 0) {
        topRight = topLeft;
        bottomLeft = topLeft;
        bottomRight = topLeft;
      }
      var len = this.text.length;
      if (length === -1) {
        length = len;
      }
      if (start < 0) {
        start = len + start;
      }
      start = Clamp(start, 0, len - 1);
      var end = Clamp(start + length, start, len);
      var charColors = this.charColors;
      for (var i = start; i < end; i++) {
        var color = charColors[i];
        if (topLeft === -1) {
          charColors[i] = null;
        } else {
          var tintEffect = tintFill ? 1 : 0;
          if (color) {
            color.tintEffect = tintEffect;
            color.tintTL = topLeft;
            color.tintTR = topRight;
            color.tintBL = bottomLeft;
            color.tintBR = bottomRight;
          } else {
            charColors[i] = {
              tintEffect,
              tintTL: topLeft,
              tintTR: topRight,
              tintBL: bottomLeft,
              tintBR: bottomRight
            };
          }
        }
      }
      return this;
    },
    setWordTint: function(word, count, tintFill, topLeft, topRight, bottomLeft, bottomRight) {
      if (count === void 0) {
        count = 1;
      }
      var bounds = this.getTextBounds();
      var words = bounds.words;
      var wordIsNumber = typeof word === "number";
      var total = 0;
      for (var i = 0; i < words.length; i++) {
        var lineword = words[i];
        if (wordIsNumber && i === word || !wordIsNumber && lineword.word === word) {
          this.setCharacterTint(lineword.i, lineword.word.length, tintFill, topLeft, topRight, bottomLeft, bottomRight);
          total++;
          if (total === count) {
            return this;
          }
        }
      }
      return this;
    },
    getTextBounds: function(round) {
      var bounds = this._bounds;
      if (this._dirty || round || this.scaleX !== bounds.scaleX || this.scaleY !== bounds.scaleY) {
        GetBitmapTextSize(this, round, true, bounds);
        this._dirty = false;
      }
      return bounds;
    },
    getCharacterAt: function(x, y, camera) {
      var point = this.getLocalPoint(x, y, null, camera);
      var bounds = this.getTextBounds();
      var chars = bounds.characters;
      var tempRect = new Rectangle();
      for (var i = 0; i < chars.length; i++) {
        var char = chars[i];
        tempRect.setTo(char.x, char.t, char.r - char.x, char.b);
        if (tempRect.contains(point.x, point.y)) {
          return char;
        }
      }
      return null;
    },
    updateDisplayOrigin: function() {
      this._dirty = true;
      this.getTextBounds(false);
      return this;
    },
    setFont: function(key, size, align) {
      if (size === void 0) {
        size = this._fontSize;
      }
      if (align === void 0) {
        align = this._align;
      }
      if (key !== this.font) {
        var entry = this.scene.sys.cache.bitmapFont.get(key);
        if (entry) {
          this.font = key;
          this.fontData = entry.data;
          this._fontSize = size;
          this._align = align;
          this.fromAtlas = entry.fromAtlas === true;
          this.setTexture(entry.texture, entry.frame);
          GetBitmapTextSize(this, false, true, this._bounds);
        }
      }
      return this;
    },
    setMaxWidth: function(value, wordWrapCharCode) {
      this._maxWidth = value;
      this._dirty = true;
      if (wordWrapCharCode !== void 0) {
        this.wordWrapCharCode = wordWrapCharCode;
      }
      return this;
    },
    align: {
      set: function(value) {
        this._align = value;
        this._dirty = true;
      },
      get: function() {
        return this._align;
      }
    },
    text: {
      set: function(value) {
        this.setText(value);
      },
      get: function() {
        return this._text;
      }
    },
    fontSize: {
      set: function(value) {
        this._fontSize = value;
        this._dirty = true;
      },
      get: function() {
        return this._fontSize;
      }
    },
    letterSpacing: {
      set: function(value) {
        this._letterSpacing = value;
        this._dirty = true;
      },
      get: function() {
        return this._letterSpacing;
      }
    },
    maxWidth: {
      set: function(value) {
        this._maxWidth = value;
        this._dirty = true;
      },
      get: function() {
        return this._maxWidth;
      }
    },
    width: {
      get: function() {
        this.getTextBounds(false);
        return this._bounds.global.width;
      }
    },
    height: {
      get: function() {
        this.getTextBounds(false);
        return this._bounds.global.height;
      }
    },
    toJSON: function() {
      var out = Components.ToJSON(this);
      var data = {
        font: this.font,
        text: this.text,
        fontSize: this.fontSize,
        letterSpacing: this.letterSpacing,
        align: this.align
      };
      out.data = data;
      return out;
    },
    preDestroy: function() {
      this.charColors.length = 0;
      this._bounds = null;
      this.fontData = null;
    }
  });
  BitmapText.ALIGN_LEFT = 0;
  BitmapText.ALIGN_CENTER = 1;
  BitmapText.ALIGN_RIGHT = 2;
  BitmapText.ParseFromAtlas = ParseFromAtlas;
  BitmapText.ParseXMLBitmapFont = ParseXMLBitmapFont;
  module2.exports = BitmapText;
});

// node_modules/phaser/src/gameobjects/blitter/BlitterWebGLRenderer.js
var require_BlitterWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TransformMatrix = require_TransformMatrix();
  var Utils = require_Utils();
  var tempMatrix = new TransformMatrix();
  var BlitterWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    var list = src.getRenderList();
    if (list.length === 0) {
      return;
    }
    var alpha = camera.alpha * src.alpha;
    if (alpha === 0) {
      return;
    }
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(this.pipeline, src);
    var cameraScrollX = camera.scrollX * src.scrollFactorX;
    var cameraScrollY = camera.scrollY * src.scrollFactorY;
    var calcMatrix = tempMatrix.copyFrom(camera.matrix);
    if (parentMatrix) {
      calcMatrix.multiplyWithOffset(parentMatrix, -cameraScrollX, -cameraScrollY);
      cameraScrollX = 0;
      cameraScrollY = 0;
    }
    var blitterX = src.x - cameraScrollX;
    var blitterY = src.y - cameraScrollY;
    var prevTextureSourceIndex = -1;
    var tintEffect = false;
    var roundPixels = camera.roundPixels;
    renderer.pipelines.preBatch(src);
    for (var index = 0; index < list.length; index++) {
      var bob = list[index];
      var frame = bob.frame;
      var bobAlpha = bob.alpha * alpha;
      if (bobAlpha === 0) {
        continue;
      }
      var width = frame.width;
      var height = frame.height;
      var x = blitterX + bob.x + frame.x;
      var y = blitterY + bob.y + frame.y;
      if (bob.flipX) {
        width *= -1;
        x += frame.width;
      }
      if (bob.flipY) {
        height *= -1;
        y += frame.height;
      }
      var xw = x + width;
      var yh = y + height;
      var tx0 = calcMatrix.getX(x, y);
      var ty0 = calcMatrix.getY(x, y);
      var tx1 = calcMatrix.getX(xw, yh);
      var ty1 = calcMatrix.getY(xw, yh);
      var tint = Utils.getTintAppendFloatAlpha(bob.tint, bobAlpha);
      if (frame.sourceIndex !== prevTextureSourceIndex) {
        var textureUnit = pipeline.setGameObject(src, frame);
        prevTextureSourceIndex = frame.sourceIndex;
      }
      if (roundPixels) {
        tx0 = Math.round(tx0);
        ty0 = Math.round(ty0);
        tx1 = Math.round(tx1);
        ty1 = Math.round(ty1);
      }
      if (pipeline.batchQuad(src, tx0, ty0, tx0, ty1, tx1, ty1, tx1, ty0, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, frame.glTexture, textureUnit)) {
        prevTextureSourceIndex = -1;
      }
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = BlitterWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/blitter/BlitterCanvasRenderer.js
var require_BlitterCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BlitterCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    var list = src.getRenderList();
    if (list.length === 0) {
      return;
    }
    var ctx = renderer.currentContext;
    var alpha = camera.alpha * src.alpha;
    if (alpha === 0) {
      return;
    }
    camera.addToRenderList(src);
    ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];
    ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame.source.scaleMode);
    var cameraScrollX = src.x - camera.scrollX * src.scrollFactorX;
    var cameraScrollY = src.y - camera.scrollY * src.scrollFactorY;
    ctx.save();
    if (parentMatrix) {
      parentMatrix.copyToContext(ctx);
    }
    var roundPixels = camera.roundPixels;
    for (var i = 0; i < list.length; i++) {
      var bob = list[i];
      var flip = bob.flipX || bob.flipY;
      var frame = bob.frame;
      var cd = frame.canvasData;
      var dx = frame.x;
      var dy = frame.y;
      var fx = 1;
      var fy = 1;
      var bobAlpha = bob.alpha * alpha;
      if (bobAlpha === 0) {
        continue;
      }
      ctx.globalAlpha = bobAlpha;
      if (!flip) {
        if (roundPixels) {
          dx = Math.round(dx);
          dy = Math.round(dy);
        }
        ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx + bob.x + cameraScrollX, dy + bob.y + cameraScrollY, cd.width, cd.height);
      } else {
        if (bob.flipX) {
          fx = -1;
          dx -= cd.width;
        }
        if (bob.flipY) {
          fy = -1;
          dy -= cd.height;
        }
        ctx.save();
        ctx.translate(bob.x + cameraScrollX, bob.y + cameraScrollY);
        ctx.scale(fx, fy);
        ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx, dy, cd.width, cd.height);
        ctx.restore();
      }
    }
    ctx.restore();
  };
  module2.exports = BlitterCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/blitter/BlitterRender.js
var require_BlitterRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_BlitterWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_BlitterCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/blitter/Bob.js
var require_Bob = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Frame = require_Frame();
  var Bob = new Class({
    initialize: function Bob2(blitter, x, y, frame, visible) {
      this.parent = blitter;
      this.x = x;
      this.y = y;
      this.frame = frame;
      this.data = {};
      this.tint = 16777215;
      this._visible = visible;
      this._alpha = 1;
      this.flipX = false;
      this.flipY = false;
    },
    setFrame: function(frame) {
      if (frame === void 0) {
        this.frame = this.parent.frame;
      } else if (frame instanceof Frame && frame.texture === this.parent.texture) {
        this.frame = frame;
      } else {
        this.frame = this.parent.texture.get(frame);
      }
      return this;
    },
    resetFlip: function() {
      this.flipX = false;
      this.flipY = false;
      return this;
    },
    reset: function(x, y, frame) {
      this.x = x;
      this.y = y;
      this.flipX = false;
      this.flipY = false;
      this._alpha = 1;
      this._visible = true;
      this.parent.dirty = true;
      if (frame) {
        this.setFrame(frame);
      }
      return this;
    },
    setPosition: function(x, y) {
      this.x = x;
      this.y = y;
      return this;
    },
    setFlipX: function(value) {
      this.flipX = value;
      return this;
    },
    setFlipY: function(value) {
      this.flipY = value;
      return this;
    },
    setFlip: function(x, y) {
      this.flipX = x;
      this.flipY = y;
      return this;
    },
    setVisible: function(value) {
      this.visible = value;
      return this;
    },
    setAlpha: function(value) {
      this.alpha = value;
      return this;
    },
    setTint: function(value) {
      this.tint = value;
      return this;
    },
    destroy: function() {
      this.parent.dirty = true;
      this.parent.children.remove(this);
      this.parent = void 0;
      this.frame = void 0;
      this.data = void 0;
    },
    visible: {
      get: function() {
        return this._visible;
      },
      set: function(value) {
        this.parent.dirty |= this._visible !== value;
        this._visible = value;
      }
    },
    alpha: {
      get: function() {
        return this._alpha;
      },
      set: function(value) {
        this.parent.dirty |= this._alpha > 0 !== value > 0;
        this._alpha = value;
      }
    }
  });
  module2.exports = Bob;
});

// node_modules/phaser/src/gameobjects/blitter/Blitter.js
var require_Blitter = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BlitterRender = require_BlitterRender();
  var Bob = require_Bob();
  var Class = require_Class();
  var Components = require_components();
  var Frame = require_Frame();
  var GameObject = require_GameObject();
  var List = require_List();
  var Blitter = new Class({
    Extends: GameObject,
    Mixins: [
      Components.Alpha,
      Components.BlendMode,
      Components.Depth,
      Components.Mask,
      Components.Pipeline,
      Components.ScrollFactor,
      Components.Size,
      Components.Texture,
      Components.Transform,
      Components.Visible,
      BlitterRender
    ],
    initialize: function Blitter2(scene, x, y, texture, frame) {
      GameObject.call(this, scene, "Blitter");
      this.setTexture(texture, frame);
      this.setPosition(x, y);
      this.initPipeline();
      this.children = new List();
      this.renderList = [];
      this.dirty = false;
    },
    create: function(x, y, frame, visible, index) {
      if (visible === void 0) {
        visible = true;
      }
      if (index === void 0) {
        index = this.children.length;
      }
      if (frame === void 0) {
        frame = this.frame;
      } else if (!(frame instanceof Frame)) {
        frame = this.texture.get(frame);
      }
      var bob = new Bob(this, x, y, frame, visible);
      this.children.addAt(bob, index, false);
      this.dirty = true;
      return bob;
    },
    createFromCallback: function(callback, quantity, frame, visible) {
      var bobs = this.createMultiple(quantity, frame, visible);
      for (var i = 0; i < bobs.length; i++) {
        var bob = bobs[i];
        callback.call(this, bob, i);
      }
      return bobs;
    },
    createMultiple: function(quantity, frame, visible) {
      if (frame === void 0) {
        frame = this.frame.name;
      }
      if (visible === void 0) {
        visible = true;
      }
      if (!Array.isArray(frame)) {
        frame = [frame];
      }
      var bobs = [];
      var _this = this;
      frame.forEach(function(singleFrame) {
        for (var i = 0; i < quantity; i++) {
          bobs.push(_this.create(0, 0, singleFrame, visible));
        }
      });
      return bobs;
    },
    childCanRender: function(child) {
      return child.visible && child.alpha > 0;
    },
    getRenderList: function() {
      if (this.dirty) {
        this.renderList = this.children.list.filter(this.childCanRender, this);
        this.dirty = false;
      }
      return this.renderList;
    },
    clear: function() {
      this.children.removeAll();
      this.dirty = true;
    },
    preDestroy: function() {
      this.children.destroy();
      this.renderList = [];
    }
  });
  module2.exports = Blitter;
});

// node_modules/phaser/src/gameobjects/container/ContainerWebGLRenderer.js
var require_ContainerWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ContainerWebGLRenderer = function(renderer, container, camera, parentMatrix) {
    camera.addToRenderList(container);
    var children = container.list;
    var childCount = children.length;
    if (childCount === 0) {
      return;
    }
    var transformMatrix = container.localTransform;
    if (parentMatrix) {
      transformMatrix.loadIdentity();
      transformMatrix.multiply(parentMatrix);
      transformMatrix.translate(container.x, container.y);
      transformMatrix.rotate(container.rotation);
      transformMatrix.scale(container.scaleX, container.scaleY);
    } else {
      transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
    }
    renderer.pipelines.preBatch(container);
    var containerHasBlendMode = container.blendMode !== -1;
    if (!containerHasBlendMode) {
      renderer.setBlendMode(0);
    }
    var alpha = container.alpha;
    var scrollFactorX = container.scrollFactorX;
    var scrollFactorY = container.scrollFactorY;
    for (var i = 0; i < childCount; i++) {
      var child = children[i];
      if (!child.willRender(camera)) {
        continue;
      }
      var childAlphaTopLeft;
      var childAlphaTopRight;
      var childAlphaBottomLeft;
      var childAlphaBottomRight;
      if (child.alphaTopLeft !== void 0) {
        childAlphaTopLeft = child.alphaTopLeft;
        childAlphaTopRight = child.alphaTopRight;
        childAlphaBottomLeft = child.alphaBottomLeft;
        childAlphaBottomRight = child.alphaBottomRight;
      } else {
        var childAlpha = child.alpha;
        childAlphaTopLeft = childAlpha;
        childAlphaTopRight = childAlpha;
        childAlphaBottomLeft = childAlpha;
        childAlphaBottomRight = childAlpha;
      }
      var childScrollFactorX = child.scrollFactorX;
      var childScrollFactorY = child.scrollFactorY;
      if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
        renderer.setBlendMode(child.blendMode);
      }
      var mask = child.mask;
      if (mask) {
        mask.preRenderWebGL(renderer, child, camera);
      }
      var type = child.type;
      if (type !== renderer.currentType) {
        renderer.newType = true;
        renderer.currentType = type;
      }
      renderer.nextTypeMatch = i < childCount - 1 ? children[i + 1].type === renderer.currentType : false;
      child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
      child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);
      child.renderWebGL(renderer, child, camera, transformMatrix);
      child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);
      child.setScrollFactor(childScrollFactorX, childScrollFactorY);
      if (mask) {
        mask.postRenderWebGL(renderer, camera);
      }
      renderer.newType = false;
    }
    renderer.pipelines.postBatch(container);
  };
  module2.exports = ContainerWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/container/ContainerCanvasRenderer.js
var require_ContainerCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ContainerCanvasRenderer = function(renderer, container, camera, parentMatrix) {
    camera.addToRenderList(container);
    var children = container.list;
    if (children.length === 0) {
      return;
    }
    var transformMatrix = container.localTransform;
    if (parentMatrix) {
      transformMatrix.loadIdentity();
      transformMatrix.multiply(parentMatrix);
      transformMatrix.translate(container.x, container.y);
      transformMatrix.rotate(container.rotation);
      transformMatrix.scale(container.scaleX, container.scaleY);
    } else {
      transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);
    }
    var containerHasBlendMode = container.blendMode !== -1;
    if (!containerHasBlendMode) {
      renderer.setBlendMode(0);
    }
    var alpha = container._alpha;
    var scrollFactorX = container.scrollFactorX;
    var scrollFactorY = container.scrollFactorY;
    if (container.mask) {
      container.mask.preRenderCanvas(renderer, null, camera);
    }
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (!child.willRender(camera)) {
        continue;
      }
      var childAlpha = child.alpha;
      var childScrollFactorX = child.scrollFactorX;
      var childScrollFactorY = child.scrollFactorY;
      if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
        renderer.setBlendMode(child.blendMode);
      }
      child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);
      child.setAlpha(childAlpha * alpha);
      child.renderCanvas(renderer, child, camera, transformMatrix);
      child.setAlpha(childAlpha);
      child.setScrollFactor(childScrollFactorX, childScrollFactorY);
    }
    if (container.mask) {
      container.mask.postRenderCanvas(renderer);
    }
  };
  module2.exports = ContainerCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/container/ContainerRender.js
var require_ContainerRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_ContainerWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_ContainerCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/geom/rectangle/Union.js
var require_Union = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  var Union = function(rectA, rectB, out) {
    if (out === void 0) {
      out = new Rectangle();
    }
    var x = Math.min(rectA.x, rectB.x);
    var y = Math.min(rectA.y, rectB.y);
    var w = Math.max(rectA.right, rectB.right) - x;
    var h = Math.max(rectA.bottom, rectB.bottom) - y;
    return out.setTo(x, y, w, h);
  };
  module2.exports = Union;
});

// node_modules/phaser/src/gameobjects/container/Container.js
var require_Container = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ArrayUtils = require_array();
  var BlendModes = require_BlendModes();
  var Class = require_Class();
  var Components = require_components();
  var Events = require_events4();
  var GameObject = require_GameObject();
  var Rectangle = require_Rectangle();
  var Render = require_ContainerRender();
  var Union = require_Union();
  var Vector2 = require_Vector2();
  var Container = new Class({
    Extends: GameObject,
    Mixins: [
      Components.AlphaSingle,
      Components.BlendMode,
      Components.ComputedSize,
      Components.Depth,
      Components.Mask,
      Components.Pipeline,
      Components.Transform,
      Components.Visible,
      Render
    ],
    initialize: function Container2(scene, x, y, children) {
      GameObject.call(this, scene, "Container");
      this.list = [];
      this.exclusive = true;
      this.maxSize = -1;
      this.position = 0;
      this.localTransform = new Components.TransformMatrix();
      this.tempTransformMatrix = new Components.TransformMatrix();
      this._sortKey = "";
      this._sysEvents = scene.sys.events;
      this.scrollFactorX = 1;
      this.scrollFactorY = 1;
      this.initPipeline();
      this.setPosition(x, y);
      this.clearAlpha();
      this.setBlendMode(BlendModes.SKIP_CHECK);
      if (children) {
        this.add(children);
      }
    },
    originX: {
      get: function() {
        return 0.5;
      }
    },
    originY: {
      get: function() {
        return 0.5;
      }
    },
    displayOriginX: {
      get: function() {
        return this.width * 0.5;
      }
    },
    displayOriginY: {
      get: function() {
        return this.height * 0.5;
      }
    },
    setExclusive: function(value) {
      if (value === void 0) {
        value = true;
      }
      this.exclusive = value;
      return this;
    },
    getBounds: function(output) {
      if (output === void 0) {
        output = new Rectangle();
      }
      output.setTo(this.x, this.y, 0, 0);
      if (this.parentContainer) {
        var parentMatrix = this.parentContainer.getBoundsTransformMatrix();
        var transformedPosition = parentMatrix.transformPoint(this.x, this.y);
        output.setTo(transformedPosition.x, transformedPosition.y, 0, 0);
      }
      if (this.list.length > 0) {
        var children = this.list;
        var tempRect = new Rectangle();
        var hasSetFirst = false;
        output.setEmpty();
        for (var i = 0; i < children.length; i++) {
          var entry = children[i];
          if (entry.getBounds) {
            entry.getBounds(tempRect);
            if (!hasSetFirst) {
              output.setTo(tempRect.x, tempRect.y, tempRect.width, tempRect.height);
              hasSetFirst = true;
            } else {
              Union(tempRect, output, output);
            }
          }
        }
      }
      return output;
    },
    addHandler: function(gameObject) {
      gameObject.once(Events.DESTROY, this.remove, this);
      if (this.exclusive) {
        if (gameObject.parentContainer) {
          gameObject.parentContainer.remove(gameObject);
        }
        gameObject.removeFromDisplayList();
        gameObject.parentContainer = this;
      }
    },
    removeHandler: function(gameObject) {
      gameObject.off(Events.DESTROY, this.remove);
      if (this.exclusive) {
        gameObject.parentContainer = null;
        gameObject.addToDisplayList();
      }
    },
    pointToContainer: function(source, output) {
      if (output === void 0) {
        output = new Vector2();
      }
      if (this.parentContainer) {
        this.parentContainer.pointToContainer(source, output);
      } else {
        output = new Vector2(source.x, source.y);
      }
      var tempMatrix = this.tempTransformMatrix;
      tempMatrix.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY);
      tempMatrix.invert();
      tempMatrix.transformPoint(source.x, source.y, output);
      return output;
    },
    getBoundsTransformMatrix: function() {
      return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform);
    },
    add: function(child) {
      ArrayUtils.Add(this.list, child, this.maxSize, this.addHandler, this);
      return this;
    },
    addAt: function(child, index) {
      ArrayUtils.AddAt(this.list, child, index, this.maxSize, this.addHandler, this);
      return this;
    },
    getAt: function(index) {
      return this.list[index];
    },
    getIndex: function(child) {
      return this.list.indexOf(child);
    },
    sort: function(property, handler) {
      if (!property) {
        return this;
      }
      if (handler === void 0) {
        handler = function(childA, childB) {
          return childA[property] - childB[property];
        };
      }
      ArrayUtils.StableSort(this.list, handler);
      return this;
    },
    getByName: function(name) {
      return ArrayUtils.GetFirst(this.list, "name", name);
    },
    getRandom: function(startIndex, length) {
      return ArrayUtils.GetRandom(this.list, startIndex, length);
    },
    getFirst: function(property, value, startIndex, endIndex) {
      return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);
    },
    getAll: function(property, value, startIndex, endIndex) {
      return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
    },
    count: function(property, value, startIndex, endIndex) {
      return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);
    },
    swap: function(child1, child2) {
      ArrayUtils.Swap(this.list, child1, child2);
      return this;
    },
    moveTo: function(child, index) {
      ArrayUtils.MoveTo(this.list, child, index);
      return this;
    },
    moveAbove: function(child1, child2) {
      ArrayUtils.MoveAbove(this.list, child1, child2);
      return this;
    },
    moveBelow: function(child1, child2) {
      ArrayUtils.MoveBelow(this.list, child1, child2);
      return this;
    },
    remove: function(child, destroyChild) {
      var removed = ArrayUtils.Remove(this.list, child, this.removeHandler, this);
      if (destroyChild && removed) {
        if (!Array.isArray(removed)) {
          removed = [removed];
        }
        for (var i = 0; i < removed.length; i++) {
          removed[i].destroy();
        }
      }
      return this;
    },
    removeAt: function(index, destroyChild) {
      var removed = ArrayUtils.RemoveAt(this.list, index, this.removeHandler, this);
      if (destroyChild && removed) {
        removed.destroy();
      }
      return this;
    },
    removeBetween: function(startIndex, endIndex, destroyChild) {
      var removed = ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeHandler, this);
      if (destroyChild) {
        for (var i = 0; i < removed.length; i++) {
          removed[i].destroy();
        }
      }
      return this;
    },
    removeAll: function(destroyChild) {
      var removed = ArrayUtils.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this);
      if (destroyChild) {
        for (var i = 0; i < removed.length; i++) {
          removed[i].destroy();
        }
      }
      return this;
    },
    bringToTop: function(child) {
      ArrayUtils.BringToTop(this.list, child);
      return this;
    },
    sendToBack: function(child) {
      ArrayUtils.SendToBack(this.list, child);
      return this;
    },
    moveUp: function(child) {
      ArrayUtils.MoveUp(this.list, child);
      return this;
    },
    moveDown: function(child) {
      ArrayUtils.MoveDown(this.list, child);
      return this;
    },
    reverse: function() {
      this.list.reverse();
      return this;
    },
    shuffle: function() {
      ArrayUtils.Shuffle(this.list);
      return this;
    },
    replace: function(oldChild, newChild, destroyChild) {
      var moved = ArrayUtils.Replace(this.list, oldChild, newChild);
      if (moved) {
        this.addHandler(newChild);
        this.removeHandler(oldChild);
        if (destroyChild) {
          oldChild.destroy();
        }
      }
      return this;
    },
    exists: function(child) {
      return this.list.indexOf(child) > -1;
    },
    setAll: function(property, value, startIndex, endIndex) {
      ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
      return this;
    },
    each: function(callback, context) {
      var args = [null];
      var i;
      var temp = this.list.slice();
      var len = temp.length;
      for (i = 2; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      for (i = 0; i < len; i++) {
        args[0] = temp[i];
        callback.apply(context, args);
      }
      return this;
    },
    iterate: function(callback, context) {
      var args = [null];
      var i;
      for (i = 2; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      for (i = 0; i < this.list.length; i++) {
        args[0] = this.list[i];
        callback.apply(context, args);
      }
      return this;
    },
    setScrollFactor: function(x, y, updateChildren) {
      if (y === void 0) {
        y = x;
      }
      if (updateChildren === void 0) {
        updateChildren = false;
      }
      this.scrollFactorX = x;
      this.scrollFactorY = y;
      if (updateChildren) {
        ArrayUtils.SetAll(this.list, "scrollFactorX", x);
        ArrayUtils.SetAll(this.list, "scrollFactorY", y);
      }
      return this;
    },
    length: {
      get: function() {
        return this.list.length;
      }
    },
    first: {
      get: function() {
        this.position = 0;
        if (this.list.length > 0) {
          return this.list[0];
        } else {
          return null;
        }
      }
    },
    last: {
      get: function() {
        if (this.list.length > 0) {
          this.position = this.list.length - 1;
          return this.list[this.position];
        } else {
          return null;
        }
      }
    },
    next: {
      get: function() {
        if (this.position < this.list.length) {
          this.position++;
          return this.list[this.position];
        } else {
          return null;
        }
      }
    },
    previous: {
      get: function() {
        if (this.position > 0) {
          this.position--;
          return this.list[this.position];
        } else {
          return null;
        }
      }
    },
    preDestroy: function() {
      this.removeAll(!!this.exclusive);
      this.localTransform.destroy();
      this.tempTransformMatrix.destroy();
      this.list = [];
    }
  });
  module2.exports = Container;
});

// node_modules/phaser/src/gameobjects/domelement/CSSBlendModes.js
var require_CSSBlendModes = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = [
    "normal",
    "multiply",
    "multiply",
    "screen",
    "overlay",
    "darken",
    "lighten",
    "color-dodge",
    "color-burn",
    "hard-light",
    "soft-light",
    "difference",
    "exclusion",
    "hue",
    "saturation",
    "color",
    "luminosity"
  ];
});

// node_modules/phaser/src/gameobjects/domelement/DOMElementCSSRenderer.js
var require_DOMElementCSSRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CSSBlendModes = require_CSSBlendModes();
  var GameObject = require_GameObject();
  var TransformMatrix = require_TransformMatrix();
  var tempMatrix1 = new TransformMatrix();
  var tempMatrix2 = new TransformMatrix();
  var tempMatrix3 = new TransformMatrix();
  var DOMElementCSSRenderer = function(renderer, src, camera, parentMatrix) {
    if (!src.node) {
      return;
    }
    var style = src.node.style;
    var settings = src.scene.sys.settings;
    if (!style || !settings.visible || GameObject.RENDER_MASK !== src.renderFlags || src.cameraFilter !== 0 && src.cameraFilter & camera.id || src.parentContainer && !src.parentContainer.willRender()) {
      style.display = "none";
      return;
    }
    var parent = src.parentContainer;
    var alpha = camera.alpha * src.alpha;
    if (parent) {
      alpha *= parent.alpha;
    }
    var camMatrix = tempMatrix1;
    var srcMatrix = tempMatrix2;
    var calcMatrix = tempMatrix3;
    var dx = 0;
    var dy = 0;
    var tx = "0%";
    var ty = "0%";
    if (parentMatrix) {
      dx = src.width * src.scaleX * src.originX;
      dy = src.height * src.scaleY * src.originY;
      srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);
      camMatrix.copyFrom(camera.matrix);
      camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
      srcMatrix.e = src.x - dx;
      srcMatrix.f = src.y - dy;
      camMatrix.multiply(srcMatrix, calcMatrix);
    } else {
      dx = src.width * src.originX;
      dy = src.height * src.originY;
      srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);
      camMatrix.copyFrom(camera.matrix);
      tx = 100 * src.originX + "%";
      ty = 100 * src.originY + "%";
      srcMatrix.e -= camera.scrollX * src.scrollFactorX;
      srcMatrix.f -= camera.scrollY * src.scrollFactorY;
      camMatrix.multiply(srcMatrix, calcMatrix);
    }
    if (!src.transformOnly) {
      style.display = "block";
      style.opacity = alpha;
      style.zIndex = src._depth;
      style.pointerEvents = src.pointerEvents;
      style.mixBlendMode = CSSBlendModes[src._blendMode];
    }
    style.transform = calcMatrix.getCSSMatrix() + " skew(" + src.skewX + "rad, " + src.skewY + "rad) rotate3d(" + src.rotate3d.x + "," + src.rotate3d.y + "," + src.rotate3d.z + "," + src.rotate3d.w + src.rotate3dAngle + ")";
    style.transformOrigin = tx + " " + ty;
  };
  module2.exports = DOMElementCSSRenderer;
});

// node_modules/phaser/src/gameobjects/domelement/DOMElementRender.js
var require_DOMElementRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_DOMElementCSSRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_DOMElementCSSRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/domelement/DOMElement.js
var require_DOMElement = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components();
  var DOMElementRender = require_DOMElementRender();
  var GameObject = require_GameObject();
  var IsPlainObject = require_IsPlainObject();
  var RemoveFromDOM = require_RemoveFromDOM();
  var SCENE_EVENTS = require_events5();
  var Vector4 = require_Vector4();
  var DOMElement = new Class({
    Extends: GameObject,
    Mixins: [
      Components.AlphaSingle,
      Components.BlendMode,
      Components.Depth,
      Components.Origin,
      Components.ScrollFactor,
      Components.Transform,
      Components.Visible,
      DOMElementRender
    ],
    initialize: function DOMElement2(scene, x, y, element, style, innerText) {
      GameObject.call(this, scene, "DOMElement");
      this.parent = scene.sys.game.domContainer;
      this.cache = scene.sys.cache.html;
      this.node;
      this.transformOnly = false;
      this.skewX = 0;
      this.skewY = 0;
      this.rotate3d = new Vector4();
      this.rotate3dAngle = "deg";
      this.pointerEvents = "auto";
      this.width = 0;
      this.height = 0;
      this.displayWidth = 0;
      this.displayHeight = 0;
      this.handler = this.dispatchNativeEvent.bind(this);
      this.setPosition(x, y);
      if (typeof element === "string") {
        if (element[0] === "#") {
          this.setElement(element.substr(1), style, innerText);
        } else {
          this.createElement(element, style, innerText);
        }
      } else if (element) {
        this.setElement(element, style, innerText);
      }
      scene.sys.events.on(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);
      scene.sys.events.on(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
    },
    addedToScene: function() {
      this.scene.sys.updateList.add(this);
    },
    removedFromScene: function() {
      this.scene.sys.updateList.remove(this);
    },
    handleSceneEvent: function(sys) {
      var node = this.node;
      var style = node.style;
      if (node) {
        style.display = sys.settings.visible ? "block" : "none";
      }
    },
    setSkew: function(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = x;
      }
      this.skewX = x;
      this.skewY = y;
      return this;
    },
    setPerspective: function(value) {
      this.parent.style.perspective = value + "px";
      return this;
    },
    perspective: {
      get: function() {
        return parseFloat(this.parent.style.perspective);
      },
      set: function(value) {
        this.parent.style.perspective = value + "px";
      }
    },
    addListener: function(events) {
      if (this.node) {
        events = events.split(" ");
        for (var i = 0; i < events.length; i++) {
          this.node.addEventListener(events[i], this.handler, false);
        }
      }
      return this;
    },
    removeListener: function(events) {
      if (this.node) {
        events = events.split(" ");
        for (var i = 0; i < events.length; i++) {
          this.node.removeEventListener(events[i], this.handler);
        }
      }
      return this;
    },
    dispatchNativeEvent: function(event) {
      this.emit(event.type, event);
    },
    createElement: function(tagName, style, innerText) {
      return this.setElement(document.createElement(tagName), style, innerText);
    },
    setElement: function(element, style, innerText) {
      this.removeElement();
      var target;
      if (typeof element === "string") {
        if (element[0] === "#") {
          element = element.substr(1);
        }
        target = document.getElementById(element);
      } else if (typeof element === "object" && element.nodeType === 1) {
        target = element;
      }
      if (!target) {
        return this;
      }
      this.node = target;
      if (style && IsPlainObject(style)) {
        for (var key in style) {
          target.style[key] = style[key];
        }
      } else if (typeof style === "string") {
        target.style = style;
      }
      target.style.zIndex = "0";
      target.style.display = "inline";
      target.style.position = "absolute";
      target.phaser = this;
      if (this.parent) {
        this.parent.appendChild(target);
      }
      if (innerText) {
        target.innerText = innerText;
      }
      return this.updateSize();
    },
    createFromCache: function(key, tagName) {
      var html = this.cache.get(key);
      if (html) {
        this.createFromHTML(html, tagName);
      }
      return this;
    },
    createFromHTML: function(html, tagName) {
      if (tagName === void 0) {
        tagName = "div";
      }
      this.removeElement();
      var element = document.createElement(tagName);
      this.node = element;
      element.style.zIndex = "0";
      element.style.display = "inline";
      element.style.position = "absolute";
      element.phaser = this;
      if (this.parent) {
        this.parent.appendChild(element);
      }
      element.innerHTML = html;
      return this.updateSize();
    },
    removeElement: function() {
      if (this.node) {
        RemoveFromDOM(this.node);
        this.node = null;
      }
      return this;
    },
    updateSize: function() {
      var node = this.node;
      var nodeBounds = node.getBoundingClientRect();
      this.width = node.clientWidth;
      this.height = node.clientHeight;
      this.displayWidth = nodeBounds.width || 0;
      this.displayHeight = nodeBounds.height || 0;
      return this;
    },
    getChildByProperty: function(property, value) {
      if (this.node) {
        var children = this.node.querySelectorAll("*");
        for (var i = 0; i < children.length; i++) {
          if (children[i][property] === value) {
            return children[i];
          }
        }
      }
      return null;
    },
    getChildByID: function(id) {
      return this.getChildByProperty("id", id);
    },
    getChildByName: function(name) {
      return this.getChildByProperty("name", name);
    },
    setClassName: function(className) {
      if (this.node) {
        this.node.className = className;
        this.updateSize();
      }
      return this;
    },
    setText: function(text) {
      if (this.node) {
        this.node.innerText = text;
        this.updateSize();
      }
      return this;
    },
    setHTML: function(html) {
      if (this.node) {
        this.node.innerHTML = html;
        this.updateSize();
      }
      return this;
    },
    preUpdate: function() {
      var parent = this.parentContainer;
      var node = this.node;
      if (node && parent && !parent.willRender()) {
        node.style.display = "none";
      }
    },
    willRender: function() {
      return true;
    },
    preDestroy: function() {
      this.removeElement();
      this.scene.sys.events.off(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);
      this.scene.sys.events.off(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);
    }
  });
  module2.exports = DOMElement;
});

// node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextWebGLRenderer.js
var require_DynamicBitmapTextWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var TransformMatrix = require_TransformMatrix();
  var Utils = require_Utils();
  var tempMatrix = new TransformMatrix();
  var DynamicBitmapTextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    var text = src.text;
    var textLength = text.length;
    if (textLength === 0) {
      return;
    }
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    var spriteMatrix = result.sprite;
    var calcMatrix = result.calc;
    var fontMatrix = tempMatrix;
    var crop = src.cropWidth > 0 || src.cropHeight > 0;
    if (crop) {
      pipeline.flush();
      renderer.pushScissor(calcMatrix.tx, calcMatrix.ty, src.cropWidth * calcMatrix.scaleX, src.cropHeight * calcMatrix.scaleY);
    }
    var frame = src.frame;
    var texture = frame.glTexture;
    var tintEffect = src.tintFill;
    var tintTL = Utils.getTintAppendFloatAlpha(src.tintTopLeft, camera.alpha * src._alphaTL);
    var tintTR = Utils.getTintAppendFloatAlpha(src.tintTopRight, camera.alpha * src._alphaTR);
    var tintBL = Utils.getTintAppendFloatAlpha(src.tintBottomLeft, camera.alpha * src._alphaBL);
    var tintBR = Utils.getTintAppendFloatAlpha(src.tintBottomRight, camera.alpha * src._alphaBR);
    var textureUnit = pipeline.setGameObject(src);
    var xAdvance = 0;
    var yAdvance = 0;
    var charCode = 0;
    var lastCharCode = 0;
    var letterSpacing = src.letterSpacing;
    var glyph;
    var glyphW = 0;
    var glyphH = 0;
    var lastGlyph;
    var scrollX = src.scrollX;
    var scrollY = src.scrollY;
    var fontData = src.fontData;
    var chars = fontData.chars;
    var lineHeight = fontData.lineHeight;
    var scale = src.fontSize / fontData.size;
    var rotation = 0;
    var align = src._align;
    var currentLine = 0;
    var lineOffsetX = 0;
    var bounds = src.getTextBounds(false);
    if (src.maxWidth > 0) {
      text = bounds.wrappedText;
      textLength = text.length;
    }
    var lineData = src._bounds.lines;
    if (align === 1) {
      lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
    } else if (align === 2) {
      lineOffsetX = lineData.longest - lineData.lengths[0];
    }
    var roundPixels = camera.roundPixels;
    var displayCallback = src.displayCallback;
    var callbackData = src.callbackData;
    renderer.pipelines.preBatch(src);
    for (var i = 0; i < textLength; i++) {
      charCode = text.charCodeAt(i);
      if (charCode === 10) {
        currentLine++;
        if (align === 1) {
          lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
        } else if (align === 2) {
          lineOffsetX = lineData.longest - lineData.lengths[currentLine];
        }
        xAdvance = 0;
        yAdvance += lineHeight;
        lastGlyph = null;
        continue;
      }
      glyph = chars[charCode];
      if (!glyph) {
        continue;
      }
      glyphW = glyph.width;
      glyphH = glyph.height;
      var x = glyph.xOffset + xAdvance - scrollX;
      var y = glyph.yOffset + yAdvance - scrollY;
      if (lastGlyph !== null) {
        var kerningOffset = glyph.kerning[lastCharCode];
        x += kerningOffset !== void 0 ? kerningOffset : 0;
      }
      xAdvance += glyph.xAdvance + letterSpacing;
      lastGlyph = glyph;
      lastCharCode = charCode;
      if (glyphW === 0 || glyphH === 0 || charCode === 32) {
        continue;
      }
      scale = src.fontSize / src.fontData.size;
      rotation = 0;
      if (displayCallback) {
        callbackData.color = 0;
        callbackData.tint.topLeft = tintTL;
        callbackData.tint.topRight = tintTR;
        callbackData.tint.bottomLeft = tintBL;
        callbackData.tint.bottomRight = tintBR;
        callbackData.index = i;
        callbackData.charCode = charCode;
        callbackData.x = x;
        callbackData.y = y;
        callbackData.scale = scale;
        callbackData.rotation = rotation;
        callbackData.data = glyph.data;
        var output = displayCallback(callbackData);
        x = output.x;
        y = output.y;
        scale = output.scale;
        rotation = output.rotation;
        if (output.color) {
          tintTL = output.color;
          tintTR = output.color;
          tintBL = output.color;
          tintBR = output.color;
        } else {
          tintTL = output.tint.topLeft;
          tintTR = output.tint.topRight;
          tintBL = output.tint.bottomLeft;
          tintBR = output.tint.bottomRight;
        }
        tintTL = Utils.getTintAppendFloatAlpha(tintTL, camera.alpha * src._alphaTL);
        tintTR = Utils.getTintAppendFloatAlpha(tintTR, camera.alpha * src._alphaTR);
        tintBL = Utils.getTintAppendFloatAlpha(tintBL, camera.alpha * src._alphaBL);
        tintBR = Utils.getTintAppendFloatAlpha(tintBR, camera.alpha * src._alphaBR);
      }
      x *= scale;
      y *= scale;
      x -= src.displayOriginX;
      y -= src.displayOriginY;
      x += lineOffsetX;
      fontMatrix.applyITRS(x, y, rotation, scale, scale);
      calcMatrix.multiply(fontMatrix, spriteMatrix);
      var u0 = glyph.u0;
      var v0 = glyph.v0;
      var u1 = glyph.u1;
      var v1 = glyph.v1;
      var xw = glyphW;
      var yh = glyphH;
      var tx0 = spriteMatrix.e;
      var ty0 = spriteMatrix.f;
      var tx1 = yh * spriteMatrix.c + spriteMatrix.e;
      var ty1 = yh * spriteMatrix.d + spriteMatrix.f;
      var tx2 = xw * spriteMatrix.a + yh * spriteMatrix.c + spriteMatrix.e;
      var ty2 = xw * spriteMatrix.b + yh * spriteMatrix.d + spriteMatrix.f;
      var tx3 = xw * spriteMatrix.a + spriteMatrix.e;
      var ty3 = xw * spriteMatrix.b + spriteMatrix.f;
      if (roundPixels) {
        tx0 = Math.round(tx0);
        ty0 = Math.round(ty0);
        tx1 = Math.round(tx1);
        ty1 = Math.round(ty1);
        tx2 = Math.round(tx2);
        ty2 = Math.round(ty2);
        tx3 = Math.round(tx3);
        ty3 = Math.round(ty3);
      }
      pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);
    }
    if (crop) {
      pipeline.flush();
      renderer.popScissor();
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = DynamicBitmapTextWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextCanvasRenderer.js
var require_DynamicBitmapTextCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetTransform = require_SetTransform();
  var DynamicBitmapTextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    var text = src._text;
    var textLength = text.length;
    var ctx = renderer.currentContext;
    if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      return;
    }
    camera.addToRenderList(src);
    var textureFrame = src.fromAtlas ? src.frame : src.texture.frames["__BASE"];
    var displayCallback = src.displayCallback;
    var callbackData = src.callbackData;
    var chars = src.fontData.chars;
    var lineHeight = src.fontData.lineHeight;
    var letterSpacing = src._letterSpacing;
    var xAdvance = 0;
    var yAdvance = 0;
    var charCode = 0;
    var glyph = null;
    var glyphX = 0;
    var glyphY = 0;
    var glyphW = 0;
    var glyphH = 0;
    var x = 0;
    var y = 0;
    var lastGlyph = null;
    var lastCharCode = 0;
    var image = src.frame.source.image;
    var textureX = textureFrame.cutX;
    var textureY = textureFrame.cutY;
    var rotation = 0;
    var scale = 0;
    var baseScale = src._fontSize / src.fontData.size;
    var align = src._align;
    var currentLine = 0;
    var lineOffsetX = 0;
    src.getTextBounds(false);
    var lineData = src._bounds.lines;
    if (align === 1) {
      lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;
    } else if (align === 2) {
      lineOffsetX = lineData.longest - lineData.lengths[0];
    }
    ctx.translate(-src.displayOriginX, -src.displayOriginY);
    var roundPixels = camera.roundPixels;
    if (src.cropWidth > 0 && src.cropHeight > 0) {
      ctx.beginPath();
      ctx.rect(0, 0, src.cropWidth, src.cropHeight);
      ctx.clip();
    }
    for (var i = 0; i < textLength; i++) {
      scale = baseScale;
      rotation = 0;
      charCode = text.charCodeAt(i);
      if (charCode === 10) {
        currentLine++;
        if (align === 1) {
          lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;
        } else if (align === 2) {
          lineOffsetX = lineData.longest - lineData.lengths[currentLine];
        }
        xAdvance = 0;
        yAdvance += lineHeight;
        lastGlyph = null;
        continue;
      }
      glyph = chars[charCode];
      if (!glyph) {
        continue;
      }
      glyphX = textureX + glyph.x;
      glyphY = textureY + glyph.y;
      glyphW = glyph.width;
      glyphH = glyph.height;
      x = glyph.xOffset + xAdvance - src.scrollX;
      y = glyph.yOffset + yAdvance - src.scrollY;
      if (lastGlyph !== null) {
        var kerningOffset = glyph.kerning[lastCharCode];
        x += kerningOffset !== void 0 ? kerningOffset : 0;
      }
      if (displayCallback) {
        callbackData.index = i;
        callbackData.charCode = charCode;
        callbackData.x = x;
        callbackData.y = y;
        callbackData.scale = scale;
        callbackData.rotation = rotation;
        callbackData.data = glyph.data;
        var output = displayCallback(callbackData);
        x = output.x;
        y = output.y;
        scale = output.scale;
        rotation = output.rotation;
      }
      x *= scale;
      y *= scale;
      x += lineOffsetX;
      xAdvance += glyph.xAdvance + letterSpacing;
      lastGlyph = glyph;
      lastCharCode = charCode;
      if (glyphW === 0 || glyphH === 0 || charCode === 32) {
        continue;
      }
      if (roundPixels) {
        x = Math.round(x);
        y = Math.round(y);
      }
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation);
      ctx.scale(scale, scale);
      ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);
      ctx.restore();
    }
    ctx.restore();
  };
  module2.exports = DynamicBitmapTextCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextRender.js
var require_DynamicBitmapTextRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_DynamicBitmapTextWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_DynamicBitmapTextCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapText.js
var require_DynamicBitmapText = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BitmapText = require_BitmapText();
  var Class = require_Class();
  var Render = require_DynamicBitmapTextRender();
  var DynamicBitmapText = new Class({
    Extends: BitmapText,
    Mixins: [
      Render
    ],
    initialize: function DynamicBitmapText2(scene, x, y, font, text, size, align) {
      BitmapText.call(this, scene, x, y, font, text, size, align);
      this.type = "DynamicBitmapText";
      this.scrollX = 0;
      this.scrollY = 0;
      this.cropWidth = 0;
      this.cropHeight = 0;
      this.displayCallback;
      this.callbackData = {
        parent: this,
        color: 0,
        tint: {
          topLeft: 0,
          topRight: 0,
          bottomLeft: 0,
          bottomRight: 0
        },
        index: 0,
        charCode: 0,
        x: 0,
        y: 0,
        scale: 0,
        rotation: 0,
        data: 0
      };
    },
    setSize: function(width, height) {
      this.cropWidth = width;
      this.cropHeight = height;
      return this;
    },
    setDisplayCallback: function(callback) {
      this.displayCallback = callback;
      return this;
    },
    setScrollX: function(value) {
      this.scrollX = value;
      return this;
    },
    setScrollY: function(value) {
      this.scrollY = value;
      return this;
    }
  });
  module2.exports = DynamicBitmapText;
});

// node_modules/phaser/src/gameobjects/extern/ExternWebGLRenderer.js
var require_ExternWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var ExternWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    renderer.pipelines.clear();
    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
    src.render.call(src, renderer, camera, calcMatrix);
    renderer.pipelines.rebind();
  };
  module2.exports = ExternWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/extern/ExternCanvasRenderer.js
var require_ExternCanvasRenderer = __commonJS(() => {
});

// node_modules/phaser/src/gameobjects/extern/ExternRender.js
var require_ExternRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_ExternWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_ExternCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/extern/Extern.js
var require_Extern = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components();
  var GameObject = require_GameObject();
  var ExternRender = require_ExternRender();
  var Extern = new Class({
    Extends: GameObject,
    Mixins: [
      Components.Alpha,
      Components.BlendMode,
      Components.Depth,
      Components.Flip,
      Components.Origin,
      Components.ScrollFactor,
      Components.Size,
      Components.Texture,
      Components.Tint,
      Components.Transform,
      Components.Visible,
      ExternRender
    ],
    initialize: function Extern2(scene) {
      GameObject.call(this, scene, "Extern");
    },
    addedToScene: function() {
      this.scene.sys.updateList.add(this);
    },
    removedFromScene: function() {
      this.scene.sys.updateList.remove(this);
    },
    preUpdate: function() {
    },
    render: function() {
    }
  });
  module2.exports = Extern;
});

// node_modules/phaser/src/gameobjects/graphics/Commands.js
var require_Commands = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ARC: 0,
    BEGIN_PATH: 1,
    CLOSE_PATH: 2,
    FILL_RECT: 3,
    LINE_TO: 4,
    MOVE_TO: 5,
    LINE_STYLE: 6,
    FILL_STYLE: 7,
    FILL_PATH: 8,
    STROKE_PATH: 9,
    FILL_TRIANGLE: 10,
    STROKE_TRIANGLE: 11,
    SAVE: 14,
    RESTORE: 15,
    TRANSLATE: 16,
    SCALE: 17,
    ROTATE: 18,
    GRADIENT_FILL_STYLE: 21,
    GRADIENT_LINE_STYLE: 22
  };
});

// node_modules/phaser/src/geom/ellipse/Contains.js
var require_Contains3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = function(ellipse, x, y) {
    if (ellipse.width <= 0 || ellipse.height <= 0) {
      return false;
    }
    var normx = (x - ellipse.x) / ellipse.width;
    var normy = (y - ellipse.y) / ellipse.height;
    normx *= normx;
    normy *= normy;
    return normx + normy < 0.25;
  };
  module2.exports = Contains;
});

// node_modules/phaser/src/geom/ellipse/CircumferencePoint.js
var require_CircumferencePoint2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var CircumferencePoint = function(ellipse, angle, out) {
    if (out === void 0) {
      out = new Point();
    }
    var halfWidth = ellipse.width / 2;
    var halfHeight = ellipse.height / 2;
    out.x = ellipse.x + halfWidth * Math.cos(angle);
    out.y = ellipse.y + halfHeight * Math.sin(angle);
    return out;
  };
  module2.exports = CircumferencePoint;
});

// node_modules/phaser/src/geom/ellipse/GetPoint.js
var require_GetPoint4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CircumferencePoint = require_CircumferencePoint2();
  var FromPercent = require_FromPercent();
  var MATH_CONST = require_const4();
  var Point = require_Point();
  var GetPoint = function(ellipse, position, out) {
    if (out === void 0) {
      out = new Point();
    }
    var angle = FromPercent(position, 0, MATH_CONST.PI2);
    return CircumferencePoint(ellipse, angle, out);
  };
  module2.exports = GetPoint;
});

// node_modules/phaser/src/geom/ellipse/Circumference.js
var require_Circumference2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Circumference = function(ellipse) {
    var rx = ellipse.width / 2;
    var ry = ellipse.height / 2;
    var h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
    return Math.PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));
  };
  module2.exports = Circumference;
});

// node_modules/phaser/src/geom/ellipse/GetPoints.js
var require_GetPoints4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Circumference = require_Circumference2();
  var CircumferencePoint = require_CircumferencePoint2();
  var FromPercent = require_FromPercent();
  var MATH_CONST = require_const4();
  var GetPoints = function(ellipse, quantity, stepRate, out) {
    if (out === void 0) {
      out = [];
    }
    if (!quantity && stepRate > 0) {
      quantity = Circumference(ellipse) / stepRate;
    }
    for (var i = 0; i < quantity; i++) {
      var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);
      out.push(CircumferencePoint(ellipse, angle));
    }
    return out;
  };
  module2.exports = GetPoints;
});

// node_modules/phaser/src/geom/ellipse/Ellipse.js
var require_Ellipse = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Contains = require_Contains3();
  var GetPoint = require_GetPoint4();
  var GetPoints = require_GetPoints4();
  var GEOM_CONST = require_const3();
  var Random = require_Random4();
  var Ellipse = new Class({
    initialize: function Ellipse2(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.type = GEOM_CONST.ELLIPSE;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    },
    contains: function(x, y) {
      return Contains(this, x, y);
    },
    getPoint: function(position, point) {
      return GetPoint(this, position, point);
    },
    getPoints: function(quantity, stepRate, output) {
      return GetPoints(this, quantity, stepRate, output);
    },
    getRandomPoint: function(point) {
      return Random(this, point);
    },
    setTo: function(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      return this;
    },
    setEmpty: function() {
      this.width = 0;
      this.height = 0;
      return this;
    },
    setPosition: function(x, y) {
      if (y === void 0) {
        y = x;
      }
      this.x = x;
      this.y = y;
      return this;
    },
    setSize: function(width, height) {
      if (height === void 0) {
        height = width;
      }
      this.width = width;
      this.height = height;
      return this;
    },
    isEmpty: function() {
      return this.width <= 0 || this.height <= 0;
    },
    getMinorRadius: function() {
      return Math.min(this.width, this.height) / 2;
    },
    getMajorRadius: function() {
      return Math.max(this.width, this.height) / 2;
    },
    left: {
      get: function() {
        return this.x - this.width / 2;
      },
      set: function(value) {
        this.x = value + this.width / 2;
      }
    },
    right: {
      get: function() {
        return this.x + this.width / 2;
      },
      set: function(value) {
        this.x = value - this.width / 2;
      }
    },
    top: {
      get: function() {
        return this.y - this.height / 2;
      },
      set: function(value) {
        this.y = value + this.height / 2;
      }
    },
    bottom: {
      get: function() {
        return this.y + this.height / 2;
      },
      set: function(value) {
        this.y = value - this.height / 2;
      }
    }
  });
  module2.exports = Ellipse;
});

// node_modules/phaser/src/gameobjects/graphics/GraphicsWebGLRenderer.js
var require_GraphicsWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Commands = require_Commands();
  var GetCalcMatrix = require_GetCalcMatrix();
  var TransformMatrix = require_TransformMatrix();
  var Utils = require_Utils();
  var Point = function(x, y, width) {
    this.x = x;
    this.y = y;
    this.width = width;
  };
  var Path = function(x, y, width) {
    this.points = [];
    this.pointsLength = 1;
    this.points[0] = new Point(x, y, width);
  };
  var matrixStack = [];
  var tempMatrix = new TransformMatrix();
  var GraphicsWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    if (src.commandBuffer.length === 0) {
      return;
    }
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    renderer.pipelines.preBatch(src);
    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
    var currentMatrix = tempMatrix.loadIdentity();
    var commands = src.commandBuffer;
    var alpha = camera.alpha * src.alpha;
    var lineWidth = 1;
    var fillTint = pipeline.fillTint;
    var strokeTint = pipeline.strokeTint;
    var tx = 0;
    var ty = 0;
    var ta = 0;
    var iterStep = 0.01;
    var PI2 = Math.PI * 2;
    var cmd;
    var path = [];
    var pathIndex = 0;
    var pathOpen = true;
    var lastPath = null;
    var getTint = Utils.getTintAppendFloatAlpha;
    for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++) {
      cmd = commands[cmdIndex];
      switch (cmd) {
        case Commands.BEGIN_PATH: {
          path.length = 0;
          lastPath = null;
          pathOpen = true;
          break;
        }
        case Commands.CLOSE_PATH: {
          pathOpen = false;
          if (lastPath && lastPath.points.length) {
            lastPath.points.push(lastPath.points[0]);
          }
          break;
        }
        case Commands.FILL_PATH: {
          for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
            pipeline.batchFillPath(path[pathIndex].points, currentMatrix, calcMatrix);
          }
          break;
        }
        case Commands.STROKE_PATH: {
          for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
            pipeline.batchStrokePath(path[pathIndex].points, lineWidth, pathOpen, currentMatrix, calcMatrix);
          }
          break;
        }
        case Commands.LINE_STYLE: {
          lineWidth = commands[++cmdIndex];
          var strokeColor = commands[++cmdIndex];
          var strokeAlpha = commands[++cmdIndex] * alpha;
          var strokeTintColor = getTint(strokeColor, strokeAlpha);
          strokeTint.TL = strokeTintColor;
          strokeTint.TR = strokeTintColor;
          strokeTint.BL = strokeTintColor;
          strokeTint.BR = strokeTintColor;
          break;
        }
        case Commands.FILL_STYLE: {
          var fillColor = commands[++cmdIndex];
          var fillAlpha = commands[++cmdIndex] * alpha;
          var fillTintColor = getTint(fillColor, fillAlpha);
          fillTint.TL = fillTintColor;
          fillTint.TR = fillTintColor;
          fillTint.BL = fillTintColor;
          fillTint.BR = fillTintColor;
          break;
        }
        case Commands.GRADIENT_FILL_STYLE: {
          var alphaTL = commands[++cmdIndex] * alpha;
          var alphaTR = commands[++cmdIndex] * alpha;
          var alphaBL = commands[++cmdIndex] * alpha;
          var alphaBR = commands[++cmdIndex] * alpha;
          fillTint.TL = getTint(commands[++cmdIndex], alphaTL);
          fillTint.TR = getTint(commands[++cmdIndex], alphaTR);
          fillTint.BL = getTint(commands[++cmdIndex], alphaBL);
          fillTint.BR = getTint(commands[++cmdIndex], alphaBR);
          break;
        }
        case Commands.GRADIENT_LINE_STYLE: {
          lineWidth = commands[++cmdIndex];
          var gradientLineAlpha = commands[++cmdIndex] * alpha;
          strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);
          strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);
          strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);
          strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);
          break;
        }
        case Commands.ARC: {
          var iteration = 0;
          var x = commands[++cmdIndex];
          var y = commands[++cmdIndex];
          var radius = commands[++cmdIndex];
          var startAngle = commands[++cmdIndex];
          var endAngle = commands[++cmdIndex];
          var anticlockwise = commands[++cmdIndex];
          var overshoot = commands[++cmdIndex];
          endAngle -= startAngle;
          if (anticlockwise) {
            if (endAngle < -PI2) {
              endAngle = -PI2;
            } else if (endAngle > 0) {
              endAngle = -PI2 + endAngle % PI2;
            }
          } else if (endAngle > PI2) {
            endAngle = PI2;
          } else if (endAngle < 0) {
            endAngle = PI2 + endAngle % PI2;
          }
          if (lastPath === null) {
            lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth);
            path.push(lastPath);
            iteration += iterStep;
          }
          while (iteration < 1 + overshoot) {
            ta = endAngle * iteration + startAngle;
            tx = x + Math.cos(ta) * radius;
            ty = y + Math.sin(ta) * radius;
            lastPath.points.push(new Point(tx, ty, lineWidth));
            iteration += iterStep;
          }
          ta = endAngle + startAngle;
          tx = x + Math.cos(ta) * radius;
          ty = y + Math.sin(ta) * radius;
          lastPath.points.push(new Point(tx, ty, lineWidth));
          break;
        }
        case Commands.FILL_RECT: {
          pipeline.batchFillRect(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
          break;
        }
        case Commands.FILL_TRIANGLE: {
          pipeline.batchFillTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, calcMatrix);
          break;
        }
        case Commands.STROKE_TRIANGLE: {
          pipeline.batchStrokeTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], lineWidth, currentMatrix, calcMatrix);
          break;
        }
        case Commands.LINE_TO: {
          if (lastPath !== null) {
            lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));
          } else {
            lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
            path.push(lastPath);
          }
          break;
        }
        case Commands.MOVE_TO: {
          lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);
          path.push(lastPath);
          break;
        }
        case Commands.SAVE: {
          matrixStack.push(currentMatrix.copyToArray());
          break;
        }
        case Commands.RESTORE: {
          currentMatrix.copyFromArray(matrixStack.pop());
          break;
        }
        case Commands.TRANSLATE: {
          x = commands[++cmdIndex];
          y = commands[++cmdIndex];
          currentMatrix.translate(x, y);
          break;
        }
        case Commands.SCALE: {
          x = commands[++cmdIndex];
          y = commands[++cmdIndex];
          currentMatrix.scale(x, y);
          break;
        }
        case Commands.ROTATE: {
          currentMatrix.rotate(commands[++cmdIndex]);
          break;
        }
      }
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = GraphicsWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/graphics/GraphicsCanvasRenderer.js
var require_GraphicsCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Commands = require_Commands();
  var SetTransform = require_SetTransform();
  var GraphicsCanvasRenderer = function(renderer, src, camera, parentMatrix, renderTargetCtx, allowClip) {
    var commandBuffer = src.commandBuffer;
    var commandBufferLength = commandBuffer.length;
    var ctx = renderTargetCtx || renderer.currentContext;
    if (commandBufferLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      return;
    }
    camera.addToRenderList(src);
    var lineAlpha = 1;
    var fillAlpha = 1;
    var lineColor = 0;
    var fillColor = 0;
    var lineWidth = 1;
    var red = 0;
    var green = 0;
    var blue = 0;
    ctx.beginPath();
    for (var index = 0; index < commandBufferLength; ++index) {
      var commandID = commandBuffer[index];
      switch (commandID) {
        case Commands.ARC:
          ctx.arc(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4], commandBuffer[index + 5], commandBuffer[index + 6]);
          index += 7;
          break;
        case Commands.LINE_STYLE:
          lineWidth = commandBuffer[index + 1];
          lineColor = commandBuffer[index + 2];
          lineAlpha = commandBuffer[index + 3];
          red = (lineColor & 16711680) >>> 16;
          green = (lineColor & 65280) >>> 8;
          blue = lineColor & 255;
          ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + lineAlpha + ")";
          ctx.lineWidth = lineWidth;
          index += 3;
          break;
        case Commands.FILL_STYLE:
          fillColor = commandBuffer[index + 1];
          fillAlpha = commandBuffer[index + 2];
          red = (fillColor & 16711680) >>> 16;
          green = (fillColor & 65280) >>> 8;
          blue = fillColor & 255;
          ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
          index += 2;
          break;
        case Commands.BEGIN_PATH:
          ctx.beginPath();
          break;
        case Commands.CLOSE_PATH:
          ctx.closePath();
          break;
        case Commands.FILL_PATH:
          if (!allowClip) {
            ctx.fill();
          }
          break;
        case Commands.STROKE_PATH:
          if (!allowClip) {
            ctx.stroke();
          }
          break;
        case Commands.FILL_RECT:
          if (!allowClip) {
            ctx.fillRect(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4]);
          } else {
            ctx.rect(commandBuffer[index + 1], commandBuffer[index + 2], commandBuffer[index + 3], commandBuffer[index + 4]);
          }
          index += 4;
          break;
        case Commands.FILL_TRIANGLE:
          ctx.beginPath();
          ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
          ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
          ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
          ctx.closePath();
          if (!allowClip) {
            ctx.fill();
          }
          index += 6;
          break;
        case Commands.STROKE_TRIANGLE:
          ctx.beginPath();
          ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
          ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);
          ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);
          ctx.closePath();
          if (!allowClip) {
            ctx.stroke();
          }
          index += 6;
          break;
        case Commands.LINE_TO:
          ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
          index += 2;
          break;
        case Commands.MOVE_TO:
          ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
          index += 2;
          break;
        case Commands.LINE_FX_TO:
          ctx.lineTo(commandBuffer[index + 1], commandBuffer[index + 2]);
          index += 5;
          break;
        case Commands.MOVE_FX_TO:
          ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);
          index += 5;
          break;
        case Commands.SAVE:
          ctx.save();
          break;
        case Commands.RESTORE:
          ctx.restore();
          break;
        case Commands.TRANSLATE:
          ctx.translate(commandBuffer[index + 1], commandBuffer[index + 2]);
          index += 2;
          break;
        case Commands.SCALE:
          ctx.scale(commandBuffer[index + 1], commandBuffer[index + 2]);
          index += 2;
          break;
        case Commands.ROTATE:
          ctx.rotate(commandBuffer[index + 1]);
          index += 1;
          break;
        case Commands.GRADIENT_FILL_STYLE:
          index += 5;
          break;
        case Commands.GRADIENT_LINE_STYLE:
          index += 6;
          break;
      }
    }
    ctx.restore();
  };
  module2.exports = GraphicsCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/graphics/GraphicsRender.js
var require_GraphicsRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_GraphicsWebGLRenderer();
    renderCanvas = require_GraphicsCanvasRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_GraphicsCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/graphics/Graphics.js
var require_Graphics = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BaseCamera = require_BaseCamera();
  var Class = require_Class();
  var Commands = require_Commands();
  var ComponentsAlpha = require_AlphaSingle();
  var ComponentsBlendMode = require_BlendMode();
  var ComponentsDepth = require_Depth();
  var ComponentsMask = require_Mask();
  var ComponentsPipeline = require_Pipeline();
  var ComponentsScrollFactor = require_ScrollFactor();
  var ComponentsTransform = require_Transform();
  var ComponentsVisible = require_Visible();
  var Ellipse = require_Ellipse();
  var GameObject = require_GameObject();
  var GetFastValue = require_GetFastValue();
  var GetValue = require_GetValue();
  var MATH_CONST = require_const4();
  var Render = require_GraphicsRender();
  var Graphics = new Class({
    Extends: GameObject,
    Mixins: [
      ComponentsAlpha,
      ComponentsBlendMode,
      ComponentsDepth,
      ComponentsMask,
      ComponentsPipeline,
      ComponentsTransform,
      ComponentsVisible,
      ComponentsScrollFactor,
      Render
    ],
    initialize: function Graphics2(scene, options) {
      var x = GetValue(options, "x", 0);
      var y = GetValue(options, "y", 0);
      GameObject.call(this, scene, "Graphics");
      this.setPosition(x, y);
      this.initPipeline();
      this.displayOriginX = 0;
      this.displayOriginY = 0;
      this.commandBuffer = [];
      this.defaultFillColor = -1;
      this.defaultFillAlpha = 1;
      this.defaultStrokeWidth = 1;
      this.defaultStrokeColor = -1;
      this.defaultStrokeAlpha = 1;
      this._lineWidth = 1;
      this.setDefaultStyles(options);
    },
    setDefaultStyles: function(options) {
      if (GetValue(options, "lineStyle", null)) {
        this.defaultStrokeWidth = GetValue(options, "lineStyle.width", 1);
        this.defaultStrokeColor = GetValue(options, "lineStyle.color", 16777215);
        this.defaultStrokeAlpha = GetValue(options, "lineStyle.alpha", 1);
        this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
      }
      if (GetValue(options, "fillStyle", null)) {
        this.defaultFillColor = GetValue(options, "fillStyle.color", 16777215);
        this.defaultFillAlpha = GetValue(options, "fillStyle.alpha", 1);
        this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
      }
      return this;
    },
    lineStyle: function(lineWidth, color, alpha) {
      if (alpha === void 0) {
        alpha = 1;
      }
      this.commandBuffer.push(Commands.LINE_STYLE, lineWidth, color, alpha);
      this._lineWidth = lineWidth;
      return this;
    },
    fillStyle: function(color, alpha) {
      if (alpha === void 0) {
        alpha = 1;
      }
      this.commandBuffer.push(Commands.FILL_STYLE, color, alpha);
      return this;
    },
    fillGradientStyle: function(topLeft, topRight, bottomLeft, bottomRight, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight) {
      if (alphaTopLeft === void 0) {
        alphaTopLeft = 1;
      }
      if (alphaTopRight === void 0) {
        alphaTopRight = alphaTopLeft;
      }
      if (alphaBottomLeft === void 0) {
        alphaBottomLeft = alphaTopLeft;
      }
      if (alphaBottomRight === void 0) {
        alphaBottomRight = alphaTopLeft;
      }
      this.commandBuffer.push(Commands.GRADIENT_FILL_STYLE, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight, topLeft, topRight, bottomLeft, bottomRight);
      return this;
    },
    lineGradientStyle: function(lineWidth, topLeft, topRight, bottomLeft, bottomRight, alpha) {
      if (alpha === void 0) {
        alpha = 1;
      }
      this.commandBuffer.push(Commands.GRADIENT_LINE_STYLE, lineWidth, alpha, topLeft, topRight, bottomLeft, bottomRight);
      return this;
    },
    beginPath: function() {
      this.commandBuffer.push(Commands.BEGIN_PATH);
      return this;
    },
    closePath: function() {
      this.commandBuffer.push(Commands.CLOSE_PATH);
      return this;
    },
    fillPath: function() {
      this.commandBuffer.push(Commands.FILL_PATH);
      return this;
    },
    fill: function() {
      this.commandBuffer.push(Commands.FILL_PATH);
      return this;
    },
    strokePath: function() {
      this.commandBuffer.push(Commands.STROKE_PATH);
      return this;
    },
    stroke: function() {
      this.commandBuffer.push(Commands.STROKE_PATH);
      return this;
    },
    fillCircleShape: function(circle) {
      return this.fillCircle(circle.x, circle.y, circle.radius);
    },
    strokeCircleShape: function(circle) {
      return this.strokeCircle(circle.x, circle.y, circle.radius);
    },
    fillCircle: function(x, y, radius) {
      this.beginPath();
      this.arc(x, y, radius, 0, MATH_CONST.PI2);
      this.fillPath();
      return this;
    },
    strokeCircle: function(x, y, radius) {
      this.beginPath();
      this.arc(x, y, radius, 0, MATH_CONST.PI2);
      this.strokePath();
      return this;
    },
    fillRectShape: function(rect) {
      return this.fillRect(rect.x, rect.y, rect.width, rect.height);
    },
    strokeRectShape: function(rect) {
      return this.strokeRect(rect.x, rect.y, rect.width, rect.height);
    },
    fillRect: function(x, y, width, height) {
      this.commandBuffer.push(Commands.FILL_RECT, x, y, width, height);
      return this;
    },
    strokeRect: function(x, y, width, height) {
      var lineWidthHalf = this._lineWidth / 2;
      var minx = x - lineWidthHalf;
      var maxx = x + lineWidthHalf;
      this.beginPath();
      this.moveTo(x, y);
      this.lineTo(x, y + height);
      this.strokePath();
      this.beginPath();
      this.moveTo(x + width, y);
      this.lineTo(x + width, y + height);
      this.strokePath();
      this.beginPath();
      this.moveTo(minx, y);
      this.lineTo(maxx + width, y);
      this.strokePath();
      this.beginPath();
      this.moveTo(minx, y + height);
      this.lineTo(maxx + width, y + height);
      this.strokePath();
      return this;
    },
    fillRoundedRect: function(x, y, width, height, radius) {
      if (radius === void 0) {
        radius = 20;
      }
      var tl = radius;
      var tr = radius;
      var bl = radius;
      var br = radius;
      if (typeof radius !== "number") {
        tl = GetFastValue(radius, "tl", 20);
        tr = GetFastValue(radius, "tr", 20);
        bl = GetFastValue(radius, "bl", 20);
        br = GetFastValue(radius, "br", 20);
      }
      this.beginPath();
      this.moveTo(x + tl, y);
      this.lineTo(x + width - tr, y);
      this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);
      this.lineTo(x + width, y + height - br);
      this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);
      this.lineTo(x + bl, y + height);
      this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);
      this.lineTo(x, y + tl);
      this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);
      this.fillPath();
      return this;
    },
    strokeRoundedRect: function(x, y, width, height, radius) {
      if (radius === void 0) {
        radius = 20;
      }
      var tl = radius;
      var tr = radius;
      var bl = radius;
      var br = radius;
      if (typeof radius !== "number") {
        tl = GetFastValue(radius, "tl", 20);
        tr = GetFastValue(radius, "tr", 20);
        bl = GetFastValue(radius, "bl", 20);
        br = GetFastValue(radius, "br", 20);
      }
      this.beginPath();
      this.moveTo(x + tl, y);
      this.lineTo(x + width - tr, y);
      this.moveTo(x + width - tr, y);
      this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);
      this.lineTo(x + width, y + height - br);
      this.moveTo(x + width, y + height - br);
      this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);
      this.lineTo(x + bl, y + height);
      this.moveTo(x + bl, y + height);
      this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);
      this.lineTo(x, y + tl);
      this.moveTo(x, y + tl);
      this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);
      this.strokePath();
      return this;
    },
    fillPointShape: function(point, size) {
      return this.fillPoint(point.x, point.y, size);
    },
    fillPoint: function(x, y, size) {
      if (!size || size < 1) {
        size = 1;
      } else {
        x -= size / 2;
        y -= size / 2;
      }
      this.commandBuffer.push(Commands.FILL_RECT, x, y, size, size);
      return this;
    },
    fillTriangleShape: function(triangle) {
      return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
    },
    strokeTriangleShape: function(triangle) {
      return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);
    },
    fillTriangle: function(x0, y0, x1, y1, x2, y2) {
      this.commandBuffer.push(Commands.FILL_TRIANGLE, x0, y0, x1, y1, x2, y2);
      return this;
    },
    strokeTriangle: function(x0, y0, x1, y1, x2, y2) {
      this.commandBuffer.push(Commands.STROKE_TRIANGLE, x0, y0, x1, y1, x2, y2);
      return this;
    },
    strokeLineShape: function(line) {
      return this.lineBetween(line.x1, line.y1, line.x2, line.y2);
    },
    lineBetween: function(x1, y1, x2, y2) {
      this.beginPath();
      this.moveTo(x1, y1);
      this.lineTo(x2, y2);
      this.strokePath();
      return this;
    },
    lineTo: function(x, y) {
      this.commandBuffer.push(Commands.LINE_TO, x, y);
      return this;
    },
    moveTo: function(x, y) {
      this.commandBuffer.push(Commands.MOVE_TO, x, y);
      return this;
    },
    strokePoints: function(points, closeShape, closePath, endIndex) {
      if (closeShape === void 0) {
        closeShape = false;
      }
      if (closePath === void 0) {
        closePath = false;
      }
      if (endIndex === void 0) {
        endIndex = points.length;
      }
      this.beginPath();
      this.moveTo(points[0].x, points[0].y);
      for (var i = 1; i < endIndex; i++) {
        this.lineTo(points[i].x, points[i].y);
      }
      if (closeShape) {
        this.lineTo(points[0].x, points[0].y);
      }
      if (closePath) {
        this.closePath();
      }
      this.strokePath();
      return this;
    },
    fillPoints: function(points, closeShape, closePath, endIndex) {
      if (closeShape === void 0) {
        closeShape = false;
      }
      if (closePath === void 0) {
        closePath = false;
      }
      if (endIndex === void 0) {
        endIndex = points.length;
      }
      this.beginPath();
      this.moveTo(points[0].x, points[0].y);
      for (var i = 1; i < endIndex; i++) {
        this.lineTo(points[i].x, points[i].y);
      }
      if (closeShape) {
        this.lineTo(points[0].x, points[0].y);
      }
      if (closePath) {
        this.closePath();
      }
      this.fillPath();
      return this;
    },
    strokeEllipseShape: function(ellipse, smoothness) {
      if (smoothness === void 0) {
        smoothness = 32;
      }
      var points = ellipse.getPoints(smoothness);
      return this.strokePoints(points, true);
    },
    strokeEllipse: function(x, y, width, height, smoothness) {
      if (smoothness === void 0) {
        smoothness = 32;
      }
      var ellipse = new Ellipse(x, y, width, height);
      var points = ellipse.getPoints(smoothness);
      return this.strokePoints(points, true);
    },
    fillEllipseShape: function(ellipse, smoothness) {
      if (smoothness === void 0) {
        smoothness = 32;
      }
      var points = ellipse.getPoints(smoothness);
      return this.fillPoints(points, true);
    },
    fillEllipse: function(x, y, width, height, smoothness) {
      if (smoothness === void 0) {
        smoothness = 32;
      }
      var ellipse = new Ellipse(x, y, width, height);
      var points = ellipse.getPoints(smoothness);
      return this.fillPoints(points, true);
    },
    arc: function(x, y, radius, startAngle, endAngle, anticlockwise, overshoot) {
      if (anticlockwise === void 0) {
        anticlockwise = false;
      }
      if (overshoot === void 0) {
        overshoot = 0;
      }
      this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);
      return this;
    },
    slice: function(x, y, radius, startAngle, endAngle, anticlockwise, overshoot) {
      if (anticlockwise === void 0) {
        anticlockwise = false;
      }
      if (overshoot === void 0) {
        overshoot = 0;
      }
      this.commandBuffer.push(Commands.BEGIN_PATH);
      this.commandBuffer.push(Commands.MOVE_TO, x, y);
      this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);
      this.commandBuffer.push(Commands.CLOSE_PATH);
      return this;
    },
    save: function() {
      this.commandBuffer.push(Commands.SAVE);
      return this;
    },
    restore: function() {
      this.commandBuffer.push(Commands.RESTORE);
      return this;
    },
    translateCanvas: function(x, y) {
      this.commandBuffer.push(Commands.TRANSLATE, x, y);
      return this;
    },
    scaleCanvas: function(x, y) {
      this.commandBuffer.push(Commands.SCALE, x, y);
      return this;
    },
    rotateCanvas: function(radians) {
      this.commandBuffer.push(Commands.ROTATE, radians);
      return this;
    },
    clear: function() {
      this.commandBuffer.length = 0;
      if (this.defaultFillColor > -1) {
        this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
      }
      if (this.defaultStrokeColor > -1) {
        this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
      }
      return this;
    },
    generateTexture: function(key, width, height) {
      var sys = this.scene.sys;
      var renderer = sys.game.renderer;
      if (width === void 0) {
        width = sys.scale.width;
      }
      if (height === void 0) {
        height = sys.scale.height;
      }
      Graphics.TargetCamera.setScene(this.scene);
      Graphics.TargetCamera.setViewport(0, 0, width, height);
      Graphics.TargetCamera.scrollX = this.x;
      Graphics.TargetCamera.scrollY = this.y;
      var texture;
      var ctx;
      if (typeof key === "string") {
        if (sys.textures.exists(key)) {
          texture = sys.textures.get(key);
          var src = texture.getSourceImage();
          if (src instanceof HTMLCanvasElement) {
            ctx = src.getContext("2d");
          }
        } else {
          texture = sys.textures.createCanvas(key, width, height);
          ctx = texture.getSourceImage().getContext("2d");
        }
      } else if (key instanceof HTMLCanvasElement) {
        ctx = key.getContext("2d");
      }
      if (ctx) {
        this.renderCanvas(renderer, this, Graphics.TargetCamera, null, ctx, false);
        if (texture) {
          texture.refresh();
        }
      }
      return this;
    },
    preDestroy: function() {
      this.commandBuffer = [];
    }
  });
  Graphics.TargetCamera = new BaseCamera();
  module2.exports = Graphics;
});

// node_modules/phaser/src/structs/Set.js
var require_Set = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Set = new Class({
    initialize: function Set2(elements) {
      this.entries = [];
      if (Array.isArray(elements)) {
        for (var i = 0; i < elements.length; i++) {
          this.set(elements[i]);
        }
      }
    },
    set: function(value) {
      if (this.entries.indexOf(value) === -1) {
        this.entries.push(value);
      }
      return this;
    },
    get: function(property, value) {
      for (var i = 0; i < this.entries.length; i++) {
        var entry = this.entries[i];
        if (entry[property] === value) {
          return entry;
        }
      }
    },
    getArray: function() {
      return this.entries.slice(0);
    },
    delete: function(value) {
      var index = this.entries.indexOf(value);
      if (index > -1) {
        this.entries.splice(index, 1);
      }
      return this;
    },
    dump: function() {
      console.group("Set");
      for (var i = 0; i < this.entries.length; i++) {
        var entry = this.entries[i];
        console.log(entry);
      }
      console.groupEnd();
    },
    each: function(callback, callbackScope) {
      var i;
      var temp = this.entries.slice();
      var len = temp.length;
      if (callbackScope) {
        for (i = 0; i < len; i++) {
          if (callback.call(callbackScope, temp[i], i) === false) {
            break;
          }
        }
      } else {
        for (i = 0; i < len; i++) {
          if (callback(temp[i], i) === false) {
            break;
          }
        }
      }
      return this;
    },
    iterate: function(callback, callbackScope) {
      var i;
      var len = this.entries.length;
      if (callbackScope) {
        for (i = 0; i < len; i++) {
          if (callback.call(callbackScope, this.entries[i], i) === false) {
            break;
          }
        }
      } else {
        for (i = 0; i < len; i++) {
          if (callback(this.entries[i], i) === false) {
            break;
          }
        }
      }
      return this;
    },
    iterateLocal: function(callbackKey) {
      var i;
      var args = [];
      for (i = 1; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      var len = this.entries.length;
      for (i = 0; i < len; i++) {
        var entry = this.entries[i];
        entry[callbackKey].apply(entry, args);
      }
      return this;
    },
    clear: function() {
      this.entries.length = 0;
      return this;
    },
    contains: function(value) {
      return this.entries.indexOf(value) > -1;
    },
    union: function(set) {
      var newSet = new Set();
      set.entries.forEach(function(value) {
        newSet.set(value);
      });
      this.entries.forEach(function(value) {
        newSet.set(value);
      });
      return newSet;
    },
    intersect: function(set) {
      var newSet = new Set();
      this.entries.forEach(function(value) {
        if (set.contains(value)) {
          newSet.set(value);
        }
      });
      return newSet;
    },
    difference: function(set) {
      var newSet = new Set();
      this.entries.forEach(function(value) {
        if (!set.contains(value)) {
          newSet.set(value);
        }
      });
      return newSet;
    },
    size: {
      get: function() {
        return this.entries.length;
      },
      set: function(value) {
        if (value < this.entries.length) {
          return this.entries.length = value;
        } else {
          return this.entries.length;
        }
      }
    }
  });
  module2.exports = Set;
});

// node_modules/phaser/src/gameobjects/sprite/SpriteWebGLRenderer.js
var require_SpriteWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SpriteWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    src.pipeline.batchSprite(src, camera, parentMatrix);
  };
  module2.exports = SpriteWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/sprite/SpriteCanvasRenderer.js
var require_SpriteCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SpriteCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    renderer.batchSprite(src, src.frame, camera, parentMatrix);
  };
  module2.exports = SpriteCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/sprite/SpriteRender.js
var require_SpriteRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_SpriteWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_SpriteCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/sprite/Sprite.js
var require_Sprite = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AnimationState = require_AnimationState();
  var Class = require_Class();
  var Components = require_components();
  var GameObject = require_GameObject();
  var SpriteRender = require_SpriteRender();
  var Sprite = new Class({
    Extends: GameObject,
    Mixins: [
      Components.Alpha,
      Components.BlendMode,
      Components.Depth,
      Components.Flip,
      Components.GetBounds,
      Components.Mask,
      Components.Origin,
      Components.Pipeline,
      Components.ScrollFactor,
      Components.Size,
      Components.TextureCrop,
      Components.Tint,
      Components.Transform,
      Components.Visible,
      SpriteRender
    ],
    initialize: function Sprite2(scene, x, y, texture, frame) {
      GameObject.call(this, scene, "Sprite");
      this._crop = this.resetCropObject();
      this.anims = new AnimationState(this);
      this.setTexture(texture, frame);
      this.setPosition(x, y);
      this.setSizeToFrame();
      this.setOriginFromFrame();
      this.initPipeline();
    },
    addedToScene: function() {
      this.scene.sys.updateList.add(this);
    },
    removedFromScene: function() {
      this.scene.sys.updateList.remove(this);
    },
    preUpdate: function(time, delta) {
      this.anims.update(time, delta);
    },
    play: function(key, ignoreIfPlaying) {
      return this.anims.play(key, ignoreIfPlaying);
    },
    playReverse: function(key, ignoreIfPlaying) {
      return this.anims.playReverse(key, ignoreIfPlaying);
    },
    playAfterDelay: function(key, delay) {
      return this.anims.playAfterDelay(key, delay);
    },
    playAfterRepeat: function(key, repeatCount) {
      return this.anims.playAfterRepeat(key, repeatCount);
    },
    chain: function(key) {
      return this.anims.chain(key);
    },
    stop: function() {
      return this.anims.stop();
    },
    stopAfterDelay: function(delay) {
      return this.anims.stopAfterDelay(delay);
    },
    stopAfterRepeat: function(repeatCount) {
      return this.anims.stopAfterRepeat(repeatCount);
    },
    stopOnFrame: function(frame) {
      return this.anims.stopOnFrame(frame);
    },
    toJSON: function() {
      return Components.ToJSON(this);
    },
    preDestroy: function() {
      this.anims.destroy();
      this.anims = void 0;
    }
  });
  module2.exports = Sprite;
});

// node_modules/phaser/src/gameobjects/group/Group.js
var require_Group = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Actions = require_actions();
  var Class = require_Class();
  var Events = require_events4();
  var EventEmitter = require_eventemitter3();
  var GetAll = require_GetAll();
  var GetFastValue = require_GetFastValue();
  var GetValue = require_GetValue();
  var IsPlainObject = require_IsPlainObject();
  var Range = require_Range();
  var Set = require_Set();
  var Sprite = require_Sprite();
  var Group = new Class({
    Extends: EventEmitter,
    initialize: function Group2(scene, children, config2) {
      EventEmitter.call(this);
      if (config2) {
        if (children && !Array.isArray(children)) {
          children = [children];
        }
      } else if (Array.isArray(children)) {
        if (IsPlainObject(children[0])) {
          config2 = children;
          children = null;
        }
      } else if (IsPlainObject(children)) {
        config2 = children;
        children = null;
      }
      this.scene = scene;
      this.children = new Set();
      this.isParent = true;
      this.type = "Group";
      this.classType = GetFastValue(config2, "classType", Sprite);
      this.name = GetFastValue(config2, "name", "");
      this.active = GetFastValue(config2, "active", true);
      this.maxSize = GetFastValue(config2, "maxSize", -1);
      this.defaultKey = GetFastValue(config2, "defaultKey", null);
      this.defaultFrame = GetFastValue(config2, "defaultFrame", null);
      this.runChildUpdate = GetFastValue(config2, "runChildUpdate", false);
      this.createCallback = GetFastValue(config2, "createCallback", null);
      this.removeCallback = GetFastValue(config2, "removeCallback", null);
      this.createMultipleCallback = GetFastValue(config2, "createMultipleCallback", null);
      this.internalCreateCallback = GetFastValue(config2, "internalCreateCallback", null);
      this.internalRemoveCallback = GetFastValue(config2, "internalRemoveCallback", null);
      if (children) {
        this.addMultiple(children);
      }
      if (config2) {
        this.createMultiple(config2);
      }
      this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);
      this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);
    },
    addedToScene: function() {
      this.scene.sys.updateList.add(this);
    },
    removedFromScene: function() {
      this.scene.sys.updateList.remove(this);
    },
    create: function(x, y, key, frame, visible, active) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (key === void 0) {
        key = this.defaultKey;
      }
      if (frame === void 0) {
        frame = this.defaultFrame;
      }
      if (visible === void 0) {
        visible = true;
      }
      if (active === void 0) {
        active = true;
      }
      if (this.isFull()) {
        return null;
      }
      var child = new this.classType(this.scene, x, y, key, frame);
      child.addToDisplayList(this.scene.sys.displayList);
      child.addToUpdateList();
      child.visible = visible;
      child.setActive(active);
      this.add(child);
      return child;
    },
    createMultiple: function(config2) {
      if (this.isFull()) {
        return [];
      }
      if (!Array.isArray(config2)) {
        config2 = [config2];
      }
      var output = [];
      if (config2[0].key) {
        for (var i = 0; i < config2.length; i++) {
          var entries = this.createFromConfig(config2[i]);
          output = output.concat(entries);
        }
      }
      return output;
    },
    createFromConfig: function(options) {
      if (this.isFull()) {
        return [];
      }
      this.classType = GetFastValue(options, "classType", this.classType);
      var key = GetFastValue(options, "key", void 0);
      var frame = GetFastValue(options, "frame", null);
      var visible = GetFastValue(options, "visible", true);
      var active = GetFastValue(options, "active", true);
      var entries = [];
      if (key === void 0) {
        return entries;
      } else {
        if (!Array.isArray(key)) {
          key = [key];
        }
        if (!Array.isArray(frame)) {
          frame = [frame];
        }
      }
      var repeat = GetFastValue(options, "repeat", 0);
      var randomKey = GetFastValue(options, "randomKey", false);
      var randomFrame = GetFastValue(options, "randomFrame", false);
      var yoyo = GetFastValue(options, "yoyo", false);
      var quantity = GetFastValue(options, "quantity", false);
      var frameQuantity = GetFastValue(options, "frameQuantity", 1);
      var max = GetFastValue(options, "max", 0);
      var range = Range(key, frame, {
        max,
        qty: quantity ? quantity : frameQuantity,
        random: randomKey,
        randomB: randomFrame,
        repeat,
        yoyo
      });
      if (options.createCallback) {
        this.createCallback = options.createCallback;
      }
      if (options.removeCallback) {
        this.removeCallback = options.removeCallback;
      }
      for (var c = 0; c < range.length; c++) {
        var created = this.create(0, 0, range[c].a, range[c].b, visible, active);
        if (!created) {
          break;
        }
        entries.push(created);
      }
      var x = GetValue(options, "setXY.x", 0);
      var y = GetValue(options, "setXY.y", 0);
      var stepX = GetValue(options, "setXY.stepX", 0);
      var stepY = GetValue(options, "setXY.stepY", 0);
      Actions.SetXY(entries, x, y, stepX, stepY);
      var rotation = GetValue(options, "setRotation.value", 0);
      var stepRotation = GetValue(options, "setRotation.step", 0);
      Actions.SetRotation(entries, rotation, stepRotation);
      var scaleX = GetValue(options, "setScale.x", 1);
      var scaleY = GetValue(options, "setScale.y", scaleX);
      var stepScaleX = GetValue(options, "setScale.stepX", 0);
      var stepScaleY = GetValue(options, "setScale.stepY", 0);
      Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);
      var originX = GetValue(options, "setOrigin.x", 0.5);
      var originY = GetValue(options, "setOrigin.y", originX);
      var stepOriginX = GetValue(options, "setOrigin.stepX", 0);
      var stepOriginY = GetValue(options, "setOrigin.stepY", 0);
      Actions.SetOrigin(entries, originX, originY, stepOriginX, stepOriginY);
      var alpha = GetValue(options, "setAlpha.value", 1);
      var stepAlpha = GetValue(options, "setAlpha.step", 0);
      Actions.SetAlpha(entries, alpha, stepAlpha);
      var depth = GetValue(options, "setDepth.value", 0);
      var stepDepth = GetValue(options, "setDepth.step", 0);
      Actions.SetDepth(entries, depth, stepDepth);
      var scrollFactorX = GetValue(options, "setScrollFactor.x", 1);
      var scrollFactorY = GetValue(options, "setScrollFactor.y", scrollFactorX);
      var stepScrollFactorX = GetValue(options, "setScrollFactor.stepX", 0);
      var stepScrollFactorY = GetValue(options, "setScrollFactor.stepY", 0);
      Actions.SetScrollFactor(entries, scrollFactorX, scrollFactorY, stepScrollFactorX, stepScrollFactorY);
      var hitArea = GetFastValue(options, "hitArea", null);
      var hitAreaCallback = GetFastValue(options, "hitAreaCallback", null);
      if (hitArea) {
        Actions.SetHitArea(entries, hitArea, hitAreaCallback);
      }
      var grid = GetFastValue(options, "gridAlign", false);
      if (grid) {
        Actions.GridAlign(entries, grid);
      }
      if (this.createMultipleCallback) {
        this.createMultipleCallback.call(this, entries);
      }
      return entries;
    },
    preUpdate: function(time, delta) {
      if (!this.runChildUpdate || this.children.size === 0) {
        return;
      }
      var temp = this.children.entries.slice();
      for (var i = 0; i < temp.length; i++) {
        var item = temp[i];
        if (item.active) {
          item.update(time, delta);
        }
      }
    },
    add: function(child, addToScene) {
      if (addToScene === void 0) {
        addToScene = false;
      }
      if (this.isFull()) {
        return this;
      }
      this.children.set(child);
      if (this.internalCreateCallback) {
        this.internalCreateCallback.call(this, child);
      }
      if (this.createCallback) {
        this.createCallback.call(this, child);
      }
      if (addToScene) {
        child.addToDisplayList(this.scene.sys.displayList);
        child.addToUpdateList();
      }
      child.on(Events.DESTROY, this.remove, this);
      return this;
    },
    addMultiple: function(children, addToScene) {
      if (addToScene === void 0) {
        addToScene = false;
      }
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          this.add(children[i], addToScene);
        }
      }
      return this;
    },
    remove: function(child, removeFromScene, destroyChild) {
      if (removeFromScene === void 0) {
        removeFromScene = false;
      }
      if (destroyChild === void 0) {
        destroyChild = false;
      }
      if (!this.children.contains(child)) {
        return this;
      }
      this.children.delete(child);
      if (this.internalRemoveCallback) {
        this.internalRemoveCallback.call(this, child);
      }
      if (this.removeCallback) {
        this.removeCallback.call(this, child);
      }
      child.off(Events.DESTROY, this.remove, this);
      if (destroyChild) {
        child.destroy();
      } else if (removeFromScene) {
        child.removeFromDisplayList();
        child.removeFromUpdateList();
      }
      return this;
    },
    clear: function(removeFromScene, destroyChild) {
      if (removeFromScene === void 0) {
        removeFromScene = false;
      }
      if (destroyChild === void 0) {
        destroyChild = false;
      }
      var children = this.children;
      for (var i = 0; i < children.size; i++) {
        var gameObject = children.entries[i];
        gameObject.off(Events.DESTROY, this.remove, this);
        if (destroyChild) {
          gameObject.destroy();
        } else if (removeFromScene) {
          gameObject.removeFromDisplayList();
          gameObject.removeFromUpdateList();
        }
      }
      this.children.clear();
      return this;
    },
    contains: function(child) {
      return this.children.contains(child);
    },
    getChildren: function() {
      return this.children.entries;
    },
    getLength: function() {
      return this.children.size;
    },
    getMatching: function(property, value, startIndex, endIndex) {
      return GetAll(this.children.entries, property, value, startIndex, endIndex);
    },
    getFirst: function(state, createIfNull, x, y, key, frame, visible) {
      return this.getHandler(true, 1, state, createIfNull, x, y, key, frame, visible);
    },
    getFirstNth: function(nth, state, createIfNull, x, y, key, frame, visible) {
      return this.getHandler(true, nth, state, createIfNull, x, y, key, frame, visible);
    },
    getLast: function(state, createIfNull, x, y, key, frame, visible) {
      return this.getHandler(false, 1, state, createIfNull, x, y, key, frame, visible);
    },
    getLastNth: function(nth, state, createIfNull, x, y, key, frame, visible) {
      return this.getHandler(false, nth, state, createIfNull, x, y, key, frame, visible);
    },
    getHandler: function(forwards, nth, state, createIfNull, x, y, key, frame, visible) {
      if (state === void 0) {
        state = false;
      }
      if (createIfNull === void 0) {
        createIfNull = false;
      }
      var gameObject;
      var i;
      var total = 0;
      var children = this.children.entries;
      if (forwards) {
        for (i = 0; i < children.length; i++) {
          gameObject = children[i];
          if (gameObject.active === state) {
            total++;
            if (total === nth) {
              break;
            }
          } else {
            gameObject = null;
          }
        }
      } else {
        for (i = children.length - 1; i >= 0; i--) {
          gameObject = children[i];
          if (gameObject.active === state) {
            total++;
            if (total === nth) {
              break;
            }
          } else {
            gameObject = null;
          }
        }
      }
      if (gameObject) {
        if (typeof x === "number") {
          gameObject.x = x;
        }
        if (typeof y === "number") {
          gameObject.y = y;
        }
        return gameObject;
      }
      if (createIfNull) {
        return this.create(x, y, key, frame, visible);
      } else {
        return null;
      }
    },
    get: function(x, y, key, frame, visible) {
      return this.getFirst(false, true, x, y, key, frame, visible);
    },
    getFirstAlive: function(createIfNull, x, y, key, frame, visible) {
      return this.getFirst(true, createIfNull, x, y, key, frame, visible);
    },
    getFirstDead: function(createIfNull, x, y, key, frame, visible) {
      return this.getFirst(false, createIfNull, x, y, key, frame, visible);
    },
    playAnimation: function(key, startFrame) {
      Actions.PlayAnimation(this.children.entries, key, startFrame);
      return this;
    },
    isFull: function() {
      if (this.maxSize === -1) {
        return false;
      } else {
        return this.children.size >= this.maxSize;
      }
    },
    countActive: function(value) {
      if (value === void 0) {
        value = true;
      }
      var total = 0;
      for (var i = 0; i < this.children.size; i++) {
        if (this.children.entries[i].active === value) {
          total++;
        }
      }
      return total;
    },
    getTotalUsed: function() {
      return this.countActive();
    },
    getTotalFree: function() {
      var used = this.getTotalUsed();
      var capacity = this.maxSize === -1 ? 999999999999 : this.maxSize;
      return capacity - used;
    },
    setActive: function(value) {
      this.active = value;
      return this;
    },
    setName: function(value) {
      this.name = value;
      return this;
    },
    propertyValueSet: function(key, value, step, index, direction) {
      Actions.PropertyValueSet(this.children.entries, key, value, step, index, direction);
      return this;
    },
    propertyValueInc: function(key, value, step, index, direction) {
      Actions.PropertyValueInc(this.children.entries, key, value, step, index, direction);
      return this;
    },
    setX: function(value, step) {
      Actions.SetX(this.children.entries, value, step);
      return this;
    },
    setY: function(value, step) {
      Actions.SetY(this.children.entries, value, step);
      return this;
    },
    setXY: function(x, y, stepX, stepY) {
      Actions.SetXY(this.children.entries, x, y, stepX, stepY);
      return this;
    },
    incX: function(value, step) {
      Actions.IncX(this.children.entries, value, step);
      return this;
    },
    incY: function(value, step) {
      Actions.IncY(this.children.entries, value, step);
      return this;
    },
    incXY: function(x, y, stepX, stepY) {
      Actions.IncXY(this.children.entries, x, y, stepX, stepY);
      return this;
    },
    shiftPosition: function(x, y, direction) {
      Actions.ShiftPosition(this.children.entries, x, y, direction);
      return this;
    },
    angle: function(value, step) {
      Actions.Angle(this.children.entries, value, step);
      return this;
    },
    rotate: function(value, step) {
      Actions.Rotate(this.children.entries, value, step);
      return this;
    },
    rotateAround: function(point, angle) {
      Actions.RotateAround(this.children.entries, point, angle);
      return this;
    },
    rotateAroundDistance: function(point, angle, distance) {
      Actions.RotateAroundDistance(this.children.entries, point, angle, distance);
      return this;
    },
    setAlpha: function(value, step) {
      Actions.SetAlpha(this.children.entries, value, step);
      return this;
    },
    setTint: function(topLeft, topRight, bottomLeft, bottomRight) {
      Actions.SetTint(this.children.entries, topLeft, topRight, bottomLeft, bottomRight);
      return this;
    },
    setOrigin: function(originX, originY, stepX, stepY) {
      Actions.SetOrigin(this.children.entries, originX, originY, stepX, stepY);
      return this;
    },
    scaleX: function(value, step) {
      Actions.ScaleX(this.children.entries, value, step);
      return this;
    },
    scaleY: function(value, step) {
      Actions.ScaleY(this.children.entries, value, step);
      return this;
    },
    scaleXY: function(scaleX, scaleY, stepX, stepY) {
      Actions.ScaleXY(this.children.entries, scaleX, scaleY, stepX, stepY);
      return this;
    },
    setDepth: function(value, step) {
      Actions.SetDepth(this.children.entries, value, step);
      return this;
    },
    setBlendMode: function(value) {
      Actions.SetBlendMode(this.children.entries, value);
      return this;
    },
    setHitArea: function(hitArea, hitAreaCallback) {
      Actions.SetHitArea(this.children.entries, hitArea, hitAreaCallback);
      return this;
    },
    shuffle: function() {
      Actions.Shuffle(this.children.entries);
      return this;
    },
    kill: function(gameObject) {
      if (this.children.contains(gameObject)) {
        gameObject.setActive(false);
      }
    },
    killAndHide: function(gameObject) {
      if (this.children.contains(gameObject)) {
        gameObject.setActive(false);
        gameObject.setVisible(false);
      }
    },
    setVisible: function(value, index, direction) {
      Actions.SetVisible(this.children.entries, value, index, direction);
      return this;
    },
    toggleVisible: function() {
      Actions.ToggleVisible(this.children.entries);
      return this;
    },
    destroy: function(destroyChildren, removeFromScene) {
      if (destroyChildren === void 0) {
        destroyChildren = false;
      }
      if (removeFromScene === void 0) {
        removeFromScene = false;
      }
      if (!this.scene || this.ignoreDestroy) {
        return;
      }
      this.emit(Events.DESTROY, this);
      this.removeAllListeners();
      this.scene.sys.updateList.remove(this);
      this.clear(removeFromScene, destroyChildren);
      this.scene = void 0;
      this.children = void 0;
    }
  });
  module2.exports = Group;
});

// node_modules/phaser/src/gameobjects/image/ImageWebGLRenderer.js
var require_ImageWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ImageWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    this.pipeline.batchSprite(src, camera, parentMatrix);
  };
  module2.exports = ImageWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/image/ImageCanvasRenderer.js
var require_ImageCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ImageCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    renderer.batchSprite(src, src.frame, camera, parentMatrix);
  };
  module2.exports = ImageCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/image/ImageRender.js
var require_ImageRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_ImageWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_ImageCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/image/Image.js
var require_Image2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components();
  var GameObject = require_GameObject();
  var ImageRender = require_ImageRender();
  var Image2 = new Class({
    Extends: GameObject,
    Mixins: [
      Components.Alpha,
      Components.BlendMode,
      Components.Depth,
      Components.Flip,
      Components.GetBounds,
      Components.Mask,
      Components.Origin,
      Components.Pipeline,
      Components.ScrollFactor,
      Components.Size,
      Components.TextureCrop,
      Components.Tint,
      Components.Transform,
      Components.Visible,
      ImageRender
    ],
    initialize: function Image3(scene, x, y, texture, frame) {
      GameObject.call(this, scene, "Image");
      this._crop = this.resetCropObject();
      this.setTexture(texture, frame);
      this.setPosition(x, y);
      this.setSizeToFrame();
      this.setOriginFromFrame();
      this.initPipeline();
    }
  });
  module2.exports = Image2;
});

// node_modules/phaser/src/gameobjects/layer/LayerWebGLRenderer.js
var require_LayerWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var LayerWebGLRenderer = function(renderer, layer, camera) {
    var children = layer.list;
    var childCount = children.length;
    if (childCount === 0) {
      return;
    }
    layer.depthSort();
    renderer.pipelines.preBatch(layer);
    var layerHasBlendMode = layer.blendMode !== -1;
    if (!layerHasBlendMode) {
      renderer.setBlendMode(0);
    }
    var alpha = layer.alpha;
    for (var i = 0; i < childCount; i++) {
      var child = children[i];
      if (!child.willRender(camera)) {
        continue;
      }
      var childAlphaTopLeft;
      var childAlphaTopRight;
      var childAlphaBottomLeft;
      var childAlphaBottomRight;
      if (child.alphaTopLeft !== void 0) {
        childAlphaTopLeft = child.alphaTopLeft;
        childAlphaTopRight = child.alphaTopRight;
        childAlphaBottomLeft = child.alphaBottomLeft;
        childAlphaBottomRight = child.alphaBottomRight;
      } else {
        var childAlpha = child.alpha;
        childAlphaTopLeft = childAlpha;
        childAlphaTopRight = childAlpha;
        childAlphaBottomLeft = childAlpha;
        childAlphaBottomRight = childAlpha;
      }
      if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
        renderer.setBlendMode(child.blendMode);
      }
      var mask = child.mask;
      if (mask) {
        mask.preRenderWebGL(renderer, child, camera);
      }
      var type = child.type;
      if (type !== renderer.currentType) {
        renderer.newType = true;
        renderer.currentType = type;
      }
      renderer.nextTypeMatch = i < childCount - 1 ? children[i + 1].type === renderer.currentType : false;
      child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);
      child.renderWebGL(renderer, child, camera);
      child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);
      if (mask) {
        mask.postRenderWebGL(renderer, camera);
      }
      renderer.newType = false;
    }
    renderer.pipelines.postBatch(layer);
  };
  module2.exports = LayerWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/layer/LayerCanvasRenderer.js
var require_LayerCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var LayerCanvasRenderer = function(renderer, layer, camera) {
    var children = layer.list;
    if (children.length === 0) {
      return;
    }
    layer.depthSort();
    var layerHasBlendMode = layer.blendMode !== -1;
    if (!layerHasBlendMode) {
      renderer.setBlendMode(0);
    }
    var alpha = layer._alpha;
    if (layer.mask) {
      layer.mask.preRenderCanvas(renderer, null, camera);
    }
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (!child.willRender(camera)) {
        continue;
      }
      var childAlpha = child.alpha;
      if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode) {
        renderer.setBlendMode(child.blendMode);
      }
      child.setAlpha(childAlpha * alpha);
      child.renderCanvas(renderer, child, camera);
      child.setAlpha(childAlpha);
    }
    if (layer.mask) {
      layer.mask.postRenderCanvas(renderer);
    }
  };
  module2.exports = LayerCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/layer/LayerRender.js
var require_LayerRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_LayerWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_LayerCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/layer/Layer.js
var require_Layer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BlendModes = require_BlendModes();
  var Class = require_Class();
  var Components = require_components();
  var ComponentsToJSON = require_ToJSON();
  var DataManager = require_DataManager();
  var EventEmitter = require_eventemitter3();
  var GameObjectEvents = require_events4();
  var List = require_List();
  var Render = require_LayerRender();
  var SceneEvents = require_events5();
  var StableSort = require_StableSort();
  var Layer = new Class({
    Extends: List,
    Mixins: [
      Components.AlphaSingle,
      Components.BlendMode,
      Components.Depth,
      Components.Mask,
      Components.Pipeline,
      Components.Visible,
      EventEmitter,
      Render
    ],
    initialize: function Layer2(scene, children) {
      List.call(this, scene);
      EventEmitter.call(this);
      this.scene = scene;
      this.displayList = null;
      this.type = "Layer";
      this.state = 0;
      this.parentContainer = null;
      this.name = "";
      this.active = true;
      this.tabIndex = -1;
      this.data = null;
      this.renderFlags = 15;
      this.cameraFilter = 0;
      this.input = null;
      this.body = null;
      this.ignoreDestroy = false;
      this.systems = scene.sys;
      this.events = scene.sys.events;
      this.sortChildrenFlag = false;
      this.addCallback = this.addChildCallback;
      this.removeCallback = this.removeChildCallback;
      this.initPipeline();
      this.clearAlpha();
      this.setBlendMode(BlendModes.SKIP_CHECK);
      if (children) {
        this.add(children);
      }
      scene.sys.queueDepthSort();
    },
    setActive: function(value) {
      this.active = value;
      return this;
    },
    setName: function(value) {
      this.name = value;
      return this;
    },
    setState: function(value) {
      this.state = value;
      return this;
    },
    setDataEnabled: function() {
      if (!this.data) {
        this.data = new DataManager(this);
      }
      return this;
    },
    setData: function(key, value) {
      if (!this.data) {
        this.data = new DataManager(this);
      }
      this.data.set(key, value);
      return this;
    },
    incData: function(key, value) {
      if (!this.data) {
        this.data = new DataManager(this);
      }
      this.data.inc(key, value);
      return this;
    },
    toggleData: function(key) {
      if (!this.data) {
        this.data = new DataManager(this);
      }
      this.data.toggle(key);
      return this;
    },
    getData: function(key) {
      if (!this.data) {
        this.data = new DataManager(this);
      }
      return this.data.get(key);
    },
    setInteractive: function() {
      return this;
    },
    disableInteractive: function() {
      return this;
    },
    removeInteractive: function() {
      return this;
    },
    addedToScene: function() {
    },
    removedFromScene: function() {
    },
    update: function() {
    },
    toJSON: function() {
      return ComponentsToJSON(this);
    },
    willRender: function(camera) {
      return !(this.renderFlags !== 15 || this.list.length === 0 || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
    },
    getIndexList: function() {
      var child = this;
      var parent = this.parentContainer;
      var indexes = [];
      while (parent) {
        indexes.unshift(parent.getIndex(child));
        child = parent;
        if (!parent.parentContainer) {
          break;
        } else {
          parent = parent.parentContainer;
        }
      }
      indexes.unshift(this.displayList.getIndex(child));
      return indexes;
    },
    addChildCallback: function(gameObject) {
      if (gameObject.displayList && gameObject.displayList !== this) {
        gameObject.removeFromDisplayList();
      }
      if (!gameObject.displayList) {
        this.queueDepthSort();
        gameObject.displayList = this;
        gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);
        this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);
      }
    },
    removeChildCallback: function(gameObject) {
      this.queueDepthSort();
      gameObject.displayList = null;
      gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
      this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);
    },
    queueDepthSort: function() {
      this.sortChildrenFlag = true;
    },
    depthSort: function() {
      if (this.sortChildrenFlag) {
        StableSort(this.list, this.sortByDepth);
        this.sortChildrenFlag = false;
      }
    },
    sortByDepth: function(childA, childB) {
      return childA._depth - childB._depth;
    },
    getChildren: function() {
      return this.list;
    },
    destroy: function() {
      if (!this.scene || this.ignoreDestroy) {
        return;
      }
      this.emit(GameObjectEvents.DESTROY, this);
      var i = this.list.length;
      while (i--) {
        this.list[i].destroy();
      }
      this.removeAllListeners();
      this.resetPostPipeline(true);
      if (this.displayList) {
        this.displayList.remove(this, true);
        this.displayList.queueDepthSort();
      }
      if (this.data) {
        this.data.destroy();
        this.data = void 0;
      }
      this.active = false;
      this.visible = false;
      this.list = void 0;
      this.scene = void 0;
      this.displayList = void 0;
      this.systems = void 0;
      this.events = void 0;
    }
  });
  module2.exports = Layer;
});

// node_modules/phaser/src/tweens/builders/GetEaseFunction.js
var require_GetEaseFunction = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var EaseMap = require_EaseMap();
  var UppercaseFirst = require_UppercaseFirst();
  var GetEaseFunction = function(ease, easeParams) {
    var easeFunction = EaseMap.Power0;
    if (typeof ease === "string") {
      if (EaseMap.hasOwnProperty(ease)) {
        easeFunction = EaseMap[ease];
      } else {
        var direction = "";
        if (ease.indexOf(".")) {
          direction = ease.substr(ease.indexOf(".") + 1);
          if (direction.toLowerCase() === "in") {
            direction = "easeIn";
          } else if (direction.toLowerCase() === "out") {
            direction = "easeOut";
          } else if (direction.toLowerCase() === "inout") {
            direction = "easeInOut";
          }
        }
        ease = UppercaseFirst(ease.substr(0, ease.indexOf(".") + 1) + direction);
        if (EaseMap.hasOwnProperty(ease)) {
          easeFunction = EaseMap[ease];
        }
      }
    } else if (typeof ease === "function") {
      easeFunction = ease;
    } else if (Array.isArray(ease) && ease.length === 4) {
    }
    if (!easeParams) {
      return easeFunction;
    }
    var cloneParams = easeParams.slice(0);
    cloneParams.unshift(0);
    return function(v) {
      cloneParams[0] = v;
      return easeFunction.apply(this, cloneParams);
    };
  };
  module2.exports = GetEaseFunction;
});

// node_modules/phaser/src/gameobjects/particles/EmitterOp.js
var require_EmitterOp = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FloatBetween = require_FloatBetween();
  var GetEaseFunction = require_GetEaseFunction();
  var GetFastValue = require_GetFastValue();
  var Wrap = require_Wrap();
  var EmitterOp = new Class({
    initialize: function EmitterOp2(config2, key, defaultValue, emitOnly) {
      if (emitOnly === void 0) {
        emitOnly = false;
      }
      this.propertyKey = key;
      this.propertyValue = defaultValue;
      this.defaultValue = defaultValue;
      this.steps = 0;
      this.counter = 0;
      this.start = 0;
      this.end = 0;
      this.ease;
      this.emitOnly = emitOnly;
      this.onEmit = this.defaultEmit;
      this.onUpdate = this.defaultUpdate;
      this.loadConfig(config2);
    },
    loadConfig: function(config2, newKey) {
      if (config2 === void 0) {
        config2 = {};
      }
      if (newKey) {
        this.propertyKey = newKey;
      }
      this.propertyValue = GetFastValue(config2, this.propertyKey, this.defaultValue);
      this.setMethods();
      if (this.emitOnly) {
        this.onUpdate = this.defaultUpdate;
      }
    },
    toJSON: function() {
      return this.propertyValue;
    },
    onChange: function(value) {
      this.propertyValue = value;
      return this.setMethods();
    },
    setMethods: function() {
      var value = this.propertyValue;
      var t = typeof value;
      this.onEmit = this.defaultEmit;
      this.onUpdate = this.defaultUpdate;
      if (t === "number") {
        this.onEmit = this.staticValueEmit;
        this.onUpdate = this.staticValueUpdate;
      } else if (Array.isArray(value)) {
        this.onEmit = this.randomStaticValueEmit;
      } else if (t === "function") {
        if (this.emitOnly) {
          this.onEmit = value;
        } else {
          this.onUpdate = value;
        }
      } else if (t === "object" && this.hasBoth(value, "start", "end")) {
        this.start = value.start;
        this.end = value.end;
        var isRandom = this.has(value, "random");
        if (isRandom) {
          this.onEmit = this.randomRangedValueEmit;
        }
        if (this.has(value, "steps")) {
          this.steps = value.steps;
          this.counter = this.start;
          this.onEmit = this.steppedEmit;
        } else {
          var easeType = this.has(value, "ease") ? value.ease : "Linear";
          this.ease = GetEaseFunction(easeType, value.easeParams);
          if (!isRandom) {
            this.onEmit = this.easedValueEmit;
          }
          this.onUpdate = this.easeValueUpdate;
        }
      } else if (t === "object" && this.hasBoth(value, "min", "max")) {
        this.start = value.min;
        this.end = value.max;
        this.onEmit = this.randomRangedValueEmit;
      } else if (t === "object" && this.has(value, "random")) {
        var rnd = value.random;
        if (Array.isArray(rnd)) {
          this.start = rnd[0];
          this.end = rnd[1];
        }
        this.onEmit = this.randomRangedValueEmit;
      } else if (t === "object" && this.hasEither(value, "onEmit", "onUpdate")) {
        if (this.has(value, "onEmit")) {
          this.onEmit = value.onEmit;
        }
        if (this.has(value, "onUpdate")) {
          this.onUpdate = value.onUpdate;
        }
      }
      return this;
    },
    has: function(object, key) {
      return object.hasOwnProperty(key);
    },
    hasBoth: function(object, key1, key2) {
      return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);
    },
    hasEither: function(object, key1, key2) {
      return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);
    },
    defaultEmit: function(particle, key, value) {
      return value;
    },
    defaultUpdate: function(particle, key, t, value) {
      return value;
    },
    staticValueEmit: function() {
      return this.propertyValue;
    },
    staticValueUpdate: function() {
      return this.propertyValue;
    },
    randomStaticValueEmit: function() {
      var randomIndex = Math.floor(Math.random() * this.propertyValue.length);
      return this.propertyValue[randomIndex];
    },
    randomRangedValueEmit: function(particle, key) {
      var value = FloatBetween(this.start, this.end);
      if (particle && particle.data[key]) {
        particle.data[key].min = value;
      }
      return value;
    },
    steppedEmit: function() {
      var current = this.counter;
      var next = this.counter + (this.end - this.start) / this.steps;
      this.counter = Wrap(next, this.start, this.end);
      return current;
    },
    easedValueEmit: function(particle, key) {
      if (particle && particle.data[key]) {
        var data = particle.data[key];
        data.min = this.start;
        data.max = this.end;
      }
      return this.start;
    },
    easeValueUpdate: function(particle, key, t) {
      var data = particle.data[key];
      return (data.max - data.min) * this.ease(t) + data.min;
    }
  });
  module2.exports = EmitterOp;
});

// node_modules/phaser/src/gameobjects/particles/GravityWell.js
var require_GravityWell = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetFastValue = require_GetFastValue();
  var GravityWell = new Class({
    initialize: function GravityWell2(x, y, power, epsilon, gravity) {
      if (typeof x === "object") {
        var config2 = x;
        x = GetFastValue(config2, "x", 0);
        y = GetFastValue(config2, "y", 0);
        power = GetFastValue(config2, "power", 0);
        epsilon = GetFastValue(config2, "epsilon", 100);
        gravity = GetFastValue(config2, "gravity", 50);
      } else {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (power === void 0) {
          power = 0;
        }
        if (epsilon === void 0) {
          epsilon = 100;
        }
        if (gravity === void 0) {
          gravity = 50;
        }
      }
      this.x = x;
      this.y = y;
      this.active = true;
      this._gravity = gravity;
      this._power = 0;
      this._epsilon = 0;
      this.power = power;
      this.epsilon = epsilon;
    },
    update: function(particle, delta) {
      var x = this.x - particle.x;
      var y = this.y - particle.y;
      var dSq = x * x + y * y;
      if (dSq === 0) {
        return;
      }
      var d = Math.sqrt(dSq);
      if (dSq < this._epsilon) {
        dSq = this._epsilon;
      }
      var factor = this._power * delta / (dSq * d) * 100;
      particle.velocityX += x * factor;
      particle.velocityY += y * factor;
    },
    epsilon: {
      get: function() {
        return Math.sqrt(this._epsilon);
      },
      set: function(value) {
        this._epsilon = value * value;
      }
    },
    power: {
      get: function() {
        return this._power / this._gravity;
      },
      set: function(value) {
        this._power = value * this._gravity;
      }
    },
    gravity: {
      get: function() {
        return this._gravity;
      },
      set: function(value) {
        var pwr = this.power;
        this._gravity = value;
        this.power = pwr;
      }
    }
  });
  module2.exports = GravityWell;
});

// node_modules/phaser/src/gameobjects/particles/Particle.js
var require_Particle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var DegToRad = require_DegToRad();
  var DistanceBetween = require_DistanceBetween();
  var Particle = new Class({
    initialize: function Particle2(emitter) {
      this.emitter = emitter;
      this.frame = null;
      this.x = 0;
      this.y = 0;
      this.velocityX = 0;
      this.velocityY = 0;
      this.accelerationX = 0;
      this.accelerationY = 0;
      this.maxVelocityX = 1e4;
      this.maxVelocityY = 1e4;
      this.bounce = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.alpha = 1;
      this.angle = 0;
      this.rotation = 0;
      this.tint = 16777215;
      this.life = 1e3;
      this.lifeCurrent = 1e3;
      this.delayCurrent = 0;
      this.lifeT = 0;
      this.data = {
        tint: {min: 16777215, max: 16777215, current: 16777215},
        alpha: {min: 1, max: 1},
        rotate: {min: 0, max: 0},
        scaleX: {min: 1, max: 1},
        scaleY: {min: 1, max: 1}
      };
    },
    isAlive: function() {
      return this.lifeCurrent > 0;
    },
    resetPosition: function() {
      this.x = 0;
      this.y = 0;
    },
    fire: function(x, y) {
      var emitter = this.emitter;
      this.frame = emitter.getFrame();
      if (emitter.emitZone) {
        emitter.emitZone.getPoint(this);
      }
      if (x === void 0) {
        this.x += emitter.x.onEmit(this, "x");
      } else {
        this.x += x;
      }
      if (y === void 0) {
        this.y += emitter.y.onEmit(this, "y");
      } else {
        this.y += y;
      }
      this.life = emitter.lifespan.onEmit(this, "lifespan");
      this.lifeCurrent = this.life;
      this.lifeT = 0;
      var sx = emitter.speedX.onEmit(this, "speedX");
      var sy = emitter.speedY ? emitter.speedY.onEmit(this, "speedY") : sx;
      if (emitter.radial) {
        var rad = DegToRad(emitter.angle.onEmit(this, "angle"));
        this.velocityX = Math.cos(rad) * Math.abs(sx);
        this.velocityY = Math.sin(rad) * Math.abs(sy);
      } else if (emitter.moveTo) {
        var mx = emitter.moveToX.onEmit(this, "moveToX");
        var my = emitter.moveToY ? emitter.moveToY.onEmit(this, "moveToY") : mx;
        var angle = Math.atan2(my - this.y, mx - this.x);
        var speed = DistanceBetween(this.x, this.y, mx, my) / (this.life / 1e3);
        this.velocityX = Math.cos(angle) * speed;
        this.velocityY = Math.sin(angle) * speed;
      } else {
        this.velocityX = sx;
        this.velocityY = sy;
      }
      if (emitter.acceleration) {
        this.accelerationX = emitter.accelerationX.onEmit(this, "accelerationX");
        this.accelerationY = emitter.accelerationY.onEmit(this, "accelerationY");
      }
      this.maxVelocityX = emitter.maxVelocityX.onEmit(this, "maxVelocityX");
      this.maxVelocityY = emitter.maxVelocityY.onEmit(this, "maxVelocityY");
      this.delayCurrent = emitter.delay.onEmit(this, "delay");
      this.scaleX = emitter.scaleX.onEmit(this, "scaleX");
      this.scaleY = emitter.scaleY ? emitter.scaleY.onEmit(this, "scaleY") : this.scaleX;
      this.angle = emitter.rotate.onEmit(this, "rotate");
      this.rotation = DegToRad(this.angle);
      this.bounce = emitter.bounce.onEmit(this, "bounce");
      this.alpha = emitter.alpha.onEmit(this, "alpha");
      this.tint = emitter.tint.onEmit(this, "tint");
    },
    computeVelocity: function(emitter, delta, step, processors) {
      var vx = this.velocityX;
      var vy = this.velocityY;
      var ax = this.accelerationX;
      var ay = this.accelerationY;
      var mx = this.maxVelocityX;
      var my = this.maxVelocityY;
      vx += emitter.gravityX * step;
      vy += emitter.gravityY * step;
      if (ax) {
        vx += ax * step;
      }
      if (ay) {
        vy += ay * step;
      }
      if (vx > mx) {
        vx = mx;
      } else if (vx < -mx) {
        vx = -mx;
      }
      if (vy > my) {
        vy = my;
      } else if (vy < -my) {
        vy = -my;
      }
      this.velocityX = vx;
      this.velocityY = vy;
      for (var i = 0; i < processors.length; i++) {
        processors[i].update(this, delta, step);
      }
    },
    checkBounds: function(emitter) {
      var bounds = emitter.bounds;
      var bounce = -this.bounce;
      if (this.x < bounds.x && emitter.collideLeft) {
        this.x = bounds.x;
        this.velocityX *= bounce;
      } else if (this.x > bounds.right && emitter.collideRight) {
        this.x = bounds.right;
        this.velocityX *= bounce;
      }
      if (this.y < bounds.y && emitter.collideTop) {
        this.y = bounds.y;
        this.velocityY *= bounce;
      } else if (this.y > bounds.bottom && emitter.collideBottom) {
        this.y = bounds.bottom;
        this.velocityY *= bounce;
      }
    },
    update: function(delta, step, processors) {
      if (this.delayCurrent > 0) {
        this.delayCurrent -= delta;
        return false;
      }
      var emitter = this.emitter;
      var t = 1 - this.lifeCurrent / this.life;
      this.lifeT = t;
      this.computeVelocity(emitter, delta, step, processors);
      this.x += this.velocityX * step;
      this.y += this.velocityY * step;
      if (emitter.bounds) {
        this.checkBounds(emitter);
      }
      if (emitter.deathZone && emitter.deathZone.willKill(this)) {
        this.lifeCurrent = 0;
        return true;
      }
      this.scaleX = emitter.scaleX.onUpdate(this, "scaleX", t, this.scaleX);
      if (emitter.scaleY) {
        this.scaleY = emitter.scaleY.onUpdate(this, "scaleY", t, this.scaleY);
      } else {
        this.scaleY = this.scaleX;
      }
      this.angle = emitter.rotate.onUpdate(this, "rotate", t, this.angle);
      this.rotation = DegToRad(this.angle);
      this.alpha = emitter.alpha.onUpdate(this, "alpha", t, this.alpha);
      this.tint = emitter.tint.onUpdate(this, "tint", t, this.tint);
      this.lifeCurrent -= delta;
      return this.lifeCurrent <= 0;
    }
  });
  module2.exports = Particle;
});

// node_modules/phaser/src/gameobjects/particles/zones/DeathZone.js
var require_DeathZone = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var DeathZone = new Class({
    initialize: function DeathZone2(source, killOnEnter) {
      this.source = source;
      this.killOnEnter = killOnEnter;
    },
    willKill: function(particle) {
      var withinZone = this.source.contains(particle.x, particle.y);
      return withinZone && this.killOnEnter || !withinZone && !this.killOnEnter;
    }
  });
  module2.exports = DeathZone;
});

// node_modules/phaser/src/gameobjects/particles/zones/EdgeZone.js
var require_EdgeZone = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var EdgeZone = new Class({
    initialize: function EdgeZone2(source, quantity, stepRate, yoyo, seamless) {
      if (yoyo === void 0) {
        yoyo = false;
      }
      if (seamless === void 0) {
        seamless = true;
      }
      this.source = source;
      this.points = [];
      this.quantity = quantity;
      this.stepRate = stepRate;
      this.yoyo = yoyo;
      this.counter = -1;
      this.seamless = seamless;
      this._length = 0;
      this._direction = 0;
      this.updateSource();
    },
    updateSource: function() {
      this.points = this.source.getPoints(this.quantity, this.stepRate);
      if (this.seamless) {
        var a = this.points[0];
        var b = this.points[this.points.length - 1];
        if (a.x === b.x && a.y === b.y) {
          this.points.pop();
        }
      }
      var oldLength = this._length;
      this._length = this.points.length;
      if (this._length < oldLength && this.counter > this._length) {
        this.counter = this._length - 1;
      }
      return this;
    },
    changeSource: function(source) {
      this.source = source;
      return this.updateSource();
    },
    getPoint: function(particle) {
      if (this._direction === 0) {
        this.counter++;
        if (this.counter >= this._length) {
          if (this.yoyo) {
            this._direction = 1;
            this.counter = this._length - 1;
          } else {
            this.counter = 0;
          }
        }
      } else {
        this.counter--;
        if (this.counter === -1) {
          if (this.yoyo) {
            this._direction = 0;
            this.counter = 0;
          } else {
            this.counter = this._length - 1;
          }
        }
      }
      var point = this.points[this.counter];
      if (point) {
        particle.x = point.x;
        particle.y = point.y;
      }
    }
  });
  module2.exports = EdgeZone;
});

// node_modules/phaser/src/utils/object/HasAny.js
var require_HasAny = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var HasAny = function(source, keys) {
    for (var i = 0; i < keys.length; i++) {
      if (source.hasOwnProperty(keys[i])) {
        return true;
      }
    }
    return false;
  };
  module2.exports = HasAny;
});

// node_modules/phaser/src/utils/object/HasValue.js
var require_HasValue = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var HasValue = function(source, key) {
    return source.hasOwnProperty(key);
  };
  module2.exports = HasValue;
});

// node_modules/phaser/src/gameobjects/particles/zones/RandomZone.js
var require_RandomZone = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Vector2 = require_Vector2();
  var RandomZone = new Class({
    initialize: function RandomZone2(source) {
      this.source = source;
      this._tempVec = new Vector2();
    },
    getPoint: function(particle) {
      var vec = this._tempVec;
      this.source.getRandomPoint(vec);
      particle.x = vec.x;
      particle.y = vec.y;
    }
  });
  module2.exports = RandomZone;
});

// node_modules/phaser/src/gameobjects/particles/ParticleEmitter.js
var require_ParticleEmitter = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BlendModes = require_BlendModes();
  var Class = require_Class();
  var Components = require_components();
  var DeathZone = require_DeathZone();
  var EdgeZone = require_EdgeZone();
  var EmitterOp = require_EmitterOp();
  var GetFastValue = require_GetFastValue();
  var GetRandom = require_GetRandom();
  var HasAny = require_HasAny();
  var HasValue = require_HasValue();
  var Particle = require_Particle();
  var RandomZone = require_RandomZone();
  var Rectangle = require_Rectangle();
  var StableSort = require_StableSort();
  var Vector2 = require_Vector2();
  var Wrap = require_Wrap();
  var ParticleEmitter = new Class({
    Mixins: [
      Components.BlendMode,
      Components.Mask,
      Components.ScrollFactor,
      Components.Visible
    ],
    initialize: function ParticleEmitter2(manager, config2) {
      this.manager = manager;
      this.texture = manager.texture;
      this.frames = [manager.defaultFrame];
      this.defaultFrame = manager.defaultFrame;
      this.configFastMap = [
        "active",
        "blendMode",
        "collideBottom",
        "collideLeft",
        "collideRight",
        "collideTop",
        "deathCallback",
        "deathCallbackScope",
        "emitCallback",
        "emitCallbackScope",
        "follow",
        "frequency",
        "gravityX",
        "gravityY",
        "maxParticles",
        "name",
        "on",
        "particleBringToTop",
        "particleClass",
        "radial",
        "timeScale",
        "trackVisible",
        "visible"
      ];
      this.configOpMap = [
        "accelerationX",
        "accelerationY",
        "angle",
        "alpha",
        "bounce",
        "delay",
        "lifespan",
        "maxVelocityX",
        "maxVelocityY",
        "moveToX",
        "moveToY",
        "quantity",
        "rotate",
        "scaleX",
        "scaleY",
        "speedX",
        "speedY",
        "tint",
        "x",
        "y"
      ];
      this.name = "";
      this.particleClass = Particle;
      this.x = new EmitterOp(config2, "x", 0, true);
      this.y = new EmitterOp(config2, "y", 0, true);
      this.radial = true;
      this.gravityX = 0;
      this.gravityY = 0;
      this.acceleration = false;
      this.accelerationX = new EmitterOp(config2, "accelerationX", 0, true);
      this.accelerationY = new EmitterOp(config2, "accelerationY", 0, true);
      this.maxVelocityX = new EmitterOp(config2, "maxVelocityX", 1e4, true);
      this.maxVelocityY = new EmitterOp(config2, "maxVelocityY", 1e4, true);
      this.speedX = new EmitterOp(config2, "speedX", 0, true);
      this.speedY = new EmitterOp(config2, "speedY", 0, true);
      this.moveTo = false;
      this.moveToX = new EmitterOp(config2, "moveToX", 0, true);
      this.moveToY = new EmitterOp(config2, "moveToY", 0, true);
      this.bounce = new EmitterOp(config2, "bounce", 0, true);
      this.scaleX = new EmitterOp(config2, "scaleX", 1);
      this.scaleY = new EmitterOp(config2, "scaleY", 1);
      this.tint = new EmitterOp(config2, "tint", 16777215);
      this.alpha = new EmitterOp(config2, "alpha", 1);
      this.lifespan = new EmitterOp(config2, "lifespan", 1e3, true);
      this.angle = new EmitterOp(config2, "angle", {min: 0, max: 360}, true);
      this.rotate = new EmitterOp(config2, "rotate", 0);
      this.emitCallback = null;
      this.emitCallbackScope = null;
      this.deathCallback = null;
      this.deathCallbackScope = null;
      this.maxParticles = 0;
      this.quantity = new EmitterOp(config2, "quantity", 1, true);
      this.delay = new EmitterOp(config2, "delay", 0, true);
      this.frequency = 0;
      this.on = true;
      this.particleBringToTop = true;
      this.timeScale = 1;
      this.emitZone = null;
      this.deathZone = null;
      this.bounds = null;
      this.collideLeft = true;
      this.collideRight = true;
      this.collideTop = true;
      this.collideBottom = true;
      this.active = true;
      this.visible = true;
      this.blendMode = BlendModes.NORMAL;
      this.follow = null;
      this.followOffset = new Vector2();
      this.trackVisible = false;
      this.currentFrame = 0;
      this.randomFrame = true;
      this.frameQuantity = 1;
      this.dead = [];
      this.alive = [];
      this._counter = 0;
      this._frameCounter = 0;
      if (config2) {
        this.fromJSON(config2);
      }
    },
    fromJSON: function(config2) {
      if (!config2) {
        return this;
      }
      var i = 0;
      var key = "";
      for (i = 0; i < this.configFastMap.length; i++) {
        key = this.configFastMap[i];
        if (HasValue(config2, key)) {
          this[key] = GetFastValue(config2, key);
        }
      }
      for (i = 0; i < this.configOpMap.length; i++) {
        key = this.configOpMap[i];
        if (HasValue(config2, key)) {
          this[key].loadConfig(config2);
        }
      }
      this.acceleration = this.accelerationX.propertyValue !== 0 || this.accelerationY.propertyValue !== 0;
      this.moveTo = this.moveToX.propertyValue !== 0 || this.moveToY.propertyValue !== 0;
      if (HasValue(config2, "speed")) {
        this.speedX.loadConfig(config2, "speed");
        this.speedY = null;
      }
      if (HasAny(config2, ["speedX", "speedY"]) || this.moveTo) {
        this.radial = false;
      }
      if (HasValue(config2, "scale")) {
        this.scaleX.loadConfig(config2, "scale");
        this.scaleY = null;
      }
      if (HasValue(config2, "callbackScope")) {
        var callbackScope = GetFastValue(config2, "callbackScope", null);
        this.emitCallbackScope = callbackScope;
        this.deathCallbackScope = callbackScope;
      }
      if (HasValue(config2, "emitZone")) {
        this.setEmitZone(config2.emitZone);
      }
      if (HasValue(config2, "deathZone")) {
        this.setDeathZone(config2.deathZone);
      }
      if (HasValue(config2, "bounds")) {
        this.setBounds(config2.bounds);
      }
      if (HasValue(config2, "followOffset")) {
        this.followOffset.setFromObject(GetFastValue(config2, "followOffset", 0));
      }
      if (HasValue(config2, "frame")) {
        this.setFrame(config2.frame);
      }
      if (HasValue(config2, "reserve")) {
        this.reserve(config2.reserve);
      }
      return this;
    },
    toJSON: function(output) {
      if (output === void 0) {
        output = {};
      }
      var i = 0;
      var key = "";
      for (i = 0; i < this.configFastMap.length; i++) {
        key = this.configFastMap[i];
        output[key] = this[key];
      }
      for (i = 0; i < this.configOpMap.length; i++) {
        key = this.configOpMap[i];
        if (this[key]) {
          output[key] = this[key].toJSON();
        }
      }
      if (!this.speedY) {
        delete output.speedX;
        output.speed = this.speedX.toJSON();
      }
      if (!this.scaleY) {
        delete output.scaleX;
        output.scale = this.scaleX.toJSON();
      }
      return output;
    },
    startFollow: function(target, offsetX, offsetY, trackVisible) {
      if (offsetX === void 0) {
        offsetX = 0;
      }
      if (offsetY === void 0) {
        offsetY = 0;
      }
      if (trackVisible === void 0) {
        trackVisible = false;
      }
      this.follow = target;
      this.followOffset.set(offsetX, offsetY);
      this.trackVisible = trackVisible;
      return this;
    },
    stopFollow: function() {
      this.follow = null;
      this.followOffset.set(0, 0);
      this.trackVisible = false;
      return this;
    },
    getFrame: function() {
      if (this.frames.length === 1) {
        return this.defaultFrame;
      } else if (this.randomFrame) {
        return GetRandom(this.frames);
      } else {
        var frame = this.frames[this.currentFrame];
        this._frameCounter++;
        if (this._frameCounter === this.frameQuantity) {
          this._frameCounter = 0;
          this.currentFrame = Wrap(this.currentFrame + 1, 0, this._frameLength);
        }
        return frame;
      }
    },
    setFrame: function(frames, pickRandom, quantity) {
      if (pickRandom === void 0) {
        pickRandom = true;
      }
      if (quantity === void 0) {
        quantity = 1;
      }
      this.randomFrame = pickRandom;
      this.frameQuantity = quantity;
      this.currentFrame = 0;
      this._frameCounter = 0;
      var t = typeof frames;
      if (Array.isArray(frames) || t === "string" || t === "number") {
        this.manager.setEmitterFrames(frames, this);
      } else if (t === "object") {
        var frameConfig = frames;
        frames = GetFastValue(frameConfig, "frames", null);
        if (frames) {
          this.manager.setEmitterFrames(frames, this);
        }
        var isCycle = GetFastValue(frameConfig, "cycle", false);
        this.randomFrame = isCycle ? false : true;
        this.frameQuantity = GetFastValue(frameConfig, "quantity", quantity);
      }
      this._frameLength = this.frames.length;
      if (this._frameLength === 1) {
        this.frameQuantity = 1;
        this.randomFrame = false;
      }
      return this;
    },
    setRadial: function(value) {
      if (value === void 0) {
        value = true;
      }
      this.radial = value;
      return this;
    },
    setPosition: function(x, y) {
      this.x.onChange(x);
      this.y.onChange(y);
      return this;
    },
    setBounds: function(x, y, width, height) {
      if (typeof x === "object") {
        var obj = x;
        x = obj.x;
        y = obj.y;
        width = HasValue(obj, "w") ? obj.w : obj.width;
        height = HasValue(obj, "h") ? obj.h : obj.height;
      }
      if (this.bounds) {
        this.bounds.setTo(x, y, width, height);
      } else {
        this.bounds = new Rectangle(x, y, width, height);
      }
      return this;
    },
    setSpeedX: function(value) {
      this.speedX.onChange(value);
      this.radial = false;
      return this;
    },
    setSpeedY: function(value) {
      if (this.speedY) {
        this.speedY.onChange(value);
        this.radial = false;
      }
      return this;
    },
    setSpeed: function(value) {
      this.speedX.onChange(value);
      this.speedY = null;
      this.radial = true;
      return this;
    },
    setScaleX: function(value) {
      this.scaleX.onChange(value);
      return this;
    },
    setScaleY: function(value) {
      this.scaleY.onChange(value);
      return this;
    },
    setScale: function(value) {
      this.scaleX.onChange(value);
      this.scaleY = null;
      return this;
    },
    setGravityX: function(value) {
      this.gravityX = value;
      return this;
    },
    setGravityY: function(value) {
      this.gravityY = value;
      return this;
    },
    setGravity: function(x, y) {
      this.gravityX = x;
      this.gravityY = y;
      return this;
    },
    setAlpha: function(value) {
      this.alpha.onChange(value);
      return this;
    },
    setTint: function(value) {
      this.tint.onChange(value);
      return this;
    },
    setEmitterAngle: function(value) {
      this.angle.onChange(value);
      return this;
    },
    setAngle: function(value) {
      this.angle.onChange(value);
      return this;
    },
    setLifespan: function(value) {
      this.lifespan.onChange(value);
      return this;
    },
    setQuantity: function(quantity) {
      this.quantity.onChange(quantity);
      return this;
    },
    setFrequency: function(frequency, quantity) {
      this.frequency = frequency;
      this._counter = 0;
      if (quantity) {
        this.quantity.onChange(quantity);
      }
      return this;
    },
    setEmitZone: function(zoneConfig) {
      if (zoneConfig === void 0) {
        this.emitZone = null;
      } else {
        var type = GetFastValue(zoneConfig, "type", "random");
        var source = GetFastValue(zoneConfig, "source", null);
        switch (type) {
          case "random":
            this.emitZone = new RandomZone(source);
            break;
          case "edge":
            var quantity = GetFastValue(zoneConfig, "quantity", 1);
            var stepRate = GetFastValue(zoneConfig, "stepRate", 0);
            var yoyo = GetFastValue(zoneConfig, "yoyo", false);
            var seamless = GetFastValue(zoneConfig, "seamless", true);
            this.emitZone = new EdgeZone(source, quantity, stepRate, yoyo, seamless);
            break;
        }
      }
      return this;
    },
    setDeathZone: function(zoneConfig) {
      if (zoneConfig === void 0) {
        this.deathZone = null;
      } else {
        var type = GetFastValue(zoneConfig, "type", "onEnter");
        var source = GetFastValue(zoneConfig, "source", null);
        if (source && typeof source.contains === "function") {
          var killOnEnter = type === "onEnter" ? true : false;
          this.deathZone = new DeathZone(source, killOnEnter);
        }
      }
      return this;
    },
    reserve: function(particleCount) {
      var dead = this.dead;
      for (var i = 0; i < particleCount; i++) {
        dead.push(new this.particleClass(this));
      }
      return this;
    },
    getAliveParticleCount: function() {
      return this.alive.length;
    },
    getDeadParticleCount: function() {
      return this.dead.length;
    },
    getParticleCount: function() {
      return this.getAliveParticleCount() + this.getDeadParticleCount();
    },
    atLimit: function() {
      return this.maxParticles > 0 && this.getParticleCount() === this.maxParticles;
    },
    onParticleEmit: function(callback, context) {
      if (callback === void 0) {
        this.emitCallback = null;
        this.emitCallbackScope = null;
      } else if (typeof callback === "function") {
        this.emitCallback = callback;
        if (context) {
          this.emitCallbackScope = context;
        }
      }
      return this;
    },
    onParticleDeath: function(callback, context) {
      if (callback === void 0) {
        this.deathCallback = null;
        this.deathCallbackScope = null;
      } else if (typeof callback === "function") {
        this.deathCallback = callback;
        if (context) {
          this.deathCallbackScope = context;
        }
      }
      return this;
    },
    killAll: function() {
      var dead = this.dead;
      var alive = this.alive;
      while (alive.length > 0) {
        dead.push(alive.pop());
      }
      return this;
    },
    forEachAlive: function(callback, context) {
      var alive = this.alive;
      var length = alive.length;
      for (var index = 0; index < length; ++index) {
        callback.call(context, alive[index], this);
      }
      return this;
    },
    forEachDead: function(callback, context) {
      var dead = this.dead;
      var length = dead.length;
      for (var index = 0; index < length; ++index) {
        callback.call(context, dead[index], this);
      }
      return this;
    },
    start: function() {
      this.on = true;
      this._counter = 0;
      return this;
    },
    stop: function() {
      this.on = false;
      return this;
    },
    pause: function() {
      this.active = false;
      return this;
    },
    resume: function() {
      this.active = true;
      return this;
    },
    remove: function() {
      this.manager.removeEmitter(this);
      return this;
    },
    depthSort: function() {
      StableSort(this.alive, this.depthSortCallback);
      return this;
    },
    flow: function(frequency, count) {
      if (count === void 0) {
        count = 1;
      }
      this.frequency = frequency;
      this.quantity.onChange(count);
      return this.start();
    },
    explode: function(count, x, y) {
      this.frequency = -1;
      return this.emitParticle(count, x, y);
    },
    emitParticleAt: function(x, y, count) {
      return this.emitParticle(count, x, y);
    },
    emitParticle: function(count, x, y) {
      if (this.atLimit()) {
        return;
      }
      if (count === void 0) {
        count = this.quantity.onEmit();
      }
      var dead = this.dead;
      var followX = this.follow ? this.follow.x + this.followOffset.x : x;
      var followY = this.follow ? this.follow.y + this.followOffset.y : y;
      for (var i = 0; i < count; i++) {
        var particle = dead.pop();
        if (!particle) {
          particle = new this.particleClass(this);
        }
        particle.fire(followX, followY);
        if (this.particleBringToTop) {
          this.alive.push(particle);
        } else {
          this.alive.unshift(particle);
        }
        if (this.emitCallback) {
          this.emitCallback.call(this.emitCallbackScope, particle, this);
        }
        if (this.atLimit()) {
          break;
        }
      }
      return particle;
    },
    preUpdate: function(time, delta) {
      delta *= this.timeScale;
      var step = delta / 1e3;
      if (this.trackVisible) {
        this.visible = this.follow.visible;
      }
      var processors = this.manager.getProcessors();
      var particles = this.alive;
      var dead = this.dead;
      var i = 0;
      var rip = [];
      var length = particles.length;
      for (i = 0; i < length; i++) {
        var particle = particles[i];
        if (particle.update(delta, step, processors)) {
          rip.push({index: i, particle});
        }
      }
      length = rip.length;
      if (length > 0) {
        var deathCallback = this.deathCallback;
        var deathCallbackScope = this.deathCallbackScope;
        for (i = length - 1; i >= 0; i--) {
          var entry = rip[i];
          particles.splice(entry.index, 1);
          dead.push(entry.particle);
          if (deathCallback) {
            deathCallback.call(deathCallbackScope, entry.particle);
          }
          entry.particle.resetPosition();
        }
      }
      if (!this.on) {
        return;
      }
      if (this.frequency === 0) {
        this.emitParticle();
      } else if (this.frequency > 0) {
        this._counter -= delta;
        if (this._counter <= 0) {
          this.emitParticle();
          this._counter = this.frequency - Math.abs(this._counter);
        }
      }
    },
    depthSortCallback: function(a, b) {
      return a.y - b.y;
    }
  });
  module2.exports = ParticleEmitter;
});

// node_modules/phaser/src/gameobjects/particles/ParticleManagerWebGLRenderer.js
var require_ParticleManagerWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TransformMatrix = require_TransformMatrix();
  var Utils = require_Utils();
  var tempMatrix1 = new TransformMatrix();
  var tempMatrix2 = new TransformMatrix();
  var tempMatrix3 = new TransformMatrix();
  var tempMatrix4 = new TransformMatrix();
  var ParticleManagerWebGLRenderer = function(renderer, emitterManager, camera, parentMatrix) {
    var emitters = emitterManager.emitters.list;
    var emittersLength = emitters.length;
    if (emittersLength === 0) {
      return;
    }
    var pipeline = renderer.pipelines.set(emitterManager.pipeline);
    var camMatrix = tempMatrix1;
    var calcMatrix = tempMatrix2;
    var particleMatrix = tempMatrix3;
    var managerMatrix = tempMatrix4;
    if (parentMatrix) {
      managerMatrix.loadIdentity();
      managerMatrix.multiply(parentMatrix);
      managerMatrix.translate(emitterManager.x, emitterManager.y);
      managerMatrix.rotate(emitterManager.rotation);
      managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY);
    } else {
      managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);
    }
    var roundPixels = camera.roundPixels;
    var texture = emitterManager.defaultFrame.glTexture;
    var getTint = Utils.getTintAppendFloatAlpha;
    var textureUnit = pipeline.setGameObject(emitterManager, emitterManager.defaultFrame);
    renderer.pipelines.preBatch(emitterManager);
    for (var e = 0; e < emittersLength; e++) {
      var emitter = emitters[e];
      var particles = emitter.alive;
      var particleCount = particles.length;
      if (!emitter.visible || particleCount === 0) {
        continue;
      }
      camera.addToRenderList(emitter);
      var scrollFactorX = emitter.scrollFactorX;
      var scrollFactorY = emitter.scrollFactorY;
      renderer.setBlendMode(emitter.blendMode);
      if (emitter.mask) {
        emitter.mask.preRenderWebGL(renderer, emitter, camera);
        renderer.pipelines.set(emitterManager.pipeline);
      }
      var tintEffect = 0;
      for (var i = 0; i < particleCount; i++) {
        var particle = particles[i];
        var alpha = particle.alpha * camera.alpha;
        if (alpha <= 0) {
          continue;
        }
        particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);
        camMatrix.copyFrom(camera.matrix);
        camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
        particleMatrix.e = particle.x;
        particleMatrix.f = particle.y;
        camMatrix.multiply(particleMatrix, calcMatrix);
        var frame = particle.frame;
        var x = -frame.halfWidth;
        var y = -frame.halfHeight;
        var xw = x + frame.width;
        var yh = y + frame.height;
        var tx0 = calcMatrix.getXRound(x, y, roundPixels);
        var ty0 = calcMatrix.getYRound(x, y, roundPixels);
        var tx1 = calcMatrix.getXRound(x, yh, roundPixels);
        var ty1 = calcMatrix.getYRound(x, yh, roundPixels);
        var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);
        var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);
        var tx3 = calcMatrix.getXRound(xw, y, roundPixels);
        var ty3 = calcMatrix.getYRound(xw, y, roundPixels);
        var tint = getTint(particle.tint, alpha);
        pipeline.batchQuad(emitter, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, texture, textureUnit);
      }
      if (emitter.mask) {
        emitter.mask.postRenderWebGL(renderer, camera);
      }
    }
    renderer.pipelines.postBatch(emitterManager);
  };
  module2.exports = ParticleManagerWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/particles/ParticleManagerCanvasRenderer.js
var require_ParticleManagerCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TransformMatrix = require_TransformMatrix();
  var tempMatrix1 = new TransformMatrix();
  var tempMatrix2 = new TransformMatrix();
  var tempMatrix3 = new TransformMatrix();
  var tempMatrix4 = new TransformMatrix();
  var ParticleManagerCanvasRenderer = function(renderer, emitterManager, camera, parentMatrix) {
    var emitters = emitterManager.emitters.list;
    var emittersLength = emitters.length;
    if (emittersLength === 0) {
      return;
    }
    var camMatrix = tempMatrix1.copyFrom(camera.matrix);
    var calcMatrix = tempMatrix2;
    var particleMatrix = tempMatrix3;
    var managerMatrix = tempMatrix4;
    if (parentMatrix) {
      managerMatrix.loadIdentity();
      managerMatrix.multiply(parentMatrix);
      managerMatrix.translate(emitterManager.x, emitterManager.y);
      managerMatrix.rotate(emitterManager.rotation);
      managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY);
    } else {
      managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);
    }
    var ctx = renderer.currentContext;
    var roundPixels = camera.roundPixels;
    for (var e = 0; e < emittersLength; e++) {
      var emitter = emitters[e];
      var particles = emitter.alive;
      var particleCount = particles.length;
      if (!emitter.visible || particleCount === 0) {
        continue;
      }
      camera.addToRenderList(emitter);
      var scrollFactorX = emitter.scrollFactorX;
      var scrollFactorY = emitter.scrollFactorY;
      ctx.save();
      ctx.globalCompositeOperation = renderer.blendModes[emitter.blendMode];
      for (var i = 0; i < particleCount; i++) {
        var particle = particles[i];
        var alpha = particle.alpha * camera.alpha;
        if (alpha <= 0) {
          continue;
        }
        particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);
        camMatrix.copyFrom(camera.matrix);
        camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);
        particleMatrix.e = particle.x;
        particleMatrix.f = particle.y;
        camMatrix.multiply(particleMatrix, calcMatrix);
        var frame = particle.frame;
        var cd = frame.canvasData;
        var x = -frame.halfWidth;
        var y = -frame.halfHeight;
        ctx.globalAlpha = alpha;
        ctx.save();
        calcMatrix.setToContext(ctx);
        if (roundPixels) {
          x = Math.round(x);
          y = Math.round(y);
        }
        ctx.imageSmoothingEnabled = !(!renderer.antialias || frame.source.scaleMode);
        ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);
        ctx.restore();
      }
      ctx.restore();
    }
  };
  module2.exports = ParticleManagerCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/particles/ParticleManagerRender.js
var require_ParticleManagerRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_ParticleManagerWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_ParticleManagerCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/particles/ParticleEmitterManager.js
var require_ParticleEmitterManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components();
  var GameObject = require_GameObject();
  var GravityWell = require_GravityWell();
  var List = require_List();
  var ParticleEmitter = require_ParticleEmitter();
  var Render = require_ParticleManagerRender();
  var ParticleEmitterManager = new Class({
    Extends: GameObject,
    Mixins: [
      Components.Depth,
      Components.Mask,
      Components.Pipeline,
      Components.Transform,
      Components.Visible,
      Render
    ],
    initialize: function ParticleEmitterManager2(scene, texture, frame, emitters) {
      GameObject.call(this, scene, "ParticleEmitterManager");
      this.blendMode = -1;
      this.timeScale = 1;
      this.texture = null;
      this.frame = null;
      this.frameNames = [];
      if (frame !== null && (typeof frame === "object" || Array.isArray(frame))) {
        emitters = frame;
        frame = null;
      }
      this.setTexture(texture, frame);
      this.initPipeline();
      this.emitters = new List(this);
      this.wells = new List(this);
      if (emitters) {
        if (!Array.isArray(emitters)) {
          emitters = [emitters];
        }
        for (var i = 0; i < emitters.length; i++) {
          this.createEmitter(emitters[i]);
        }
      }
    },
    addedToScene: function() {
      this.scene.sys.updateList.add(this);
    },
    removedFromScene: function() {
      this.scene.sys.updateList.remove(this);
    },
    setTexture: function(key, frame) {
      this.texture = this.scene.sys.textures.get(key);
      return this.setFrame(frame);
    },
    setFrame: function(frame) {
      this.frame = this.texture.get(frame);
      var frames = this.texture.getFramesFromTextureSource(this.frame.sourceIndex);
      var names = [];
      frames.forEach(function(sourceFrame) {
        names.push(sourceFrame.name);
      });
      this.frameNames = names;
      this.defaultFrame = this.frame;
      return this;
    },
    setEmitterFrames: function(frames, emitter) {
      if (!Array.isArray(frames)) {
        frames = [frames];
      }
      var out = emitter.frames;
      out.length = 0;
      for (var i = 0; i < frames.length; i++) {
        var frame = frames[i];
        if (this.frameNames.indexOf(frame) !== -1) {
          out.push(this.texture.get(frame));
        }
      }
      if (out.length > 0) {
        emitter.defaultFrame = out[0];
      } else {
        emitter.defaultFrame = this.defaultFrame;
      }
      return this;
    },
    addEmitter: function(emitter) {
      return this.emitters.add(emitter);
    },
    createEmitter: function(config2) {
      return this.addEmitter(new ParticleEmitter(this, config2));
    },
    removeEmitter: function(emitter) {
      return this.emitters.remove(emitter, true);
    },
    addGravityWell: function(well) {
      return this.wells.add(well);
    },
    createGravityWell: function(config2) {
      return this.addGravityWell(new GravityWell(config2));
    },
    emitParticle: function(count, x, y) {
      var emitters = this.emitters.list;
      for (var i = 0; i < emitters.length; i++) {
        var emitter = emitters[i];
        if (emitter.active) {
          emitter.emitParticle(count, x, y);
        }
      }
      return this;
    },
    emitParticleAt: function(x, y, count) {
      return this.emitParticle(count, x, y);
    },
    pause: function() {
      this.active = false;
      return this;
    },
    resume: function() {
      this.active = true;
      return this;
    },
    getProcessors: function() {
      return this.wells.getAll("active", true);
    },
    preUpdate: function(time, delta) {
      delta *= this.timeScale;
      var emitters = this.emitters.list;
      for (var i = 0; i < emitters.length; i++) {
        var emitter = emitters[i];
        if (emitter.active) {
          emitter.preUpdate(time, delta);
        }
      }
    },
    setAlpha: function() {
    },
    setScrollFactor: function() {
    },
    setBlendMode: function() {
    }
  });
  module2.exports = ParticleEmitterManager;
});

// node_modules/phaser/src/gameobjects/particles/zones/index.js
var require_zones = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    DeathZone: require_DeathZone(),
    EdgeZone: require_EdgeZone(),
    RandomZone: require_RandomZone()
  };
});

// node_modules/phaser/src/gameobjects/particles/index.js
var require_particles = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    EmitterOp: require_EmitterOp(),
    GravityWell: require_GravityWell(),
    Particle: require_Particle(),
    ParticleEmitter: require_ParticleEmitter(),
    ParticleEmitterManager: require_ParticleEmitterManager(),
    Zones: require_zones()
  };
});

// node_modules/phaser/src/gameobjects/pathfollower/PathFollower.js
var require_PathFollower2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components();
  var Sprite = require_Sprite();
  var PathFollower = new Class({
    Extends: Sprite,
    Mixins: [
      Components.PathFollower
    ],
    initialize: function PathFollower2(scene, path, x, y, texture, frame) {
      Sprite.call(this, scene, x, y, texture, frame);
      this.path = path;
    },
    preUpdate: function(time, delta) {
      this.anims.update(time, delta);
      this.pathUpdate(time);
    }
  });
  module2.exports = PathFollower;
});

// node_modules/phaser/src/gameobjects/rendertexture/RenderTextureWebGLRenderer.js
var require_RenderTextureWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Utils = require_Utils();
  var RenderTextureWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var cameraAlpha = camera.alpha;
    var renderTarget = src.renderTarget;
    var width = renderTarget.width;
    var height = renderTarget.height;
    var getTint = Utils.getTintAppendFloatAlpha;
    var pipeline = renderer.pipelines.set(src.pipeline);
    var textureUnit = pipeline.setTexture2D(renderTarget.texture);
    renderer.pipelines.preBatch(src);
    pipeline.batchTexture(src, renderTarget.texture, width, height, src.x, src.y, width, height, src.scaleX, src.scaleY, src.rotation, src.flipX, !src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, cameraAlpha * src._alphaTL), getTint(src.tintTopRight, cameraAlpha * src._alphaTR), getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL), getTint(src.tintBottomRight, cameraAlpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, true, textureUnit);
    renderer.resetTextures();
    renderer.pipelines.postBatch(src);
  };
  module2.exports = RenderTextureWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/rendertexture/RenderTextureCanvasRenderer.js
var require_RenderTextureCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RenderTextureCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    renderer.batchSprite(src, src.frame, camera, parentMatrix);
  };
  module2.exports = RenderTextureCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/rendertexture/RenderTextureRender.js
var require_RenderTextureRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_RenderTextureWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_RenderTextureCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/utils/string/UUID.js
var require_UUID = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var UUID = function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0;
      var v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  };
  module2.exports = UUID;
});

// node_modules/phaser/src/gameobjects/rendertexture/RenderTexture.js
var require_RenderTexture = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BlendModes = require_BlendModes();
  var Camera = require_BaseCamera();
  var CanvasPool = require_CanvasPool();
  var Class = require_Class();
  var Components = require_components();
  var CONST = require_const();
  var Frame = require_Frame();
  var GameObject = require_GameObject();
  var NOOP = require_NOOP();
  var PIPELINE_CONST = require_const6();
  var Render = require_RenderTextureRender();
  var RenderTarget = require_RenderTarget();
  var Utils = require_Utils();
  var UUID = require_UUID();
  var RenderTexture = new Class({
    Extends: GameObject,
    Mixins: [
      Components.Alpha,
      Components.BlendMode,
      Components.ComputedSize,
      Components.Crop,
      Components.Depth,
      Components.Flip,
      Components.GetBounds,
      Components.Mask,
      Components.Origin,
      Components.Pipeline,
      Components.ScrollFactor,
      Components.Tint,
      Components.Transform,
      Components.Visible,
      Render
    ],
    initialize: function RenderTexture2(scene, x, y, width, height, key, frame) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 32;
      }
      if (height === void 0) {
        height = 32;
      }
      GameObject.call(this, scene, "RenderTexture");
      this.renderer = scene.sys.renderer;
      this.textureManager = scene.sys.textures;
      this.globalTint = 16777215;
      this.globalAlpha = 1;
      this.canvas = null;
      this.dirty = false;
      this._crop = this.resetCropObject();
      this.texture = null;
      this.frame = null;
      this._saved = false;
      if (key === void 0) {
        this.canvas = CanvasPool.create2D(this, width, height);
        this.texture = scene.sys.textures.addCanvas(UUID(), this.canvas);
        this.frame = this.texture.get();
      } else {
        this.texture = scene.sys.textures.get(key);
        this.frame = this.texture.get(frame);
        this.canvas = this.frame.source.image;
        this._saved = true;
        this.dirty = true;
        this.width = this.frame.cutWidth;
        this.height = this.frame.cutHeight;
      }
      this.context = this.canvas.getContext("2d");
      this._eraseMode = false;
      this.camera = new Camera(0, 0, width, height);
      this.renderTarget = null;
      var renderer = this.renderer;
      if (!renderer) {
        this.drawGameObject = NOOP;
      } else if (renderer.type === CONST.WEBGL) {
        this.drawGameObject = this.batchGameObjectWebGL;
        this.renderTarget = new RenderTarget(renderer, width, height, 1, 0, false);
      } else if (renderer.type === CONST.CANVAS) {
        this.drawGameObject = this.batchGameObjectCanvas;
      }
      this.camera.setScene(scene);
      this.setPosition(x, y);
      if (key === void 0) {
        this.setSize(width, height);
      }
      this.setOrigin(0, 0);
      this.initPipeline(PIPELINE_CONST.SINGLE_PIPELINE);
    },
    setSize: function(width, height) {
      return this.resize(width, height);
    },
    resize: function(width, height) {
      if (height === void 0) {
        height = width;
      }
      var frame = this.frame;
      if (width !== this.width || height !== this.height) {
        if (frame.name === "__BASE") {
          this.canvas.width = width;
          this.canvas.height = height;
          this.texture.width = width;
          this.texture.height = height;
          var renderTarget = this.renderTarget;
          if (renderTarget) {
            renderTarget.resize(width, height);
            frame.glTexture = renderTarget.texture;
            frame.source.isRenderTexture = true;
            frame.source.isGLTexture = true;
            frame.source.glTexture = renderTarget.texture;
          }
          this.camera.setSize(width, height);
          frame.source.width = width;
          frame.source.height = height;
          frame.setSize(width, height);
          this.width = width;
          this.height = height;
        }
      } else {
        var baseFrame = this.texture.getSourceImage();
        if (frame.cutX + width > baseFrame.width) {
          width = baseFrame.width - frame.cutX;
        }
        if (frame.cutY + height > baseFrame.height) {
          height = baseFrame.height - frame.cutY;
        }
        frame.setSize(width, height, frame.cutX, frame.cutY);
      }
      this.updateDisplayOrigin();
      var input = this.input;
      if (input && !input.customHitArea) {
        input.hitArea.width = width;
        input.hitArea.height = height;
      }
      return this;
    },
    setGlobalTint: function(tint) {
      this.globalTint = tint;
      return this;
    },
    setGlobalAlpha: function(alpha) {
      this.globalAlpha = alpha;
      return this;
    },
    saveTexture: function(key) {
      this.textureManager.renameTexture(this.texture.key, key);
      this._saved = true;
      return this.texture;
    },
    fill: function(rgb, alpha, x, y, width, height) {
      var frame = this.frame;
      var camera = this.camera;
      var renderer = this.renderer;
      if (alpha === void 0) {
        alpha = 1;
      }
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = frame.cutWidth;
      }
      if (height === void 0) {
        height = frame.cutHeight;
      }
      var r = (rgb >> 16 & 255) / 255;
      var g = (rgb >> 8 & 255) / 255;
      var b = (rgb & 255) / 255;
      var renderTarget = this.renderTarget;
      camera.preRender();
      if (renderTarget) {
        renderTarget.bind(true);
        var pipeline = this.pipeline;
        pipeline.manager.set(pipeline);
        var tw = renderTarget.width;
        var th = renderTarget.height;
        var rw = renderer.width;
        var rh = renderer.height;
        var sx = rw / tw;
        var sy = rh / th;
        pipeline.drawFillRect(x * sx, y * sy, width * sx, height * sy, Utils.getTintFromFloats(b, g, r, 1), alpha);
        renderTarget.unbind(true);
      } else {
        var ctx = this.context;
        renderer.setContext(ctx);
        ctx.fillStyle = "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
        ctx.fillRect(x + frame.cutX, y + frame.cutY, width, height);
        renderer.setContext();
      }
      this.dirty = true;
      return this;
    },
    clear: function() {
      if (this.dirty) {
        var renderTarget = this.renderTarget;
        if (renderTarget) {
          renderTarget.clear();
        } else {
          var ctx = this.context;
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight);
          ctx.restore();
        }
        this.dirty = false;
      }
      return this;
    },
    erase: function(entries, x, y) {
      this._eraseMode = true;
      this.draw(entries, x, y, 1, 16777215);
      this._eraseMode = false;
      return this;
    },
    draw: function(entries, x, y, alpha, tint) {
      this.beginDraw();
      this.batchDraw(entries, x, y, alpha, tint);
      this.endDraw();
      return this;
    },
    drawFrame: function(key, frame, x, y, alpha, tint) {
      this.beginDraw();
      this.batchDrawFrame(key, frame, x, y, alpha, tint);
      this.endDraw();
      return this;
    },
    beginDraw: function() {
      var camera = this.camera;
      var renderer = this.renderer;
      var renderTarget = this.renderTarget;
      camera.preRender();
      if (renderTarget) {
        renderer.beginCapture(renderTarget.width, renderTarget.height);
      } else {
        renderer.setContext(this.context);
      }
      return this;
    },
    batchDraw: function(entries, x, y, alpha, tint) {
      if (alpha === void 0) {
        alpha = this.globalAlpha;
      }
      if (tint === void 0) {
        tint = (this.globalTint >> 16) + (this.globalTint & 65280) + ((this.globalTint & 255) << 16);
      } else {
        tint = (tint >> 16) + (tint & 65280) + ((tint & 255) << 16);
      }
      if (!Array.isArray(entries)) {
        entries = [entries];
      }
      this.batchList(entries, x, y, alpha, tint);
      return this;
    },
    batchDrawFrame: function(key, frame, x, y, alpha, tint) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (alpha === void 0) {
        alpha = this.globalAlpha;
      }
      if (tint === void 0) {
        tint = (this.globalTint >> 16) + (this.globalTint & 65280) + ((this.globalTint & 255) << 16);
      } else {
        tint = (tint >> 16) + (tint & 65280) + ((tint & 255) << 16);
      }
      var textureFrame = this.textureManager.getFrame(key, frame);
      if (textureFrame) {
        if (this.renderTarget) {
          this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);
        } else {
          this.batchTextureFrame(textureFrame, x + this.frame.cutX, y + this.frame.cutY, alpha, tint);
        }
      }
      return this;
    },
    endDraw: function(erase) {
      if (erase === void 0) {
        erase = this._eraseMode;
      }
      var renderer = this.renderer;
      var renderTarget = this.renderTarget;
      if (renderTarget) {
        var canvasTarget = renderer.endCapture();
        var util = renderer.pipelines.setUtility();
        util.blitFrame(canvasTarget, renderTarget, 1, false, false, erase);
        renderer.resetScissor();
        renderer.resetViewport();
      } else {
        renderer.setContext();
      }
      this.dirty = true;
      return this;
    },
    batchList: function(children, x, y, alpha, tint) {
      for (var i = 0; i < children.length; i++) {
        var entry = children[i];
        if (!entry || entry === this) {
          continue;
        }
        if (entry.renderWebGL || entry.renderCanvas) {
          this.drawGameObject(entry, x, y);
        } else if (entry.isParent || entry.list) {
          this.batchGroup(entry.getChildren(), x, y);
        } else if (typeof entry === "string") {
          this.batchTextureFrameKey(entry, null, x, y, alpha, tint);
        } else if (entry instanceof Frame) {
          this.batchTextureFrame(entry, x, y, alpha, tint);
        } else if (Array.isArray(entry)) {
          this.batchList(entry, x, y, alpha, tint);
        }
      }
    },
    batchGroup: function(children, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      x += this.frame.cutX;
      y += this.frame.cutY;
      for (var i = 0; i < children.length; i++) {
        var entry = children[i];
        if (entry.willRender(this.camera)) {
          var tx = entry.x + x;
          var ty = entry.y + y;
          this.drawGameObject(entry, tx, ty);
        }
      }
    },
    batchGameObjectWebGL: function(gameObject, x, y) {
      if (x === void 0) {
        x = gameObject.x;
      }
      if (y === void 0) {
        y = gameObject.y;
      }
      var prevX = gameObject.x;
      var prevY = gameObject.y;
      gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);
      if (gameObject.renderDirect) {
        gameObject.renderDirect(this.renderer, gameObject, this.camera);
      } else {
        gameObject.renderWebGL(this.renderer, gameObject, this.camera);
      }
      gameObject.setPosition(prevX, prevY);
    },
    batchGameObjectCanvas: function(gameObject, x, y) {
      if (x === void 0) {
        x = gameObject.x;
      }
      if (y === void 0) {
        y = gameObject.y;
      }
      var prevX = gameObject.x;
      var prevY = gameObject.y;
      if (this._eraseMode) {
        var blendMode = gameObject.blendMode;
        gameObject.blendMode = BlendModes.ERASE;
      }
      gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);
      gameObject.renderCanvas(this.renderer, gameObject, this.camera, null);
      gameObject.setPosition(prevX, prevY);
      if (this._eraseMode) {
        gameObject.blendMode = blendMode;
      }
    },
    batchTextureFrameKey: function(key, frame, x, y, alpha, tint) {
      var textureFrame = this.textureManager.getFrame(key, frame);
      if (textureFrame) {
        this.batchTextureFrame(textureFrame, x, y, alpha, tint);
      }
    },
    batchTextureFrame: function(textureFrame, x, y, alpha, tint) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      x += this.frame.cutX;
      y += this.frame.cutY;
      var renderTarget = this.renderTarget;
      if (renderTarget) {
        this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);
      } else {
        var ctx = this.context;
        var cd = textureFrame.canvasData;
        var source = textureFrame.source.image;
        var matrix = this.camera.matrix;
        ctx.save();
        ctx.globalCompositeOperation = this._eraseMode ? "destination-out" : "source-over";
        ctx.globalAlpha = alpha;
        matrix.setToContext(ctx);
        ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);
        ctx.restore();
      }
    },
    snapshotArea: function(x, y, width, height, callback, type, encoderOptions) {
      if (this.renderTarget) {
        this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, x, y, width, height, type, encoderOptions);
      } else {
        this.renderer.snapshotCanvas(this.canvas, callback, false, x, y, width, height, type, encoderOptions);
      }
      return this;
    },
    snapshot: function(callback, type, encoderOptions) {
      if (this.renderTarget) {
        this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, 0, 0, this.width, this.height, type, encoderOptions);
      } else {
        this.renderer.snapshotCanvas(this.canvas, callback, false, 0, 0, this.width, this.height, type, encoderOptions);
      }
      return this;
    },
    snapshotPixel: function(x, y, callback) {
      if (this.renderTarget) {
        this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, true, x, y);
      } else {
        this.renderer.snapshotCanvas(this.canvas, callback, true, x, y);
      }
      return this;
    },
    preDestroy: function() {
      if (!this._saved) {
        CanvasPool.remove(this.canvas);
        if (this.renderTarget) {
          this.renderTarget.destroy();
        }
        this.texture.destroy();
        this.camera.destroy();
        this.canvas = null;
        this.context = null;
        this.texture = null;
      }
    }
  });
  module2.exports = RenderTexture;
});

// node_modules/phaser/src/gameobjects/bitmaptext/const.js
var require_const11 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RETRO_FONT_CONST = {
    TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
    TEXT_SET2: ` !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ`,
    TEXT_SET3: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",
    TEXT_SET4: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",
    TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",
    TEXT_SET6: `ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.' `,
    TEXT_SET7: `AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39`,
    TEXT_SET8: "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    TEXT_SET9: `ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!`,
    TEXT_SET10: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    TEXT_SET11: `ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789`
  };
  module2.exports = RETRO_FONT_CONST;
});

// node_modules/phaser/src/gameobjects/bitmaptext/ParseRetroFont.js
var require_ParseRetroFont = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetValue = require_GetValue();
  var ParseRetroFont = function(scene, config2) {
    var w = config2.width;
    var h = config2.height;
    var cx = Math.floor(w / 2);
    var cy = Math.floor(h / 2);
    var letters = GetValue(config2, "chars", "");
    if (letters === "") {
      return;
    }
    var key = GetValue(config2, "image", "");
    var frame = scene.sys.textures.getFrame(key);
    var textureX = frame.cutX;
    var textureY = frame.cutY;
    var textureWidth = frame.source.width;
    var textureHeight = frame.source.height;
    var offsetX = GetValue(config2, "offset.x", 0);
    var offsetY = GetValue(config2, "offset.y", 0);
    var spacingX = GetValue(config2, "spacing.x", 0);
    var spacingY = GetValue(config2, "spacing.y", 0);
    var lineSpacing = GetValue(config2, "lineSpacing", 0);
    var charsPerRow = GetValue(config2, "charsPerRow", null);
    if (charsPerRow === null) {
      charsPerRow = textureWidth / w;
      if (charsPerRow > letters.length) {
        charsPerRow = letters.length;
      }
    }
    var x = offsetX;
    var y = offsetY;
    var data = {
      retroFont: true,
      font: key,
      size: w,
      lineHeight: h + lineSpacing,
      chars: {}
    };
    var r = 0;
    for (var i = 0; i < letters.length; i++) {
      var charCode = letters.charCodeAt(i);
      var u0 = (textureX + x) / textureWidth;
      var v0 = (textureY + y) / textureHeight;
      var u1 = (textureX + x + w) / textureWidth;
      var v1 = (textureY + y + h) / textureHeight;
      data.chars[charCode] = {
        x,
        y,
        width: w,
        height: h,
        centerX: cx,
        centerY: cy,
        xOffset: 0,
        yOffset: 0,
        xAdvance: w,
        data: {},
        kerning: {},
        u0,
        v0,
        u1,
        v1
      };
      r++;
      if (r === charsPerRow) {
        r = 0;
        x = offsetX;
        y += h + spacingY;
      } else {
        x += w + spacingX;
      }
    }
    var entry = {
      data,
      frame: null,
      texture: key
    };
    return entry;
  };
  module2.exports = ParseRetroFont;
});

// node_modules/phaser/src/gameobjects/bitmaptext/RetroFont.js
var require_RetroFont = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RETRO_FONT_CONST = require_const11();
  var Extend = require_Extend();
  var RetroFont = {Parse: require_ParseRetroFont()};
  RetroFont = Extend(false, RetroFont, RETRO_FONT_CONST);
  module2.exports = RetroFont;
});

// node_modules/phaser/src/gameobjects/rope/RopeWebGLRenderer.js
var require_RopeWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var Utils = require_Utils();
  var RopeWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
    var vertices = src.vertices;
    var uvs = src.uv;
    var colors = src.colors;
    var alphas = src.alphas;
    var alpha = src.alpha;
    var getTint = Utils.getTintAppendFloatAlpha;
    var roundPixels = camera.roundPixels;
    var meshVerticesLength = vertices.length;
    var vertexCount = Math.floor(meshVerticesLength * 0.5);
    pipeline.flush();
    renderer.pipelines.preBatch(src);
    var textureUnit = pipeline.setGameObject(src);
    var vertexViewF32 = pipeline.vertexViewF32;
    var vertexViewU32 = pipeline.vertexViewU32;
    var vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1;
    var colorIndex = 0;
    var tintEffect = src.tintFill;
    if (src.dirty) {
      src.updateVertices();
    }
    var debugCallback = src.debugCallback;
    var debugVerts = [];
    for (var i = 0; i < meshVerticesLength; i += 2) {
      var x = vertices[i + 0];
      var y = vertices[i + 1];
      var tx = x * calcMatrix.a + y * calcMatrix.c + calcMatrix.e;
      var ty = x * calcMatrix.b + y * calcMatrix.d + calcMatrix.f;
      if (roundPixels) {
        tx = Math.round(tx);
        ty = Math.round(ty);
      }
      vertexViewF32[++vertexOffset] = tx;
      vertexViewF32[++vertexOffset] = ty;
      vertexViewF32[++vertexOffset] = uvs[i + 0];
      vertexViewF32[++vertexOffset] = uvs[i + 1];
      vertexViewF32[++vertexOffset] = textureUnit;
      vertexViewF32[++vertexOffset] = tintEffect;
      vertexViewU32[++vertexOffset] = getTint(colors[colorIndex], camera.alpha * (alphas[colorIndex] * alpha));
      colorIndex++;
      if (debugCallback) {
        debugVerts[i + 0] = tx;
        debugVerts[i + 1] = ty;
      }
    }
    if (debugCallback) {
      debugCallback.call(src, src, meshVerticesLength, debugVerts);
    }
    pipeline.vertexCount += vertexCount;
    renderer.pipelines.postBatch(src);
  };
  module2.exports = RopeWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/rope/RopeCanvasRenderer.js
var require_RopeCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RopeCanvasRenderer = function() {
  };
  module2.exports = RopeCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/rope/RopeRender.js
var require_RopeRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_RopeWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_RopeCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/rope/Rope.js
var require_Rope = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AnimationState = require_AnimationState();
  var Class = require_Class();
  var Components = require_components();
  var GameObject = require_GameObject();
  var PIPELINE_CONST = require_const6();
  var RopeRender = require_RopeRender();
  var Vector2 = require_Vector2();
  var Rope = new Class({
    Extends: GameObject,
    Mixins: [
      Components.AlphaSingle,
      Components.BlendMode,
      Components.Depth,
      Components.Flip,
      Components.Mask,
      Components.Pipeline,
      Components.Size,
      Components.Texture,
      Components.Transform,
      Components.Visible,
      Components.ScrollFactor,
      RopeRender
    ],
    initialize: function Rope2(scene, x, y, texture, frame, points, horizontal, colors, alphas) {
      if (texture === void 0) {
        texture = "__DEFAULT";
      }
      if (points === void 0) {
        points = 2;
      }
      if (horizontal === void 0) {
        horizontal = true;
      }
      GameObject.call(this, scene, "Rope");
      this.anims = new AnimationState(this);
      this.points = points;
      this.vertices;
      this.uv;
      this.colors;
      this.alphas;
      this.tintFill = texture === "__DEFAULT" ? true : false;
      this.dirty = false;
      this.horizontal = horizontal;
      this._flipX = false;
      this._flipY = false;
      this._perp = new Vector2();
      this.debugCallback = null;
      this.debugGraphic = null;
      this.setTexture(texture, frame);
      this.setPosition(x, y);
      this.setSizeToFrame();
      this.initPipeline(PIPELINE_CONST.ROPE_PIPELINE);
      if (Array.isArray(points)) {
        this.resizeArrays(points.length);
      }
      this.setPoints(points, colors, alphas);
      this.updateVertices();
    },
    addedToScene: function() {
      this.scene.sys.updateList.add(this);
    },
    removedFromScene: function() {
      this.scene.sys.updateList.remove(this);
    },
    preUpdate: function(time, delta) {
      var prevFrame = this.anims.currentFrame;
      this.anims.update(time, delta);
      if (this.anims.currentFrame !== prevFrame) {
        this.updateUVs();
        this.updateVertices();
      }
    },
    play: function(key, ignoreIfPlaying, startFrame) {
      this.anims.play(key, ignoreIfPlaying, startFrame);
      return this;
    },
    setDirty: function() {
      this.dirty = true;
      return this;
    },
    setHorizontal: function(points, colors, alphas) {
      if (points === void 0) {
        points = this.points.length;
      }
      if (this.horizontal) {
        return this;
      }
      this.horizontal = true;
      return this.setPoints(points, colors, alphas);
    },
    setVertical: function(points, colors, alphas) {
      if (points === void 0) {
        points = this.points.length;
      }
      if (!this.horizontal) {
        return this;
      }
      this.horizontal = false;
      return this.setPoints(points, colors, alphas);
    },
    setTintFill: function(value) {
      if (value === void 0) {
        value = false;
      }
      this.tintFill = value;
      return this;
    },
    setAlphas: function(alphas, bottomAlpha) {
      var total = this.points.length;
      if (total < 1) {
        return this;
      }
      var currentAlphas = this.alphas;
      if (alphas === void 0) {
        alphas = [1];
      } else if (!Array.isArray(alphas) && bottomAlpha === void 0) {
        alphas = [alphas];
      }
      var i;
      var index = 0;
      if (bottomAlpha !== void 0) {
        for (i = 0; i < total; i++) {
          index = i * 2;
          currentAlphas[index] = alphas;
          currentAlphas[index + 1] = bottomAlpha;
        }
      } else if (alphas.length === total) {
        for (i = 0; i < total; i++) {
          index = i * 2;
          currentAlphas[index] = alphas[i];
          currentAlphas[index + 1] = alphas[i];
        }
      } else {
        var prevAlpha = alphas[0];
        for (i = 0; i < total; i++) {
          index = i * 2;
          if (alphas.length > index) {
            prevAlpha = alphas[index];
          }
          currentAlphas[index] = prevAlpha;
          if (alphas.length > index + 1) {
            prevAlpha = alphas[index + 1];
          }
          currentAlphas[index + 1] = prevAlpha;
        }
      }
      return this;
    },
    setColors: function(colors) {
      var total = this.points.length;
      if (total < 1) {
        return this;
      }
      var currentColors = this.colors;
      if (colors === void 0) {
        colors = [16777215];
      } else if (!Array.isArray(colors)) {
        colors = [colors];
      }
      var i;
      var index = 0;
      if (colors.length === total) {
        for (i = 0; i < total; i++) {
          index = i * 2;
          currentColors[index] = colors[i];
          currentColors[index + 1] = colors[i];
        }
      } else {
        var prevColor = colors[0];
        for (i = 0; i < total; i++) {
          index = i * 2;
          if (colors.length > index) {
            prevColor = colors[index];
          }
          currentColors[index] = prevColor;
          if (colors.length > index + 1) {
            prevColor = colors[index + 1];
          }
          currentColors[index + 1] = prevColor;
        }
      }
      return this;
    },
    setPoints: function(points, colors, alphas) {
      if (points === void 0) {
        points = 2;
      }
      if (typeof points === "number") {
        var segments = points;
        if (segments < 2) {
          segments = 2;
        }
        points = [];
        var s;
        var frameSegment;
        var offset;
        if (this.horizontal) {
          offset = -this.frame.halfWidth;
          frameSegment = this.frame.width / (segments - 1);
          for (s = 0; s < segments; s++) {
            points.push({x: offset + s * frameSegment, y: 0});
          }
        } else {
          offset = -this.frame.halfHeight;
          frameSegment = this.frame.height / (segments - 1);
          for (s = 0; s < segments; s++) {
            points.push({x: 0, y: offset + s * frameSegment});
          }
        }
      }
      var total = points.length;
      var currentTotal = this.points.length;
      if (total < 1) {
        console.warn("Rope: Not enough points given");
        return this;
      } else if (total === 1) {
        points.unshift({x: 0, y: 0});
        total++;
      }
      if (currentTotal !== total) {
        this.resizeArrays(total);
      }
      this.points = points;
      this.updateUVs();
      if (colors !== void 0 && colors !== null) {
        this.setColors(colors);
      }
      if (alphas !== void 0 && alphas !== null) {
        this.setAlphas(alphas);
      }
      return this;
    },
    updateUVs: function() {
      var currentUVs = this.uv;
      var total = this.points.length;
      var u0 = this.frame.u0;
      var v0 = this.frame.v0;
      var u1 = this.frame.u1;
      var v1 = this.frame.v1;
      var partH = (u1 - u0) / (total - 1);
      var partV = (v1 - v0) / (total - 1);
      for (var i = 0; i < total; i++) {
        var index = i * 4;
        var uv0;
        var uv1;
        var uv2;
        var uv3;
        if (this.horizontal) {
          if (this._flipX) {
            uv0 = u1 - i * partH;
            uv2 = u1 - i * partH;
          } else {
            uv0 = u0 + i * partH;
            uv2 = u0 + i * partH;
          }
          if (this._flipY) {
            uv1 = v1;
            uv3 = v0;
          } else {
            uv1 = v0;
            uv3 = v1;
          }
        } else {
          if (this._flipX) {
            uv0 = u0;
            uv2 = u1;
          } else {
            uv0 = u1;
            uv2 = u0;
          }
          if (this._flipY) {
            uv1 = v1 - i * partV;
            uv3 = v1 - i * partV;
          } else {
            uv1 = v0 + i * partV;
            uv3 = v0 + i * partV;
          }
        }
        currentUVs[index + 0] = uv0;
        currentUVs[index + 1] = uv1;
        currentUVs[index + 2] = uv2;
        currentUVs[index + 3] = uv3;
      }
      return this;
    },
    resizeArrays: function(newSize) {
      var colors = this.colors;
      var alphas = this.alphas;
      this.vertices = new Float32Array(newSize * 4);
      this.uv = new Float32Array(newSize * 4);
      colors = new Uint32Array(newSize * 2);
      alphas = new Float32Array(newSize * 2);
      for (var i = 0; i < newSize * 2; i++) {
        colors[i] = 16777215;
        alphas[i] = 1;
      }
      this.colors = colors;
      this.alphas = alphas;
      this.dirty = true;
      return this;
    },
    updateVertices: function() {
      var perp = this._perp;
      var points = this.points;
      var vertices = this.vertices;
      var total = points.length;
      this.dirty = false;
      if (total < 1) {
        return;
      }
      var nextPoint;
      var lastPoint = points[0];
      var frameSize = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth;
      for (var i = 0; i < total; i++) {
        var point = points[i];
        var index = i * 4;
        if (i < total - 1) {
          nextPoint = points[i + 1];
        } else {
          nextPoint = point;
        }
        perp.x = nextPoint.y - lastPoint.y;
        perp.y = -(nextPoint.x - lastPoint.x);
        var perpLength = perp.length();
        perp.x /= perpLength;
        perp.y /= perpLength;
        perp.x *= frameSize;
        perp.y *= frameSize;
        vertices[index] = point.x + perp.x;
        vertices[index + 1] = point.y + perp.y;
        vertices[index + 2] = point.x - perp.x;
        vertices[index + 3] = point.y - perp.y;
        lastPoint = point;
      }
      return this;
    },
    setDebug: function(graphic, callback) {
      this.debugGraphic = graphic;
      if (!graphic && !callback) {
        this.debugCallback = null;
      } else if (!callback) {
        this.debugCallback = this.renderDebugVerts;
      } else {
        this.debugCallback = callback;
      }
      return this;
    },
    renderDebugVerts: function(src, meshLength, verts) {
      var graphic = src.debugGraphic;
      var px0 = verts[0];
      var py0 = verts[1];
      var px1 = verts[2];
      var py1 = verts[3];
      graphic.lineBetween(px0, py0, px1, py1);
      for (var i = 4; i < meshLength; i += 4) {
        var x0 = verts[i + 0];
        var y0 = verts[i + 1];
        var x1 = verts[i + 2];
        var y1 = verts[i + 3];
        graphic.lineBetween(px0, py0, x0, y0);
        graphic.lineBetween(px1, py1, x1, y1);
        graphic.lineBetween(px1, py1, x0, y0);
        graphic.lineBetween(x0, y0, x1, y1);
        px0 = x0;
        py0 = y0;
        px1 = x1;
        py1 = y1;
      }
    },
    preDestroy: function() {
      this.anims.destroy();
      this.anims = void 0;
      this.points = null;
      this.vertices = null;
      this.uv = null;
      this.colors = null;
      this.alphas = null;
      this.debugCallback = null;
      this.debugGraphic = null;
    },
    flipX: {
      get: function() {
        return this._flipX;
      },
      set: function(value) {
        this._flipX = value;
        return this.updateUVs();
      }
    },
    flipY: {
      get: function() {
        return this._flipY;
      },
      set: function(value) {
        this._flipY = value;
        return this.updateUVs();
      }
    }
  });
  module2.exports = Rope;
});

// node_modules/phaser/src/gameobjects/text/GetTextSize.js
var require_GetTextSize = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTextSize = function(text, size, lines) {
    var canvas = text.canvas;
    var context = text.context;
    var style = text.style;
    var lineWidths = [];
    var maxLineWidth = 0;
    var drawnLines = lines.length;
    if (style.maxLines > 0 && style.maxLines < lines.length) {
      drawnLines = style.maxLines;
    }
    style.syncFont(canvas, context);
    for (var i = 0; i < drawnLines; i++) {
      var lineWidth = style.strokeThickness;
      lineWidth += context.measureText(lines[i]).width;
      if (style.wordWrap) {
        lineWidth -= context.measureText(" ").width;
      }
      lineWidths[i] = Math.ceil(lineWidth);
      maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);
    }
    var lineHeight = size.fontSize + style.strokeThickness;
    var height = lineHeight * drawnLines;
    var lineSpacing = text.lineSpacing;
    if (drawnLines > 1) {
      height += lineSpacing * (drawnLines - 1);
    }
    return {
      width: maxLineWidth,
      height,
      lines: drawnLines,
      lineWidths,
      lineSpacing,
      lineHeight
    };
  };
  module2.exports = GetTextSize;
});

// node_modules/phaser/src/gameobjects/text/TextWebGLRenderer.js
var require_TextWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Utils = require_Utils();
  var TextWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    if (src.width === 0 || src.height === 0) {
      return;
    }
    camera.addToRenderList(src);
    var frame = src.frame;
    var width = frame.width;
    var height = frame.height;
    var getTint = Utils.getTintAppendFloatAlpha;
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
    renderer.pipelines.preBatch(src);
    pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.style.resolution, height / src.style.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, false, textureUnit);
    renderer.pipelines.postBatch(src);
  };
  module2.exports = TextWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/text/TextCanvasRenderer.js
var require_TextCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TextCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    if (src.width === 0 || src.height === 0) {
      return;
    }
    camera.addToRenderList(src);
    renderer.batchSprite(src, src.frame, camera, parentMatrix);
  };
  module2.exports = TextCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/text/TextRender.js
var require_TextRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_TextWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_TextCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/text/MeasureText.js
var require_MeasureText = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CanvasPool = require_CanvasPool();
  var MeasureText = function(textStyle) {
    var canvas = CanvasPool.create(this);
    var context = canvas.getContext("2d");
    textStyle.syncFont(canvas, context);
    var metrics = context.measureText(textStyle.testString);
    if ("actualBoundingBoxAscent" in metrics) {
      var ascent = metrics.actualBoundingBoxAscent;
      var descent = metrics.actualBoundingBoxDescent;
      CanvasPool.remove(canvas);
      return {
        ascent,
        descent,
        fontSize: ascent + descent
      };
    }
    var width = Math.ceil(metrics.width * textStyle.baselineX);
    var baseline = width;
    var height = 2 * baseline;
    baseline = baseline * textStyle.baselineY | 0;
    canvas.width = width;
    canvas.height = height;
    context.fillStyle = "#f00";
    context.fillRect(0, 0, width, height);
    context.font = textStyle._font;
    context.textBaseline = "alphabetic";
    context.fillStyle = "#000";
    context.fillText(textStyle.testString, 0, baseline);
    var output = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    var imagedata = context.getImageData(0, 0, width, height);
    if (!imagedata) {
      output.ascent = baseline;
      output.descent = baseline + 6;
      output.fontSize = output.ascent + output.descent;
      CanvasPool.remove(canvas);
      return output;
    }
    var pixels = imagedata.data;
    var numPixels = pixels.length;
    var line = width * 4;
    var i;
    var j;
    var idx = 0;
    var stop = false;
    for (i = 0; i < baseline; i++) {
      for (j = 0; j < line; j += 4) {
        if (pixels[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    output.ascent = baseline - i;
    idx = numPixels - line;
    stop = false;
    for (i = height; i > baseline; i--) {
      for (j = 0; j < line; j += 4) {
        if (pixels[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    output.descent = i - baseline;
    output.fontSize = output.ascent + output.descent;
    CanvasPool.remove(canvas);
    return output;
  };
  module2.exports = MeasureText;
});

// node_modules/phaser/src/gameobjects/text/TextStyle.js
var require_TextStyle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetAdvancedValue = require_GetAdvancedValue();
  var GetValue = require_GetValue();
  var MeasureText = require_MeasureText();
  var propertyMap = {
    fontFamily: ["fontFamily", "Courier"],
    fontSize: ["fontSize", "16px"],
    fontStyle: ["fontStyle", ""],
    backgroundColor: ["backgroundColor", null],
    color: ["color", "#fff"],
    stroke: ["stroke", "#fff"],
    strokeThickness: ["strokeThickness", 0],
    shadowOffsetX: ["shadow.offsetX", 0],
    shadowOffsetY: ["shadow.offsetY", 0],
    shadowColor: ["shadow.color", "#000"],
    shadowBlur: ["shadow.blur", 0],
    shadowStroke: ["shadow.stroke", false],
    shadowFill: ["shadow.fill", false],
    align: ["align", "left"],
    maxLines: ["maxLines", 0],
    fixedWidth: ["fixedWidth", 0],
    fixedHeight: ["fixedHeight", 0],
    resolution: ["resolution", 0],
    rtl: ["rtl", false],
    testString: ["testString", "|M\xC3\u2030qgy"],
    baselineX: ["baselineX", 1.2],
    baselineY: ["baselineY", 1.4],
    wordWrapWidth: ["wordWrap.width", null],
    wordWrapCallback: ["wordWrap.callback", null],
    wordWrapCallbackScope: ["wordWrap.callbackScope", null],
    wordWrapUseAdvanced: ["wordWrap.useAdvancedWrap", false]
  };
  var TextStyle = new Class({
    initialize: function TextStyle2(text, style) {
      this.parent = text;
      this.fontFamily;
      this.fontSize;
      this.fontStyle;
      this.backgroundColor;
      this.color;
      this.stroke;
      this.strokeThickness;
      this.shadowOffsetX;
      this.shadowOffsetY;
      this.shadowColor;
      this.shadowBlur;
      this.shadowStroke;
      this.shadowFill;
      this.align;
      this.maxLines;
      this.fixedWidth;
      this.fixedHeight;
      this.resolution;
      this.rtl;
      this.testString;
      this.baselineX;
      this.baselineY;
      this.wordWrapWidth;
      this.wordWrapCallback;
      this.wordWrapCallbackScope;
      this.wordWrapUseAdvanced;
      this._font;
      this.setStyle(style, false, true);
      var metrics = GetValue(style, "metrics", false);
      if (metrics) {
        this.metrics = {
          ascent: GetValue(metrics, "ascent", 0),
          descent: GetValue(metrics, "descent", 0),
          fontSize: GetValue(metrics, "fontSize", 0)
        };
      } else {
        this.metrics = MeasureText(this);
      }
    },
    setStyle: function(style, updateText, setDefaults) {
      if (updateText === void 0) {
        updateText = true;
      }
      if (setDefaults === void 0) {
        setDefaults = false;
      }
      if (style && style.hasOwnProperty("fontSize") && typeof style.fontSize === "number") {
        style.fontSize = style.fontSize.toString() + "px";
      }
      for (var key in propertyMap) {
        var value = setDefaults ? propertyMap[key][1] : this[key];
        if (key === "wordWrapCallback" || key === "wordWrapCallbackScope") {
          this[key] = GetValue(style, propertyMap[key][0], value);
        } else {
          this[key] = GetAdvancedValue(style, propertyMap[key][0], value);
        }
      }
      var font = GetValue(style, "font", null);
      if (font !== null) {
        this.setFont(font, false);
      }
      this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
      var fill = GetValue(style, "fill", null);
      if (fill !== null) {
        this.color = fill;
      }
      if (updateText) {
        return this.update(true);
      } else {
        return this.parent;
      }
    },
    syncFont: function(canvas, context) {
      context.font = this._font;
    },
    syncStyle: function(canvas, context) {
      context.textBaseline = "alphabetic";
      context.fillStyle = this.color;
      context.strokeStyle = this.stroke;
      context.lineWidth = this.strokeThickness;
      context.lineCap = "round";
      context.lineJoin = "round";
    },
    syncShadow: function(context, enabled) {
      if (enabled) {
        context.shadowOffsetX = this.shadowOffsetX;
        context.shadowOffsetY = this.shadowOffsetY;
        context.shadowColor = this.shadowColor;
        context.shadowBlur = this.shadowBlur;
      } else {
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;
        context.shadowColor = 0;
        context.shadowBlur = 0;
      }
    },
    update: function(recalculateMetrics) {
      if (recalculateMetrics) {
        this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
        this.metrics = MeasureText(this);
      }
      return this.parent.updateText();
    },
    setFont: function(font, updateText) {
      if (updateText === void 0) {
        updateText = true;
      }
      var fontFamily = font;
      var fontSize = "";
      var fontStyle = "";
      if (typeof font !== "string") {
        fontFamily = GetValue(font, "fontFamily", "Courier");
        fontSize = GetValue(font, "fontSize", "16px");
        fontStyle = GetValue(font, "fontStyle", "");
      } else {
        var fontSplit = font.split(" ");
        var i = 0;
        fontStyle = fontSplit.length > 2 ? fontSplit[i++] : "";
        fontSize = fontSplit[i++] || "16px";
        fontFamily = fontSplit[i++] || "Courier";
      }
      if (fontFamily !== this.fontFamily || fontSize !== this.fontSize || fontStyle !== this.fontStyle) {
        this.fontFamily = fontFamily;
        this.fontSize = fontSize;
        this.fontStyle = fontStyle;
        if (updateText) {
          this.update(true);
        }
      }
      return this.parent;
    },
    setFontFamily: function(family) {
      if (this.fontFamily !== family) {
        this.fontFamily = family;
        this.update(true);
      }
      return this.parent;
    },
    setFontStyle: function(style) {
      if (this.fontStyle !== style) {
        this.fontStyle = style;
        this.update(true);
      }
      return this.parent;
    },
    setFontSize: function(size) {
      if (typeof size === "number") {
        size = size.toString() + "px";
      }
      if (this.fontSize !== size) {
        this.fontSize = size;
        this.update(true);
      }
      return this.parent;
    },
    setTestString: function(string) {
      this.testString = string;
      return this.update(true);
    },
    setFixedSize: function(width, height) {
      this.fixedWidth = width;
      this.fixedHeight = height;
      if (width) {
        this.parent.width = width;
      }
      if (height) {
        this.parent.height = height;
      }
      return this.update(false);
    },
    setBackgroundColor: function(color) {
      this.backgroundColor = color;
      return this.update(false);
    },
    setFill: function(color) {
      this.color = color;
      return this.update(false);
    },
    setColor: function(color) {
      this.color = color;
      return this.update(false);
    },
    setResolution: function(value) {
      this.resolution = value;
      return this.update(false);
    },
    setStroke: function(color, thickness) {
      if (thickness === void 0) {
        thickness = this.strokeThickness;
      }
      if (color === void 0 && this.strokeThickness !== 0) {
        this.strokeThickness = 0;
        this.update(true);
      } else if (this.stroke !== color || this.strokeThickness !== thickness) {
        this.stroke = color;
        this.strokeThickness = thickness;
        this.update(true);
      }
      return this.parent;
    },
    setShadow: function(x, y, color, blur, shadowStroke, shadowFill) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (color === void 0) {
        color = "#000";
      }
      if (blur === void 0) {
        blur = 0;
      }
      if (shadowStroke === void 0) {
        shadowStroke = false;
      }
      if (shadowFill === void 0) {
        shadowFill = true;
      }
      this.shadowOffsetX = x;
      this.shadowOffsetY = y;
      this.shadowColor = color;
      this.shadowBlur = blur;
      this.shadowStroke = shadowStroke;
      this.shadowFill = shadowFill;
      return this.update(false);
    },
    setShadowOffset: function(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = x;
      }
      this.shadowOffsetX = x;
      this.shadowOffsetY = y;
      return this.update(false);
    },
    setShadowColor: function(color) {
      if (color === void 0) {
        color = "#000";
      }
      this.shadowColor = color;
      return this.update(false);
    },
    setShadowBlur: function(blur) {
      if (blur === void 0) {
        blur = 0;
      }
      this.shadowBlur = blur;
      return this.update(false);
    },
    setShadowStroke: function(enabled) {
      this.shadowStroke = enabled;
      return this.update(false);
    },
    setShadowFill: function(enabled) {
      this.shadowFill = enabled;
      return this.update(false);
    },
    setWordWrapWidth: function(width, useAdvancedWrap) {
      if (useAdvancedWrap === void 0) {
        useAdvancedWrap = false;
      }
      this.wordWrapWidth = width;
      this.wordWrapUseAdvanced = useAdvancedWrap;
      return this.update(false);
    },
    setWordWrapCallback: function(callback, scope) {
      if (scope === void 0) {
        scope = null;
      }
      this.wordWrapCallback = callback;
      this.wordWrapCallbackScope = scope;
      return this.update(false);
    },
    setAlign: function(align) {
      if (align === void 0) {
        align = "left";
      }
      this.align = align;
      return this.update(false);
    },
    setMaxLines: function(max) {
      if (max === void 0) {
        max = 0;
      }
      this.maxLines = max;
      return this.update(false);
    },
    getTextMetrics: function() {
      var metrics = this.metrics;
      return {
        ascent: metrics.ascent,
        descent: metrics.descent,
        fontSize: metrics.fontSize
      };
    },
    toJSON: function() {
      var output = {};
      for (var key in propertyMap) {
        output[key] = this[key];
      }
      output.metrics = this.getTextMetrics();
      return output;
    },
    destroy: function() {
      this.parent = void 0;
    }
  });
  module2.exports = TextStyle;
});

// node_modules/phaser/src/gameobjects/text/Text.js
var require_Text = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AddToDOM = require_AddToDOM();
  var CanvasPool = require_CanvasPool();
  var Class = require_Class();
  var Components = require_components();
  var GameEvents = require_events();
  var GameObject = require_GameObject();
  var GetTextSize = require_GetTextSize();
  var GetValue = require_GetValue();
  var RemoveFromDOM = require_RemoveFromDOM();
  var TextRender = require_TextRender();
  var TextStyle = require_TextStyle();
  var Text = new Class({
    Extends: GameObject,
    Mixins: [
      Components.Alpha,
      Components.BlendMode,
      Components.ComputedSize,
      Components.Crop,
      Components.Depth,
      Components.Flip,
      Components.GetBounds,
      Components.Mask,
      Components.Origin,
      Components.Pipeline,
      Components.ScrollFactor,
      Components.Tint,
      Components.Transform,
      Components.Visible,
      TextRender
    ],
    initialize: function Text2(scene, x, y, text, style) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      GameObject.call(this, scene, "Text");
      this.renderer = scene.sys.renderer;
      this.setPosition(x, y);
      this.setOrigin(0, 0);
      this.initPipeline();
      this.canvas = CanvasPool.create(this);
      this.context = this.canvas.getContext("2d");
      this.style = new TextStyle(this, style);
      this.autoRound = true;
      this.splitRegExp = /(?:\r\n|\r|\n)/;
      this._text = void 0;
      this.padding = {left: 0, right: 0, top: 0, bottom: 0};
      this.width = 1;
      this.height = 1;
      this.lineSpacing = 0;
      this.dirty = false;
      if (this.style.resolution === 0) {
        this.style.resolution = 1;
      }
      this._crop = this.resetCropObject();
      this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);
      this.frame = this.texture.get();
      this.frame.source.resolution = this.style.resolution;
      if (this.renderer && this.renderer.gl) {
        this.renderer.deleteTexture(this.frame.source.glTexture);
        this.frame.source.glTexture = null;
      }
      this.initRTL();
      this.setText(text);
      if (style && style.padding) {
        this.setPadding(style.padding);
      }
      if (style && style.lineSpacing) {
        this.setLineSpacing(style.lineSpacing);
      }
      scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function() {
        this.dirty = true;
      }, this);
    },
    initRTL: function() {
      if (!this.style.rtl) {
        return;
      }
      this.canvas.dir = "rtl";
      this.context.direction = "rtl";
      this.canvas.style.display = "none";
      AddToDOM(this.canvas, this.scene.sys.canvas);
      this.originX = 1;
    },
    runWordWrap: function(text) {
      var style = this.style;
      if (style.wordWrapCallback) {
        var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);
        if (Array.isArray(wrappedLines)) {
          wrappedLines = wrappedLines.join("\n");
        }
        return wrappedLines;
      } else if (style.wordWrapWidth) {
        if (style.wordWrapUseAdvanced) {
          return this.advancedWordWrap(text, this.context, this.style.wordWrapWidth);
        } else {
          return this.basicWordWrap(text, this.context, this.style.wordWrapWidth);
        }
      } else {
        return text;
      }
    },
    advancedWordWrap: function(text, context, wordWrapWidth) {
      var output = "";
      var lines = text.replace(/ +/gi, " ").split(this.splitRegExp);
      var linesCount = lines.length;
      for (var i = 0; i < linesCount; i++) {
        var line = lines[i];
        var out = "";
        line = line.replace(/^ *|\s*$/gi, "");
        var lineWidth = context.measureText(line).width;
        if (lineWidth < wordWrapWidth) {
          output += line + "\n";
          continue;
        }
        var currentLineWidth = wordWrapWidth;
        var words = line.split(" ");
        for (var j = 0; j < words.length; j++) {
          var word = words[j];
          var wordWithSpace = word + " ";
          var wordWidth = context.measureText(wordWithSpace).width;
          if (wordWidth > currentLineWidth) {
            if (j === 0) {
              var newWord = wordWithSpace;
              while (newWord.length) {
                newWord = newWord.slice(0, -1);
                wordWidth = context.measureText(newWord).width;
                if (wordWidth <= currentLineWidth) {
                  break;
                }
              }
              if (!newWord.length) {
                throw new Error("This text's wordWrapWidth setting is less than a single character!");
              }
              var secondPart = word.substr(newWord.length);
              words[j] = secondPart;
              out += newWord;
            }
            var offset = words[j].length ? j : j + 1;
            var remainder = words.slice(offset).join(" ").replace(/[ \n]*$/gi, "");
            lines[i + 1] = remainder + " " + (lines[i + 1] || "");
            linesCount = lines.length;
            break;
          } else {
            out += wordWithSpace;
            currentLineWidth -= wordWidth;
          }
        }
        output += out.replace(/[ \n]*$/gi, "") + "\n";
      }
      output = output.replace(/[\s|\n]*$/gi, "");
      return output;
    },
    basicWordWrap: function(text, context, wordWrapWidth) {
      var result = "";
      var lines = text.split(this.splitRegExp);
      var lastLineIndex = lines.length - 1;
      var whiteSpaceWidth = context.measureText(" ").width;
      for (var i = 0; i <= lastLineIndex; i++) {
        var spaceLeft = wordWrapWidth;
        var words = lines[i].split(" ");
        var lastWordIndex = words.length - 1;
        for (var j = 0; j <= lastWordIndex; j++) {
          var word = words[j];
          var wordWidth = context.measureText(word).width;
          var wordWidthWithSpace = wordWidth;
          if (j < lastWordIndex) {
            wordWidthWithSpace += whiteSpaceWidth;
          }
          if (wordWidthWithSpace > spaceLeft) {
            if (j > 0) {
              result += "\n";
              spaceLeft = wordWrapWidth;
            }
          }
          result += word;
          if (j < lastWordIndex) {
            result += " ";
            spaceLeft -= wordWidthWithSpace;
          } else {
            spaceLeft -= wordWidth;
          }
        }
        if (i < lastLineIndex) {
          result += "\n";
        }
      }
      return result;
    },
    getWrappedText: function(text) {
      if (text === void 0) {
        text = this._text;
      }
      this.style.syncFont(this.canvas, this.context);
      var wrappedLines = this.runWordWrap(text);
      return wrappedLines.split(this.splitRegExp);
    },
    setText: function(value) {
      if (!value && value !== 0) {
        value = "";
      }
      if (Array.isArray(value)) {
        value = value.join("\n");
      }
      if (value !== this._text) {
        this._text = value.toString();
        this.updateText();
      }
      return this;
    },
    setStyle: function(style) {
      return this.style.setStyle(style);
    },
    setFont: function(font) {
      return this.style.setFont(font);
    },
    setFontFamily: function(family) {
      return this.style.setFontFamily(family);
    },
    setFontSize: function(size) {
      return this.style.setFontSize(size);
    },
    setFontStyle: function(style) {
      return this.style.setFontStyle(style);
    },
    setFixedSize: function(width, height) {
      return this.style.setFixedSize(width, height);
    },
    setBackgroundColor: function(color) {
      return this.style.setBackgroundColor(color);
    },
    setFill: function(fillStyle) {
      return this.style.setFill(fillStyle);
    },
    setColor: function(color) {
      return this.style.setColor(color);
    },
    setStroke: function(color, thickness) {
      return this.style.setStroke(color, thickness);
    },
    setShadow: function(x, y, color, blur, shadowStroke, shadowFill) {
      return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
    },
    setShadowOffset: function(x, y) {
      return this.style.setShadowOffset(x, y);
    },
    setShadowColor: function(color) {
      return this.style.setShadowColor(color);
    },
    setShadowBlur: function(blur) {
      return this.style.setShadowBlur(blur);
    },
    setShadowStroke: function(enabled) {
      return this.style.setShadowStroke(enabled);
    },
    setShadowFill: function(enabled) {
      return this.style.setShadowFill(enabled);
    },
    setWordWrapWidth: function(width, useAdvancedWrap) {
      return this.style.setWordWrapWidth(width, useAdvancedWrap);
    },
    setWordWrapCallback: function(callback, scope) {
      return this.style.setWordWrapCallback(callback, scope);
    },
    setAlign: function(align) {
      return this.style.setAlign(align);
    },
    setResolution: function(value) {
      return this.style.setResolution(value);
    },
    setLineSpacing: function(value) {
      this.lineSpacing = value;
      return this.updateText();
    },
    setPadding: function(left, top, right, bottom) {
      if (typeof left === "object") {
        var config2 = left;
        var x = GetValue(config2, "x", null);
        if (x !== null) {
          left = x;
          right = x;
        } else {
          left = GetValue(config2, "left", 0);
          right = GetValue(config2, "right", left);
        }
        var y = GetValue(config2, "y", null);
        if (y !== null) {
          top = y;
          bottom = y;
        } else {
          top = GetValue(config2, "top", 0);
          bottom = GetValue(config2, "bottom", top);
        }
      } else {
        if (left === void 0) {
          left = 0;
        }
        if (top === void 0) {
          top = left;
        }
        if (right === void 0) {
          right = left;
        }
        if (bottom === void 0) {
          bottom = top;
        }
      }
      this.padding.left = left;
      this.padding.top = top;
      this.padding.right = right;
      this.padding.bottom = bottom;
      return this.updateText();
    },
    setMaxLines: function(max) {
      return this.style.setMaxLines(max);
    },
    updateText: function() {
      var canvas = this.canvas;
      var context = this.context;
      var style = this.style;
      var resolution = style.resolution;
      var size = style.metrics;
      style.syncFont(canvas, context);
      var outputText = this._text;
      if (style.wordWrapWidth || style.wordWrapCallback) {
        outputText = this.runWordWrap(this._text);
      }
      var lines = outputText.split(this.splitRegExp);
      var textSize = GetTextSize(this, size, lines);
      var padding = this.padding;
      var textWidth;
      if (style.fixedWidth === 0) {
        this.width = textSize.width + padding.left + padding.right;
        textWidth = textSize.width;
      } else {
        this.width = style.fixedWidth;
        textWidth = this.width - padding.left - padding.right;
        if (textWidth < textSize.width) {
          textWidth = textSize.width;
        }
      }
      if (style.fixedHeight === 0) {
        this.height = textSize.height + padding.top + padding.bottom;
      } else {
        this.height = style.fixedHeight;
      }
      var w = this.width;
      var h = this.height;
      this.updateDisplayOrigin();
      w *= resolution;
      h *= resolution;
      w = Math.max(w, 1);
      h = Math.max(h, 1);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
        this.frame.setSize(w, h);
        style.syncFont(canvas, context);
      } else {
        context.clearRect(0, 0, w, h);
      }
      context.save();
      context.scale(resolution, resolution);
      if (style.backgroundColor) {
        context.fillStyle = style.backgroundColor;
        context.fillRect(0, 0, w, h);
      }
      style.syncStyle(canvas, context);
      context.textBaseline = "alphabetic";
      context.translate(padding.left, padding.top);
      var linePositionX;
      var linePositionY;
      for (var i = 0; i < textSize.lines; i++) {
        linePositionX = style.strokeThickness / 2;
        linePositionY = style.strokeThickness / 2 + i * textSize.lineHeight + size.ascent;
        if (i > 0) {
          linePositionY += textSize.lineSpacing * i;
        }
        if (style.rtl) {
          linePositionX = w - linePositionX;
        } else if (style.align === "right") {
          linePositionX += textWidth - textSize.lineWidths[i];
        } else if (style.align === "center") {
          linePositionX += (textWidth - textSize.lineWidths[i]) / 2;
        } else if (style.align === "justify") {
          var minimumLengthToApplyJustification = 0.85;
          if (textSize.lineWidths[i] / textSize.width >= minimumLengthToApplyJustification) {
            var extraSpace = textSize.width - textSize.lineWidths[i];
            var spaceSize = context.measureText(" ").width;
            var trimmedLine = lines[i].trim();
            var array = trimmedLine.split(" ");
            extraSpace += (lines[i].length - trimmedLine.length) * spaceSize;
            var extraSpaceCharacters = Math.floor(extraSpace / spaceSize);
            var idx = 0;
            while (extraSpaceCharacters > 0) {
              array[idx] += " ";
              idx = (idx + 1) % (array.length - 1 || 1);
              --extraSpaceCharacters;
            }
            lines[i] = array.join(" ");
          }
        }
        if (this.autoRound) {
          linePositionX = Math.round(linePositionX);
          linePositionY = Math.round(linePositionY);
        }
        if (style.strokeThickness) {
          this.style.syncShadow(context, style.shadowStroke);
          context.strokeText(lines[i], linePositionX, linePositionY);
        }
        if (style.color) {
          this.style.syncShadow(context, style.shadowFill);
          context.fillText(lines[i], linePositionX, linePositionY);
        }
      }
      context.restore();
      if (this.renderer && this.renderer.gl) {
        this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
        this.frame.glTexture = this.frame.source.glTexture;
      }
      this.dirty = true;
      var input = this.input;
      if (input && !input.customHitArea) {
        input.hitArea.width = this.width;
        input.hitArea.height = this.height;
      }
      return this;
    },
    getTextMetrics: function() {
      return this.style.getTextMetrics();
    },
    text: {
      get: function() {
        return this._text;
      },
      set: function(value) {
        this.setText(value);
      }
    },
    toJSON: function() {
      var out = Components.ToJSON(this);
      var data = {
        autoRound: this.autoRound,
        text: this._text,
        style: this.style.toJSON(),
        padding: {
          left: this.padding.left,
          right: this.padding.right,
          top: this.padding.top,
          bottom: this.padding.bottom
        }
      };
      out.data = data;
      return out;
    },
    preDestroy: function() {
      if (this.style.rtl) {
        RemoveFromDOM(this.canvas);
      }
      CanvasPool.remove(this.canvas);
      this.texture.destroy();
    }
  });
  module2.exports = Text;
});

// node_modules/phaser/src/gameobjects/tilesprite/TileSpriteWebGLRenderer.js
var require_TileSpriteWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Utils = require_Utils();
  var TileSpriteWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    src.updateCanvas();
    var width = src.width;
    var height = src.height;
    if (width === 0 || height === 0) {
      return;
    }
    camera.addToRenderList(src);
    renderer.pipelines.preBatch(src);
    var getTint = Utils.getTintAppendFloatAlpha;
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var textureUnit = pipeline.setTexture2D(src.fillPattern, src);
    pipeline.batchTexture(src, src.fillPattern, src.displayFrame.width * src.tileScaleX, src.displayFrame.height * src.tileScaleY, src.x, src.y, width, height, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.originX * width, src.originY * height, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, src.tilePositionX % src.displayFrame.width / src.displayFrame.width, src.tilePositionY % src.displayFrame.height / src.displayFrame.height, camera, parentMatrix, false, textureUnit);
    renderer.pipelines.postBatch(src);
  };
  module2.exports = TileSpriteWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/tilesprite/TileSpriteCanvasRenderer.js
var require_TileSpriteCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TileSpriteCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    src.updateCanvas();
    camera.addToRenderList(src);
    renderer.batchSprite(src, src.frame, camera, parentMatrix);
  };
  module2.exports = TileSpriteCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/tilesprite/TileSpriteRender.js
var require_TileSpriteRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_TileSpriteWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_TileSpriteCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/tilesprite/TileSprite.js
var require_TileSprite = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CanvasPool = require_CanvasPool();
  var Class = require_Class();
  var Components = require_components();
  var GameEvents = require_events();
  var GameObject = require_GameObject();
  var GetPowerOfTwo = require_GetPowerOfTwo();
  var Smoothing = require_Smoothing();
  var TileSpriteRender = require_TileSpriteRender();
  var Vector2 = require_Vector2();
  var _FLAG = 8;
  var TileSprite = new Class({
    Extends: GameObject,
    Mixins: [
      Components.Alpha,
      Components.BlendMode,
      Components.ComputedSize,
      Components.Crop,
      Components.Depth,
      Components.Flip,
      Components.GetBounds,
      Components.Mask,
      Components.Origin,
      Components.Pipeline,
      Components.ScrollFactor,
      Components.Tint,
      Components.Transform,
      Components.Visible,
      TileSpriteRender
    ],
    initialize: function TileSprite2(scene, x, y, width, height, textureKey, frameKey) {
      var renderer = scene.sys.renderer;
      GameObject.call(this, scene, "TileSprite");
      var displayTexture = scene.sys.textures.get(textureKey);
      var displayFrame = displayTexture.get(frameKey);
      if (!width || !height) {
        width = displayFrame.width;
        height = displayFrame.height;
      } else {
        width = Math.floor(width);
        height = Math.floor(height);
      }
      this._tilePosition = new Vector2();
      this._tileScale = new Vector2(1, 1);
      this.dirty = false;
      this.renderer = renderer;
      this.canvas = CanvasPool.create(this, width, height);
      this.context = this.canvas.getContext("2d");
      this.displayTexture = displayTexture;
      this.displayFrame = displayFrame;
      this._crop = this.resetCropObject();
      this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);
      this.frame = this.texture.get();
      this.potWidth = GetPowerOfTwo(displayFrame.width);
      this.potHeight = GetPowerOfTwo(displayFrame.height);
      this.fillCanvas = CanvasPool.create2D(this, this.potWidth, this.potHeight);
      this.fillContext = this.fillCanvas.getContext("2d");
      this.fillPattern = null;
      this.setPosition(x, y);
      this.setSize(width, height);
      this.setFrame(frameKey);
      this.setOriginFromFrame();
      this.initPipeline();
      scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function(renderer2) {
        if (!renderer2) {
          return;
        }
        var gl = renderer2.gl;
        this.dirty = true;
        this.fillPattern = null;
        this.fillPattern = renderer2.createTexture2D(0, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT, gl.RGBA, this.fillCanvas, this.potWidth, this.potHeight);
      }, this);
    },
    setTexture: function(key, frame) {
      this.displayTexture = this.scene.sys.textures.get(key);
      return this.setFrame(frame);
    },
    setFrame: function(frame) {
      var newFrame = this.displayTexture.get(frame);
      this.potWidth = GetPowerOfTwo(newFrame.width);
      this.potHeight = GetPowerOfTwo(newFrame.height);
      this.canvas.width = 0;
      if (!newFrame.cutWidth || !newFrame.cutHeight) {
        this.renderFlags &= ~_FLAG;
      } else {
        this.renderFlags |= _FLAG;
      }
      this.displayFrame = newFrame;
      this.dirty = true;
      this.updateTileTexture();
      return this;
    },
    setTilePosition: function(x, y) {
      if (x !== void 0) {
        this.tilePositionX = x;
      }
      if (y !== void 0) {
        this.tilePositionY = y;
      }
      return this;
    },
    setTileScale: function(x, y) {
      if (x === void 0) {
        x = this.tileScaleX;
      }
      if (y === void 0) {
        y = x;
      }
      this.tileScaleX = x;
      this.tileScaleY = y;
      return this;
    },
    updateTileTexture: function() {
      if (!this.dirty || !this.renderer) {
        return;
      }
      var frame = this.displayFrame;
      if (frame.source.isRenderTexture || frame.source.isGLTexture) {
        console.warn("TileSprites can only use Image or Canvas based textures");
        this.dirty = false;
        return;
      }
      var ctx = this.fillContext;
      var canvas = this.fillCanvas;
      var fw = this.potWidth;
      var fh = this.potHeight;
      if (!this.renderer || !this.renderer.gl) {
        fw = frame.cutWidth;
        fh = frame.cutHeight;
      }
      ctx.clearRect(0, 0, fw, fh);
      canvas.width = fw;
      canvas.height = fh;
      ctx.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, 0, 0, fw, fh);
      if (this.renderer && this.renderer.gl) {
        this.fillPattern = this.renderer.canvasToTexture(canvas, this.fillPattern);
      } else {
        this.fillPattern = ctx.createPattern(canvas, "repeat");
      }
      this.updateCanvas();
      this.dirty = false;
    },
    updateCanvas: function() {
      var canvas = this.canvas;
      if (canvas.width !== this.width || canvas.height !== this.height) {
        canvas.width = this.width;
        canvas.height = this.height;
        this.frame.setSize(this.width, this.height);
        this.updateDisplayOrigin();
        this.dirty = true;
      }
      if (!this.dirty || this.renderer && this.renderer.gl) {
        this.dirty = false;
        return;
      }
      var ctx = this.context;
      if (!this.scene.sys.game.config.antialias) {
        Smoothing.disable(ctx);
      }
      var scaleX = this._tileScale.x;
      var scaleY = this._tileScale.y;
      var positionX = this._tilePosition.x;
      var positionY = this._tilePosition.y;
      ctx.clearRect(0, 0, this.width, this.height);
      ctx.save();
      ctx.scale(scaleX, scaleY);
      ctx.translate(-positionX, -positionY);
      ctx.fillStyle = this.fillPattern;
      ctx.fillRect(positionX, positionY, this.width / scaleX, this.height / scaleY);
      ctx.restore();
      this.dirty = false;
    },
    preDestroy: function() {
      if (this.renderer && this.renderer.gl) {
        this.renderer.deleteTexture(this.fillPattern);
      }
      CanvasPool.remove(this.canvas);
      CanvasPool.remove(this.fillCanvas);
      this.fillPattern = null;
      this.fillContext = null;
      this.fillCanvas = null;
      this.displayTexture = null;
      this.displayFrame = null;
      this.texture.destroy();
      this.renderer = null;
    },
    tilePositionX: {
      get: function() {
        return this._tilePosition.x;
      },
      set: function(value) {
        this._tilePosition.x = value;
        this.dirty = true;
      }
    },
    tilePositionY: {
      get: function() {
        return this._tilePosition.y;
      },
      set: function(value) {
        this._tilePosition.y = value;
        this.dirty = true;
      }
    },
    tileScaleX: {
      get: function() {
        return this._tileScale.x;
      },
      set: function(value) {
        this._tileScale.x = value;
        this.dirty = true;
      }
    },
    tileScaleY: {
      get: function() {
        return this._tileScale.y;
      },
      set: function(value) {
        this._tileScale.y = value;
        this.dirty = true;
      }
    }
  });
  module2.exports = TileSprite;
});

// node_modules/phaser/src/gameobjects/video/VideoWebGLRenderer.js
var require_VideoWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var VideoWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    if (src.videoTexture) {
      camera.addToRenderList(src);
      src.pipeline.batchSprite(src, camera, parentMatrix);
    }
  };
  module2.exports = VideoWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/video/VideoCanvasRenderer.js
var require_VideoCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var VideoCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    if (src.videoTexture) {
      camera.addToRenderList(src);
      renderer.batchSprite(src, src.frame, camera, parentMatrix);
    }
  };
  module2.exports = VideoCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/video/VideoRender.js
var require_VideoRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_VideoWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_VideoCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/video/Video.js
var require_Video2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Clamp = require_Clamp();
  var Components = require_components();
  var Events = require_events4();
  var GameEvents = require_events();
  var InputEvents = require_events13();
  var GameObject = require_GameObject();
  var SoundEvents = require_events15();
  var UUID = require_UUID();
  var VideoRender = require_VideoRender();
  var MATH_CONST = require_const4();
  var Video = new Class({
    Extends: GameObject,
    Mixins: [
      Components.Alpha,
      Components.BlendMode,
      Components.Depth,
      Components.Flip,
      Components.GetBounds,
      Components.Mask,
      Components.Origin,
      Components.Pipeline,
      Components.ScrollFactor,
      Components.Size,
      Components.TextureCrop,
      Components.Tint,
      Components.Transform,
      Components.Visible,
      VideoRender
    ],
    initialize: function Video2(scene, x, y, key) {
      GameObject.call(this, scene, "Video");
      this.video = null;
      this.videoTexture = null;
      this.videoTextureSource = null;
      this.snapshotTexture = null;
      this.flipY = false;
      this._key = UUID();
      this.touchLocked = true;
      this.playWhenUnlocked = false;
      this.retryLimit = 20;
      this.retry = 0;
      this.retryInterval = 500;
      this._retryID = null;
      this._systemMuted = false;
      this._codeMuted = false;
      this._systemPaused = false;
      this._codePaused = false;
      this._callbacks = {
        play: this.playHandler.bind(this),
        error: this.loadErrorHandler.bind(this),
        end: this.completeHandler.bind(this),
        time: this.timeUpdateHandler.bind(this),
        seeking: this.seekingHandler.bind(this),
        seeked: this.seekedHandler.bind(this)
      };
      this._crop = this.resetCropObject();
      this.markers = {};
      this._markerIn = -1;
      this._markerOut = MATH_CONST.MAX_SAFE_INTEGER;
      this._lastUpdate = 0;
      this._cacheKey = "";
      this._isSeeking = false;
      this.removeVideoElementOnDestroy = false;
      this.setPosition(x, y);
      this.initPipeline();
      if (key) {
        this.changeSource(key, false);
      }
      var game2 = scene.sys.game.events;
      game2.on(GameEvents.PAUSE, this.globalPause, this);
      game2.on(GameEvents.RESUME, this.globalResume, this);
      var sound = scene.sys.sound;
      if (sound) {
        sound.on(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
      }
    },
    addedToScene: function() {
      this.scene.sys.updateList.add(this);
    },
    removedFromScene: function() {
      this.scene.sys.updateList.remove(this);
    },
    play: function(loop, markerIn, markerOut) {
      if (this.touchLocked && this.playWhenUnlocked || this.isPlaying()) {
        return this;
      }
      var video = this.video;
      if (!video) {
        console.warn("Video not loaded");
        return this;
      }
      if (loop === void 0) {
        loop = video.loop;
      }
      var sound = this.scene.sys.sound;
      if (sound && sound.mute) {
        this.setMute(true);
      }
      if (!isNaN(markerIn)) {
        this._markerIn = markerIn;
      }
      if (!isNaN(markerOut) && markerOut > markerIn) {
        this._markerOut = markerOut;
      }
      video.loop = loop;
      var callbacks = this._callbacks;
      var playPromise = video.play();
      if (playPromise !== void 0) {
        playPromise.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this));
      } else {
        video.addEventListener("playing", callbacks.play, true);
        if (video.readyState < 2) {
          this.retry = this.retryLimit;
          this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
        }
      }
      video.addEventListener("ended", callbacks.end, true);
      video.addEventListener("timeupdate", callbacks.time, true);
      video.addEventListener("seeking", callbacks.seeking, true);
      video.addEventListener("seeked", callbacks.seeked, true);
      return this;
    },
    changeSource: function(key, autoplay, loop, markerIn, markerOut) {
      if (autoplay === void 0) {
        autoplay = true;
      }
      var currentVideo = this.video;
      if (currentVideo) {
        this.stop();
      }
      var newVideo = this.scene.sys.cache.video.get(key);
      if (newVideo) {
        this.video = newVideo;
        this._cacheKey = key;
        this._codePaused = newVideo.paused;
        this._codeMuted = newVideo.muted;
        if (this.videoTexture) {
          this.scene.sys.textures.remove(this._key);
          this.videoTexture = this.scene.sys.textures.create(this._key, newVideo, newVideo.videoWidth, newVideo.videoHeight);
          this.videoTextureSource = this.videoTexture.source[0];
          this.videoTexture.add("__BASE", 0, 0, 0, newVideo.videoWidth, newVideo.videoHeight);
          this.setTexture(this.videoTexture);
          this.setSizeToFrame();
          this.updateDisplayOrigin();
          this.emit(Events.VIDEO_CREATED, this, newVideo.videoWidth, newVideo.videoHeight);
        } else {
          this.updateTexture();
        }
        newVideo.currentTime = 0;
        this._lastUpdate = 0;
        if (autoplay) {
          this.play(loop, markerIn, markerOut);
        }
      } else {
        this.video = null;
      }
      return this;
    },
    addMarker: function(key, markerIn, markerOut) {
      if (!isNaN(markerIn) && markerIn >= 0 && !isNaN(markerOut)) {
        this.markers[key] = [markerIn, markerOut];
      }
      return this;
    },
    playMarker: function(key, loop) {
      var marker = this.markers[key];
      if (marker) {
        this.play(loop, marker[0], marker[1]);
      }
      return this;
    },
    removeMarker: function(key) {
      delete this.markers[key];
      return this;
    },
    snapshot: function(width, height) {
      if (width === void 0) {
        width = this.width;
      }
      if (height === void 0) {
        height = this.height;
      }
      return this.snapshotArea(0, 0, this.width, this.height, width, height);
    },
    snapshotArea: function(x, y, srcWidth, srcHeight, destWidth, destHeight) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (srcWidth === void 0) {
        srcWidth = this.width;
      }
      if (srcHeight === void 0) {
        srcHeight = this.height;
      }
      if (destWidth === void 0) {
        destWidth = srcWidth;
      }
      if (destHeight === void 0) {
        destHeight = srcHeight;
      }
      var video = this.video;
      var snap = this.snapshotTexture;
      if (!snap) {
        snap = this.scene.sys.textures.createCanvas(UUID(), destWidth, destHeight);
        this.snapshotTexture = snap;
        if (video) {
          snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);
        }
      } else {
        snap.setSize(destWidth, destHeight);
        if (video) {
          snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);
        }
      }
      return snap.update();
    },
    saveSnapshotTexture: function(key) {
      if (this.snapshotTexture) {
        this.scene.sys.textures.renameTexture(this.snapshotTexture.key, key);
      } else {
        this.snapshotTexture = this.scene.sys.textures.createCanvas(key, this.width, this.height);
      }
      return this.snapshotTexture;
    },
    loadURL: function(url, loadEvent, noAudio) {
      if (loadEvent === void 0) {
        loadEvent = "loadeddata";
      }
      if (noAudio === void 0) {
        noAudio = false;
      }
      if (this.video) {
        this.stop();
      }
      if (this.videoTexture) {
        this.scene.sys.textures.remove(this._key);
      }
      var video = document.createElement("video");
      video.controls = false;
      if (noAudio) {
        video.muted = true;
        video.defaultMuted = true;
        video.setAttribute("autoplay", "autoplay");
      }
      video.setAttribute("playsinline", "playsinline");
      video.setAttribute("preload", "auto");
      video.addEventListener("error", this._callbacks.error, true);
      video.src = url;
      video.load();
      this.video = video;
      return this;
    },
    loadMediaStream: function(stream, loadEvent, noAudio) {
      if (loadEvent === void 0) {
        loadEvent = "loadeddata";
      }
      if (noAudio === void 0) {
        noAudio = false;
      }
      if (this.video) {
        this.stop();
      }
      if (this.videoTexture) {
        this.scene.sys.textures.remove(this._key);
      }
      var video = document.createElement("video");
      video.controls = false;
      if (noAudio) {
        video.muted = true;
        video.defaultMuted = true;
        video.setAttribute("autoplay", "autoplay");
      }
      video.setAttribute("playsinline", "playsinline");
      video.setAttribute("preload", "auto");
      video.addEventListener("error", this._callbacks.error, true);
      try {
        video.srcObject = stream;
      } catch (error) {
        video.src = window.URL.createObjectURL(stream);
      }
      video.load();
      this.video = video;
      return this;
    },
    playPromiseSuccessHandler: function() {
      this._codePaused = false;
      this.touchLocked = false;
      this.emit(Events.VIDEO_PLAY, this);
      if (this._markerIn > -1) {
        this.video.currentTime = this._markerIn;
      }
    },
    playPromiseErrorHandler: function(error) {
      this.scene.sys.input.once(InputEvents.POINTER_DOWN, this.unlockHandler, this);
      this.touchLocked = true;
      this.playWhenUnlocked = true;
      this.emit(Events.VIDEO_ERROR, this, error);
    },
    playHandler: function() {
      this._codePaused = false;
      this.touchLocked = false;
      this.emit(Events.VIDEO_PLAY, this);
      this.video.removeEventListener("playing", this._callbacks.play, true);
    },
    loadErrorHandler: function(event) {
      this.stop();
      this.emit(Events.VIDEO_ERROR, this, event);
    },
    unlockHandler: function() {
      this.touchLocked = false;
      this.playWhenUnlocked = false;
      this.emit(Events.VIDEO_UNLOCKED, this);
      if (this._markerIn > -1) {
        this.video.currentTime = this._markerIn;
      }
      this.video.play();
      this.emit(Events.VIDEO_PLAY, this);
    },
    completeHandler: function() {
      this.emit(Events.VIDEO_COMPLETE, this);
    },
    timeUpdateHandler: function() {
      if (this.video && this.video.currentTime < this._lastUpdate) {
        this.emit(Events.VIDEO_LOOP, this);
        this._lastUpdate = 0;
      }
    },
    preUpdate: function() {
      var video = this.video;
      if (video) {
        var currentTime = video.currentTime;
        if (currentTime !== this._lastUpdate) {
          this._lastUpdate = currentTime;
          this.updateTexture();
          if (currentTime >= this._markerOut) {
            if (video.loop) {
              video.currentTime = this._markerIn;
              this.updateTexture();
              this._lastUpdate = currentTime;
              this.emit(Events.VIDEO_LOOP, this);
            } else {
              this.emit(Events.VIDEO_COMPLETE, this);
              this.stop();
            }
          }
        }
      }
    },
    checkVideoProgress: function() {
      if (this.video.readyState >= 2) {
        this.updateTexture();
      } else {
        this.retry--;
        if (this.retry > 0) {
          this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
        } else {
          this.emit(Events.VIDEO_TIMEOUT, this);
        }
      }
    },
    updateTexture: function() {
      var video = this.video;
      var width = video.videoWidth;
      var height = video.videoHeight;
      if (!this.videoTexture) {
        this.videoTexture = this.scene.sys.textures.create(this._key, video, width, height);
        this.videoTextureSource = this.videoTexture.source[0];
        this.videoTexture.add("__BASE", 0, 0, 0, width, height);
        this.setTexture(this.videoTexture);
        this.setSizeToFrame();
        this.updateDisplayOrigin();
        this.emit(Events.VIDEO_CREATED, this, width, height);
      } else {
        var textureSource = this.videoTextureSource;
        if (textureSource.source !== video) {
          textureSource.source = video;
          textureSource.width = width;
          textureSource.height = height;
        }
        textureSource.update();
      }
    },
    getVideoKey: function() {
      return this._cacheKey;
    },
    seekTo: function(value) {
      var video = this.video;
      if (video) {
        var duration = video.duration;
        if (duration !== Infinity && !isNaN(duration)) {
          var seekTime = duration * value;
          this.setCurrentTime(seekTime);
        }
      }
      return this;
    },
    getCurrentTime: function() {
      return this.video ? this.video.currentTime : 0;
    },
    setCurrentTime: function(value) {
      var video = this.video;
      if (video) {
        if (typeof value === "string") {
          var op = value[0];
          var num = parseFloat(value.substr(1));
          if (op === "+") {
            value = video.currentTime + num;
          } else if (op === "-") {
            value = video.currentTime - num;
          }
        }
        video.currentTime = value;
        this._lastUpdate = value;
      }
      return this;
    },
    isSeeking: function() {
      return this._isSeeking;
    },
    seekingHandler: function() {
      this._isSeeking = true;
      this.emit(Events.VIDEO_SEEKING, this);
    },
    seekedHandler: function() {
      this._isSeeking = false;
      this.emit(Events.VIDEO_SEEKED, this);
      var video = this.video;
      if (video) {
        this.updateTexture();
      }
    },
    getProgress: function() {
      var video = this.video;
      if (video) {
        var now = video.currentTime;
        var duration = video.duration;
        if (duration !== Infinity && !isNaN(duration)) {
          return now / duration;
        }
      }
      return 0;
    },
    getDuration: function() {
      return this.video ? this.video.duration : 0;
    },
    setMute: function(value) {
      if (value === void 0) {
        value = true;
      }
      this._codeMuted = value;
      var video = this.video;
      if (video) {
        video.muted = this._systemMuted ? true : value;
      }
      return this;
    },
    isMuted: function() {
      return this._codeMuted;
    },
    globalMute: function(soundManager, value) {
      this._systemMuted = value;
      var video = this.video;
      if (video) {
        video.muted = this._codeMuted ? true : value;
      }
    },
    globalPause: function() {
      this._systemPaused = true;
      if (this.video) {
        this.video.pause();
      }
    },
    globalResume: function() {
      this._systemPaused = false;
      if (this.video && !this._codePaused) {
        this.video.play();
      }
    },
    setPaused: function(value) {
      if (value === void 0) {
        value = true;
      }
      var video = this.video;
      this._codePaused = value;
      if (video) {
        if (value) {
          if (!video.paused) {
            video.pause();
          }
        } else if (!value) {
          if (video.paused && !this._systemPaused) {
            video.play();
          }
        }
      }
      return this;
    },
    getVolume: function() {
      return this.video ? this.video.volume : 1;
    },
    setVolume: function(value) {
      if (value === void 0) {
        value = 1;
      }
      if (this.video) {
        this.video.volume = Clamp(value, 0, 1);
      }
      return this;
    },
    getPlaybackRate: function() {
      return this.video ? this.video.playbackRate : 1;
    },
    setPlaybackRate: function(rate) {
      if (this.video) {
        this.video.playbackRate = rate;
      }
      return this;
    },
    getLoop: function() {
      return this.video ? this.video.loop : false;
    },
    setLoop: function(value) {
      if (value === void 0) {
        value = true;
      }
      if (this.video) {
        this.video.loop = value;
      }
      return this;
    },
    isPlaying: function() {
      return this.video ? !(this.video.paused || this.video.ended) : false;
    },
    isPaused: function() {
      return this.video && this.video.paused || this._codePaused || this._systemPaused;
    },
    saveTexture: function(key, flipY) {
      if (flipY === void 0) {
        flipY = false;
      }
      if (this.videoTexture) {
        this.scene.sys.textures.renameTexture(this._key, key);
      }
      this._key = key;
      this.flipY = flipY;
      if (this.videoTextureSource) {
        this.videoTextureSource.setFlipY(flipY);
      }
      return this.videoTexture;
    },
    stop: function() {
      var video = this.video;
      if (video) {
        var callbacks = this._callbacks;
        for (var callback in callbacks) {
          video.removeEventListener(callback, callbacks[callback], true);
        }
        video.pause();
      }
      if (this._retryID) {
        window.clearTimeout(this._retryID);
      }
      this.emit(Events.VIDEO_STOP, this);
      return this;
    },
    removeVideoElement: function() {
      var video = this.video;
      if (!video) {
        return;
      }
      if (video.parentNode) {
        video.parentNode.removeChild(video);
      }
      while (video.hasChildNodes()) {
        video.removeChild(video.firstChild);
      }
      video.removeAttribute("autoplay");
      video.removeAttribute("src");
      this.video = null;
    },
    preDestroy: function() {
      this.stop();
      if (this.removeVideoElementOnDestroy) {
        this.removeVideoElement();
      }
      var game2 = this.scene.sys.game.events;
      game2.off(GameEvents.PAUSE, this.globalPause, this);
      game2.off(GameEvents.RESUME, this.globalResume, this);
      var sound = this.scene.sys.sound;
      if (sound) {
        sound.off(SoundEvents.GLOBAL_MUTE, this.globalMute, this);
      }
      if (this._retryID) {
        window.clearTimeout(this._retryID);
      }
    }
  });
  module2.exports = Video;
});

// node_modules/phaser/src/gameobjects/shape/Shape.js
var require_Shape = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components();
  var GameObject = require_GameObject();
  var Line = require_Line();
  var Shape = new Class({
    Extends: GameObject,
    Mixins: [
      Components.AlphaSingle,
      Components.BlendMode,
      Components.Depth,
      Components.GetBounds,
      Components.Mask,
      Components.Origin,
      Components.Pipeline,
      Components.ScrollFactor,
      Components.Transform,
      Components.Visible
    ],
    initialize: function Shape2(scene, type, data) {
      if (type === void 0) {
        type = "Shape";
      }
      GameObject.call(this, scene, type);
      this.geom = data;
      this.pathData = [];
      this.pathIndexes = [];
      this.fillColor = 16777215;
      this.fillAlpha = 1;
      this.strokeColor = 16777215;
      this.strokeAlpha = 1;
      this.lineWidth = 1;
      this.isFilled = false;
      this.isStroked = false;
      this.closePath = true;
      this._tempLine = new Line();
      this.width = 0;
      this.height = 0;
      this.initPipeline();
    },
    setFillStyle: function(color, alpha) {
      if (alpha === void 0) {
        alpha = 1;
      }
      if (color === void 0) {
        this.isFilled = false;
      } else {
        this.fillColor = color;
        this.fillAlpha = alpha;
        this.isFilled = true;
      }
      return this;
    },
    setStrokeStyle: function(lineWidth, color, alpha) {
      if (alpha === void 0) {
        alpha = 1;
      }
      if (lineWidth === void 0) {
        this.isStroked = false;
      } else {
        this.lineWidth = lineWidth;
        this.strokeColor = color;
        this.strokeAlpha = alpha;
        this.isStroked = true;
      }
      return this;
    },
    setClosePath: function(value) {
      this.closePath = value;
      return this;
    },
    setSize: function(width, height) {
      this.width = width;
      this.height = height;
      return this;
    },
    setDisplaySize: function(width, height) {
      this.displayWidth = width;
      this.displayHeight = height;
      return this;
    },
    preDestroy: function() {
      this.geom = null;
      this._tempLine = null;
      this.pathData = [];
      this.pathIndexes = [];
    },
    displayWidth: {
      get: function() {
        return this.scaleX * this.width;
      },
      set: function(value) {
        this.scaleX = value / this.width;
      }
    },
    displayHeight: {
      get: function() {
        return this.scaleY * this.height;
      },
      set: function(value) {
        this.scaleY = value / this.height;
      }
    }
  });
  module2.exports = Shape;
});

// node_modules/phaser/src/gameobjects/shape/FillPathWebGL.js
var require_FillPathWebGL = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Utils = require_Utils();
  var FillPathWebGL = function(pipeline, calcMatrix, src, alpha, dx, dy) {
    var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
    var path = src.pathData;
    var pathIndexes = src.pathIndexes;
    for (var i = 0; i < pathIndexes.length; i += 3) {
      var p0 = pathIndexes[i] * 2;
      var p1 = pathIndexes[i + 1] * 2;
      var p2 = pathIndexes[i + 2] * 2;
      var x0 = path[p0 + 0] - dx;
      var y0 = path[p0 + 1] - dy;
      var x1 = path[p1 + 0] - dx;
      var y1 = path[p1 + 1] - dy;
      var x2 = path[p2 + 0] - dx;
      var y2 = path[p2 + 1] - dy;
      var tx0 = calcMatrix.getX(x0, y0);
      var ty0 = calcMatrix.getY(x0, y0);
      var tx1 = calcMatrix.getX(x1, y1);
      var ty1 = calcMatrix.getY(x1, y1);
      var tx2 = calcMatrix.getX(x2, y2);
      var ty2 = calcMatrix.getY(x2, y2);
      pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
    }
  };
  module2.exports = FillPathWebGL;
});

// node_modules/phaser/src/gameobjects/shape/StrokePathWebGL.js
var require_StrokePathWebGL = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Utils = require_Utils();
  var StrokePathWebGL = function(pipeline, src, alpha, dx, dy) {
    var strokeTint = pipeline.strokeTint;
    var strokeTintColor = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
    strokeTint.TL = strokeTintColor;
    strokeTint.TR = strokeTintColor;
    strokeTint.BL = strokeTintColor;
    strokeTint.BR = strokeTintColor;
    var path = src.pathData;
    var pathLength = path.length - 1;
    var lineWidth = src.lineWidth;
    var halfLineWidth = lineWidth / 2;
    var px1 = path[0] - dx;
    var py1 = path[1] - dy;
    if (!src.closePath) {
      pathLength -= 2;
    }
    for (var i = 2; i < pathLength; i += 2) {
      var px2 = path[i] - dx;
      var py2 = path[i + 1] - dy;
      pipeline.batchLine(px1, py1, px2, py2, halfLineWidth, halfLineWidth, lineWidth, i - 2, src.closePath ? i === pathLength - 1 : false);
      px1 = px2;
      py1 = py2;
    }
  };
  module2.exports = StrokePathWebGL;
});

// node_modules/phaser/src/gameobjects/shape/arc/ArcWebGLRenderer.js
var require_ArcWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var FillPathWebGL = require_FillPathWebGL();
  var StrokePathWebGL = require_StrokePathWebGL();
  var ArcWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);
    if (src.isFilled) {
      FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
    }
    if (src.isStroked) {
      StrokePathWebGL(pipeline, src, alpha, dx, dy);
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = ArcWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/shape/FillStyleCanvas.js
var require_FillStyleCanvas = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillStyleCanvas = function(ctx, src, altColor, altAlpha) {
    var fillColor = altColor ? altColor : src.fillColor;
    var fillAlpha = altAlpha ? altAlpha : src.fillAlpha;
    var red = (fillColor & 16711680) >>> 16;
    var green = (fillColor & 65280) >>> 8;
    var blue = fillColor & 255;
    ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
  };
  module2.exports = FillStyleCanvas;
});

// node_modules/phaser/src/gameobjects/shape/LineStyleCanvas.js
var require_LineStyleCanvas = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var LineStyleCanvas = function(ctx, src, altColor, altAlpha) {
    var strokeColor = altColor ? altColor : src.strokeColor;
    var strokeAlpha = altAlpha ? altAlpha : src.strokeAlpha;
    var red = (strokeColor & 16711680) >>> 16;
    var green = (strokeColor & 65280) >>> 8;
    var blue = strokeColor & 255;
    ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + strokeAlpha + ")";
    ctx.lineWidth = src.lineWidth;
  };
  module2.exports = LineStyleCanvas;
});

// node_modules/phaser/src/gameobjects/shape/arc/ArcCanvasRenderer.js
var require_ArcCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DegToRad = require_DegToRad();
  var FillStyleCanvas = require_FillStyleCanvas();
  var LineStyleCanvas = require_LineStyleCanvas();
  var SetTransform = require_SetTransform();
  var ArcCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      var radius = src.radius;
      ctx.beginPath();
      ctx.arc(radius - src.originX * (radius * 2), radius - src.originY * (radius * 2), radius, DegToRad(src._startAngle), DegToRad(src._endAngle), src.anticlockwise);
      if (src.closePath) {
        ctx.closePath();
      }
      if (src.isFilled) {
        FillStyleCanvas(ctx, src);
        ctx.fill();
      }
      if (src.isStroked) {
        LineStyleCanvas(ctx, src);
        ctx.stroke();
      }
      ctx.restore();
    }
  };
  module2.exports = ArcCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/shape/arc/ArcRender.js
var require_ArcRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_ArcWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_ArcCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/shape/arc/Arc.js
var require_Arc = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ArcRender = require_ArcRender();
  var Class = require_Class();
  var DegToRad = require_DegToRad();
  var Earcut = require_Earcut();
  var GeomCircle = require_Circle();
  var MATH_CONST = require_const4();
  var Shape = require_Shape();
  var Arc = new Class({
    Extends: Shape,
    Mixins: [
      ArcRender
    ],
    initialize: function Arc2(scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (radius === void 0) {
        radius = 128;
      }
      if (startAngle === void 0) {
        startAngle = 0;
      }
      if (endAngle === void 0) {
        endAngle = 360;
      }
      if (anticlockwise === void 0) {
        anticlockwise = false;
      }
      Shape.call(this, scene, "Arc", new GeomCircle(0, 0, radius));
      this._startAngle = startAngle;
      this._endAngle = endAngle;
      this._anticlockwise = anticlockwise;
      this._iterations = 0.01;
      this.setPosition(x, y);
      var diameter = this.geom.radius * 2;
      this.setSize(diameter, diameter);
      if (fillColor !== void 0) {
        this.setFillStyle(fillColor, fillAlpha);
      }
      this.updateDisplayOrigin();
      this.updateData();
    },
    iterations: {
      get: function() {
        return this._iterations;
      },
      set: function(value) {
        this._iterations = value;
        this.updateData();
      }
    },
    radius: {
      get: function() {
        return this.geom.radius;
      },
      set: function(value) {
        this.geom.radius = value;
        var diameter = value * 2;
        this.setSize(diameter, diameter);
        this.updateDisplayOrigin();
        this.updateData();
      }
    },
    startAngle: {
      get: function() {
        return this._startAngle;
      },
      set: function(value) {
        this._startAngle = value;
        this.updateData();
      }
    },
    endAngle: {
      get: function() {
        return this._endAngle;
      },
      set: function(value) {
        this._endAngle = value;
        this.updateData();
      }
    },
    anticlockwise: {
      get: function() {
        return this._anticlockwise;
      },
      set: function(value) {
        this._anticlockwise = value;
        this.updateData();
      }
    },
    setRadius: function(value) {
      this.radius = value;
      return this;
    },
    setIterations: function(value) {
      if (value === void 0) {
        value = 0.01;
      }
      this.iterations = value;
      return this;
    },
    setStartAngle: function(angle, anticlockwise) {
      this._startAngle = angle;
      if (anticlockwise !== void 0) {
        this._anticlockwise = anticlockwise;
      }
      return this.updateData();
    },
    setEndAngle: function(angle, anticlockwise) {
      this._endAngle = angle;
      if (anticlockwise !== void 0) {
        this._anticlockwise = anticlockwise;
      }
      return this.updateData();
    },
    updateData: function() {
      var step = this._iterations;
      var iteration = step;
      var radius = this.geom.radius;
      var startAngle = DegToRad(this._startAngle);
      var endAngle = DegToRad(this._endAngle);
      var anticlockwise = this._anticlockwise;
      var x = radius;
      var y = radius;
      endAngle -= startAngle;
      if (anticlockwise) {
        if (endAngle < -MATH_CONST.PI2) {
          endAngle = -MATH_CONST.PI2;
        } else if (endAngle > 0) {
          endAngle = -MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;
        }
      } else if (endAngle > MATH_CONST.PI2) {
        endAngle = MATH_CONST.PI2;
      } else if (endAngle < 0) {
        endAngle = MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;
      }
      var path = [x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius];
      var ta;
      while (iteration < 1) {
        ta = endAngle * iteration + startAngle;
        path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);
        iteration += step;
      }
      ta = endAngle + startAngle;
      path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);
      path.push(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius);
      this.pathIndexes = Earcut(path);
      this.pathData = path;
      return this;
    }
  });
  module2.exports = Arc;
});

// node_modules/phaser/src/gameobjects/shape/curve/CurveWebGLRenderer.js
var require_CurveWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillPathWebGL = require_FillPathWebGL();
  var GetCalcMatrix = require_GetCalcMatrix();
  var StrokePathWebGL = require_StrokePathWebGL();
  var CurveWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX + src._curveBounds.x;
    var dy = src._displayOriginY + src._curveBounds.y;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);
    if (src.isFilled) {
      FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
    }
    if (src.isStroked) {
      StrokePathWebGL(pipeline, src, alpha, dx, dy);
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = CurveWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/shape/curve/CurveCanvasRenderer.js
var require_CurveCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillStyleCanvas = require_FillStyleCanvas();
  var LineStyleCanvas = require_LineStyleCanvas();
  var SetTransform = require_SetTransform();
  var CurveCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      var dx = src._displayOriginX + src._curveBounds.x;
      var dy = src._displayOriginY + src._curveBounds.y;
      var path = src.pathData;
      var pathLength = path.length - 1;
      var px1 = path[0] - dx;
      var py1 = path[1] - dy;
      ctx.beginPath();
      ctx.moveTo(px1, py1);
      if (!src.closePath) {
        pathLength -= 2;
      }
      for (var i = 2; i < pathLength; i += 2) {
        var px2 = path[i] - dx;
        var py2 = path[i + 1] - dy;
        ctx.lineTo(px2, py2);
      }
      if (src.closePath) {
        ctx.closePath();
      }
      if (src.isFilled) {
        FillStyleCanvas(ctx, src);
        ctx.fill();
      }
      if (src.isStroked) {
        LineStyleCanvas(ctx, src);
        ctx.stroke();
      }
      ctx.restore();
    }
  };
  module2.exports = CurveCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/shape/curve/CurveRender.js
var require_CurveRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_CurveWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_CurveCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/shape/curve/Curve.js
var require_Curve2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CurveRender = require_CurveRender();
  var Earcut = require_Earcut();
  var Rectangle = require_Rectangle();
  var Shape = require_Shape();
  var Curve = new Class({
    Extends: Shape,
    Mixins: [
      CurveRender
    ],
    initialize: function Curve2(scene, x, y, curve, fillColor, fillAlpha) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      Shape.call(this, scene, "Curve", curve);
      this._smoothness = 32;
      this._curveBounds = new Rectangle();
      this.closePath = false;
      this.setPosition(x, y);
      if (fillColor !== void 0) {
        this.setFillStyle(fillColor, fillAlpha);
      }
      this.updateData();
    },
    smoothness: {
      get: function() {
        return this._smoothness;
      },
      set: function(value) {
        this._smoothness = value;
        this.updateData();
      }
    },
    setSmoothness: function(value) {
      this._smoothness = value;
      return this.updateData();
    },
    updateData: function() {
      var bounds = this._curveBounds;
      var smoothness = this._smoothness;
      this.geom.getBounds(bounds, smoothness);
      this.setSize(bounds.width, bounds.height);
      this.updateDisplayOrigin();
      var path = [];
      var points = this.geom.getPoints(smoothness);
      for (var i = 0; i < points.length; i++) {
        path.push(points[i].x, points[i].y);
      }
      path.push(points[0].x, points[0].y);
      this.pathIndexes = Earcut(path);
      this.pathData = path;
      return this;
    }
  });
  module2.exports = Curve;
});

// node_modules/phaser/src/gameobjects/shape/ellipse/EllipseWebGLRenderer.js
var require_EllipseWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillPathWebGL = require_FillPathWebGL();
  var GetCalcMatrix = require_GetCalcMatrix();
  var StrokePathWebGL = require_StrokePathWebGL();
  var EllipseWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);
    if (src.isFilled) {
      FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
    }
    if (src.isStroked) {
      StrokePathWebGL(pipeline, src, alpha, dx, dy);
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = EllipseWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/shape/ellipse/EllipseCanvasRenderer.js
var require_EllipseCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillStyleCanvas = require_FillStyleCanvas();
  var LineStyleCanvas = require_LineStyleCanvas();
  var SetTransform = require_SetTransform();
  var EllipseCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      var path = src.pathData;
      var pathLength = path.length - 1;
      var px1 = path[0] - dx;
      var py1 = path[1] - dy;
      ctx.beginPath();
      ctx.moveTo(px1, py1);
      if (!src.closePath) {
        pathLength -= 2;
      }
      for (var i = 2; i < pathLength; i += 2) {
        var px2 = path[i] - dx;
        var py2 = path[i + 1] - dy;
        ctx.lineTo(px2, py2);
      }
      ctx.closePath();
      if (src.isFilled) {
        FillStyleCanvas(ctx, src);
        ctx.fill();
      }
      if (src.isStroked) {
        LineStyleCanvas(ctx, src);
        ctx.stroke();
      }
      ctx.restore();
    }
  };
  module2.exports = EllipseCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/shape/ellipse/EllipseRender.js
var require_EllipseRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_EllipseWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_EllipseCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/shape/ellipse/Ellipse.js
var require_Ellipse2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Earcut = require_Earcut();
  var EllipseRender = require_EllipseRender();
  var GeomEllipse = require_Ellipse();
  var Shape = require_Shape();
  var Ellipse = new Class({
    Extends: Shape,
    Mixins: [
      EllipseRender
    ],
    initialize: function Ellipse2(scene, x, y, width, height, fillColor, fillAlpha) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 128;
      }
      if (height === void 0) {
        height = 128;
      }
      Shape.call(this, scene, "Ellipse", new GeomEllipse(width / 2, height / 2, width, height));
      this._smoothness = 64;
      this.setPosition(x, y);
      this.width = width;
      this.height = height;
      if (fillColor !== void 0) {
        this.setFillStyle(fillColor, fillAlpha);
      }
      this.updateDisplayOrigin();
      this.updateData();
    },
    smoothness: {
      get: function() {
        return this._smoothness;
      },
      set: function(value) {
        this._smoothness = value;
        this.updateData();
      }
    },
    setSize: function(width, height) {
      this.width = width;
      this.height = height;
      this.geom.setPosition(width / 2, height / 2);
      this.geom.setSize(width, height);
      return this.updateData();
    },
    setSmoothness: function(value) {
      this._smoothness = value;
      return this.updateData();
    },
    updateData: function() {
      var path = [];
      var points = this.geom.getPoints(this._smoothness);
      for (var i = 0; i < points.length; i++) {
        path.push(points[i].x, points[i].y);
      }
      path.push(points[0].x, points[0].y);
      this.pathIndexes = Earcut(path);
      this.pathData = path;
      return this;
    }
  });
  module2.exports = Ellipse;
});

// node_modules/phaser/src/gameobjects/shape/grid/GridWebGLRenderer.js
var require_GridWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var Utils = require_Utils();
  var GridWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    calcMatrix.translate(-src._displayOriginX, -src._displayOriginY);
    var alpha = camera.alpha * src.alpha;
    var width = src.width;
    var height = src.height;
    var cellWidth = src.cellWidth;
    var cellHeight = src.cellHeight;
    var gridWidth = Math.ceil(width / cellWidth);
    var gridHeight = Math.ceil(height / cellHeight);
    var cellWidthA = cellWidth;
    var cellHeightA = cellHeight;
    var cellWidthB = cellWidth - (gridWidth * cellWidth - width);
    var cellHeightB = cellHeight - (gridHeight * cellHeight - height);
    var fillTint;
    var fillTintColor;
    var showCells = src.showCells;
    var showAltCells = src.showAltCells;
    var showOutline = src.showOutline;
    var x = 0;
    var y = 0;
    var r = 0;
    var cw = 0;
    var ch = 0;
    if (showOutline) {
      cellWidthA--;
      cellHeightA--;
      if (cellWidthB === cellWidth) {
        cellWidthB--;
      }
      if (cellHeightB === cellHeight) {
        cellHeightB--;
      }
    }
    renderer.pipelines.preBatch(src);
    if (showCells && src.fillAlpha > 0) {
      fillTint = pipeline.fillTint;
      fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
      fillTint.TL = fillTintColor;
      fillTint.TR = fillTintColor;
      fillTint.BL = fillTintColor;
      fillTint.BR = fillTintColor;
      for (y = 0; y < gridHeight; y++) {
        if (showAltCells) {
          r = y % 2;
        }
        for (x = 0; x < gridWidth; x++) {
          if (showAltCells && r) {
            r = 0;
            continue;
          }
          r++;
          cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
          ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
          pipeline.batchFillRect(x * cellWidth, y * cellHeight, cw, ch);
        }
      }
    }
    if (showAltCells && src.altFillAlpha > 0) {
      fillTint = pipeline.fillTint;
      fillTintColor = Utils.getTintAppendFloatAlpha(src.altFillColor, src.altFillAlpha * alpha);
      fillTint.TL = fillTintColor;
      fillTint.TR = fillTintColor;
      fillTint.BL = fillTintColor;
      fillTint.BR = fillTintColor;
      for (y = 0; y < gridHeight; y++) {
        if (showAltCells) {
          r = y % 2;
        }
        for (x = 0; x < gridWidth; x++) {
          if (showAltCells && !r) {
            r = 1;
            continue;
          }
          r = 0;
          cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
          ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
          pipeline.batchFillRect(x * cellWidth, y * cellHeight, cw, ch);
        }
      }
    }
    if (showOutline && src.outlineFillAlpha > 0) {
      var strokeTint = pipeline.strokeTint;
      var color = Utils.getTintAppendFloatAlpha(src.outlineFillColor, src.outlineFillAlpha * alpha);
      strokeTint.TL = color;
      strokeTint.TR = color;
      strokeTint.BL = color;
      strokeTint.BR = color;
      for (x = 1; x < gridWidth; x++) {
        var x1 = x * cellWidth;
        pipeline.batchLine(x1, 0, x1, height, 1, 1, 1, 0, false);
      }
      for (y = 1; y < gridHeight; y++) {
        var y1 = y * cellHeight;
        pipeline.batchLine(0, y1, width, y1, 1, 1, 1, 0, false);
      }
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = GridWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/shape/grid/GridCanvasRenderer.js
var require_GridCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillStyleCanvas = require_FillStyleCanvas();
  var LineStyleCanvas = require_LineStyleCanvas();
  var SetTransform = require_SetTransform();
  var GridCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      var dx = -src._displayOriginX;
      var dy = -src._displayOriginY;
      var alpha = camera.alpha * src.alpha;
      var width = src.width;
      var height = src.height;
      var cellWidth = src.cellWidth;
      var cellHeight = src.cellHeight;
      var gridWidth = Math.ceil(width / cellWidth);
      var gridHeight = Math.ceil(height / cellHeight);
      var cellWidthA = cellWidth;
      var cellHeightA = cellHeight;
      var cellWidthB = cellWidth - (gridWidth * cellWidth - width);
      var cellHeightB = cellHeight - (gridHeight * cellHeight - height);
      var showCells = src.showCells;
      var showAltCells = src.showAltCells;
      var showOutline = src.showOutline;
      var x = 0;
      var y = 0;
      var r = 0;
      var cw = 0;
      var ch = 0;
      if (showOutline) {
        cellWidthA--;
        cellHeightA--;
        if (cellWidthB === cellWidth) {
          cellWidthB--;
        }
        if (cellHeightB === cellHeight) {
          cellHeightB--;
        }
      }
      if (showCells && src.fillAlpha > 0) {
        FillStyleCanvas(ctx, src);
        for (y = 0; y < gridHeight; y++) {
          if (showAltCells) {
            r = y % 2;
          }
          for (x = 0; x < gridWidth; x++) {
            if (showAltCells && r) {
              r = 0;
              continue;
            }
            r++;
            cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
            ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
            ctx.fillRect(dx + x * cellWidth, dy + y * cellHeight, cw, ch);
          }
        }
      }
      if (showAltCells && src.altFillAlpha > 0) {
        FillStyleCanvas(ctx, src, src.altFillColor, src.altFillAlpha * alpha);
        for (y = 0; y < gridHeight; y++) {
          if (showAltCells) {
            r = y % 2;
          }
          for (x = 0; x < gridWidth; x++) {
            if (showAltCells && !r) {
              r = 1;
              continue;
            }
            r = 0;
            cw = x < gridWidth - 1 ? cellWidthA : cellWidthB;
            ch = y < gridHeight - 1 ? cellHeightA : cellHeightB;
            ctx.fillRect(dx + x * cellWidth, dy + y * cellHeight, cw, ch);
          }
        }
      }
      if (showOutline && src.outlineFillAlpha > 0) {
        LineStyleCanvas(ctx, src, src.outlineFillColor, src.outlineFillAlpha * alpha);
        for (x = 1; x < gridWidth; x++) {
          var x1 = x * cellWidth;
          ctx.beginPath();
          ctx.moveTo(x1 + dx, dy);
          ctx.lineTo(x1 + dx, height + dy);
          ctx.stroke();
        }
        for (y = 1; y < gridHeight; y++) {
          var y1 = y * cellHeight;
          ctx.beginPath();
          ctx.moveTo(dx, y1 + dy);
          ctx.lineTo(dx + width, y1 + dy);
          ctx.stroke();
        }
      }
      ctx.restore();
    }
  };
  module2.exports = GridCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/shape/grid/GridRender.js
var require_GridRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_GridWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_GridCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/shape/grid/Grid.js
var require_Grid = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Shape = require_Shape();
  var GridRender = require_GridRender();
  var Grid = new Class({
    Extends: Shape,
    Mixins: [
      GridRender
    ],
    initialize: function Grid2(scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 128;
      }
      if (height === void 0) {
        height = 128;
      }
      if (cellWidth === void 0) {
        cellWidth = 32;
      }
      if (cellHeight === void 0) {
        cellHeight = 32;
      }
      Shape.call(this, scene, "Grid", null);
      this.cellWidth = cellWidth;
      this.cellHeight = cellHeight;
      this.showCells = true;
      this.outlineFillColor = 0;
      this.outlineFillAlpha = 0;
      this.showOutline = true;
      this.showAltCells = false;
      this.altFillColor;
      this.altFillAlpha;
      this.setPosition(x, y);
      this.setSize(width, height);
      this.setFillStyle(fillColor, fillAlpha);
      if (outlineFillColor !== void 0) {
        this.setOutlineStyle(outlineFillColor, outlineFillAlpha);
      }
      this.updateDisplayOrigin();
    },
    setFillStyle: function(fillColor, fillAlpha) {
      if (fillAlpha === void 0) {
        fillAlpha = 1;
      }
      if (fillColor === void 0) {
        this.showCells = false;
      } else {
        this.fillColor = fillColor;
        this.fillAlpha = fillAlpha;
        this.showCells = true;
      }
      return this;
    },
    setAltFillStyle: function(fillColor, fillAlpha) {
      if (fillAlpha === void 0) {
        fillAlpha = 1;
      }
      if (fillColor === void 0) {
        this.showAltCells = false;
      } else {
        this.altFillColor = fillColor;
        this.altFillAlpha = fillAlpha;
        this.showAltCells = true;
      }
      return this;
    },
    setOutlineStyle: function(fillColor, fillAlpha) {
      if (fillAlpha === void 0) {
        fillAlpha = 1;
      }
      if (fillColor === void 0) {
        this.showOutline = false;
      } else {
        this.outlineFillColor = fillColor;
        this.outlineFillAlpha = fillAlpha;
        this.showOutline = true;
      }
      return this;
    }
  });
  module2.exports = Grid;
});

// node_modules/phaser/src/gameobjects/shape/isobox/IsoBoxWebGLRenderer.js
var require_IsoBoxWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var Utils = require_Utils();
  var IsoBoxWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var size = src.width;
    var height = src.height;
    var sizeA = size / 2;
    var sizeB = size / src.projection;
    var alpha = camera.alpha * src.alpha;
    if (!src.isFilled) {
      return;
    }
    var tint;
    var x0;
    var y0;
    var x1;
    var y1;
    var x2;
    var y2;
    var x3;
    var y3;
    renderer.pipelines.preBatch(src);
    if (src.showTop) {
      tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);
      x0 = calcMatrix.getX(-sizeA, -height);
      y0 = calcMatrix.getY(-sizeA, -height);
      x1 = calcMatrix.getX(0, -sizeB - height);
      y1 = calcMatrix.getY(0, -sizeB - height);
      x2 = calcMatrix.getX(sizeA, -height);
      y2 = calcMatrix.getY(sizeA, -height);
      x3 = calcMatrix.getX(0, sizeB - height);
      y3 = calcMatrix.getY(0, sizeB - height);
      pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
    }
    if (src.showLeft) {
      tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);
      x0 = calcMatrix.getX(-sizeA, 0);
      y0 = calcMatrix.getY(-sizeA, 0);
      x1 = calcMatrix.getX(0, sizeB);
      y1 = calcMatrix.getY(0, sizeB);
      x2 = calcMatrix.getX(0, sizeB - height);
      y2 = calcMatrix.getY(0, sizeB - height);
      x3 = calcMatrix.getX(-sizeA, -height);
      y3 = calcMatrix.getY(-sizeA, -height);
      pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
    }
    if (src.showRight) {
      tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);
      x0 = calcMatrix.getX(sizeA, 0);
      y0 = calcMatrix.getY(sizeA, 0);
      x1 = calcMatrix.getX(0, sizeB);
      y1 = calcMatrix.getY(0, sizeB);
      x2 = calcMatrix.getX(0, sizeB - height);
      y2 = calcMatrix.getY(0, sizeB - height);
      x3 = calcMatrix.getX(sizeA, -height);
      y3 = calcMatrix.getY(sizeA, -height);
      pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = IsoBoxWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/shape/isobox/IsoBoxCanvasRenderer.js
var require_IsoBoxCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillStyleCanvas = require_FillStyleCanvas();
  var SetTransform = require_SetTransform();
  var IsoBoxCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled) {
      var size = src.width;
      var height = src.height;
      var sizeA = size / 2;
      var sizeB = size / src.projection;
      if (src.showTop) {
        FillStyleCanvas(ctx, src, src.fillTop);
        ctx.beginPath();
        ctx.moveTo(-sizeA, -height);
        ctx.lineTo(0, -sizeB - height);
        ctx.lineTo(sizeA, -height);
        ctx.lineTo(sizeA, -1);
        ctx.lineTo(0, sizeB - 1);
        ctx.lineTo(-sizeA, -1);
        ctx.lineTo(-sizeA, -height);
        ctx.fill();
      }
      if (src.showLeft) {
        FillStyleCanvas(ctx, src, src.fillLeft);
        ctx.beginPath();
        ctx.moveTo(-sizeA, 0);
        ctx.lineTo(0, sizeB);
        ctx.lineTo(0, sizeB - height);
        ctx.lineTo(-sizeA, -height);
        ctx.lineTo(-sizeA, 0);
        ctx.fill();
      }
      if (src.showRight) {
        FillStyleCanvas(ctx, src, src.fillRight);
        ctx.beginPath();
        ctx.moveTo(sizeA, 0);
        ctx.lineTo(0, sizeB);
        ctx.lineTo(0, sizeB - height);
        ctx.lineTo(sizeA, -height);
        ctx.lineTo(sizeA, 0);
        ctx.fill();
      }
      ctx.restore();
    }
  };
  module2.exports = IsoBoxCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/shape/isobox/IsoBoxRender.js
var require_IsoBoxRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_IsoBoxWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_IsoBoxCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/shape/isobox/IsoBox.js
var require_IsoBox = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var IsoBoxRender = require_IsoBoxRender();
  var Class = require_Class();
  var Shape = require_Shape();
  var IsoBox = new Class({
    Extends: Shape,
    Mixins: [
      IsoBoxRender
    ],
    initialize: function IsoBox2(scene, x, y, size, height, fillTop, fillLeft, fillRight) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (size === void 0) {
        size = 48;
      }
      if (height === void 0) {
        height = 32;
      }
      if (fillTop === void 0) {
        fillTop = 15658734;
      }
      if (fillLeft === void 0) {
        fillLeft = 10066329;
      }
      if (fillRight === void 0) {
        fillRight = 13421772;
      }
      Shape.call(this, scene, "IsoBox", null);
      this.projection = 4;
      this.fillTop = fillTop;
      this.fillLeft = fillLeft;
      this.fillRight = fillRight;
      this.showTop = true;
      this.showLeft = true;
      this.showRight = true;
      this.isFilled = true;
      this.setPosition(x, y);
      this.setSize(size, height);
      this.updateDisplayOrigin();
    },
    setProjection: function(value) {
      this.projection = value;
      return this;
    },
    setFaces: function(showTop, showLeft, showRight) {
      if (showTop === void 0) {
        showTop = true;
      }
      if (showLeft === void 0) {
        showLeft = true;
      }
      if (showRight === void 0) {
        showRight = true;
      }
      this.showTop = showTop;
      this.showLeft = showLeft;
      this.showRight = showRight;
      return this;
    },
    setFillStyle: function(fillTop, fillLeft, fillRight) {
      this.fillTop = fillTop;
      this.fillLeft = fillLeft;
      this.fillRight = fillRight;
      this.isFilled = true;
      return this;
    }
  });
  module2.exports = IsoBox;
});

// node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangleWebGLRenderer.js
var require_IsoTriangleWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var Utils = require_Utils();
  var IsoTriangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var size = src.width;
    var height = src.height;
    var sizeA = size / 2;
    var sizeB = size / src.projection;
    var reversed = src.isReversed;
    var alpha = camera.alpha * src.alpha;
    if (!src.isFilled) {
      return;
    }
    renderer.pipelines.preBatch(src);
    var tint;
    var x0;
    var y0;
    var x1;
    var y1;
    var x2;
    var y2;
    if (src.showTop && reversed) {
      tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);
      x0 = calcMatrix.getX(-sizeA, -height);
      y0 = calcMatrix.getY(-sizeA, -height);
      x1 = calcMatrix.getX(0, -sizeB - height);
      y1 = calcMatrix.getY(0, -sizeB - height);
      x2 = calcMatrix.getX(sizeA, -height);
      y2 = calcMatrix.getY(sizeA, -height);
      var x3 = calcMatrix.getX(0, sizeB - height);
      var y3 = calcMatrix.getY(0, sizeB - height);
      pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);
    }
    if (src.showLeft) {
      tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);
      if (reversed) {
        x0 = calcMatrix.getX(-sizeA, -height);
        y0 = calcMatrix.getY(-sizeA, -height);
        x1 = calcMatrix.getX(0, sizeB);
        y1 = calcMatrix.getY(0, sizeB);
        x2 = calcMatrix.getX(0, sizeB - height);
        y2 = calcMatrix.getY(0, sizeB - height);
      } else {
        x0 = calcMatrix.getX(-sizeA, 0);
        y0 = calcMatrix.getY(-sizeA, 0);
        x1 = calcMatrix.getX(0, sizeB);
        y1 = calcMatrix.getY(0, sizeB);
        x2 = calcMatrix.getX(0, sizeB - height);
        y2 = calcMatrix.getY(0, sizeB - height);
      }
      pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);
    }
    if (src.showRight) {
      tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);
      if (reversed) {
        x0 = calcMatrix.getX(sizeA, -height);
        y0 = calcMatrix.getY(sizeA, -height);
        x1 = calcMatrix.getX(0, sizeB);
        y1 = calcMatrix.getY(0, sizeB);
        x2 = calcMatrix.getX(0, sizeB - height);
        y2 = calcMatrix.getY(0, sizeB - height);
      } else {
        x0 = calcMatrix.getX(sizeA, 0);
        y0 = calcMatrix.getY(sizeA, 0);
        x1 = calcMatrix.getX(0, sizeB);
        y1 = calcMatrix.getY(0, sizeB);
        x2 = calcMatrix.getX(0, sizeB - height);
        y2 = calcMatrix.getY(0, sizeB - height);
      }
      pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = IsoTriangleWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangleCanvasRenderer.js
var require_IsoTriangleCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillStyleCanvas = require_FillStyleCanvas();
  var SetTransform = require_SetTransform();
  var IsoTriangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled) {
      var size = src.width;
      var height = src.height;
      var sizeA = size / 2;
      var sizeB = size / src.projection;
      var reversed = src.isReversed;
      if (src.showTop && reversed) {
        FillStyleCanvas(ctx, src, src.fillTop);
        ctx.beginPath();
        ctx.moveTo(-sizeA, -height);
        ctx.lineTo(0, -sizeB - height);
        ctx.lineTo(sizeA, -height);
        ctx.lineTo(0, sizeB - height);
        ctx.fill();
      }
      if (src.showLeft) {
        FillStyleCanvas(ctx, src, src.fillLeft);
        ctx.beginPath();
        if (reversed) {
          ctx.moveTo(-sizeA, -height);
          ctx.lineTo(0, sizeB);
          ctx.lineTo(0, sizeB - height);
        } else {
          ctx.moveTo(-sizeA, 0);
          ctx.lineTo(0, sizeB);
          ctx.lineTo(0, sizeB - height);
        }
        ctx.fill();
      }
      if (src.showRight) {
        FillStyleCanvas(ctx, src, src.fillRight);
        ctx.beginPath();
        if (reversed) {
          ctx.moveTo(sizeA, -height);
          ctx.lineTo(0, sizeB);
          ctx.lineTo(0, sizeB - height);
        } else {
          ctx.moveTo(sizeA, 0);
          ctx.lineTo(0, sizeB);
          ctx.lineTo(0, sizeB - height);
        }
        ctx.fill();
      }
      ctx.restore();
    }
  };
  module2.exports = IsoTriangleCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangleRender.js
var require_IsoTriangleRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_IsoTriangleWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_IsoTriangleCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangle.js
var require_IsoTriangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var IsoTriangleRender = require_IsoTriangleRender();
  var Shape = require_Shape();
  var IsoTriangle = new Class({
    Extends: Shape,
    Mixins: [
      IsoTriangleRender
    ],
    initialize: function IsoTriangle2(scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (size === void 0) {
        size = 48;
      }
      if (height === void 0) {
        height = 32;
      }
      if (reversed === void 0) {
        reversed = false;
      }
      if (fillTop === void 0) {
        fillTop = 15658734;
      }
      if (fillLeft === void 0) {
        fillLeft = 10066329;
      }
      if (fillRight === void 0) {
        fillRight = 13421772;
      }
      Shape.call(this, scene, "IsoTriangle", null);
      this.projection = 4;
      this.fillTop = fillTop;
      this.fillLeft = fillLeft;
      this.fillRight = fillRight;
      this.showTop = true;
      this.showLeft = true;
      this.showRight = true;
      this.isReversed = reversed;
      this.isFilled = true;
      this.setPosition(x, y);
      this.setSize(size, height);
      this.updateDisplayOrigin();
    },
    setProjection: function(value) {
      this.projection = value;
      return this;
    },
    setReversed: function(reversed) {
      this.isReversed = reversed;
      return this;
    },
    setFaces: function(showTop, showLeft, showRight) {
      if (showTop === void 0) {
        showTop = true;
      }
      if (showLeft === void 0) {
        showLeft = true;
      }
      if (showRight === void 0) {
        showRight = true;
      }
      this.showTop = showTop;
      this.showLeft = showLeft;
      this.showRight = showRight;
      return this;
    },
    setFillStyle: function(fillTop, fillLeft, fillRight) {
      this.fillTop = fillTop;
      this.fillLeft = fillLeft;
      this.fillRight = fillRight;
      this.isFilled = true;
      return this;
    }
  });
  module2.exports = IsoTriangle;
});

// node_modules/phaser/src/gameobjects/shape/line/LineWebGLRenderer.js
var require_LineWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var Utils = require_Utils();
  var LineWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);
    if (src.isStroked) {
      var strokeTint = pipeline.strokeTint;
      var color = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
      strokeTint.TL = color;
      strokeTint.TR = color;
      strokeTint.BL = color;
      strokeTint.BR = color;
      var startWidth = src._startWidth;
      var endWidth = src._endWidth;
      pipeline.batchLine(src.geom.x1 - dx, src.geom.y1 - dy, src.geom.x2 - dx, src.geom.y2 - dy, startWidth, endWidth, 1, 0, false, result.sprite, result.camera);
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = LineWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/shape/line/LineCanvasRenderer.js
var require_LineCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var LineStyleCanvas = require_LineStyleCanvas();
  var SetTransform = require_SetTransform();
  var LineCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      if (src.isStroked) {
        LineStyleCanvas(ctx, src);
        ctx.beginPath();
        ctx.moveTo(src.geom.x1 - dx, src.geom.y1 - dy);
        ctx.lineTo(src.geom.x2 - dx, src.geom.y2 - dy);
        ctx.stroke();
      }
      ctx.restore();
    }
  };
  module2.exports = LineCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/shape/line/LineRender.js
var require_LineRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_LineWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_LineCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/shape/line/Line.js
var require_Line2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Shape = require_Shape();
  var GeomLine = require_Line();
  var LineRender = require_LineRender();
  var Line = new Class({
    Extends: Shape,
    Mixins: [
      LineRender
    ],
    initialize: function Line2(scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (x1 === void 0) {
        x1 = 0;
      }
      if (y1 === void 0) {
        y1 = 0;
      }
      if (x2 === void 0) {
        x2 = 128;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      Shape.call(this, scene, "Line", new GeomLine(x1, y1, x2, y2));
      var width = Math.max(1, this.geom.right - this.geom.left);
      var height = Math.max(1, this.geom.bottom - this.geom.top);
      this.lineWidth = 1;
      this._startWidth = 1;
      this._endWidth = 1;
      this.setPosition(x, y);
      this.setSize(width, height);
      if (strokeColor !== void 0) {
        this.setStrokeStyle(1, strokeColor, strokeAlpha);
      }
      this.updateDisplayOrigin();
    },
    setLineWidth: function(startWidth, endWidth) {
      if (endWidth === void 0) {
        endWidth = startWidth;
      }
      this._startWidth = startWidth;
      this._endWidth = endWidth;
      this.lineWidth = startWidth;
      return this;
    },
    setTo: function(x1, y1, x2, y2) {
      this.geom.setTo(x1, y1, x2, y2);
      return this;
    }
  });
  module2.exports = Line;
});

// node_modules/phaser/src/gameobjects/shape/polygon/PolygonWebGLRenderer.js
var require_PolygonWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillPathWebGL = require_FillPathWebGL();
  var GetCalcMatrix = require_GetCalcMatrix();
  var StrokePathWebGL = require_StrokePathWebGL();
  var PolygonWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);
    if (src.isFilled) {
      FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
    }
    if (src.isStroked) {
      StrokePathWebGL(pipeline, src, alpha, dx, dy);
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = PolygonWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/shape/polygon/PolygonCanvasRenderer.js
var require_PolygonCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillStyleCanvas = require_FillStyleCanvas();
  var LineStyleCanvas = require_LineStyleCanvas();
  var SetTransform = require_SetTransform();
  var PolygonCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      var path = src.pathData;
      var pathLength = path.length - 1;
      var px1 = path[0] - dx;
      var py1 = path[1] - dy;
      ctx.beginPath();
      ctx.moveTo(px1, py1);
      if (!src.closePath) {
        pathLength -= 2;
      }
      for (var i = 2; i < pathLength; i += 2) {
        var px2 = path[i] - dx;
        var py2 = path[i + 1] - dy;
        ctx.lineTo(px2, py2);
      }
      ctx.closePath();
      if (src.isFilled) {
        FillStyleCanvas(ctx, src);
        ctx.fill();
      }
      if (src.isStroked) {
        LineStyleCanvas(ctx, src);
        ctx.stroke();
      }
      ctx.restore();
    }
  };
  module2.exports = PolygonCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/shape/polygon/PolygonRender.js
var require_PolygonRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_PolygonWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_PolygonCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/geom/polygon/GetAABB.js
var require_GetAABB = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  var GetAABB = function(polygon, out) {
    if (out === void 0) {
      out = new Rectangle();
    }
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -minX;
    var maxY = -minY;
    var p;
    for (var i = 0; i < polygon.points.length; i++) {
      p = polygon.points[i];
      minX = Math.min(minX, p.x);
      minY = Math.min(minY, p.y);
      maxX = Math.max(maxX, p.x);
      maxY = Math.max(maxY, p.y);
    }
    out.x = minX;
    out.y = minY;
    out.width = maxX - minX;
    out.height = maxY - minY;
    return out;
  };
  module2.exports = GetAABB;
});

// node_modules/phaser/src/geom/polygon/Contains.js
var require_Contains4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = function(polygon, x, y) {
    var inside = false;
    for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i) {
      var ix = polygon.points[i].x;
      var iy = polygon.points[i].y;
      var jx = polygon.points[j].x;
      var jy = polygon.points[j].y;
      if ((iy <= y && y < jy || jy <= y && y < iy) && x < (jx - ix) * (y - iy) / (jy - iy) + ix) {
        inside = !inside;
      }
    }
    return inside;
  };
  module2.exports = Contains;
});

// node_modules/phaser/src/geom/polygon/Perimeter.js
var require_Perimeter2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Length = require_Length();
  var Line = require_Line();
  var Perimeter = function(polygon) {
    var points = polygon.points;
    var perimeter = 0;
    for (var i = 0; i < points.length; i++) {
      var pointA = points[i];
      var pointB = points[(i + 1) % points.length];
      var line = new Line(pointA.x, pointA.y, pointB.x, pointB.y);
      perimeter += Length(line);
    }
    return perimeter;
  };
  module2.exports = Perimeter;
});

// node_modules/phaser/src/geom/polygon/GetPoints.js
var require_GetPoints5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Length = require_Length();
  var Line = require_Line();
  var Perimeter = require_Perimeter2();
  var GetPoints = function(polygon, quantity, stepRate, out) {
    if (out === void 0) {
      out = [];
    }
    var points = polygon.points;
    var perimeter = Perimeter(polygon);
    if (!quantity && stepRate > 0) {
      quantity = perimeter / stepRate;
    }
    for (var i = 0; i < quantity; i++) {
      var position = perimeter * (i / quantity);
      var accumulatedPerimeter = 0;
      for (var j = 0; j < points.length; j++) {
        var pointA = points[j];
        var pointB = points[(j + 1) % points.length];
        var line = new Line(pointA.x, pointA.y, pointB.x, pointB.y);
        var length = Length(line);
        if (position < accumulatedPerimeter || position > accumulatedPerimeter + length) {
          accumulatedPerimeter += length;
          continue;
        }
        var point = line.getPoint((position - accumulatedPerimeter) / length);
        out.push(point);
        break;
      }
    }
    return out;
  };
  module2.exports = GetPoints;
});

// node_modules/phaser/src/geom/polygon/Polygon.js
var require_Polygon = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Contains = require_Contains4();
  var GetPoints = require_GetPoints5();
  var GEOM_CONST = require_const3();
  var Polygon = new Class({
    initialize: function Polygon2(points) {
      this.type = GEOM_CONST.POLYGON;
      this.area = 0;
      this.points = [];
      if (points) {
        this.setTo(points);
      }
    },
    contains: function(x, y) {
      return Contains(this, x, y);
    },
    setTo: function(points) {
      this.area = 0;
      this.points = [];
      if (typeof points === "string") {
        points = points.split(" ");
      }
      if (!Array.isArray(points)) {
        return this;
      }
      var p;
      var y0 = Number.MAX_VALUE;
      for (var i = 0; i < points.length; i++) {
        p = {x: 0, y: 0};
        if (typeof points[i] === "number" || typeof points[i] === "string") {
          p.x = parseFloat(points[i]);
          p.y = parseFloat(points[i + 1]);
          i++;
        } else if (Array.isArray(points[i])) {
          p.x = points[i][0];
          p.y = points[i][1];
        } else {
          p.x = points[i].x;
          p.y = points[i].y;
        }
        this.points.push(p);
        if (p.y < y0) {
          y0 = p.y;
        }
      }
      this.calculateArea(y0);
      return this;
    },
    calculateArea: function() {
      if (this.points.length < 3) {
        this.area = 0;
        return this.area;
      }
      var sum = 0;
      var p1;
      var p2;
      for (var i = 0; i < this.points.length - 1; i++) {
        p1 = this.points[i];
        p2 = this.points[i + 1];
        sum += (p2.x - p1.x) * (p1.y + p2.y);
      }
      p1 = this.points[0];
      p2 = this.points[this.points.length - 1];
      sum += (p1.x - p2.x) * (p2.y + p1.y);
      this.area = -sum * 0.5;
      return this.area;
    },
    getPoints: function(quantity, step, output) {
      return GetPoints(this, quantity, step, output);
    }
  });
  module2.exports = Polygon;
});

// node_modules/phaser/src/geom/polygon/Smooth.js
var require_Smooth = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Igor Ognichenko <ognichenko.igor@gmail.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
  };
  var Smooth = function(polygon) {
    var i;
    var points = [];
    var data = polygon.points;
    for (i = 0; i < data.length; i++) {
      points.push([data[i].x, data[i].y]);
    }
    var output = [];
    if (points.length > 0) {
      output.push(copy([0, 0], points[0]));
    }
    for (i = 0; i < points.length - 1; i++) {
      var p0 = points[i];
      var p1 = points[i + 1];
      var p0x = p0[0];
      var p0y = p0[1];
      var p1x = p1[0];
      var p1y = p1[1];
      output.push([0.85 * p0x + 0.15 * p1x, 0.85 * p0y + 0.15 * p1y]);
      output.push([0.15 * p0x + 0.85 * p1x, 0.15 * p0y + 0.85 * p1y]);
    }
    if (points.length > 1) {
      output.push(copy([0, 0], points[points.length - 1]));
    }
    return polygon.setTo(output);
  };
  module2.exports = Smooth;
});

// node_modules/phaser/src/gameobjects/shape/polygon/Polygon.js
var require_Polygon2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PolygonRender = require_PolygonRender();
  var Class = require_Class();
  var Earcut = require_Earcut();
  var GetAABB = require_GetAABB();
  var GeomPolygon = require_Polygon();
  var Shape = require_Shape();
  var Smooth = require_Smooth();
  var Polygon = new Class({
    Extends: Shape,
    Mixins: [
      PolygonRender
    ],
    initialize: function Polygon2(scene, x, y, points, fillColor, fillAlpha) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      Shape.call(this, scene, "Polygon", new GeomPolygon(points));
      var bounds = GetAABB(this.geom);
      this.setPosition(x, y);
      this.setSize(bounds.width, bounds.height);
      if (fillColor !== void 0) {
        this.setFillStyle(fillColor, fillAlpha);
      }
      this.updateDisplayOrigin();
      this.updateData();
    },
    smooth: function(iterations) {
      if (iterations === void 0) {
        iterations = 1;
      }
      for (var i = 0; i < iterations; i++) {
        Smooth(this.geom);
      }
      return this.updateData();
    },
    updateData: function() {
      var path = [];
      var points = this.geom.points;
      for (var i = 0; i < points.length; i++) {
        path.push(points[i].x, points[i].y);
      }
      path.push(points[0].x, points[0].y);
      this.pathIndexes = Earcut(path);
      this.pathData = path;
      return this;
    }
  });
  module2.exports = Polygon;
});

// node_modules/phaser/src/gameobjects/shape/rectangle/RectangleWebGLRenderer.js
var require_RectangleWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var StrokePathWebGL = require_StrokePathWebGL();
  var Utils = require_Utils();
  var RectangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);
    if (src.isFilled) {
      var fillTint = pipeline.fillTint;
      var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
      fillTint.TL = fillTintColor;
      fillTint.TR = fillTintColor;
      fillTint.BL = fillTintColor;
      fillTint.BR = fillTintColor;
      pipeline.batchFillRect(-dx, -dy, src.width, src.height);
    }
    if (src.isStroked) {
      StrokePathWebGL(pipeline, src, alpha, dx, dy);
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = RectangleWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/shape/rectangle/RectangleCanvasRenderer.js
var require_RectangleCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillStyleCanvas = require_FillStyleCanvas();
  var LineStyleCanvas = require_LineStyleCanvas();
  var SetTransform = require_SetTransform();
  var RectangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      if (src.isFilled) {
        FillStyleCanvas(ctx, src);
        ctx.fillRect(-dx, -dy, src.width, src.height);
      }
      if (src.isStroked) {
        LineStyleCanvas(ctx, src);
        ctx.beginPath();
        ctx.rect(-dx, -dy, src.width, src.height);
        ctx.stroke();
      }
      ctx.restore();
    }
  };
  module2.exports = RectangleCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/shape/rectangle/RectangleRender.js
var require_RectangleRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_RectangleWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_RectangleCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/shape/rectangle/Rectangle.js
var require_Rectangle2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GeomRectangle = require_Rectangle();
  var Shape = require_Shape();
  var RectangleRender = require_RectangleRender();
  var Rectangle = new Class({
    Extends: Shape,
    Mixins: [
      RectangleRender
    ],
    initialize: function Rectangle2(scene, x, y, width, height, fillColor, fillAlpha) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 128;
      }
      if (height === void 0) {
        height = 128;
      }
      Shape.call(this, scene, "Rectangle", new GeomRectangle(0, 0, width, height));
      this.setPosition(x, y);
      this.setSize(width, height);
      if (fillColor !== void 0) {
        this.setFillStyle(fillColor, fillAlpha);
      }
      this.updateDisplayOrigin();
      this.updateData();
    },
    setSize: function(width, height) {
      this.width = width;
      this.height = height;
      this.geom.setSize(width, height);
      this.updateData();
      return this;
    },
    updateData: function() {
      var path = [];
      var rect = this.geom;
      var line = this._tempLine;
      rect.getLineA(line);
      path.push(line.x1, line.y1, line.x2, line.y2);
      rect.getLineB(line);
      path.push(line.x2, line.y2);
      rect.getLineC(line);
      path.push(line.x2, line.y2);
      rect.getLineD(line);
      path.push(line.x2, line.y2);
      this.pathData = path;
      return this;
    }
  });
  module2.exports = Rectangle;
});

// node_modules/phaser/src/gameobjects/shape/star/StarWebGLRenderer.js
var require_StarWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillPathWebGL = require_FillPathWebGL();
  var GetCalcMatrix = require_GetCalcMatrix();
  var StrokePathWebGL = require_StrokePathWebGL();
  var StarWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);
    if (src.isFilled) {
      FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
    }
    if (src.isStroked) {
      StrokePathWebGL(pipeline, src, alpha, dx, dy);
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = StarWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/shape/star/StarCanvasRenderer.js
var require_StarCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillStyleCanvas = require_FillStyleCanvas();
  var LineStyleCanvas = require_LineStyleCanvas();
  var SetTransform = require_SetTransform();
  var StarCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      var path = src.pathData;
      var pathLength = path.length - 1;
      var px1 = path[0] - dx;
      var py1 = path[1] - dy;
      ctx.beginPath();
      ctx.moveTo(px1, py1);
      if (!src.closePath) {
        pathLength -= 2;
      }
      for (var i = 2; i < pathLength; i += 2) {
        var px2 = path[i] - dx;
        var py2 = path[i + 1] - dy;
        ctx.lineTo(px2, py2);
      }
      ctx.closePath();
      if (src.isFilled) {
        FillStyleCanvas(ctx, src);
        ctx.fill();
      }
      if (src.isStroked) {
        LineStyleCanvas(ctx, src);
        ctx.stroke();
      }
      ctx.restore();
    }
  };
  module2.exports = StarCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/shape/star/StarRender.js
var require_StarRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_StarWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_StarCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/shape/star/Star.js
var require_Star = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var StarRender = require_StarRender();
  var Class = require_Class();
  var Earcut = require_Earcut();
  var Shape = require_Shape();
  var Star = new Class({
    Extends: Shape,
    Mixins: [
      StarRender
    ],
    initialize: function Star2(scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (points === void 0) {
        points = 5;
      }
      if (innerRadius === void 0) {
        innerRadius = 32;
      }
      if (outerRadius === void 0) {
        outerRadius = 64;
      }
      Shape.call(this, scene, "Star", null);
      this._points = points;
      this._innerRadius = innerRadius;
      this._outerRadius = outerRadius;
      this.setPosition(x, y);
      this.setSize(outerRadius * 2, outerRadius * 2);
      if (fillColor !== void 0) {
        this.setFillStyle(fillColor, fillAlpha);
      }
      this.updateDisplayOrigin();
      this.updateData();
    },
    setPoints: function(value) {
      this._points = value;
      return this.updateData();
    },
    setInnerRadius: function(value) {
      this._innerRadius = value;
      return this.updateData();
    },
    setOuterRadius: function(value) {
      this._outerRadius = value;
      return this.updateData();
    },
    points: {
      get: function() {
        return this._points;
      },
      set: function(value) {
        this._points = value;
        this.updateData();
      }
    },
    innerRadius: {
      get: function() {
        return this._innerRadius;
      },
      set: function(value) {
        this._innerRadius = value;
        this.updateData();
      }
    },
    outerRadius: {
      get: function() {
        return this._outerRadius;
      },
      set: function(value) {
        this._outerRadius = value;
        this.updateData();
      }
    },
    updateData: function() {
      var path = [];
      var points = this._points;
      var innerRadius = this._innerRadius;
      var outerRadius = this._outerRadius;
      var rot = Math.PI / 2 * 3;
      var step = Math.PI / points;
      var x = outerRadius;
      var y = outerRadius;
      path.push(x, y + -outerRadius);
      for (var i = 0; i < points; i++) {
        path.push(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);
        rot += step;
        path.push(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);
        rot += step;
      }
      path.push(x, y + -outerRadius);
      this.pathIndexes = Earcut(path);
      this.pathData = path;
      return this;
    }
  });
  module2.exports = Star;
});

// node_modules/phaser/src/geom/triangle/Contains.js
var require_Contains5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = function(triangle, x, y) {
    var v0x = triangle.x3 - triangle.x1;
    var v0y = triangle.y3 - triangle.y1;
    var v1x = triangle.x2 - triangle.x1;
    var v1y = triangle.y2 - triangle.y1;
    var v2x = x - triangle.x1;
    var v2y = y - triangle.y1;
    var dot00 = v0x * v0x + v0y * v0y;
    var dot01 = v0x * v1x + v0y * v1y;
    var dot02 = v0x * v2x + v0y * v2y;
    var dot11 = v1x * v1x + v1y * v1y;
    var dot12 = v1x * v2x + v1y * v2y;
    var b = dot00 * dot11 - dot01 * dot01;
    var inv = b === 0 ? 0 : 1 / b;
    var u = (dot11 * dot02 - dot01 * dot12) * inv;
    var v = (dot00 * dot12 - dot01 * dot02) * inv;
    return u >= 0 && v >= 0 && u + v < 1;
  };
  module2.exports = Contains;
});

// node_modules/phaser/src/geom/triangle/GetPoint.js
var require_GetPoint5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var Length = require_Length();
  var GetPoint = function(triangle, position, out) {
    if (out === void 0) {
      out = new Point();
    }
    var line1 = triangle.getLineA();
    var line2 = triangle.getLineB();
    var line3 = triangle.getLineC();
    if (position <= 0 || position >= 1) {
      out.x = line1.x1;
      out.y = line1.y1;
      return out;
    }
    var length1 = Length(line1);
    var length2 = Length(line2);
    var length3 = Length(line3);
    var perimeter = length1 + length2 + length3;
    var p = perimeter * position;
    var localPosition = 0;
    if (p < length1) {
      localPosition = p / length1;
      out.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
      out.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
    } else if (p > length1 + length2) {
      p -= length1 + length2;
      localPosition = p / length3;
      out.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
      out.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
    } else {
      p -= length1;
      localPosition = p / length2;
      out.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
      out.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
    }
    return out;
  };
  module2.exports = GetPoint;
});

// node_modules/phaser/src/geom/triangle/GetPoints.js
var require_GetPoints6 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Length = require_Length();
  var Point = require_Point();
  var GetPoints = function(triangle, quantity, stepRate, out) {
    if (out === void 0) {
      out = [];
    }
    var line1 = triangle.getLineA();
    var line2 = triangle.getLineB();
    var line3 = triangle.getLineC();
    var length1 = Length(line1);
    var length2 = Length(line2);
    var length3 = Length(line3);
    var perimeter = length1 + length2 + length3;
    if (!quantity && stepRate > 0) {
      quantity = perimeter / stepRate;
    }
    for (var i = 0; i < quantity; i++) {
      var p = perimeter * (i / quantity);
      var localPosition = 0;
      var point = new Point();
      if (p < length1) {
        localPosition = p / length1;
        point.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;
        point.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;
      } else if (p > length1 + length2) {
        p -= length1 + length2;
        localPosition = p / length3;
        point.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;
        point.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;
      } else {
        p -= length1;
        localPosition = p / length2;
        point.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;
        point.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;
      }
      out.push(point);
    }
    return out;
  };
  module2.exports = GetPoints;
});

// node_modules/phaser/src/geom/triangle/Triangle.js
var require_Triangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Contains = require_Contains5();
  var GetPoint = require_GetPoint5();
  var GetPoints = require_GetPoints6();
  var GEOM_CONST = require_const3();
  var Line = require_Line();
  var Random = require_Random5();
  var Triangle = new Class({
    initialize: function Triangle2(x1, y1, x2, y2, x3, y3) {
      if (x1 === void 0) {
        x1 = 0;
      }
      if (y1 === void 0) {
        y1 = 0;
      }
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (x3 === void 0) {
        x3 = 0;
      }
      if (y3 === void 0) {
        y3 = 0;
      }
      this.type = GEOM_CONST.TRIANGLE;
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      this.x3 = x3;
      this.y3 = y3;
    },
    contains: function(x, y) {
      return Contains(this, x, y);
    },
    getPoint: function(position, output) {
      return GetPoint(this, position, output);
    },
    getPoints: function(quantity, stepRate, output) {
      return GetPoints(this, quantity, stepRate, output);
    },
    getRandomPoint: function(point) {
      return Random(this, point);
    },
    setTo: function(x1, y1, x2, y2, x3, y3) {
      if (x1 === void 0) {
        x1 = 0;
      }
      if (y1 === void 0) {
        y1 = 0;
      }
      if (x2 === void 0) {
        x2 = 0;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (x3 === void 0) {
        x3 = 0;
      }
      if (y3 === void 0) {
        y3 = 0;
      }
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      this.x3 = x3;
      this.y3 = y3;
      return this;
    },
    getLineA: function(line) {
      if (line === void 0) {
        line = new Line();
      }
      line.setTo(this.x1, this.y1, this.x2, this.y2);
      return line;
    },
    getLineB: function(line) {
      if (line === void 0) {
        line = new Line();
      }
      line.setTo(this.x2, this.y2, this.x3, this.y3);
      return line;
    },
    getLineC: function(line) {
      if (line === void 0) {
        line = new Line();
      }
      line.setTo(this.x3, this.y3, this.x1, this.y1);
      return line;
    },
    left: {
      get: function() {
        return Math.min(this.x1, this.x2, this.x3);
      },
      set: function(value) {
        var diff = 0;
        if (this.x1 <= this.x2 && this.x1 <= this.x3) {
          diff = this.x1 - value;
        } else if (this.x2 <= this.x1 && this.x2 <= this.x3) {
          diff = this.x2 - value;
        } else {
          diff = this.x3 - value;
        }
        this.x1 -= diff;
        this.x2 -= diff;
        this.x3 -= diff;
      }
    },
    right: {
      get: function() {
        return Math.max(this.x1, this.x2, this.x3);
      },
      set: function(value) {
        var diff = 0;
        if (this.x1 >= this.x2 && this.x1 >= this.x3) {
          diff = this.x1 - value;
        } else if (this.x2 >= this.x1 && this.x2 >= this.x3) {
          diff = this.x2 - value;
        } else {
          diff = this.x3 - value;
        }
        this.x1 -= diff;
        this.x2 -= diff;
        this.x3 -= diff;
      }
    },
    top: {
      get: function() {
        return Math.min(this.y1, this.y2, this.y3);
      },
      set: function(value) {
        var diff = 0;
        if (this.y1 <= this.y2 && this.y1 <= this.y3) {
          diff = this.y1 - value;
        } else if (this.y2 <= this.y1 && this.y2 <= this.y3) {
          diff = this.y2 - value;
        } else {
          diff = this.y3 - value;
        }
        this.y1 -= diff;
        this.y2 -= diff;
        this.y3 -= diff;
      }
    },
    bottom: {
      get: function() {
        return Math.max(this.y1, this.y2, this.y3);
      },
      set: function(value) {
        var diff = 0;
        if (this.y1 >= this.y2 && this.y1 >= this.y3) {
          diff = this.y1 - value;
        } else if (this.y2 >= this.y1 && this.y2 >= this.y3) {
          diff = this.y2 - value;
        } else {
          diff = this.y3 - value;
        }
        this.y1 -= diff;
        this.y2 -= diff;
        this.y3 -= diff;
      }
    }
  });
  module2.exports = Triangle;
});

// node_modules/phaser/src/gameobjects/shape/triangle/TriangleWebGLRenderer.js
var require_TriangleWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var StrokePathWebGL = require_StrokePathWebGL();
  var Utils = require_Utils();
  var TriangleWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);
    if (src.isFilled) {
      var fillTint = pipeline.fillTint;
      var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
      fillTint.TL = fillTintColor;
      fillTint.TR = fillTintColor;
      fillTint.BL = fillTintColor;
      fillTint.BR = fillTintColor;
      var x1 = src.geom.x1 - dx;
      var y1 = src.geom.y1 - dy;
      var x2 = src.geom.x2 - dx;
      var y2 = src.geom.y2 - dy;
      var x3 = src.geom.x3 - dx;
      var y3 = src.geom.y3 - dy;
      pipeline.batchFillTriangle(x1, y1, x2, y2, x3, y3, result.sprite, result.camera);
    }
    if (src.isStroked) {
      StrokePathWebGL(pipeline, src, alpha, dx, dy);
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = TriangleWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/shape/triangle/TriangleCanvasRenderer.js
var require_TriangleCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FillStyleCanvas = require_FillStyleCanvas();
  var LineStyleCanvas = require_LineStyleCanvas();
  var SetTransform = require_SetTransform();
  var TriangleCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;
    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      var x1 = src.geom.x1 - dx;
      var y1 = src.geom.y1 - dy;
      var x2 = src.geom.x2 - dx;
      var y2 = src.geom.y2 - dy;
      var x3 = src.geom.x3 - dx;
      var y3 = src.geom.y3 - dy;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.lineTo(x3, y3);
      ctx.closePath();
      if (src.isFilled) {
        FillStyleCanvas(ctx, src);
        ctx.fill();
      }
      if (src.isStroked) {
        LineStyleCanvas(ctx, src);
        ctx.stroke();
      }
      ctx.restore();
    }
  };
  module2.exports = TriangleCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/shape/triangle/TriangleRender.js
var require_TriangleRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_TriangleWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_TriangleCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/shape/triangle/Triangle.js
var require_Triangle2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Shape = require_Shape();
  var GeomTriangle = require_Triangle();
  var TriangleRender = require_TriangleRender();
  var Triangle = new Class({
    Extends: Shape,
    Mixins: [
      TriangleRender
    ],
    initialize: function Triangle2(scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (x1 === void 0) {
        x1 = 0;
      }
      if (y1 === void 0) {
        y1 = 128;
      }
      if (x2 === void 0) {
        x2 = 64;
      }
      if (y2 === void 0) {
        y2 = 0;
      }
      if (x3 === void 0) {
        x3 = 128;
      }
      if (y3 === void 0) {
        y3 = 128;
      }
      Shape.call(this, scene, "Triangle", new GeomTriangle(x1, y1, x2, y2, x3, y3));
      var width = this.geom.right - this.geom.left;
      var height = this.geom.bottom - this.geom.top;
      this.setPosition(x, y);
      this.setSize(width, height);
      if (fillColor !== void 0) {
        this.setFillStyle(fillColor, fillAlpha);
      }
      this.updateDisplayOrigin();
      this.updateData();
    },
    setTo: function(x1, y1, x2, y2, x3, y3) {
      this.geom.setTo(x1, y1, x2, y2, x3, y3);
      return this.updateData();
    },
    updateData: function() {
      var path = [];
      var tri = this.geom;
      var line = this._tempLine;
      tri.getLineA(line);
      path.push(line.x1, line.y1, line.x2, line.y2);
      tri.getLineB(line);
      path.push(line.x2, line.y2);
      tri.getLineC(line);
      path.push(line.x2, line.y2);
      this.pathData = path;
      return this;
    }
  });
  module2.exports = Triangle;
});

// node_modules/phaser/src/gameobjects/blitter/BlitterFactory.js
var require_BlitterFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Blitter = require_Blitter();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("blitter", function(x, y, key, frame) {
    return this.displayList.add(new Blitter(this.scene, x, y, key, frame));
  });
});

// node_modules/phaser/src/gameobjects/container/ContainerFactory.js
var require_ContainerFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Container = require_Container();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("container", function(x, y, children) {
    return this.displayList.add(new Container(this.scene, x, y, children));
  });
});

// node_modules/phaser/src/gameobjects/domelement/DOMElementFactory.js
var require_DOMElementFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DOMElement = require_DOMElement();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("dom", function(x, y, element, style, innerText) {
    var gameObject = new DOMElement(this.scene, x, y, element, style, innerText);
    this.displayList.add(gameObject);
    return gameObject;
  });
});

// node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextFactory.js
var require_DynamicBitmapTextFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DynamicBitmapText = require_DynamicBitmapText();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("dynamicBitmapText", function(x, y, font, text, size) {
    return this.displayList.add(new DynamicBitmapText(this.scene, x, y, font, text, size));
  });
});

// node_modules/phaser/src/gameobjects/extern/ExternFactory.js
var require_ExternFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Extern = require_Extern();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("extern", function() {
    var extern = new Extern(this.scene);
    this.displayList.add(extern);
    return extern;
  });
});

// node_modules/phaser/src/gameobjects/graphics/GraphicsFactory.js
var require_GraphicsFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Graphics = require_Graphics();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("graphics", function(config2) {
    return this.displayList.add(new Graphics(this.scene, config2));
  });
});

// node_modules/phaser/src/gameobjects/group/GroupFactory.js
var require_GroupFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Group = require_Group();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("group", function(children, config2) {
    return this.updateList.add(new Group(this.scene, children, config2));
  });
});

// node_modules/phaser/src/gameobjects/image/ImageFactory.js
var require_ImageFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Image2 = require_Image2();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("image", function(x, y, key, frame) {
    return this.displayList.add(new Image2(this.scene, x, y, key, frame));
  });
});

// node_modules/phaser/src/gameobjects/layer/LayerFactory.js
var require_LayerFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Layer = require_Layer();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("layer", function(children) {
    return this.displayList.add(new Layer(this.scene, children));
  });
});

// node_modules/phaser/src/gameobjects/particles/ParticleManagerFactory.js
var require_ParticleManagerFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var ParticleEmitterManager = require_ParticleEmitterManager();
  GameObjectFactory.register("particles", function(key, frame, emitters) {
    return this.displayList.add(new ParticleEmitterManager(this.scene, key, frame, emitters));
  });
});

// node_modules/phaser/src/gameobjects/pathfollower/PathFollowerFactory.js
var require_PathFollowerFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var PathFollower = require_PathFollower2();
  GameObjectFactory.register("follower", function(path, x, y, key, frame) {
    var sprite = new PathFollower(this.scene, path, x, y, key, frame);
    this.displayList.add(sprite);
    this.updateList.add(sprite);
    return sprite;
  });
});

// node_modules/phaser/src/gameobjects/rendertexture/RenderTextureFactory.js
var require_RenderTextureFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var RenderTexture = require_RenderTexture();
  GameObjectFactory.register("renderTexture", function(x, y, width, height, key, frame) {
    return this.displayList.add(new RenderTexture(this.scene, x, y, width, height, key, frame));
  });
});

// node_modules/phaser/src/gameobjects/rope/RopeFactory.js
var require_RopeFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rope = require_Rope();
  var GameObjectFactory = require_GameObjectFactory();
  if (typeof WEBGL_RENDERER) {
    GameObjectFactory.register("rope", function(x, y, texture, frame, points, horizontal, colors, alphas) {
      return this.displayList.add(new Rope(this.scene, x, y, texture, frame, points, horizontal, colors, alphas));
    });
  }
});

// node_modules/phaser/src/gameobjects/sprite/SpriteFactory.js
var require_SpriteFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var Sprite = require_Sprite();
  GameObjectFactory.register("sprite", function(x, y, key, frame) {
    var sprite = new Sprite(this.scene, x, y, key, frame);
    this.displayList.add(sprite);
    return sprite;
  });
});

// node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextFactory.js
var require_BitmapTextFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BitmapText = require_BitmapText();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("bitmapText", function(x, y, font, text, size, align) {
    return this.displayList.add(new BitmapText(this.scene, x, y, font, text, size, align));
  });
});

// node_modules/phaser/src/gameobjects/text/TextFactory.js
var require_TextFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Text = require_Text();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("text", function(x, y, text, style) {
    return this.displayList.add(new Text(this.scene, x, y, text, style));
  });
});

// node_modules/phaser/src/gameobjects/tilesprite/TileSpriteFactory.js
var require_TileSpriteFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TileSprite = require_TileSprite();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("tileSprite", function(x, y, width, height, key, frame) {
    return this.displayList.add(new TileSprite(this.scene, x, y, width, height, key, frame));
  });
});

// node_modules/phaser/src/gameobjects/zone/ZoneFactory.js
var require_ZoneFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Zone = require_Zone();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("zone", function(x, y, width, height) {
    return this.displayList.add(new Zone(this.scene, x, y, width, height));
  });
});

// node_modules/phaser/src/gameobjects/video/VideoFactory.js
var require_VideoFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Video = require_Video2();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("video", function(x, y, key) {
    return this.displayList.add(new Video(this.scene, x, y, key));
  });
});

// node_modules/phaser/src/gameobjects/shape/arc/ArcFactory.js
var require_ArcFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Arc = require_Arc();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("arc", function(x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {
    return this.displayList.add(new Arc(this.scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha));
  });
  GameObjectFactory.register("circle", function(x, y, radius, fillColor, fillAlpha) {
    return this.displayList.add(new Arc(this.scene, x, y, radius, 0, 360, false, fillColor, fillAlpha));
  });
});

// node_modules/phaser/src/gameobjects/shape/curve/CurveFactory.js
var require_CurveFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var Curve = require_Curve2();
  GameObjectFactory.register("curve", function(x, y, curve, fillColor, fillAlpha) {
    return this.displayList.add(new Curve(this.scene, x, y, curve, fillColor, fillAlpha));
  });
});

// node_modules/phaser/src/gameobjects/shape/ellipse/EllipseFactory.js
var require_EllipseFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Ellipse = require_Ellipse2();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("ellipse", function(x, y, width, height, fillColor, fillAlpha) {
    return this.displayList.add(new Ellipse(this.scene, x, y, width, height, fillColor, fillAlpha));
  });
});

// node_modules/phaser/src/gameobjects/shape/grid/GridFactory.js
var require_GridFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var Grid = require_Grid();
  GameObjectFactory.register("grid", function(x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha) {
    return this.displayList.add(new Grid(this.scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha));
  });
});

// node_modules/phaser/src/gameobjects/shape/isobox/IsoBoxFactory.js
var require_IsoBoxFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var IsoBox = require_IsoBox();
  GameObjectFactory.register("isobox", function(x, y, size, height, fillTop, fillLeft, fillRight) {
    return this.displayList.add(new IsoBox(this.scene, x, y, size, height, fillTop, fillLeft, fillRight));
  });
});

// node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangleFactory.js
var require_IsoTriangleFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var IsoTriangle = require_IsoTriangle();
  GameObjectFactory.register("isotriangle", function(x, y, size, height, reversed, fillTop, fillLeft, fillRight) {
    return this.displayList.add(new IsoTriangle(this.scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight));
  });
});

// node_modules/phaser/src/gameobjects/shape/line/LineFactory.js
var require_LineFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var Line = require_Line2();
  GameObjectFactory.register("line", function(x, y, x1, y1, x2, y2, strokeColor, strokeAlpha) {
    return this.displayList.add(new Line(this.scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha));
  });
});

// node_modules/phaser/src/gameobjects/shape/polygon/PolygonFactory.js
var require_PolygonFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var Polygon = require_Polygon2();
  GameObjectFactory.register("polygon", function(x, y, points, fillColor, fillAlpha) {
    return this.displayList.add(new Polygon(this.scene, x, y, points, fillColor, fillAlpha));
  });
});

// node_modules/phaser/src/gameobjects/shape/rectangle/RectangleFactory.js
var require_RectangleFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var Rectangle = require_Rectangle2();
  GameObjectFactory.register("rectangle", function(x, y, width, height, fillColor, fillAlpha) {
    return this.displayList.add(new Rectangle(this.scene, x, y, width, height, fillColor, fillAlpha));
  });
});

// node_modules/phaser/src/gameobjects/shape/star/StarFactory.js
var require_StarFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Star = require_Star();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("star", function(x, y, points, innerRadius, outerRadius, fillColor, fillAlpha) {
    return this.displayList.add(new Star(this.scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha));
  });
});

// node_modules/phaser/src/gameobjects/shape/triangle/TriangleFactory.js
var require_TriangleFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var Triangle = require_Triangle2();
  GameObjectFactory.register("triangle", function(x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha) {
    return this.displayList.add(new Triangle(this.scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha));
  });
});

// node_modules/phaser/src/gameobjects/blitter/BlitterCreator.js
var require_BlitterCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Blitter = require_Blitter();
  var BuildGameObject = require_BuildGameObject();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  GameObjectCreator.register("blitter", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var key = GetAdvancedValue(config2, "key", null);
    var frame = GetAdvancedValue(config2, "frame", null);
    var blitter = new Blitter(this.scene, 0, 0, key, frame);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, blitter, config2);
    return blitter;
  });
});

// node_modules/phaser/src/gameobjects/container/ContainerCreator.js
var require_ContainerCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Felipe Alfonso <@bitnenfer>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var Container = require_Container();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  GameObjectCreator.register("container", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var x = GetAdvancedValue(config2, "x", 0);
    var y = GetAdvancedValue(config2, "y", 0);
    var children = GetAdvancedValue(config2, "children", null);
    var container = new Container(this.scene, x, y, children);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, container, config2);
    return container;
  });
});

// node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextCreator.js
var require_DynamicBitmapTextCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BitmapText = require_DynamicBitmapText();
  var BuildGameObject = require_BuildGameObject();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  GameObjectCreator.register("dynamicBitmapText", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var font = GetAdvancedValue(config2, "font", "");
    var text = GetAdvancedValue(config2, "text", "");
    var size = GetAdvancedValue(config2, "size", false);
    var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, bitmapText, config2);
    return bitmapText;
  });
});

// node_modules/phaser/src/gameobjects/graphics/GraphicsCreator.js
var require_GraphicsCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectCreator = require_GameObjectCreator();
  var Graphics = require_Graphics();
  GameObjectCreator.register("graphics", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    var graphics = new Graphics(this.scene, config2);
    if (config2.add) {
      this.scene.sys.displayList.add(graphics);
    }
    return graphics;
  });
});

// node_modules/phaser/src/gameobjects/group/GroupCreator.js
var require_GroupCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectCreator = require_GameObjectCreator();
  var Group = require_Group();
  GameObjectCreator.register("group", function(config2) {
    return new Group(this.scene, null, config2);
  });
});

// node_modules/phaser/src/gameobjects/image/ImageCreator.js
var require_ImageCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var Image2 = require_Image2();
  GameObjectCreator.register("image", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var key = GetAdvancedValue(config2, "key", null);
    var frame = GetAdvancedValue(config2, "frame", null);
    var image = new Image2(this.scene, 0, 0, key, frame);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, image, config2);
    return image;
  });
});

// node_modules/phaser/src/gameobjects/layer/LayerCreator.js
var require_LayerCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var Layer = require_Layer();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  GameObjectCreator.register("layer", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var children = GetAdvancedValue(config2, "children", null);
    var layer = new Layer(this.scene, children);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, layer, config2);
    return layer;
  });
});

// node_modules/phaser/src/gameobjects/particles/ParticleManagerCreator.js
var require_ParticleManagerCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var GetFastValue = require_GetFastValue();
  var ParticleEmitterManager = require_ParticleEmitterManager();
  GameObjectCreator.register("particles", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var key = GetAdvancedValue(config2, "key", null);
    var frame = GetAdvancedValue(config2, "frame", null);
    var emitters = GetFastValue(config2, "emitters", null);
    var manager = new ParticleEmitterManager(this.scene, key, frame, emitters);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    var add = GetFastValue(config2, "add", false);
    if (add) {
      this.displayList.add(manager);
    } else {
      this.updateList.add(manager);
    }
    return manager;
  });
});

// node_modules/phaser/src/gameobjects/rendertexture/RenderTextureCreator.js
var require_RenderTextureCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var RenderTexture = require_RenderTexture();
  GameObjectCreator.register("renderTexture", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var x = GetAdvancedValue(config2, "x", 0);
    var y = GetAdvancedValue(config2, "y", 0);
    var width = GetAdvancedValue(config2, "width", 32);
    var height = GetAdvancedValue(config2, "height", 32);
    var key = GetAdvancedValue(config2, "key", void 0);
    var frame = GetAdvancedValue(config2, "frame", void 0);
    var renderTexture = new RenderTexture(this.scene, x, y, width, height, key, frame);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, renderTexture, config2);
    return renderTexture;
  });
});

// node_modules/phaser/src/gameobjects/rope/RopeCreator.js
var require_RopeCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var GetValue = require_GetValue();
  var Rope = require_Rope();
  GameObjectCreator.register("rope", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var key = GetAdvancedValue(config2, "key", null);
    var frame = GetAdvancedValue(config2, "frame", null);
    var horizontal = GetAdvancedValue(config2, "horizontal", true);
    var points = GetValue(config2, "points", void 0);
    var colors = GetValue(config2, "colors", void 0);
    var alphas = GetValue(config2, "alphas", void 0);
    var rope = new Rope(this.scene, 0, 0, key, frame, points, horizontal, colors, alphas);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, rope, config2);
    if (!config2.add) {
      this.updateList.add(rope);
    }
    return rope;
  });
});

// node_modules/phaser/src/gameobjects/sprite/SpriteCreator.js
var require_SpriteCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var BuildGameObjectAnimation = require_BuildGameObjectAnimation();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var Sprite = require_Sprite();
  GameObjectCreator.register("sprite", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var key = GetAdvancedValue(config2, "key", null);
    var frame = GetAdvancedValue(config2, "frame", null);
    var sprite = new Sprite(this.scene, 0, 0, key, frame);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, sprite, config2);
    BuildGameObjectAnimation(sprite, config2);
    return sprite;
  });
});

// node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextCreator.js
var require_BitmapTextCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BitmapText = require_BitmapText();
  var BuildGameObject = require_BuildGameObject();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var GetValue = require_GetValue();
  GameObjectCreator.register("bitmapText", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var font = GetValue(config2, "font", "");
    var text = GetAdvancedValue(config2, "text", "");
    var size = GetAdvancedValue(config2, "size", false);
    var align = GetValue(config2, "align", 0);
    var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size, align);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, bitmapText, config2);
    return bitmapText;
  });
});

// node_modules/phaser/src/gameobjects/text/TextCreator.js
var require_TextCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var Text = require_Text();
  GameObjectCreator.register("text", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var content = GetAdvancedValue(config2, "text", "");
    var style = GetAdvancedValue(config2, "style", null);
    var padding = GetAdvancedValue(config2, "padding", null);
    if (padding !== null) {
      style.padding = padding;
    }
    var text = new Text(this.scene, 0, 0, content, style);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, text, config2);
    text.autoRound = GetAdvancedValue(config2, "autoRound", true);
    text.resolution = GetAdvancedValue(config2, "resolution", 1);
    return text;
  });
});

// node_modules/phaser/src/gameobjects/tilesprite/TileSpriteCreator.js
var require_TileSpriteCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var TileSprite = require_TileSprite();
  GameObjectCreator.register("tileSprite", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var x = GetAdvancedValue(config2, "x", 0);
    var y = GetAdvancedValue(config2, "y", 0);
    var width = GetAdvancedValue(config2, "width", 512);
    var height = GetAdvancedValue(config2, "height", 512);
    var key = GetAdvancedValue(config2, "key", "");
    var frame = GetAdvancedValue(config2, "frame", "");
    var tile = new TileSprite(this.scene, x, y, width, height, key, frame);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, tile, config2);
    return tile;
  });
});

// node_modules/phaser/src/gameobjects/zone/ZoneCreator.js
var require_ZoneCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var Zone = require_Zone();
  GameObjectCreator.register("zone", function(config2) {
    var x = GetAdvancedValue(config2, "x", 0);
    var y = GetAdvancedValue(config2, "y", 0);
    var width = GetAdvancedValue(config2, "width", 1);
    var height = GetAdvancedValue(config2, "height", width);
    return new Zone(this.scene, x, y, width, height);
  });
});

// node_modules/phaser/src/gameobjects/video/VideoCreator.js
var require_VideoCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var Video = require_Video2();
  GameObjectCreator.register("video", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var key = GetAdvancedValue(config2, "key", null);
    var video = new Video(this.scene, 0, 0, key);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, video, config2);
    if (!config2.add) {
      this.updateList.add(video);
    }
    return video;
  });
});

// node_modules/phaser/src/utils/object/SetValue.js
var require_SetValue = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetValue = function(source, key, value) {
    if (!source || typeof source === "number") {
      return false;
    } else if (source.hasOwnProperty(key)) {
      source[key] = value;
      return true;
    } else if (key.indexOf(".") !== -1) {
      var keys = key.split(".");
      var parent = source;
      var prev = source;
      for (var i = 0; i < keys.length; i++) {
        if (parent.hasOwnProperty(keys[i])) {
          prev = parent;
          parent = parent[keys[i]];
        } else {
          return false;
        }
      }
      prev[keys[keys.length - 1]] = value;
      return true;
    }
    return false;
  };
  module2.exports = SetValue;
});

// node_modules/phaser/src/gameobjects/shader/ShaderWebGLRenderer.js
var require_ShaderWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var ShaderWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    if (!src.shader) {
      return;
    }
    camera.addToRenderList(src);
    renderer.pipelines.clear();
    if (src.renderToTexture) {
      src.load();
      src.flush();
    } else {
      var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
      if (renderer.width !== src._rendererWidth || renderer.height !== src._rendererHeight) {
        src.projOrtho(0, renderer.width, renderer.height, 0);
      }
      src.load(calcMatrix.matrix);
      src.flush();
    }
    renderer.pipelines.rebind();
  };
  module2.exports = ShaderWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/shader/ShaderCanvasRenderer.js
var require_ShaderCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ShaderCanvasRenderer = function() {
  };
  module2.exports = ShaderCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/shader/ShaderRender.js
var require_ShaderRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_ShaderWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_ShaderCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/shader/Shader.js
var require_Shader = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components();
  var GameObject = require_GameObject();
  var GetFastValue = require_GetFastValue();
  var Extend = require_Extend();
  var SetValue = require_SetValue();
  var ShaderRender = require_ShaderRender();
  var TransformMatrix = require_TransformMatrix();
  var Shader = new Class({
    Extends: GameObject,
    Mixins: [
      Components.ComputedSize,
      Components.Depth,
      Components.GetBounds,
      Components.Mask,
      Components.Origin,
      Components.ScrollFactor,
      Components.Transform,
      Components.Visible,
      ShaderRender
    ],
    initialize: function Shader2(scene, key, x, y, width, height, textures, textureData) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 128;
      }
      if (height === void 0) {
        height = 128;
      }
      GameObject.call(this, scene, "Shader");
      this.blendMode = -1;
      this.shader;
      var renderer = scene.sys.renderer;
      this.renderer = renderer;
      this.gl = renderer.gl;
      this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2));
      this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW);
      this.program = null;
      this.bytes = new Uint8Array(this.vertexData);
      this.vertexViewF32 = new Float32Array(this.vertexData);
      this._tempMatrix1 = new TransformMatrix();
      this._tempMatrix2 = new TransformMatrix();
      this._tempMatrix3 = new TransformMatrix();
      this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.uniforms = {};
      this.pointer = null;
      this._rendererWidth = renderer.width;
      this._rendererHeight = renderer.height;
      this._textureCount = 0;
      this.framebuffer = null;
      this.glTexture = null;
      this.renderToTexture = false;
      this.texture = null;
      this.setPosition(x, y);
      this.setSize(width, height);
      this.setOrigin(0.5, 0.5);
      this.setShader(key, textures, textureData);
    },
    willRender: function(camera) {
      if (this.renderToTexture) {
        return true;
      } else {
        return !(GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
      }
    },
    setRenderToTexture: function(key, flipY) {
      if (flipY === void 0) {
        flipY = false;
      }
      if (!this.renderToTexture) {
        var width = this.width;
        var height = this.height;
        var renderer = this.renderer;
        this.glTexture = renderer.createTextureFromSource(null, width, height, 0);
        this.glTexture.flipY = flipY;
        this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, false);
        this._rendererWidth = width;
        this._rendererHeight = height;
        this.renderToTexture = true;
        this.projOrtho(0, this.width, this.height, 0);
        if (key) {
          this.texture = this.scene.sys.textures.addGLTexture(key, this.glTexture, width, height);
        }
      }
      if (this.shader) {
        renderer.pipelines.clear();
        this.load();
        this.flush();
        renderer.pipelines.rebind();
      }
      return this;
    },
    setShader: function(key, textures, textureData) {
      if (textures === void 0) {
        textures = [];
      }
      if (typeof key === "string") {
        var cache = this.scene.sys.cache.shader;
        if (!cache.has(key)) {
          console.warn("Shader missing: " + key);
          return this;
        }
        this.shader = cache.get(key);
      } else {
        this.shader = key;
      }
      var gl = this.gl;
      var renderer = this.renderer;
      if (this.program) {
        gl.deleteProgram(this.program);
      }
      var program = renderer.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);
      gl.uniformMatrix4fv(gl.getUniformLocation(program, "uViewMatrix"), false, this.viewMatrix);
      gl.uniformMatrix4fv(gl.getUniformLocation(program, "uProjectionMatrix"), false, this.projectionMatrix);
      gl.uniform2f(gl.getUniformLocation(program, "uResolution"), this.width, this.height);
      this.program = program;
      var d = new Date();
      var defaultUniforms = {
        resolution: {type: "2f", value: {x: this.width, y: this.height}},
        time: {type: "1f", value: 0},
        mouse: {type: "2f", value: {x: this.width / 2, y: this.height / 2}},
        date: {type: "4fv", value: [d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds()]},
        sampleRate: {type: "1f", value: 44100},
        iChannel0: {type: "sampler2D", value: null, textureData: {repeat: true}},
        iChannel1: {type: "sampler2D", value: null, textureData: {repeat: true}},
        iChannel2: {type: "sampler2D", value: null, textureData: {repeat: true}},
        iChannel3: {type: "sampler2D", value: null, textureData: {repeat: true}}
      };
      if (this.shader.uniforms) {
        this.uniforms = Extend(true, {}, this.shader.uniforms, defaultUniforms);
      } else {
        this.uniforms = defaultUniforms;
      }
      for (var i = 0; i < 4; i++) {
        if (textures[i]) {
          this.setSampler2D("iChannel" + i, textures[i], i, textureData);
        }
      }
      this.initUniforms();
      this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0);
      return this;
    },
    setPointer: function(pointer) {
      this.pointer = pointer;
      return this;
    },
    projOrtho: function(left, right, bottom, top) {
      var near = -1e3;
      var far = 1e3;
      var leftRight = 1 / (left - right);
      var bottomTop = 1 / (bottom - top);
      var nearFar = 1 / (near - far);
      var pm = this.projectionMatrix;
      pm[0] = -2 * leftRight;
      pm[5] = -2 * bottomTop;
      pm[10] = 2 * nearFar;
      pm[12] = (left + right) * leftRight;
      pm[13] = (top + bottom) * bottomTop;
      pm[14] = (far + near) * nearFar;
      var program = this.program;
      var gl = this.gl;
      var renderer = this.renderer;
      renderer.setProgram(program);
      gl.uniformMatrix4fv(gl.getUniformLocation(program, "uProjectionMatrix"), false, this.projectionMatrix);
      this._rendererWidth = right;
      this._rendererHeight = bottom;
    },
    initUniforms: function() {
      var gl = this.gl;
      var map = this.renderer.glFuncMap;
      var program = this.program;
      this._textureCount = 0;
      for (var key in this.uniforms) {
        var uniform = this.uniforms[key];
        var type = uniform.type;
        var data = map[type];
        uniform.uniformLocation = gl.getUniformLocation(program, key);
        if (type !== "sampler2D") {
          uniform.glMatrix = data.matrix;
          uniform.glValueLength = data.length;
          uniform.glFunc = data.func;
        }
      }
    },
    setSampler2DBuffer: function(uniformKey, texture, width, height, textureIndex, textureData) {
      if (textureIndex === void 0) {
        textureIndex = 0;
      }
      if (textureData === void 0) {
        textureData = {};
      }
      var uniform = this.uniforms[uniformKey];
      uniform.value = texture;
      textureData.width = width;
      textureData.height = height;
      uniform.textureData = textureData;
      this._textureCount = textureIndex;
      this.initSampler2D(uniform);
      return this;
    },
    setSampler2D: function(uniformKey, textureKey, textureIndex, textureData) {
      if (textureIndex === void 0) {
        textureIndex = 0;
      }
      var textureManager = this.scene.sys.textures;
      if (textureManager.exists(textureKey)) {
        var frame = textureManager.getFrame(textureKey);
        if (frame.glTexture && frame.glTexture.isRenderTexture) {
          return this.setSampler2DBuffer(uniformKey, frame.glTexture, frame.width, frame.height, textureIndex, textureData);
        }
        var uniform = this.uniforms[uniformKey];
        var source = frame.source;
        uniform.textureKey = textureKey;
        uniform.source = source.image;
        uniform.value = frame.glTexture;
        if (source.isGLTexture) {
          if (!textureData) {
            textureData = {};
          }
          textureData.width = source.width;
          textureData.height = source.height;
        }
        if (textureData) {
          uniform.textureData = textureData;
        }
        this._textureCount = textureIndex;
        this.initSampler2D(uniform);
      }
      return this;
    },
    setUniform: function(key, value) {
      SetValue(this.uniforms, key, value);
      return this;
    },
    getUniform: function(key) {
      return GetFastValue(this.uniforms, key, null);
    },
    setChannel0: function(textureKey, textureData) {
      return this.setSampler2D("iChannel0", textureKey, 0, textureData);
    },
    setChannel1: function(textureKey, textureData) {
      return this.setSampler2D("iChannel1", textureKey, 1, textureData);
    },
    setChannel2: function(textureKey, textureData) {
      return this.setSampler2D("iChannel2", textureKey, 2, textureData);
    },
    setChannel3: function(textureKey, textureData) {
      return this.setSampler2D("iChannel3", textureKey, 3, textureData);
    },
    initSampler2D: function(uniform) {
      if (!uniform.value) {
        return;
      }
      var gl = this.gl;
      gl.activeTexture(gl.TEXTURE0 + this._textureCount);
      gl.bindTexture(gl.TEXTURE_2D, uniform.value);
      var data = uniform.textureData;
      if (data && !uniform.value.isRenderTexture) {
        var magFilter = gl[GetFastValue(data, "magFilter", "linear").toUpperCase()];
        var minFilter = gl[GetFastValue(data, "minFilter", "linear").toUpperCase()];
        var wrapS = gl[GetFastValue(data, "wrapS", "repeat").toUpperCase()];
        var wrapT = gl[GetFastValue(data, "wrapT", "repeat").toUpperCase()];
        var format = gl[GetFastValue(data, "format", "rgba").toUpperCase()];
        if (data.repeat) {
          wrapS = gl.REPEAT;
          wrapT = gl.REPEAT;
        }
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);
        if (data.width) {
          var width = GetFastValue(data, "width", 512);
          var height = GetFastValue(data, "height", 2);
          var border = GetFastValue(data, "border", 0);
          gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.source);
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
      }
      this.renderer.setProgram(this.program);
      gl.uniform1i(uniform.uniformLocation, this._textureCount);
      this._textureCount++;
    },
    syncUniforms: function() {
      var gl = this.gl;
      var uniforms = this.uniforms;
      var uniform;
      var length;
      var glFunc;
      var location;
      var value;
      var textureCount = 0;
      for (var key in uniforms) {
        uniform = uniforms[key];
        glFunc = uniform.glFunc;
        length = uniform.glValueLength;
        location = uniform.uniformLocation;
        value = uniform.value;
        if (value === null) {
          continue;
        }
        if (length === 1) {
          if (uniform.glMatrix) {
            glFunc.call(gl, location, uniform.transpose, value);
          } else {
            glFunc.call(gl, location, value);
          }
        } else if (length === 2) {
          glFunc.call(gl, location, value.x, value.y);
        } else if (length === 3) {
          glFunc.call(gl, location, value.x, value.y, value.z);
        } else if (length === 4) {
          glFunc.call(gl, location, value.x, value.y, value.z, value.w);
        } else if (uniform.type === "sampler2D") {
          gl.activeTexture(gl.TEXTURE0 + textureCount);
          gl.bindTexture(gl.TEXTURE_2D, value);
          gl.uniform1i(location, textureCount);
          textureCount++;
        }
      }
    },
    load: function(matrix2D) {
      var gl = this.gl;
      var width = this.width;
      var height = this.height;
      var renderer = this.renderer;
      var program = this.program;
      var vm = this.viewMatrix;
      if (!this.renderToTexture) {
        var x = -this._displayOriginX;
        var y = -this._displayOriginY;
        vm[0] = matrix2D[0];
        vm[1] = matrix2D[1];
        vm[4] = matrix2D[2];
        vm[5] = matrix2D[3];
        vm[8] = matrix2D[4];
        vm[9] = matrix2D[5];
        vm[12] = vm[0] * x + vm[4] * y;
        vm[13] = vm[1] * x + vm[5] * y;
      }
      gl.useProgram(program);
      gl.uniformMatrix4fv(gl.getUniformLocation(program, "uViewMatrix"), false, vm);
      gl.uniform2f(gl.getUniformLocation(program, "uResolution"), this.width, this.height);
      var uniforms = this.uniforms;
      var res = uniforms.resolution;
      res.value.x = width;
      res.value.y = height;
      uniforms.time.value = renderer.game.loop.getDuration();
      var pointer = this.pointer;
      if (pointer) {
        var mouse = uniforms.mouse;
        var px = pointer.x / width;
        var py = 1 - pointer.y / height;
        mouse.value.x = px.toFixed(2);
        mouse.value.y = py.toFixed(2);
      }
      this.syncUniforms();
    },
    flush: function() {
      var width = this.width;
      var height = this.height;
      var program = this.program;
      var gl = this.gl;
      var vertexBuffer = this.vertexBuffer;
      var renderer = this.renderer;
      var vertexSize = Float32Array.BYTES_PER_ELEMENT * 2;
      if (this.renderToTexture) {
        renderer.setFramebuffer(this.framebuffer);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      var location = gl.getAttribLocation(program, "inPosition");
      if (location !== -1) {
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, 2, gl.FLOAT, false, vertexSize, 0);
      }
      var vf = this.vertexViewF32;
      vf[3] = height;
      vf[4] = width;
      vf[5] = height;
      vf[8] = width;
      vf[9] = height;
      vf[10] = width;
      var vertexCount = 6;
      gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));
      gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
      if (this.renderToTexture) {
        renderer.setFramebuffer(null, false);
      }
    },
    setAlpha: function() {
    },
    setBlendMode: function() {
    },
    preDestroy: function() {
      var gl = this.gl;
      gl.deleteProgram(this.program);
      gl.deleteBuffer(this.vertexBuffer);
      if (this.renderToTexture) {
        this.renderer.deleteFramebuffer(this.framebuffer);
        this.texture.destroy();
        this.framebuffer = null;
        this.glTexture = null;
        this.texture = null;
      }
    }
  });
  module2.exports = Shader;
});

// node_modules/phaser/src/geom/mesh/Face.js
var require_Face = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Rectangle = require_Rectangle();
  var Vector2 = require_Vector2();
  function GetLength(x1, y1, x2, y2) {
    var x = x1 - x2;
    var y = y1 - y2;
    var magnitude = x * x + y * y;
    return Math.sqrt(magnitude);
  }
  var Face = new Class({
    initialize: function Face2(vertex1, vertex2, vertex3) {
      this.vertex1 = vertex1;
      this.vertex2 = vertex2;
      this.vertex3 = vertex3;
      this.bounds = new Rectangle();
      this._inCenter = new Vector2();
    },
    getInCenter: function(local) {
      if (local === void 0) {
        local = true;
      }
      var v1 = this.vertex1;
      var v2 = this.vertex2;
      var v3 = this.vertex3;
      var v1x;
      var v1y;
      var v2x;
      var v2y;
      var v3x;
      var v3y;
      if (local) {
        v1x = v1.x;
        v1y = v1.y;
        v2x = v2.x;
        v2y = v2.y;
        v3x = v3.x;
        v3y = v3.y;
      } else {
        v1x = v1.vx;
        v1y = v1.vy;
        v2x = v2.vx;
        v2y = v2.vy;
        v3x = v3.vx;
        v3y = v3.vy;
      }
      var d1 = GetLength(v3x, v3y, v2x, v2y);
      var d2 = GetLength(v1x, v1y, v3x, v3y);
      var d3 = GetLength(v2x, v2y, v1x, v1y);
      var p = d1 + d2 + d3;
      return this._inCenter.set((v1x * d1 + v2x * d2 + v3x * d3) / p, (v1y * d1 + v2y * d2 + v3y * d3) / p);
    },
    contains: function(x, y, calcMatrix) {
      var vertex1 = this.vertex1;
      var vertex2 = this.vertex2;
      var vertex3 = this.vertex3;
      var v1x = vertex1.vx;
      var v1y = vertex1.vy;
      var v2x = vertex2.vx;
      var v2y = vertex2.vy;
      var v3x = vertex3.vx;
      var v3y = vertex3.vy;
      if (calcMatrix) {
        var a = calcMatrix.a;
        var b = calcMatrix.b;
        var c = calcMatrix.c;
        var d = calcMatrix.d;
        var e = calcMatrix.e;
        var f = calcMatrix.f;
        v1x = vertex1.vx * a + vertex1.vy * c + e;
        v1y = vertex1.vx * b + vertex1.vy * d + f;
        v2x = vertex2.vx * a + vertex2.vy * c + e;
        v2y = vertex2.vx * b + vertex2.vy * d + f;
        v3x = vertex3.vx * a + vertex3.vy * c + e;
        v3y = vertex3.vx * b + vertex3.vy * d + f;
      }
      var t0x = v3x - v1x;
      var t0y = v3y - v1y;
      var t1x = v2x - v1x;
      var t1y = v2y - v1y;
      var t2x = x - v1x;
      var t2y = y - v1y;
      var dot00 = t0x * t0x + t0y * t0y;
      var dot01 = t0x * t1x + t0y * t1y;
      var dot02 = t0x * t2x + t0y * t2y;
      var dot11 = t1x * t1x + t1y * t1y;
      var dot12 = t1x * t2x + t1y * t2y;
      var bc = dot00 * dot11 - dot01 * dot01;
      var inv = bc === 0 ? 0 : 1 / bc;
      var u = (dot11 * dot02 - dot01 * dot12) * inv;
      var v = (dot00 * dot12 - dot01 * dot02) * inv;
      return u >= 0 && v >= 0 && u + v < 1;
    },
    isCounterClockwise: function(z) {
      var v1 = this.vertex1;
      var v2 = this.vertex2;
      var v3 = this.vertex3;
      var d = (v2.vx - v1.vx) * (v3.vy - v1.vy) - (v2.vy - v1.vy) * (v3.vx - v1.vx);
      return z <= 0 ? d >= 0 : d < 0;
    },
    load: function(F32, U32, offset, textureUnit, tintEffect) {
      offset = this.vertex1.load(F32, U32, offset, textureUnit, tintEffect);
      offset = this.vertex2.load(F32, U32, offset, textureUnit, tintEffect);
      offset = this.vertex3.load(F32, U32, offset, textureUnit, tintEffect);
      return offset;
    },
    transformCoordinatesLocal: function(transformMatrix, width, height, cameraZ) {
      this.vertex1.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
      this.vertex2.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
      this.vertex3.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);
      return this;
    },
    updateBounds: function() {
      var v1 = this.vertex1;
      var v2 = this.vertex2;
      var v3 = this.vertex3;
      var bounds = this.bounds;
      bounds.x = Math.min(v1.vx, v2.vx, v3.vx);
      bounds.y = Math.min(v1.vy, v2.vy, v3.vy);
      bounds.width = Math.max(v1.vx, v2.vx, v3.vx) - bounds.x;
      bounds.height = Math.max(v1.vy, v2.vy, v3.vy) - bounds.y;
      return this;
    },
    isInView: function(camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels) {
      var v1 = this.vertex1.update(a, b, c, d, e, f, roundPixels, alpha);
      var v2 = this.vertex2.update(a, b, c, d, e, f, roundPixels, alpha);
      var v3 = this.vertex3.update(a, b, c, d, e, f, roundPixels, alpha);
      if (v1.ta <= 0 && v2.ta <= 0 && v3.ta <= 0) {
        return false;
      }
      if (hideCCW && !this.isCounterClockwise(z)) {
        return false;
      }
      var bounds = this.bounds;
      bounds.x = Math.min(v1.tx, v2.tx, v3.tx);
      bounds.y = Math.min(v1.ty, v2.ty, v3.ty);
      bounds.width = Math.max(v1.tx, v2.tx, v3.tx) - bounds.x;
      bounds.height = Math.max(v1.ty, v2.ty, v3.ty) - bounds.y;
      var cr = camera.x + camera.width;
      var cb = camera.y + camera.height;
      if (bounds.width <= 0 || bounds.height <= 0 || camera.width <= 0 || camera.height <= 0) {
        return false;
      }
      return !(bounds.right < camera.x || bounds.bottom < camera.y || bounds.x > cr || bounds.y > cb);
    },
    translate: function(x, y) {
      if (y === void 0) {
        y = 0;
      }
      var v1 = this.vertex1;
      var v2 = this.vertex2;
      var v3 = this.vertex3;
      v1.x += x;
      v1.y += y;
      v2.x += x;
      v2.y += y;
      v3.x += x;
      v3.y += y;
      return this;
    },
    x: {
      get: function() {
        return this.getInCenter().x;
      },
      set: function(value) {
        var current = this.getInCenter();
        this.translate(value - current.x, 0);
      }
    },
    y: {
      get: function() {
        return this.getInCenter().y;
      },
      set: function(value) {
        var current = this.getInCenter();
        this.translate(0, value - current.y);
      }
    },
    alpha: {
      get: function() {
        var v1 = this.vertex1;
        var v2 = this.vertex2;
        var v3 = this.vertex3;
        return (v1.alpha + v2.alpha + v3.alpha) / 3;
      },
      set: function(value) {
        this.vertex1.alpha = value;
        this.vertex2.alpha = value;
        this.vertex3.alpha = value;
      }
    },
    depth: {
      get: function() {
        var v1 = this.vertex1;
        var v2 = this.vertex2;
        var v3 = this.vertex3;
        return (v1.vz + v2.vz + v3.vz) / 3;
      }
    },
    destroy: function() {
      this.vertex1 = null;
      this.vertex2 = null;
      this.vertex3 = null;
    }
  });
  module2.exports = Face;
});

// node_modules/phaser/src/geom/mesh/Vertex.js
var require_Vertex = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Utils = require_Utils();
  var Vector3 = require_Vector3();
  var Vertex = new Class({
    Extends: Vector3,
    initialize: function Vertex2(x, y, z, u, v, color, alpha, nx, ny, nz) {
      if (color === void 0) {
        color = 16777215;
      }
      if (alpha === void 0) {
        alpha = 1;
      }
      if (nx === void 0) {
        nx = 0;
      }
      if (ny === void 0) {
        ny = 0;
      }
      if (nz === void 0) {
        nz = 0;
      }
      Vector3.call(this, x, y, z);
      this.vx = 0;
      this.vy = 0;
      this.vz = 0;
      this.nx = nx;
      this.ny = ny;
      this.nz = nz;
      this.u = u;
      this.v = v;
      this.color = color;
      this.alpha = alpha;
      this.tx = 0;
      this.ty = 0;
      this.ta = 0;
    },
    setUVs: function(u, v) {
      this.u = u;
      this.v = v;
      return this;
    },
    transformCoordinatesLocal: function(transformMatrix, width, height, cameraZ) {
      var x = this.x;
      var y = this.y;
      var z = this.z;
      var m = transformMatrix.val;
      var tx = x * m[0] + y * m[4] + z * m[8] + m[12];
      var ty = x * m[1] + y * m[5] + z * m[9] + m[13];
      var tz = x * m[2] + y * m[6] + z * m[10] + m[14];
      var tw = x * m[3] + y * m[7] + z * m[11] + m[15];
      this.vx = tx / tw * width;
      this.vy = -(ty / tw) * height;
      if (cameraZ <= 0) {
        this.vz = tz / tw;
      } else {
        this.vz = -(tz / tw);
      }
    },
    update: function(a, b, c, d, e, f, roundPixels, alpha) {
      var tx = this.vx * a + this.vy * c + e;
      var ty = this.vx * b + this.vy * d + f;
      if (roundPixels) {
        tx = Math.round(tx);
        ty = Math.round(ty);
      }
      this.tx = tx;
      this.ty = ty;
      this.ta = this.alpha * alpha;
      return this;
    },
    load: function(F32, U32, offset, textureUnit, tintEffect) {
      F32[++offset] = this.tx;
      F32[++offset] = this.ty;
      F32[++offset] = this.u;
      F32[++offset] = this.v;
      F32[++offset] = textureUnit;
      F32[++offset] = tintEffect;
      U32[++offset] = Utils.getTintAppendFloatAlpha(this.color, this.ta);
      return offset;
    }
  });
  module2.exports = Vertex;
});

// node_modules/phaser/src/geom/mesh/GenerateVerts.js
var require_GenerateVerts = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Face = require_Face();
  var Vertex = require_Vertex();
  var GenerateVerts = function(vertices, uvs, indicies, containsZ, normals, colors, alphas) {
    if (containsZ === void 0) {
      containsZ = false;
    }
    if (colors === void 0) {
      colors = 16777215;
    }
    if (alphas === void 0) {
      alphas = 1;
    }
    if (vertices.length !== uvs.length) {
      console.warn("GenerateVerts: vertices and uvs count not equal");
      return;
    }
    var result = {
      faces: [],
      vertices: []
    };
    var i;
    var x;
    var y;
    var z;
    var u;
    var v;
    var color;
    var alpha;
    var normalX;
    var normalY;
    var normalZ;
    var iInc = containsZ ? 3 : 2;
    var isColorArray = Array.isArray(colors);
    var isAlphaArray = Array.isArray(alphas);
    if (Array.isArray(indicies) && indicies.length > 0) {
      for (i = 0; i < indicies.length; i++) {
        var index1 = indicies[i];
        var index2 = indicies[i] * 2;
        var index3 = indicies[i] * iInc;
        x = vertices[index3];
        y = vertices[index3 + 1];
        z = containsZ ? vertices[index3 + 2] : 0;
        u = uvs[index2];
        v = uvs[index2 + 1];
        color = isColorArray ? colors[index1] : colors;
        alpha = isAlphaArray ? alphas[index1] : alphas;
        normalX = 0;
        normalY = 0;
        normalZ = 0;
        if (normals) {
          normalX = normals[index3];
          normalY = normals[index3 + 1];
          normalZ = containsZ ? normals[index3 + 2] : 0;
        }
        result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));
      }
    } else {
      var uvIndex = 0;
      var colorIndex = 0;
      for (i = 0; i < vertices.length; i += iInc) {
        x = vertices[i];
        y = vertices[i + 1];
        z = containsZ ? vertices[i + 2] : 0;
        u = uvs[uvIndex];
        v = uvs[uvIndex + 1];
        color = isColorArray ? colors[colorIndex] : colors;
        alpha = isAlphaArray ? alphas[colorIndex] : alphas;
        normalX = 0;
        normalY = 0;
        normalZ = 0;
        if (normals) {
          normalX = normals[i];
          normalY = normals[i + 1];
          normalZ = containsZ ? normals[i + 2] : 0;
        }
        result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));
        uvIndex += 2;
        colorIndex++;
      }
    }
    for (i = 0; i < result.vertices.length; i += 3) {
      var vert1 = result.vertices[i];
      var vert2 = result.vertices[i + 1];
      var vert3 = result.vertices[i + 2];
      result.faces.push(new Face(vert1, vert2, vert3));
    }
    return result;
  };
  module2.exports = GenerateVerts;
});

// node_modules/phaser/src/geom/mesh/GenerateObjVerts.js
var require_GenerateObjVerts = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Face = require_Face();
  var Matrix4 = require_Matrix4();
  var Vector3 = require_Vector3();
  var Vertex = require_Vertex();
  var tempPosition = new Vector3();
  var tempRotation = new Vector3();
  var tempMatrix = new Matrix4();
  var GenerateObjVerts = function(data, mesh, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp) {
    if (scale === void 0) {
      scale = 1;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (rotateX === void 0) {
      rotateX = 0;
    }
    if (rotateY === void 0) {
      rotateY = 0;
    }
    if (rotateZ === void 0) {
      rotateZ = 0;
    }
    if (zIsUp === void 0) {
      zIsUp = true;
    }
    var result = {
      faces: [],
      verts: []
    };
    var materials = data.materials;
    tempPosition.set(x, y, z);
    tempRotation.set(rotateX, rotateY, rotateZ);
    tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);
    for (var m = 0; m < data.models.length; m++) {
      var model = data.models[m];
      var vertices = model.vertices;
      var textureCoords = model.textureCoords;
      var faces = model.faces;
      for (var i = 0; i < faces.length; i++) {
        var face = faces[i];
        var v1 = face.vertices[0];
        var v2 = face.vertices[1];
        var v3 = face.vertices[2];
        var m1 = vertices[v1.vertexIndex];
        var m2 = vertices[v2.vertexIndex];
        var m3 = vertices[v3.vertexIndex];
        var t1 = v1.textureCoordsIndex;
        var t2 = v2.textureCoordsIndex;
        var t3 = v3.textureCoordsIndex;
        var uv1 = t1 === -1 ? {u: 0, v: 1} : textureCoords[t1];
        var uv2 = t2 === -1 ? {u: 0, v: 0} : textureCoords[t2];
        var uv3 = t3 === -1 ? {u: 1, v: 1} : textureCoords[t3];
        var color = 16777215;
        if (face.material !== "" && materials[face.material]) {
          color = materials[face.material];
        }
        var vert1 = new Vertex(m1.x * scale, m1.y * scale, m1.z * scale, uv1.u, uv1.v, color).transformMat4(tempMatrix);
        var vert2 = new Vertex(m2.x * scale, m2.y * scale, m2.z * scale, uv2.u, uv2.v, color).transformMat4(tempMatrix);
        var vert3 = new Vertex(m3.x * scale, m3.y * scale, m3.z * scale, uv3.u, uv3.v, color).transformMat4(tempMatrix);
        result.verts.push(vert1, vert2, vert3);
        result.faces.push(new Face(vert1, vert2, vert3));
      }
    }
    if (mesh) {
      mesh.faces = mesh.faces.concat(result.faces);
      mesh.vertices = mesh.vertices.concat(result.verts);
    }
    return result;
  };
  module2.exports = GenerateObjVerts;
});

// node_modules/phaser/src/gameobjects/mesh/MeshWebGLRenderer.js
var require_MeshWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var MeshWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    var faces = src.faces;
    var totalFaces = faces.length;
    if (totalFaces === 0) {
      return;
    }
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
    var textureUnit = pipeline.setGameObject(src);
    var F32 = pipeline.vertexViewF32;
    var U32 = pipeline.vertexViewU32;
    var vertexOffset = pipeline.vertexCount * pipeline.currentShader.vertexComponentCount - 1;
    var tintEffect = src.tintFill;
    var debugFaces = [];
    var debugCallback = src.debugCallback;
    var a = calcMatrix.a;
    var b = calcMatrix.b;
    var c = calcMatrix.c;
    var d = calcMatrix.d;
    var e = calcMatrix.e;
    var f = calcMatrix.f;
    var z = src.viewPosition.z;
    var hideCCW = src.hideCCW;
    var roundPixels = camera.roundPixels;
    var alpha = camera.alpha * src.alpha;
    var totalFacesRendered = 0;
    renderer.pipelines.preBatch(src);
    for (var i = 0; i < totalFaces; i++) {
      var face = faces[i];
      if (!face.isInView(camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels)) {
        continue;
      }
      if (pipeline.shouldFlush(3)) {
        pipeline.flush();
        vertexOffset = 0;
      }
      vertexOffset = face.load(F32, U32, vertexOffset, textureUnit, tintEffect);
      totalFacesRendered++;
      pipeline.vertexCount += 3;
      if (debugCallback) {
        debugFaces.push(face);
      }
    }
    src.totalFrame += totalFacesRendered;
    if (debugCallback) {
      debugCallback.call(src, src, debugFaces);
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = MeshWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/mesh/MeshCanvasRenderer.js
var require_MeshCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MeshCanvasRenderer = function() {
  };
  module2.exports = MeshCanvasRenderer;
});

// node_modules/phaser/src/gameobjects/mesh/MeshRender.js
var require_MeshRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_MeshWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_MeshCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/mesh/Mesh.js
var require_Mesh = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components();
  var DegToRad = require_DegToRad();
  var Face = require_Face();
  var GameObject = require_GameObject();
  var GenerateVerts = require_GenerateVerts();
  var GenerateObjVerts = require_GenerateObjVerts();
  var GetCalcMatrix = require_GetCalcMatrix();
  var Matrix4 = require_Matrix4();
  var MeshRender = require_MeshRender();
  var StableSort = require_StableSort();
  var Vector3 = require_Vector3();
  var Vertex = require_Vertex();
  var Mesh = new Class({
    Extends: GameObject,
    Mixins: [
      Components.AlphaSingle,
      Components.BlendMode,
      Components.Depth,
      Components.Mask,
      Components.Pipeline,
      Components.Size,
      Components.Texture,
      Components.Transform,
      Components.Visible,
      Components.ScrollFactor,
      MeshRender
    ],
    initialize: function Mesh2(scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (texture === void 0) {
        texture = "__WHITE";
      }
      GameObject.call(this, scene, "Mesh");
      this.faces = [];
      this.vertices = [];
      this.tintFill = false;
      this.debugCallback = null;
      this.debugGraphic = null;
      this.hideCCW = true;
      this.modelPosition = new Vector3();
      this.modelScale = new Vector3(1, 1, 1);
      this.modelRotation = new Vector3();
      this.dirtyCache = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.transformMatrix = new Matrix4();
      this.viewPosition = new Vector3();
      this.viewMatrix = new Matrix4();
      this.projectionMatrix = new Matrix4();
      this.totalRendered = 0;
      this.totalFrame = 0;
      this.ignoreDirtyCache = false;
      var renderer = scene.sys.renderer;
      this.setPosition(x, y);
      this.setTexture(texture, frame);
      this.setSize(renderer.width, renderer.height);
      this.initPipeline();
      this.setPerspective(renderer.width, renderer.height);
      if (vertices) {
        this.addVertices(vertices, uvs, indicies, containsZ, normals, colors, alphas);
      }
    },
    addedToScene: function() {
      this.scene.sys.updateList.add(this);
    },
    removedFromScene: function() {
      this.scene.sys.updateList.remove(this);
    },
    panX: function(v) {
      this.viewPosition.addScale(Vector3.LEFT, v);
      this.dirtyCache[10] = 1;
      return this;
    },
    panY: function(v) {
      this.viewPosition.y += Vector3.DOWN.y * v;
      this.dirtyCache[10] = 1;
      return this;
    },
    panZ: function(amount) {
      this.viewPosition.z += amount;
      this.dirtyCache[10] = 1;
      return this;
    },
    setPerspective: function(width, height, fov, near, far) {
      if (fov === void 0) {
        fov = 45;
      }
      if (near === void 0) {
        near = 0.01;
      }
      if (far === void 0) {
        far = 1e3;
      }
      this.projectionMatrix.perspective(DegToRad(fov), width / height, near, far);
      this.dirtyCache[10] = 1;
      this.dirtyCache[11] = 0;
      return this;
    },
    setOrtho: function(scaleX, scaleY, near, far) {
      if (scaleX === void 0) {
        scaleX = this.scene.sys.renderer.getAspectRatio();
      }
      if (scaleY === void 0) {
        scaleY = 1;
      }
      if (near === void 0) {
        near = -1e3;
      }
      if (far === void 0) {
        far = 1e3;
      }
      this.projectionMatrix.ortho(-scaleX, scaleX, -scaleY, scaleY, near, far);
      this.dirtyCache[10] = 1;
      this.dirtyCache[11] = 1;
      return this;
    },
    clear: function() {
      this.faces.forEach(function(face) {
        face.destroy();
      });
      this.faces = [];
      this.vertices = [];
      return this;
    },
    addVerticesFromObj: function(key, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp) {
      var data = this.scene.sys.cache.obj.get(key);
      if (data) {
        GenerateObjVerts(data, this, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp);
      }
      return this;
    },
    sortByDepth: function(faceA, faceB) {
      return faceA.depth - faceB.depth;
    },
    depthSort: function() {
      StableSort(this.faces, this.sortByDepth);
      return this;
    },
    addVertex: function(x, y, z, u, v, color, alpha) {
      var vert = new Vertex(x, y, z, u, v, color, alpha);
      this.vertices.push(vert);
      return vert;
    },
    addFace: function(vertex1, vertex2, vertex3) {
      var face = new Face(vertex1, vertex2, vertex3);
      this.faces.push(face);
      this.dirtyCache[9] = -1;
      return face;
    },
    addVertices: function(vertices, uvs, indicies, containsZ, normals, colors, alphas) {
      var result = GenerateVerts(vertices, uvs, indicies, containsZ, normals, colors, alphas);
      if (result) {
        this.faces = this.faces.concat(result.faces);
        this.vertices = this.vertices.concat(result.vertices);
      }
      this.dirtyCache[9] = -1;
      return this;
    },
    getFaceCount: function() {
      return this.faces.length;
    },
    getVertexCount: function() {
      return this.vertices.length;
    },
    getFace: function(index) {
      return this.faces[index];
    },
    getFaceAt: function(x, y, camera) {
      if (camera === void 0) {
        camera = this.scene.sys.cameras.main;
      }
      var calcMatrix = GetCalcMatrix(this, camera).calc;
      var faces = this.faces;
      var results = [];
      for (var i = 0; i < faces.length; i++) {
        var face = faces[i];
        if (face.contains(x, y, calcMatrix)) {
          results.push(face);
        }
      }
      return StableSort(results, this.sortByDepth);
    },
    setDebug: function(graphic, callback) {
      this.debugGraphic = graphic;
      if (!graphic && !callback) {
        this.debugCallback = null;
      } else if (!callback) {
        this.debugCallback = this.renderDebug;
      } else {
        this.debugCallback = callback;
      }
      return this;
    },
    isDirty: function() {
      var position = this.modelPosition;
      var rotation = this.modelRotation;
      var scale = this.modelScale;
      var dirtyCache = this.dirtyCache;
      var px = position.x;
      var py = position.y;
      var pz = position.z;
      var rx = rotation.x;
      var ry = rotation.y;
      var rz = rotation.z;
      var sx = scale.x;
      var sy = scale.y;
      var sz = scale.z;
      var faces = this.getFaceCount();
      var pxCached = dirtyCache[0];
      var pyCached = dirtyCache[1];
      var pzCached = dirtyCache[2];
      var rxCached = dirtyCache[3];
      var ryCached = dirtyCache[4];
      var rzCached = dirtyCache[5];
      var sxCached = dirtyCache[6];
      var syCached = dirtyCache[7];
      var szCached = dirtyCache[8];
      var fCached = dirtyCache[9];
      dirtyCache[0] = px;
      dirtyCache[1] = py;
      dirtyCache[2] = pz;
      dirtyCache[3] = rx;
      dirtyCache[4] = ry;
      dirtyCache[5] = rz;
      dirtyCache[6] = sx;
      dirtyCache[7] = sy;
      dirtyCache[8] = sz;
      dirtyCache[9] = faces;
      return pxCached !== px || pyCached !== py || pzCached !== pz || rxCached !== rx || ryCached !== ry || rzCached !== rz || sxCached !== sx || syCached !== sy || szCached !== sz || fCached !== faces;
    },
    preUpdate: function() {
      this.totalRendered = this.totalFrame;
      this.totalFrame = 0;
      var dirty = this.dirtyCache;
      if (!this.ignoreDirtyCache && !dirty[10] && !this.isDirty()) {
        return;
      }
      var width = this.width;
      var height = this.height;
      var viewMatrix = this.viewMatrix;
      var viewPosition = this.viewPosition;
      if (dirty[10]) {
        viewMatrix.identity();
        viewMatrix.translate(viewPosition);
        viewMatrix.invert();
        dirty[10] = 0;
      }
      var transformMatrix = this.transformMatrix;
      transformMatrix.setWorldMatrix(this.modelRotation, this.modelPosition, this.modelScale, this.viewMatrix, this.projectionMatrix);
      var z = viewPosition.z;
      var faces = this.faces;
      for (var i = 0; i < faces.length; i++) {
        faces[i].transformCoordinatesLocal(transformMatrix, width, height, z);
      }
      this.depthSort();
    },
    renderDebug: function(src, faces) {
      var graphic = src.debugGraphic;
      for (var i = 0; i < faces.length; i++) {
        var face = faces[i];
        var x0 = face.vertex1.tx;
        var y0 = face.vertex1.ty;
        var x1 = face.vertex2.tx;
        var y1 = face.vertex2.ty;
        var x2 = face.vertex3.tx;
        var y2 = face.vertex3.ty;
        graphic.strokeTriangle(x0, y0, x1, y1, x2, y2);
      }
    },
    preDestroy: function() {
      this.clear();
      this.debugCallback = null;
      this.debugGraphic = null;
    }
  });
  module2.exports = Mesh;
});

// node_modules/phaser/src/gameobjects/pointlight/PointLightWebGLRenderer.js
var require_PointLightWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetCalcMatrix = require_GetCalcMatrix();
  var PointLightWebGLRenderer = function(renderer, src, camera, parentMatrix) {
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;
    var width = src.width;
    var height = src.height;
    var x = -src._radius;
    var y = -src._radius;
    var xw = x + width;
    var yh = y + height;
    var lightX = calcMatrix.getX(0, 0);
    var lightY = calcMatrix.getY(0, 0);
    var tx0 = calcMatrix.getX(x, y);
    var ty0 = calcMatrix.getY(x, y);
    var tx1 = calcMatrix.getX(x, yh);
    var ty1 = calcMatrix.getY(x, yh);
    var tx2 = calcMatrix.getX(xw, yh);
    var ty2 = calcMatrix.getY(xw, yh);
    var tx3 = calcMatrix.getX(xw, y);
    var ty3 = calcMatrix.getY(xw, y);
    renderer.pipelines.preBatch(src);
    pipeline.batchPointLight(src, camera, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, lightX, lightY);
    renderer.pipelines.postBatch(src);
  };
  module2.exports = PointLightWebGLRenderer;
});

// node_modules/phaser/src/gameobjects/pointlight/PointLightRender.js
var require_PointLightRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_PointLightWebGLRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/gameobjects/pointlight/PointLight.js
var require_PointLight = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components();
  var GameObject = require_GameObject();
  var IntegerToColor = require_IntegerToColor();
  var PIPELINES_CONST = require_const6();
  var Render = require_PointLightRender();
  var PointLight = new Class({
    Extends: GameObject,
    Mixins: [
      Components.AlphaSingle,
      Components.BlendMode,
      Components.Depth,
      Components.GetBounds,
      Components.Mask,
      Components.Pipeline,
      Components.ScrollFactor,
      Components.Transform,
      Components.Visible,
      Render
    ],
    initialize: function PointLight2(scene, x, y, color, radius, intensity, attenuation) {
      if (color === void 0) {
        color = 16777215;
      }
      if (radius === void 0) {
        radius = 128;
      }
      if (intensity === void 0) {
        intensity = 1;
      }
      if (attenuation === void 0) {
        attenuation = 0.1;
      }
      GameObject.call(this, scene, "PointLight");
      this.initPipeline(PIPELINES_CONST.POINTLIGHT_PIPELINE);
      this.setPosition(x, y);
      this.color = IntegerToColor(color);
      this.intensity = intensity;
      this.attenuation = attenuation;
      this.width = radius * 2;
      this.height = radius * 2;
      this._radius = radius;
    },
    radius: {
      get: function() {
        return this._radius;
      },
      set: function(value) {
        this._radius = value;
        this.width = value * 2;
        this.height = value * 2;
      }
    },
    originX: {
      get: function() {
        return 0.5;
      }
    },
    originY: {
      get: function() {
        return 0.5;
      }
    },
    displayOriginX: {
      get: function() {
        return this._radius;
      }
    },
    displayOriginY: {
      get: function() {
        return this._radius;
      }
    }
  });
  module2.exports = PointLight;
});

// node_modules/phaser/src/gameobjects/shader/ShaderFactory.js
var require_ShaderFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Shader = require_Shader();
  var GameObjectFactory = require_GameObjectFactory();
  if (typeof WEBGL_RENDERER) {
    GameObjectFactory.register("shader", function(key, x, y, width, height, textures, textureData) {
      return this.displayList.add(new Shader(this.scene, key, x, y, width, height, textures, textureData));
    });
  }
});

// node_modules/phaser/src/gameobjects/mesh/MeshFactory.js
var require_MeshFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Mesh = require_Mesh();
  var GameObjectFactory = require_GameObjectFactory();
  if (typeof WEBGL_RENDERER) {
    GameObjectFactory.register("mesh", function(x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas) {
      return this.displayList.add(new Mesh(this.scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas));
    });
  }
});

// node_modules/phaser/src/gameobjects/pointlight/PointLightFactory.js
var require_PointLightFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var PointLight = require_PointLight();
  GameObjectFactory.register("pointlight", function(x, y, color, radius, intensity, attenuation) {
    return this.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));
  });
});

// node_modules/phaser/src/gameobjects/shader/ShaderCreator.js
var require_ShaderCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var Shader = require_Shader();
  GameObjectCreator.register("shader", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var key = GetAdvancedValue(config2, "key", null);
    var x = GetAdvancedValue(config2, "x", 0);
    var y = GetAdvancedValue(config2, "y", 0);
    var width = GetAdvancedValue(config2, "width", 128);
    var height = GetAdvancedValue(config2, "height", 128);
    var shader = new Shader(this.scene, key, x, y, width, height);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, shader, config2);
    return shader;
  });
});

// node_modules/phaser/src/gameobjects/mesh/MeshCreator.js
var require_MeshCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var GetValue = require_GetValue();
  var Mesh = require_Mesh();
  GameObjectCreator.register("mesh", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var key = GetAdvancedValue(config2, "key", null);
    var frame = GetAdvancedValue(config2, "frame", null);
    var vertices = GetValue(config2, "vertices", []);
    var uvs = GetValue(config2, "uvs", []);
    var indicies = GetValue(config2, "indicies", []);
    var containsZ = GetValue(config2, "containsZ", false);
    var normals = GetValue(config2, "normals", []);
    var colors = GetValue(config2, "colors", 16777215);
    var alphas = GetValue(config2, "alphas", 1);
    var mesh = new Mesh(this.scene, 0, 0, key, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, mesh, config2);
    return mesh;
  });
});

// node_modules/phaser/src/gameobjects/pointlight/PointLightCreator.js
var require_PointLightCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var PointLight = require_PointLight();
  GameObjectCreator.register("pointlight", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var color = GetAdvancedValue(config2, "color", 16777215);
    var radius = GetAdvancedValue(config2, "radius", 128);
    var intensity = GetAdvancedValue(config2, "intensity", 1);
    var attenuation = GetAdvancedValue(config2, "attenuation", 0.1);
    var layer = new PointLight(this.scene, 0, 0, color, radius, intensity, attenuation);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, layer, config2);
    return layer;
  });
});

// node_modules/phaser/src/gameobjects/lights/Light.js
var require_Light = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Circle = require_Circle();
  var Class = require_Class();
  var Components = require_components();
  var RGB = require_RGB();
  var Utils = require_Utils();
  var Light = new Class({
    Extends: Circle,
    Mixins: [
      Components.ScrollFactor,
      Components.Visible
    ],
    initialize: function Light2(x, y, radius, r, g, b, intensity) {
      Circle.call(this, x, y, radius);
      this.color = new RGB(r, g, b);
      this.intensity = intensity;
      this.renderFlags = 15;
      this.cameraFilter = 0;
      this.setScrollFactor(1, 1);
    },
    willRender: function(camera) {
      return !(Light.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);
    },
    setColor: function(rgb) {
      var color = Utils.getFloatsFromUintRGB(rgb);
      this.color.set(color[0], color[1], color[2]);
      return this;
    },
    setIntensity: function(intensity) {
      this.intensity = intensity;
      return this;
    },
    setRadius: function(radius) {
      this.radius = radius;
      return this;
    }
  });
  Light.RENDER_MASK = 15;
  module2.exports = Light;
});

// node_modules/phaser/src/geom/intersects/CircleToRectangle.js
var require_CircleToRectangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CircleToRectangle = function(circle, rect) {
    var halfWidth = rect.width / 2;
    var halfHeight = rect.height / 2;
    var cx = Math.abs(circle.x - rect.x - halfWidth);
    var cy = Math.abs(circle.y - rect.y - halfHeight);
    var xDist = halfWidth + circle.radius;
    var yDist = halfHeight + circle.radius;
    if (cx > xDist || cy > yDist) {
      return false;
    } else if (cx <= halfWidth || cy <= halfHeight) {
      return true;
    } else {
      var xCornerDist = cx - halfWidth;
      var yCornerDist = cy - halfHeight;
      var xCornerDistSq = xCornerDist * xCornerDist;
      var yCornerDistSq = yCornerDist * yCornerDist;
      var maxCornerDistSq = circle.radius * circle.radius;
      return xCornerDistSq + yCornerDistSq <= maxCornerDistSq;
    }
  };
  module2.exports = CircleToRectangle;
});

// node_modules/phaser/src/gameobjects/lights/LightsManager.js
var require_LightsManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CircleToRectangle = require_CircleToRectangle();
  var Class = require_Class();
  var DistanceBetween = require_DistanceBetween();
  var Light = require_Light();
  var PointLight = require_PointLight();
  var RGB = require_RGB();
  var SpliceOne = require_SpliceOne();
  var StableSort = require_StableSort();
  var Utils = require_Utils();
  var LightsManager = new Class({
    initialize: function LightsManager2() {
      this.lights = [];
      this.ambientColor = new RGB(0.1, 0.1, 0.1);
      this.active = false;
      this.maxLights = -1;
      this.visibleLights = 0;
    },
    addPointLight: function(x, y, color, radius, intensity, attenuation) {
      return this.systems.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));
    },
    enable: function() {
      if (this.maxLights === -1) {
        this.maxLights = this.systems.renderer.config.maxLights;
      }
      this.active = true;
      return this;
    },
    disable: function() {
      this.active = false;
      return this;
    },
    getLights: function(camera) {
      var lights = this.lights;
      var worldView = camera.worldView;
      var visibleLights = [];
      for (var i = 0; i < lights.length; i++) {
        var light = lights[i];
        if (light.willRender(camera) && CircleToRectangle(light, worldView)) {
          visibleLights.push({
            light,
            distance: DistanceBetween(light.x, light.y, worldView.centerX, worldView.centerY)
          });
        }
      }
      if (visibleLights.length > this.maxLights) {
        StableSort(visibleLights, this.sortByDistance);
        visibleLights = visibleLights.slice(0, this.maxLights);
      }
      this.visibleLights = visibleLights.length;
      return visibleLights;
    },
    sortByDistance: function(a, b) {
      return a.distance >= b.distance;
    },
    setAmbientColor: function(rgb) {
      var color = Utils.getFloatsFromUintRGB(rgb);
      this.ambientColor.set(color[0], color[1], color[2]);
      return this;
    },
    getMaxVisibleLights: function() {
      return this.maxLights;
    },
    getLightCount: function() {
      return this.lights.length;
    },
    addLight: function(x, y, radius, rgb, intensity) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (radius === void 0) {
        radius = 128;
      }
      if (rgb === void 0) {
        rgb = 16777215;
      }
      if (intensity === void 0) {
        intensity = 1;
      }
      var color = Utils.getFloatsFromUintRGB(rgb);
      var light = new Light(x, y, radius, color[0], color[1], color[2], intensity);
      this.lights.push(light);
      return light;
    },
    removeLight: function(light) {
      var index = this.lights.indexOf(light);
      if (index >= 0) {
        SpliceOne(this.lights, index);
      }
      return this;
    },
    shutdown: function() {
      this.lights.length = 0;
    },
    destroy: function() {
      this.shutdown();
    }
  });
  module2.exports = LightsManager;
});

// node_modules/phaser/src/gameobjects/lights/LightsPlugin.js
var require_LightsPlugin = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var LightsManager = require_LightsManager();
  var PluginCache = require_PluginCache();
  var SceneEvents = require_events5();
  var LightsPlugin = new Class({
    Extends: LightsManager,
    initialize: function LightsPlugin2(scene) {
      this.scene = scene;
      this.systems = scene.sys;
      if (!scene.sys.settings.isBooted) {
        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
      }
      LightsManager.call(this);
    },
    boot: function() {
      var eventEmitter = this.systems.events;
      eventEmitter.on(SceneEvents.SHUTDOWN, this.shutdown, this);
      eventEmitter.on(SceneEvents.DESTROY, this.destroy, this);
    },
    destroy: function() {
      this.shutdown();
      this.scene = void 0;
      this.systems = void 0;
    }
  });
  PluginCache.register("LightsPlugin", LightsPlugin, "lights");
  module2.exports = LightsPlugin;
});

// node_modules/phaser/src/gameobjects/index.js
var require_gameobjects = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjects = {
    Events: require_events4(),
    DisplayList: require_DisplayList(),
    GameObjectCreator: require_GameObjectCreator(),
    GameObjectFactory: require_GameObjectFactory(),
    UpdateList: require_UpdateList(),
    Components: require_components(),
    GetCalcMatrix: require_GetCalcMatrix(),
    BuildGameObject: require_BuildGameObject(),
    BuildGameObjectAnimation: require_BuildGameObjectAnimation(),
    GameObject: require_GameObject(),
    BitmapText: require_BitmapText(),
    Blitter: require_Blitter(),
    Bob: require_Bob(),
    Container: require_Container(),
    DOMElement: require_DOMElement(),
    DynamicBitmapText: require_DynamicBitmapText(),
    Extern: require_Extern(),
    Graphics: require_Graphics(),
    Group: require_Group(),
    Image: require_Image2(),
    Layer: require_Layer(),
    Particles: require_particles(),
    PathFollower: require_PathFollower2(),
    RenderTexture: require_RenderTexture(),
    RetroFont: require_RetroFont(),
    Rope: require_Rope(),
    Sprite: require_Sprite(),
    Text: require_Text(),
    GetTextSize: require_GetTextSize(),
    MeasureText: require_MeasureText(),
    TextStyle: require_TextStyle(),
    TileSprite: require_TileSprite(),
    Zone: require_Zone(),
    Video: require_Video2(),
    Shape: require_Shape(),
    Arc: require_Arc(),
    Curve: require_Curve2(),
    Ellipse: require_Ellipse2(),
    Grid: require_Grid(),
    IsoBox: require_IsoBox(),
    IsoTriangle: require_IsoTriangle(),
    Line: require_Line2(),
    Polygon: require_Polygon2(),
    Rectangle: require_Rectangle2(),
    Star: require_Star(),
    Triangle: require_Triangle2(),
    Factories: {
      Blitter: require_BlitterFactory(),
      Container: require_ContainerFactory(),
      DOMElement: require_DOMElementFactory(),
      DynamicBitmapText: require_DynamicBitmapTextFactory(),
      Extern: require_ExternFactory(),
      Graphics: require_GraphicsFactory(),
      Group: require_GroupFactory(),
      Image: require_ImageFactory(),
      Layer: require_LayerFactory(),
      Particles: require_ParticleManagerFactory(),
      PathFollower: require_PathFollowerFactory(),
      RenderTexture: require_RenderTextureFactory(),
      Rope: require_RopeFactory(),
      Sprite: require_SpriteFactory(),
      StaticBitmapText: require_BitmapTextFactory(),
      Text: require_TextFactory(),
      TileSprite: require_TileSpriteFactory(),
      Zone: require_ZoneFactory(),
      Video: require_VideoFactory(),
      Arc: require_ArcFactory(),
      Curve: require_CurveFactory(),
      Ellipse: require_EllipseFactory(),
      Grid: require_GridFactory(),
      IsoBox: require_IsoBoxFactory(),
      IsoTriangle: require_IsoTriangleFactory(),
      Line: require_LineFactory(),
      Polygon: require_PolygonFactory(),
      Rectangle: require_RectangleFactory(),
      Star: require_StarFactory(),
      Triangle: require_TriangleFactory()
    },
    Creators: {
      Blitter: require_BlitterCreator(),
      Container: require_ContainerCreator(),
      DynamicBitmapText: require_DynamicBitmapTextCreator(),
      Graphics: require_GraphicsCreator(),
      Group: require_GroupCreator(),
      Image: require_ImageCreator(),
      Layer: require_LayerCreator(),
      Particles: require_ParticleManagerCreator(),
      RenderTexture: require_RenderTextureCreator(),
      Rope: require_RopeCreator(),
      Sprite: require_SpriteCreator(),
      StaticBitmapText: require_BitmapTextCreator(),
      Text: require_TextCreator(),
      TileSprite: require_TileSpriteCreator(),
      Zone: require_ZoneCreator(),
      Video: require_VideoCreator()
    }
  };
  if (typeof WEBGL_RENDERER) {
    GameObjects.Shader = require_Shader();
    GameObjects.Mesh = require_Mesh();
    GameObjects.PointLight = require_PointLight();
    GameObjects.Factories.Shader = require_ShaderFactory();
    GameObjects.Factories.Mesh = require_MeshFactory();
    GameObjects.Factories.PointLight = require_PointLightFactory();
    GameObjects.Creators.Shader = require_ShaderCreator();
    GameObjects.Creators.Mesh = require_MeshCreator();
    GameObjects.Creators.PointLight = require_PointLightCreator();
    GameObjects.Light = require_Light();
    GameObjects.LightsManager = require_LightsManager();
    GameObjects.LightsPlugin = require_LightsPlugin();
  }
  module2.exports = GameObjects;
});

// node_modules/phaser/src/geom/circle/Area.js
var require_Area = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Area = function(circle) {
    return circle.radius > 0 ? Math.PI * circle.radius * circle.radius : 0;
  };
  module2.exports = Area;
});

// node_modules/phaser/src/geom/circle/Clone.js
var require_Clone2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Circle = require_Circle();
  var Clone = function(source) {
    return new Circle(source.x, source.y, source.radius);
  };
  module2.exports = Clone;
});

// node_modules/phaser/src/geom/circle/ContainsPoint.js
var require_ContainsPoint = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = require_Contains();
  var ContainsPoint = function(circle, point) {
    return Contains(circle, point.x, point.y);
  };
  module2.exports = ContainsPoint;
});

// node_modules/phaser/src/geom/circle/ContainsRect.js
var require_ContainsRect = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = require_Contains();
  var ContainsRect = function(circle, rect) {
    return Contains(circle, rect.x, rect.y) && Contains(circle, rect.right, rect.y) && Contains(circle, rect.x, rect.bottom) && Contains(circle, rect.right, rect.bottom);
  };
  module2.exports = ContainsRect;
});

// node_modules/phaser/src/geom/circle/CopyFrom.js
var require_CopyFrom = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CopyFrom = function(source, dest) {
    return dest.setTo(source.x, source.y, source.radius);
  };
  module2.exports = CopyFrom;
});

// node_modules/phaser/src/geom/circle/Equals.js
var require_Equals = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Equals = function(circle, toCompare) {
    return circle.x === toCompare.x && circle.y === toCompare.y && circle.radius === toCompare.radius;
  };
  module2.exports = Equals;
});

// node_modules/phaser/src/geom/circle/GetBounds.js
var require_GetBounds3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  var GetBounds = function(circle, out) {
    if (out === void 0) {
      out = new Rectangle();
    }
    out.x = circle.left;
    out.y = circle.top;
    out.width = circle.diameter;
    out.height = circle.diameter;
    return out;
  };
  module2.exports = GetBounds;
});

// node_modules/phaser/src/geom/circle/Offset.js
var require_Offset = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Offset = function(circle, x, y) {
    circle.x += x;
    circle.y += y;
    return circle;
  };
  module2.exports = Offset;
});

// node_modules/phaser/src/geom/circle/OffsetPoint.js
var require_OffsetPoint = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var OffsetPoint = function(circle, point) {
    circle.x += point.x;
    circle.y += point.y;
    return circle;
  };
  module2.exports = OffsetPoint;
});

// node_modules/phaser/src/geom/circle/index.js
var require_circle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Circle = require_Circle();
  Circle.Area = require_Area();
  Circle.Circumference = require_Circumference();
  Circle.CircumferencePoint = require_CircumferencePoint();
  Circle.Clone = require_Clone2();
  Circle.Contains = require_Contains();
  Circle.ContainsPoint = require_ContainsPoint();
  Circle.ContainsRect = require_ContainsRect();
  Circle.CopyFrom = require_CopyFrom();
  Circle.Equals = require_Equals();
  Circle.GetBounds = require_GetBounds3();
  Circle.GetPoint = require_GetPoint();
  Circle.GetPoints = require_GetPoints();
  Circle.Offset = require_Offset();
  Circle.OffsetPoint = require_OffsetPoint();
  Circle.Random = require_Random();
  module2.exports = Circle;
});

// node_modules/phaser/src/geom/ellipse/Area.js
var require_Area2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Area = function(ellipse) {
    if (ellipse.isEmpty()) {
      return 0;
    }
    return ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI;
  };
  module2.exports = Area;
});

// node_modules/phaser/src/geom/ellipse/Clone.js
var require_Clone3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Ellipse = require_Ellipse();
  var Clone = function(source) {
    return new Ellipse(source.x, source.y, source.width, source.height);
  };
  module2.exports = Clone;
});

// node_modules/phaser/src/geom/ellipse/ContainsPoint.js
var require_ContainsPoint2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = require_Contains3();
  var ContainsPoint = function(ellipse, point) {
    return Contains(ellipse, point.x, point.y);
  };
  module2.exports = ContainsPoint;
});

// node_modules/phaser/src/geom/ellipse/ContainsRect.js
var require_ContainsRect2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = require_Contains3();
  var ContainsRect = function(ellipse, rect) {
    return Contains(ellipse, rect.x, rect.y) && Contains(ellipse, rect.right, rect.y) && Contains(ellipse, rect.x, rect.bottom) && Contains(ellipse, rect.right, rect.bottom);
  };
  module2.exports = ContainsRect;
});

// node_modules/phaser/src/geom/ellipse/CopyFrom.js
var require_CopyFrom2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CopyFrom = function(source, dest) {
    return dest.setTo(source.x, source.y, source.width, source.height);
  };
  module2.exports = CopyFrom;
});

// node_modules/phaser/src/geom/ellipse/Equals.js
var require_Equals2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Equals = function(ellipse, toCompare) {
    return ellipse.x === toCompare.x && ellipse.y === toCompare.y && ellipse.width === toCompare.width && ellipse.height === toCompare.height;
  };
  module2.exports = Equals;
});

// node_modules/phaser/src/geom/ellipse/GetBounds.js
var require_GetBounds4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  var GetBounds = function(ellipse, out) {
    if (out === void 0) {
      out = new Rectangle();
    }
    out.x = ellipse.left;
    out.y = ellipse.top;
    out.width = ellipse.width;
    out.height = ellipse.height;
    return out;
  };
  module2.exports = GetBounds;
});

// node_modules/phaser/src/geom/ellipse/Offset.js
var require_Offset2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Offset = function(ellipse, x, y) {
    ellipse.x += x;
    ellipse.y += y;
    return ellipse;
  };
  module2.exports = Offset;
});

// node_modules/phaser/src/geom/ellipse/OffsetPoint.js
var require_OffsetPoint2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var OffsetPoint = function(ellipse, point) {
    ellipse.x += point.x;
    ellipse.y += point.y;
    return ellipse;
  };
  module2.exports = OffsetPoint;
});

// node_modules/phaser/src/geom/ellipse/index.js
var require_ellipse = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Ellipse = require_Ellipse();
  Ellipse.Area = require_Area2();
  Ellipse.Circumference = require_Circumference2();
  Ellipse.CircumferencePoint = require_CircumferencePoint2();
  Ellipse.Clone = require_Clone3();
  Ellipse.Contains = require_Contains3();
  Ellipse.ContainsPoint = require_ContainsPoint2();
  Ellipse.ContainsRect = require_ContainsRect2();
  Ellipse.CopyFrom = require_CopyFrom2();
  Ellipse.Equals = require_Equals2();
  Ellipse.GetBounds = require_GetBounds4();
  Ellipse.GetPoint = require_GetPoint4();
  Ellipse.GetPoints = require_GetPoints4();
  Ellipse.Offset = require_Offset2();
  Ellipse.OffsetPoint = require_OffsetPoint2();
  Ellipse.Random = require_Random4();
  module2.exports = Ellipse;
});

// node_modules/phaser/src/geom/intersects/CircleToCircle.js
var require_CircleToCircle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DistanceBetween = require_DistanceBetween();
  var CircleToCircle = function(circleA, circleB) {
    return DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= circleA.radius + circleB.radius;
  };
  module2.exports = CircleToCircle;
});

// node_modules/phaser/src/geom/intersects/GetCircleToCircle.js
var require_GetCircleToCircle = __commonJS((exports2, module2) => {
  /**
   * @author       Florian Vazelle
   * @author       Geoffrey Glaive
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var CircleToCircle = require_CircleToCircle();
  var GetCircleToCircle = function(circleA, circleB, out) {
    if (out === void 0) {
      out = [];
    }
    if (CircleToCircle(circleA, circleB)) {
      var x0 = circleA.x;
      var y0 = circleA.y;
      var r0 = circleA.radius;
      var x1 = circleB.x;
      var y1 = circleB.y;
      var r1 = circleB.radius;
      var coefficientA, coefficientB, coefficientC, lambda, x;
      if (y0 === y1) {
        x = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0) / (2 * (x0 - x1));
        coefficientA = 1;
        coefficientB = -2 * y1;
        coefficientC = x1 * x1 + x * x - 2 * x1 * x + y1 * y1 - r1 * r1;
        lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
        if (lambda === 0) {
          out.push(new Point(x, -coefficientB / (2 * coefficientA)));
        } else if (lambda > 0) {
          out.push(new Point(x, (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA)));
          out.push(new Point(x, (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA)));
        }
      } else {
        var v1 = (x0 - x1) / (y0 - y1);
        var n = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0 - y1 * y1 + y0 * y0) / (2 * (y0 - y1));
        coefficientA = v1 * v1 + 1;
        coefficientB = 2 * y0 * v1 - 2 * n * v1 - 2 * x0;
        coefficientC = x0 * x0 + y0 * y0 + n * n - r0 * r0 - 2 * y0 * n;
        lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
        if (lambda === 0) {
          x = -coefficientB / (2 * coefficientA);
          out.push(new Point(x, n - x * v1));
        } else if (lambda > 0) {
          x = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);
          out.push(new Point(x, n - x * v1));
          x = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);
          out.push(new Point(x, n - x * v1));
        }
      }
    }
    return out;
  };
  module2.exports = GetCircleToCircle;
});

// node_modules/phaser/src/geom/intersects/LineToCircle.js
var require_LineToCircle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = require_Contains();
  var Point = require_Point();
  var tmp = new Point();
  var LineToCircle = function(line, circle, nearest) {
    if (nearest === void 0) {
      nearest = tmp;
    }
    if (Contains(circle, line.x1, line.y1)) {
      nearest.x = line.x1;
      nearest.y = line.y1;
      return true;
    }
    if (Contains(circle, line.x2, line.y2)) {
      nearest.x = line.x2;
      nearest.y = line.y2;
      return true;
    }
    var dx = line.x2 - line.x1;
    var dy = line.y2 - line.y1;
    var lcx = circle.x - line.x1;
    var lcy = circle.y - line.y1;
    var dLen2 = dx * dx + dy * dy;
    var px = dx;
    var py = dy;
    if (dLen2 > 0) {
      var dp = (lcx * dx + lcy * dy) / dLen2;
      px *= dp;
      py *= dp;
    }
    nearest.x = line.x1 + px;
    nearest.y = line.y1 + py;
    var pLen2 = px * px + py * py;
    return pLen2 <= dLen2 && px * dx + py * dy >= 0 && Contains(circle, nearest.x, nearest.y);
  };
  module2.exports = LineToCircle;
});

// node_modules/phaser/src/geom/intersects/GetLineToCircle.js
var require_GetLineToCircle = __commonJS((exports2, module2) => {
  /**
   * @author       Florian Vazelle
   * @author       Geoffrey Glaive
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var LineToCircle = require_LineToCircle();
  var GetLineToCircle = function(line, circle, out) {
    if (out === void 0) {
      out = [];
    }
    if (LineToCircle(line, circle)) {
      var lx1 = line.x1;
      var ly1 = line.y1;
      var lx2 = line.x2;
      var ly2 = line.y2;
      var cx = circle.x;
      var cy = circle.y;
      var cr = circle.radius;
      var lDirX = lx2 - lx1;
      var lDirY = ly2 - ly1;
      var oDirX = lx1 - cx;
      var oDirY = ly1 - cy;
      var coefficientA = lDirX * lDirX + lDirY * lDirY;
      var coefficientB = 2 * (lDirX * oDirX + lDirY * oDirY);
      var coefficientC = oDirX * oDirX + oDirY * oDirY - cr * cr;
      var lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;
      var x, y;
      if (lambda === 0) {
        var root = -coefficientB / (2 * coefficientA);
        x = lx1 + root * lDirX;
        y = ly1 + root * lDirY;
        if (root >= 0 && root <= 1) {
          out.push(new Point(x, y));
        }
      } else if (lambda > 0) {
        var root1 = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);
        x = lx1 + root1 * lDirX;
        y = ly1 + root1 * lDirY;
        if (root1 >= 0 && root1 <= 1) {
          out.push(new Point(x, y));
        }
        var root2 = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);
        x = lx1 + root2 * lDirX;
        y = ly1 + root2 * lDirY;
        if (root2 >= 0 && root2 <= 1) {
          out.push(new Point(x, y));
        }
      }
    }
    return out;
  };
  module2.exports = GetLineToCircle;
});

// node_modules/phaser/src/geom/intersects/GetCircleToRectangle.js
var require_GetCircleToRectangle = __commonJS((exports2, module2) => {
  /**
   * @author       Florian Vazelle
   * @author       Geoffrey Glaive
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetLineToCircle = require_GetLineToCircle();
  var CircleToRectangle = require_CircleToRectangle();
  var GetCircleToRectangle = function(circle, rect, out) {
    if (out === void 0) {
      out = [];
    }
    if (CircleToRectangle(circle, rect)) {
      var lineA = rect.getLineA();
      var lineB = rect.getLineB();
      var lineC = rect.getLineC();
      var lineD = rect.getLineD();
      GetLineToCircle(lineA, circle, out);
      GetLineToCircle(lineB, circle, out);
      GetLineToCircle(lineC, circle, out);
      GetLineToCircle(lineD, circle, out);
    }
    return out;
  };
  module2.exports = GetCircleToRectangle;
});

// node_modules/phaser/src/geom/intersects/GetLineToLine.js
var require_GetLineToLine = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector3 = require_Vector3();
  var GetLineToLine = function(line1, line2, out) {
    var x1 = line1.x1;
    var y1 = line1.y1;
    var x2 = line1.x2;
    var y2 = line1.y2;
    var x3 = line2.x1;
    var y3 = line2.y1;
    var x4 = line2.x2;
    var y4 = line2.y2;
    var dx1 = x2 - x1;
    var dy1 = y2 - y1;
    var dx2 = x4 - x3;
    var dy2 = y4 - y3;
    var denom = dy2 * dx1 - dx2 * dy1;
    if (dx1 === 0 || denom === 0) {
      return false;
    }
    var T2 = (dx1 * (y3 - y1) + dy1 * (x1 - x3)) / (dx2 * dy1 - dy2 * dx1);
    var T1 = (x3 + dx2 * T2 - x1) / dx1;
    if (T1 < 0 || T2 < 0 || T2 > 1) {
      return null;
    }
    if (out === void 0) {
      out = new Vector3();
    }
    return out.set(x1 + dx1 * T1, y1 + dy1 * T1, T1);
  };
  module2.exports = GetLineToLine;
});

// node_modules/phaser/src/geom/intersects/GetLineToPoints.js
var require_GetLineToPoints = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector3 = require_Vector3();
  var GetLineToLine = require_GetLineToLine();
  var Line = require_Line();
  var segment = new Line();
  var tempIntersect = new Vector3();
  var GetLineToPoints = function(line, points, out) {
    if (out === void 0) {
      out = new Vector3();
    }
    var closestIntersect = false;
    out.set();
    tempIntersect.set();
    var prev = points[0];
    for (var i = 1; i < points.length; i++) {
      var current = points[i];
      segment.setTo(prev.x, prev.y, current.x, current.y);
      prev = current;
      if (GetLineToLine(line, segment, tempIntersect)) {
        if (!closestIntersect || tempIntersect.z < out.z) {
          out.copy(tempIntersect);
          closestIntersect = true;
        }
      }
    }
    return closestIntersect ? out : null;
  };
  module2.exports = GetLineToPoints;
});

// node_modules/phaser/src/geom/intersects/GetLineToPolygon.js
var require_GetLineToPolygon = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector3 = require_Vector3();
  var Vector4 = require_Vector4();
  var GetLineToPoints = require_GetLineToPoints();
  var tempIntersect = new Vector3();
  var GetLineToPolygon = function(line, polygons, out) {
    if (out === void 0) {
      out = new Vector4();
    }
    if (!Array.isArray(polygons)) {
      polygons = [polygons];
    }
    var closestIntersect = false;
    out.set();
    tempIntersect.set();
    for (var i = 0; i < polygons.length; i++) {
      if (GetLineToPoints(line, polygons[i].points, tempIntersect)) {
        if (!closestIntersect || tempIntersect.z < out.z) {
          out.set(tempIntersect.x, tempIntersect.y, tempIntersect.z, i);
          closestIntersect = true;
        }
      }
    }
    return closestIntersect ? out : null;
  };
  module2.exports = GetLineToPolygon;
});

// node_modules/phaser/src/geom/intersects/LineToLine.js
var require_LineToLine = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var LineToLine = function(line1, line2, out) {
    if (out === void 0) {
      out = new Point();
    }
    var x1 = line1.x1;
    var y1 = line1.y1;
    var x2 = line1.x2;
    var y2 = line1.y2;
    var x3 = line2.x1;
    var y3 = line2.y1;
    var x4 = line2.x2;
    var y4 = line2.y2;
    var numA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    var numB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    var deNom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    if (deNom === 0) {
      return false;
    }
    var uA = numA / deNom;
    var uB = numB / deNom;
    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
      out.x = x1 + uA * (x2 - x1);
      out.y = y1 + uA * (y2 - y1);
      return true;
    }
    return false;
  };
  module2.exports = LineToLine;
});

// node_modules/phaser/src/geom/intersects/LineToRectangle.js
var require_LineToRectangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var LineToRectangle = function(line, rect) {
    var x1 = line.x1;
    var y1 = line.y1;
    var x2 = line.x2;
    var y2 = line.y2;
    var bx1 = rect.x;
    var by1 = rect.y;
    var bx2 = rect.right;
    var by2 = rect.bottom;
    var t = 0;
    if (x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2 || x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2) {
      return true;
    }
    if (x1 < bx1 && x2 >= bx1) {
      t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);
      if (t > by1 && t <= by2) {
        return true;
      }
    } else if (x1 > bx2 && x2 <= bx2) {
      t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);
      if (t >= by1 && t <= by2) {
        return true;
      }
    }
    if (y1 < by1 && y2 >= by1) {
      t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);
      if (t >= bx1 && t <= bx2) {
        return true;
      }
    } else if (y1 > by2 && y2 <= by2) {
      t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);
      if (t >= bx1 && t <= bx2) {
        return true;
      }
    }
    return false;
  };
  module2.exports = LineToRectangle;
});

// node_modules/phaser/src/geom/intersects/GetLineToRectangle.js
var require_GetLineToRectangle = __commonJS((exports2, module2) => {
  /**
   * @author       Florian Vazelle
   * @author       Geoffrey Glaive
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var LineToLine = require_LineToLine();
  var LineToRectangle = require_LineToRectangle();
  var GetLineToRectangle = function(line, rect, out) {
    if (out === void 0) {
      out = [];
    }
    if (LineToRectangle(line, rect)) {
      var lineA = rect.getLineA();
      var lineB = rect.getLineB();
      var lineC = rect.getLineC();
      var lineD = rect.getLineD();
      var output = [new Point(), new Point(), new Point(), new Point()];
      var result = [
        LineToLine(lineA, line, output[0]),
        LineToLine(lineB, line, output[1]),
        LineToLine(lineC, line, output[2]),
        LineToLine(lineD, line, output[3])
      ];
      for (var i = 0; i < 4; i++) {
        if (result[i]) {
          out.push(output[i]);
        }
      }
    }
    return out;
  };
  module2.exports = GetLineToRectangle;
});

// node_modules/phaser/src/geom/intersects/GetRaysFromPointToPolygon.js
var require_GetRaysFromPointToPolygon = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector4 = require_Vector4();
  var GetLineToPolygon = require_GetLineToPolygon();
  var Line = require_Line();
  var segment = new Line();
  function CheckIntersects(angle, x, y, polygons, intersects) {
    var dx = Math.cos(angle);
    var dy = Math.sin(angle);
    segment.setTo(x, y, x + dx, y + dy);
    var closestIntersect = GetLineToPolygon(segment, polygons);
    if (closestIntersect) {
      intersects.push(new Vector4(closestIntersect.x, closestIntersect.y, angle, closestIntersect.w));
    }
  }
  function SortIntersects(a, b) {
    return a.z - b.z;
  }
  var GetRaysFromPointToPolygon = function(x, y, polygons) {
    if (!Array.isArray(polygons)) {
      polygons = [polygons];
    }
    var intersects = [];
    var angles = [];
    for (var i = 0; i < polygons.length; i++) {
      var points = polygons[i].points;
      for (var p = 0; p < points.length; p++) {
        var angle = Math.atan2(points[p].y - y, points[p].x - x);
        if (angles.indexOf(angle) === -1) {
          CheckIntersects(angle, x, y, polygons, intersects);
          CheckIntersects(angle - 1e-5, x, y, polygons, intersects);
          CheckIntersects(angle + 1e-5, x, y, polygons, intersects);
          angles.push(angle);
        }
      }
    }
    return intersects.sort(SortIntersects);
  };
  module2.exports = GetRaysFromPointToPolygon;
});

// node_modules/phaser/src/geom/intersects/RectangleToRectangle.js
var require_RectangleToRectangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RectangleToRectangle = function(rectA, rectB) {
    if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0) {
      return false;
    }
    return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);
  };
  module2.exports = RectangleToRectangle;
});

// node_modules/phaser/src/geom/intersects/GetRectangleIntersection.js
var require_GetRectangleIntersection = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  var RectangleToRectangle = require_RectangleToRectangle();
  var GetRectangleIntersection = function(rectA, rectB, output) {
    if (output === void 0) {
      output = new Rectangle();
    }
    if (RectangleToRectangle(rectA, rectB)) {
      output.x = Math.max(rectA.x, rectB.x);
      output.y = Math.max(rectA.y, rectB.y);
      output.width = Math.min(rectA.right, rectB.right) - output.x;
      output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;
    }
    return output;
  };
  module2.exports = GetRectangleIntersection;
});

// node_modules/phaser/src/geom/intersects/GetRectangleToRectangle.js
var require_GetRectangleToRectangle = __commonJS((exports2, module2) => {
  /**
   * @author       Florian Vazelle
   * @author       Geoffrey Glaive
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetLineToRectangle = require_GetLineToRectangle();
  var RectangleToRectangle = require_RectangleToRectangle();
  var GetRectangleToRectangle = function(rectA, rectB, out) {
    if (out === void 0) {
      out = [];
    }
    if (RectangleToRectangle(rectA, rectB)) {
      var lineA = rectA.getLineA();
      var lineB = rectA.getLineB();
      var lineC = rectA.getLineC();
      var lineD = rectA.getLineD();
      GetLineToRectangle(lineA, rectB, out);
      GetLineToRectangle(lineB, rectB, out);
      GetLineToRectangle(lineC, rectB, out);
      GetLineToRectangle(lineD, rectB, out);
    }
    return out;
  };
  module2.exports = GetRectangleToRectangle;
});

// node_modules/phaser/src/geom/triangle/ContainsArray.js
var require_ContainsArray = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ContainsArray = function(triangle, points, returnFirst, out) {
    if (returnFirst === void 0) {
      returnFirst = false;
    }
    if (out === void 0) {
      out = [];
    }
    var v0x = triangle.x3 - triangle.x1;
    var v0y = triangle.y3 - triangle.y1;
    var v1x = triangle.x2 - triangle.x1;
    var v1y = triangle.y2 - triangle.y1;
    var dot00 = v0x * v0x + v0y * v0y;
    var dot01 = v0x * v1x + v0y * v1y;
    var dot11 = v1x * v1x + v1y * v1y;
    var b = dot00 * dot11 - dot01 * dot01;
    var inv = b === 0 ? 0 : 1 / b;
    var u;
    var v;
    var v2x;
    var v2y;
    var dot02;
    var dot12;
    var x1 = triangle.x1;
    var y1 = triangle.y1;
    for (var i = 0; i < points.length; i++) {
      v2x = points[i].x - x1;
      v2y = points[i].y - y1;
      dot02 = v0x * v2x + v0y * v2y;
      dot12 = v1x * v2x + v1y * v2y;
      u = (dot11 * dot02 - dot01 * dot12) * inv;
      v = (dot00 * dot12 - dot01 * dot02) * inv;
      if (u >= 0 && v >= 0 && u + v < 1) {
        out.push({x: points[i].x, y: points[i].y});
        if (returnFirst) {
          break;
        }
      }
    }
    return out;
  };
  module2.exports = ContainsArray;
});

// node_modules/phaser/src/geom/rectangle/Decompose.js
var require_Decompose = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Decompose = function(rect, out) {
    if (out === void 0) {
      out = [];
    }
    out.push({x: rect.x, y: rect.y});
    out.push({x: rect.right, y: rect.y});
    out.push({x: rect.right, y: rect.bottom});
    out.push({x: rect.x, y: rect.bottom});
    return out;
  };
  module2.exports = Decompose;
});

// node_modules/phaser/src/geom/intersects/RectangleToTriangle.js
var require_RectangleToTriangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var LineToLine = require_LineToLine();
  var Contains = require_Contains2();
  var ContainsArray = require_ContainsArray();
  var Decompose = require_Decompose();
  var RectangleToTriangle = function(rect, triangle) {
    if (triangle.left > rect.right || triangle.right < rect.left || triangle.top > rect.bottom || triangle.bottom < rect.top) {
      return false;
    }
    var triA = triangle.getLineA();
    var triB = triangle.getLineB();
    var triC = triangle.getLineC();
    if (Contains(rect, triA.x1, triA.y1) || Contains(rect, triA.x2, triA.y2)) {
      return true;
    }
    if (Contains(rect, triB.x1, triB.y1) || Contains(rect, triB.x2, triB.y2)) {
      return true;
    }
    if (Contains(rect, triC.x1, triC.y1) || Contains(rect, triC.x2, triC.y2)) {
      return true;
    }
    var rectA = rect.getLineA();
    var rectB = rect.getLineB();
    var rectC = rect.getLineC();
    var rectD = rect.getLineD();
    if (LineToLine(triA, rectA) || LineToLine(triA, rectB) || LineToLine(triA, rectC) || LineToLine(triA, rectD)) {
      return true;
    }
    if (LineToLine(triB, rectA) || LineToLine(triB, rectB) || LineToLine(triB, rectC) || LineToLine(triB, rectD)) {
      return true;
    }
    if (LineToLine(triC, rectA) || LineToLine(triC, rectB) || LineToLine(triC, rectC) || LineToLine(triC, rectD)) {
      return true;
    }
    var points = Decompose(rect);
    var within = ContainsArray(triangle, points, true);
    return within.length > 0;
  };
  module2.exports = RectangleToTriangle;
});

// node_modules/phaser/src/geom/intersects/GetRectangleToTriangle.js
var require_GetRectangleToTriangle = __commonJS((exports2, module2) => {
  /**
   * @author       Florian Vazelle
   * @author       Geoffrey Glaive
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RectangleToTriangle = require_RectangleToTriangle();
  var GetLineToRectangle = require_GetLineToRectangle();
  var GetRectangleToTriangle = function(rect, triangle, out) {
    if (out === void 0) {
      out = [];
    }
    if (RectangleToTriangle(rect, triangle)) {
      var lineA = triangle.getLineA();
      var lineB = triangle.getLineB();
      var lineC = triangle.getLineC();
      GetLineToRectangle(lineA, rect, out);
      GetLineToRectangle(lineB, rect, out);
      GetLineToRectangle(lineC, rect, out);
    }
    return out;
  };
  module2.exports = GetRectangleToTriangle;
});

// node_modules/phaser/src/geom/intersects/TriangleToCircle.js
var require_TriangleToCircle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var LineToCircle = require_LineToCircle();
  var Contains = require_Contains5();
  var TriangleToCircle = function(triangle, circle) {
    if (triangle.left > circle.right || triangle.right < circle.left || triangle.top > circle.bottom || triangle.bottom < circle.top) {
      return false;
    }
    if (Contains(triangle, circle.x, circle.y)) {
      return true;
    }
    if (LineToCircle(triangle.getLineA(), circle)) {
      return true;
    }
    if (LineToCircle(triangle.getLineB(), circle)) {
      return true;
    }
    if (LineToCircle(triangle.getLineC(), circle)) {
      return true;
    }
    return false;
  };
  module2.exports = TriangleToCircle;
});

// node_modules/phaser/src/geom/intersects/GetTriangleToCircle.js
var require_GetTriangleToCircle = __commonJS((exports2, module2) => {
  /**
   * @author       Florian Vazelle
   * @author       Geoffrey Glaive
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetLineToCircle = require_GetLineToCircle();
  var TriangleToCircle = require_TriangleToCircle();
  var GetTriangleToCircle = function(triangle, circle, out) {
    if (out === void 0) {
      out = [];
    }
    if (TriangleToCircle(triangle, circle)) {
      var lineA = triangle.getLineA();
      var lineB = triangle.getLineB();
      var lineC = triangle.getLineC();
      GetLineToCircle(lineA, circle, out);
      GetLineToCircle(lineB, circle, out);
      GetLineToCircle(lineC, circle, out);
    }
    return out;
  };
  module2.exports = GetTriangleToCircle;
});

// node_modules/phaser/src/geom/intersects/TriangleToLine.js
var require_TriangleToLine = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var LineToLine = require_LineToLine();
  var TriangleToLine = function(triangle, line) {
    if (triangle.contains(line.x1, line.y1) || triangle.contains(line.x2, line.y2)) {
      return true;
    }
    if (LineToLine(triangle.getLineA(), line)) {
      return true;
    }
    if (LineToLine(triangle.getLineB(), line)) {
      return true;
    }
    if (LineToLine(triangle.getLineC(), line)) {
      return true;
    }
    return false;
  };
  module2.exports = TriangleToLine;
});

// node_modules/phaser/src/geom/intersects/GetTriangleToLine.js
var require_GetTriangleToLine = __commonJS((exports2, module2) => {
  /**
   * @author       Florian Vazelle
   * @author       Geoffrey Glaive
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var TriangleToLine = require_TriangleToLine();
  var LineToLine = require_LineToLine();
  var GetTriangleToLine = function(triangle, line, out) {
    if (out === void 0) {
      out = [];
    }
    if (TriangleToLine(triangle, line)) {
      var lineA = triangle.getLineA();
      var lineB = triangle.getLineB();
      var lineC = triangle.getLineC();
      var output = [new Point(), new Point(), new Point()];
      var result = [
        LineToLine(lineA, line, output[0]),
        LineToLine(lineB, line, output[1]),
        LineToLine(lineC, line, output[2])
      ];
      for (var i = 0; i < 3; i++) {
        if (result[i]) {
          out.push(output[i]);
        }
      }
    }
    return out;
  };
  module2.exports = GetTriangleToLine;
});

// node_modules/phaser/src/geom/triangle/Decompose.js
var require_Decompose2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Decompose = function(triangle, out) {
    if (out === void 0) {
      out = [];
    }
    out.push({x: triangle.x1, y: triangle.y1});
    out.push({x: triangle.x2, y: triangle.y2});
    out.push({x: triangle.x3, y: triangle.y3});
    return out;
  };
  module2.exports = Decompose;
});

// node_modules/phaser/src/geom/intersects/TriangleToTriangle.js
var require_TriangleToTriangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ContainsArray = require_ContainsArray();
  var Decompose = require_Decompose2();
  var LineToLine = require_LineToLine();
  var TriangleToTriangle = function(triangleA, triangleB) {
    if (triangleA.left > triangleB.right || triangleA.right < triangleB.left || triangleA.top > triangleB.bottom || triangleA.bottom < triangleB.top) {
      return false;
    }
    var lineAA = triangleA.getLineA();
    var lineAB = triangleA.getLineB();
    var lineAC = triangleA.getLineC();
    var lineBA = triangleB.getLineA();
    var lineBB = triangleB.getLineB();
    var lineBC = triangleB.getLineC();
    if (LineToLine(lineAA, lineBA) || LineToLine(lineAA, lineBB) || LineToLine(lineAA, lineBC)) {
      return true;
    }
    if (LineToLine(lineAB, lineBA) || LineToLine(lineAB, lineBB) || LineToLine(lineAB, lineBC)) {
      return true;
    }
    if (LineToLine(lineAC, lineBA) || LineToLine(lineAC, lineBB) || LineToLine(lineAC, lineBC)) {
      return true;
    }
    var points = Decompose(triangleA);
    var within = ContainsArray(triangleB, points, true);
    if (within.length > 0) {
      return true;
    }
    points = Decompose(triangleB);
    within = ContainsArray(triangleA, points, true);
    if (within.length > 0) {
      return true;
    }
    return false;
  };
  module2.exports = TriangleToTriangle;
});

// node_modules/phaser/src/geom/intersects/GetTriangleToTriangle.js
var require_GetTriangleToTriangle = __commonJS((exports2, module2) => {
  /**
   * @author       Florian Vazelle
   * @author       Geoffrey Glaive
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TriangleToTriangle = require_TriangleToTriangle();
  var GetTriangleToLine = require_GetTriangleToLine();
  var GetTriangleToTriangle = function(triangleA, triangleB, out) {
    if (out === void 0) {
      out = [];
    }
    if (TriangleToTriangle(triangleA, triangleB)) {
      var lineA = triangleB.getLineA();
      var lineB = triangleB.getLineB();
      var lineC = triangleB.getLineC();
      GetTriangleToLine(triangleA, lineA, out);
      GetTriangleToLine(triangleA, lineB, out);
      GetTriangleToLine(triangleA, lineC, out);
    }
    return out;
  };
  module2.exports = GetTriangleToTriangle;
});

// node_modules/phaser/src/geom/intersects/PointToLine.js
var require_PointToLine = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Florian Mertens
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PointToLine = function(point, line, lineThickness) {
    if (lineThickness === void 0) {
      lineThickness = 1;
    }
    var x1 = line.x1;
    var y1 = line.y1;
    var x2 = line.x2;
    var y2 = line.y2;
    var px = point.x;
    var py = point.y;
    var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (L2 === 0) {
      return false;
    }
    var r = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / L2;
    if (r < 0) {
      return Math.sqrt((x1 - px) * (x1 - px) + (y1 - py) * (y1 - py)) <= lineThickness;
    } else if (r >= 0 && r <= 1) {
      var s = ((y1 - py) * (x2 - x1) - (x1 - px) * (y2 - y1)) / L2;
      return Math.abs(s) * Math.sqrt(L2) <= lineThickness;
    } else {
      return Math.sqrt((x2 - px) * (x2 - px) + (y2 - py) * (y2 - py)) <= lineThickness;
    }
  };
  module2.exports = PointToLine;
});

// node_modules/phaser/src/geom/intersects/PointToLineSegment.js
var require_PointToLineSegment = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PointToLine = require_PointToLine();
  var PointToLineSegment = function(point, line) {
    if (!PointToLine(point, line)) {
      return false;
    }
    var xMin = Math.min(line.x1, line.x2);
    var xMax = Math.max(line.x1, line.x2);
    var yMin = Math.min(line.y1, line.y2);
    var yMax = Math.max(line.y1, line.y2);
    return point.x >= xMin && point.x <= xMax && (point.y >= yMin && point.y <= yMax);
  };
  module2.exports = PointToLineSegment;
});

// node_modules/phaser/src/geom/intersects/RectangleToValues.js
var require_RectangleToValues = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RectangleToValues = function(rect, left, right, top, bottom, tolerance) {
    if (tolerance === void 0) {
      tolerance = 0;
    }
    return !(left > rect.right + tolerance || right < rect.left - tolerance || top > rect.bottom + tolerance || bottom < rect.top - tolerance);
  };
  module2.exports = RectangleToValues;
});

// node_modules/phaser/src/geom/intersects/index.js
var require_intersects = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    CircleToCircle: require_CircleToCircle(),
    CircleToRectangle: require_CircleToRectangle(),
    GetCircleToCircle: require_GetCircleToCircle(),
    GetCircleToRectangle: require_GetCircleToRectangle(),
    GetLineToCircle: require_GetLineToCircle(),
    GetLineToLine: require_GetLineToLine(),
    GetLineToPoints: require_GetLineToPoints(),
    GetLineToPolygon: require_GetLineToPolygon(),
    GetLineToRectangle: require_GetLineToRectangle(),
    GetRaysFromPointToPolygon: require_GetRaysFromPointToPolygon(),
    GetRectangleIntersection: require_GetRectangleIntersection(),
    GetRectangleToRectangle: require_GetRectangleToRectangle(),
    GetRectangleToTriangle: require_GetRectangleToTriangle(),
    GetTriangleToCircle: require_GetTriangleToCircle(),
    GetTriangleToLine: require_GetTriangleToLine(),
    GetTriangleToTriangle: require_GetTriangleToTriangle(),
    LineToCircle: require_LineToCircle(),
    LineToLine: require_LineToLine(),
    LineToRectangle: require_LineToRectangle(),
    PointToLine: require_PointToLine(),
    PointToLineSegment: require_PointToLineSegment(),
    RectangleToRectangle: require_RectangleToRectangle(),
    RectangleToTriangle: require_RectangleToTriangle(),
    RectangleToValues: require_RectangleToValues(),
    TriangleToCircle: require_TriangleToCircle(),
    TriangleToLine: require_TriangleToLine(),
    TriangleToTriangle: require_TriangleToTriangle()
  };
});

// node_modules/phaser/src/geom/line/Angle.js
var require_Angle2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Angle = function(line) {
    return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
  };
  module2.exports = Angle;
});

// node_modules/phaser/src/geom/line/CenterOn.js
var require_CenterOn3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CenterOn = function(line, x, y) {
    var tx = x - (line.x1 + line.x2) / 2;
    var ty = y - (line.y1 + line.y2) / 2;
    line.x1 += tx;
    line.y1 += ty;
    line.x2 += tx;
    line.y2 += ty;
    return line;
  };
  module2.exports = CenterOn;
});

// node_modules/phaser/src/geom/line/Clone.js
var require_Clone4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Line = require_Line();
  var Clone = function(source) {
    return new Line(source.x1, source.y1, source.x2, source.y2);
  };
  module2.exports = Clone;
});

// node_modules/phaser/src/geom/line/CopyFrom.js
var require_CopyFrom3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CopyFrom = function(source, dest) {
    return dest.setTo(source.x1, source.y1, source.x2, source.y2);
  };
  module2.exports = CopyFrom;
});

// node_modules/phaser/src/geom/line/Equals.js
var require_Equals3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Equals = function(line, toCompare) {
    return line.x1 === toCompare.x1 && line.y1 === toCompare.y1 && line.x2 === toCompare.x2 && line.y2 === toCompare.y2;
  };
  module2.exports = Equals;
});

// node_modules/phaser/src/geom/line/Extend.js
var require_Extend2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Length = require_Length();
  var Extend = function(line, left, right) {
    if (right === void 0) {
      right = left;
    }
    var length = Length(line);
    var slopX = line.x2 - line.x1;
    var slopY = line.y2 - line.y1;
    if (left) {
      line.x1 = line.x1 - slopX / length * left;
      line.y1 = line.y1 - slopY / length * left;
    }
    if (right) {
      line.x2 = line.x2 + slopX / length * right;
      line.y2 = line.y2 + slopY / length * right;
    }
    return line;
  };
  module2.exports = Extend;
});

// node_modules/phaser/src/geom/line/GetEasedPoints.js
var require_GetEasedPoints = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DistanceBetweenPoints = require_DistanceBetweenPoints();
  var GetEaseFunction = require_GetEaseFunction();
  var Point = require_Point();
  var GetEasedPoints = function(line, ease, quantity, collinearThreshold, easeParams) {
    if (collinearThreshold === void 0) {
      collinearThreshold = 0;
    }
    if (easeParams === void 0) {
      easeParams = [];
    }
    var results = [];
    var x1 = line.x1;
    var y1 = line.y1;
    var spaceX = line.x2 - x1;
    var spaceY = line.y2 - y1;
    var easeFunc = GetEaseFunction(ease, easeParams);
    var i;
    var v;
    var q = quantity - 1;
    for (i = 0; i < q; i++) {
      v = easeFunc(i / q);
      results.push(new Point(x1 + spaceX * v, y1 + spaceY * v));
    }
    v = easeFunc(1);
    results.push(new Point(x1 + spaceX * v, y1 + spaceY * v));
    if (collinearThreshold > 0) {
      var prevPoint = results[0];
      var sortedResults = [prevPoint];
      for (i = 1; i < results.length - 1; i++) {
        var point = results[i];
        if (DistanceBetweenPoints(prevPoint, point) >= collinearThreshold) {
          sortedResults.push(point);
          prevPoint = point;
        }
      }
      var endPoint = results[results.length - 1];
      if (DistanceBetweenPoints(prevPoint, endPoint) < collinearThreshold) {
        sortedResults.pop();
      }
      sortedResults.push(endPoint);
      return sortedResults;
    } else {
      return results;
    }
  };
  module2.exports = GetEasedPoints;
});

// node_modules/phaser/src/geom/line/GetMidPoint.js
var require_GetMidPoint = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var GetMidPoint = function(line, out) {
    if (out === void 0) {
      out = new Point();
    }
    out.x = (line.x1 + line.x2) / 2;
    out.y = (line.y1 + line.y2) / 2;
    return out;
  };
  module2.exports = GetMidPoint;
});

// node_modules/phaser/src/geom/line/GetNearestPoint.js
var require_GetNearestPoint = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Florian Mertens
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var GetNearestPoint = function(line, point, out) {
    if (out === void 0) {
      out = new Point();
    }
    var x1 = line.x1;
    var y1 = line.y1;
    var x2 = line.x2;
    var y2 = line.y2;
    var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (L2 === 0) {
      return out;
    }
    var r = ((point.x - x1) * (x2 - x1) + (point.y - y1) * (y2 - y1)) / L2;
    out.x = x1 + r * (x2 - x1);
    out.y = y1 + r * (y2 - y1);
    return out;
  };
  module2.exports = GetNearestPoint;
});

// node_modules/phaser/src/geom/line/GetNormal.js
var require_GetNormal = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MATH_CONST = require_const4();
  var Angle = require_Angle2();
  var Point = require_Point();
  var GetNormal = function(line, out) {
    if (out === void 0) {
      out = new Point();
    }
    var a = Angle(line) - MATH_CONST.TAU;
    out.x = Math.cos(a);
    out.y = Math.sin(a);
    return out;
  };
  module2.exports = GetNormal;
});

// node_modules/phaser/src/geom/line/GetShortestDistance.js
var require_GetShortestDistance = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Florian Mertens
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetShortestDistance = function(line, point) {
    var x1 = line.x1;
    var y1 = line.y1;
    var x2 = line.x2;
    var y2 = line.y2;
    var L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (L2 === 0) {
      return false;
    }
    var s = ((y1 - point.y) * (x2 - x1) - (x1 - point.x) * (y2 - y1)) / L2;
    return Math.abs(s) * Math.sqrt(L2);
  };
  module2.exports = GetShortestDistance;
});

// node_modules/phaser/src/geom/line/Height.js
var require_Height = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Height = function(line) {
    return Math.abs(line.y1 - line.y2);
  };
  module2.exports = Height;
});

// node_modules/phaser/src/geom/line/NormalAngle.js
var require_NormalAngle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MATH_CONST = require_const4();
  var Wrap = require_Wrap();
  var Angle = require_Angle2();
  var NormalAngle = function(line) {
    var angle = Angle(line) - MATH_CONST.TAU;
    return Wrap(angle, -Math.PI, Math.PI);
  };
  module2.exports = NormalAngle;
});

// node_modules/phaser/src/geom/line/NormalX.js
var require_NormalX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MATH_CONST = require_const4();
  var Angle = require_Angle2();
  var NormalX = function(line) {
    return Math.cos(Angle(line) - MATH_CONST.TAU);
  };
  module2.exports = NormalX;
});

// node_modules/phaser/src/geom/line/NormalY.js
var require_NormalY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MATH_CONST = require_const4();
  var Angle = require_Angle2();
  var NormalY = function(line) {
    return Math.sin(Angle(line) - MATH_CONST.TAU);
  };
  module2.exports = NormalY;
});

// node_modules/phaser/src/geom/line/Offset.js
var require_Offset3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Offset = function(line, x, y) {
    line.x1 += x;
    line.y1 += y;
    line.x2 += x;
    line.y2 += y;
    return line;
  };
  module2.exports = Offset;
});

// node_modules/phaser/src/geom/line/PerpSlope.js
var require_PerpSlope = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PerpSlope = function(line) {
    return -((line.x2 - line.x1) / (line.y2 - line.y1));
  };
  module2.exports = PerpSlope;
});

// node_modules/phaser/src/geom/line/ReflectAngle.js
var require_ReflectAngle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Angle = require_Angle2();
  var NormalAngle = require_NormalAngle();
  var ReflectAngle = function(lineA, lineB) {
    return 2 * NormalAngle(lineB) - Math.PI - Angle(lineA);
  };
  module2.exports = ReflectAngle;
});

// node_modules/phaser/src/geom/line/RotateAroundXY.js
var require_RotateAroundXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateAroundXY = function(line, x, y, angle) {
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var tx = line.x1 - x;
    var ty = line.y1 - y;
    line.x1 = tx * c - ty * s + x;
    line.y1 = tx * s + ty * c + y;
    tx = line.x2 - x;
    ty = line.y2 - y;
    line.x2 = tx * c - ty * s + x;
    line.y2 = tx * s + ty * c + y;
    return line;
  };
  module2.exports = RotateAroundXY;
});

// node_modules/phaser/src/geom/line/Rotate.js
var require_Rotate3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateAroundXY = require_RotateAroundXY();
  var Rotate = function(line, angle) {
    var x = (line.x1 + line.x2) / 2;
    var y = (line.y1 + line.y2) / 2;
    return RotateAroundXY(line, x, y, angle);
  };
  module2.exports = Rotate;
});

// node_modules/phaser/src/geom/line/RotateAroundPoint.js
var require_RotateAroundPoint = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateAroundXY = require_RotateAroundXY();
  var RotateAroundPoint = function(line, point, angle) {
    return RotateAroundXY(line, point.x, point.y, angle);
  };
  module2.exports = RotateAroundPoint;
});

// node_modules/phaser/src/geom/line/SetToAngle.js
var require_SetToAngle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetToAngle = function(line, x, y, angle, length) {
    line.x1 = x;
    line.y1 = y;
    line.x2 = x + Math.cos(angle) * length;
    line.y2 = y + Math.sin(angle) * length;
    return line;
  };
  module2.exports = SetToAngle;
});

// node_modules/phaser/src/geom/line/Slope.js
var require_Slope = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Slope = function(line) {
    return (line.y2 - line.y1) / (line.x2 - line.x1);
  };
  module2.exports = Slope;
});

// node_modules/phaser/src/geom/line/Width.js
var require_Width = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Width = function(line) {
    return Math.abs(line.x1 - line.x2);
  };
  module2.exports = Width;
});

// node_modules/phaser/src/geom/line/index.js
var require_line = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Line = require_Line();
  Line.Angle = require_Angle2();
  Line.BresenhamPoints = require_BresenhamPoints();
  Line.CenterOn = require_CenterOn3();
  Line.Clone = require_Clone4();
  Line.CopyFrom = require_CopyFrom3();
  Line.Equals = require_Equals3();
  Line.Extend = require_Extend2();
  Line.GetEasedPoints = require_GetEasedPoints();
  Line.GetMidPoint = require_GetMidPoint();
  Line.GetNearestPoint = require_GetNearestPoint();
  Line.GetNormal = require_GetNormal();
  Line.GetPoint = require_GetPoint3();
  Line.GetPoints = require_GetPoints3();
  Line.GetShortestDistance = require_GetShortestDistance();
  Line.Height = require_Height();
  Line.Length = require_Length();
  Line.NormalAngle = require_NormalAngle();
  Line.NormalX = require_NormalX();
  Line.NormalY = require_NormalY();
  Line.Offset = require_Offset3();
  Line.PerpSlope = require_PerpSlope();
  Line.Random = require_Random2();
  Line.ReflectAngle = require_ReflectAngle();
  Line.Rotate = require_Rotate3();
  Line.RotateAroundPoint = require_RotateAroundPoint();
  Line.RotateAroundXY = require_RotateAroundXY();
  Line.SetToAngle = require_SetToAngle();
  Line.Slope = require_Slope();
  Line.Width = require_Width();
  module2.exports = Line;
});

// node_modules/phaser/src/geom/mesh/GenerateGridVerts.js
var require_GenerateGridVerts = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Face = require_Face();
  var GetFastValue = require_GetFastValue();
  var Matrix4 = require_Matrix4();
  var Vector3 = require_Vector3();
  var Vertex = require_Vertex();
  var tempPosition = new Vector3();
  var tempRotation = new Vector3();
  var tempMatrix = new Matrix4();
  var GenerateGridVerts = function(config2) {
    var mesh = GetFastValue(config2, "mesh");
    var texture = GetFastValue(config2, "texture", null);
    var frame = GetFastValue(config2, "frame");
    var width = GetFastValue(config2, "width", 1);
    var height = GetFastValue(config2, "height", width);
    var widthSegments = GetFastValue(config2, "widthSegments", 1);
    var heightSegments = GetFastValue(config2, "heightSegments", widthSegments);
    var posX = GetFastValue(config2, "x", 0);
    var posY = GetFastValue(config2, "y", 0);
    var posZ = GetFastValue(config2, "z", 0);
    var rotateX = GetFastValue(config2, "rotateX", 0);
    var rotateY = GetFastValue(config2, "rotateY", 0);
    var rotateZ = GetFastValue(config2, "rotateZ", 0);
    var zIsUp = GetFastValue(config2, "zIsUp", true);
    var isOrtho = GetFastValue(config2, "isOrtho", mesh ? mesh.dirtyCache[11] : false);
    var colors = GetFastValue(config2, "colors", [16777215]);
    var alphas = GetFastValue(config2, "alphas", [1]);
    var tile = GetFastValue(config2, "tile", false);
    var flipY = GetFastValue(config2, "flipY", false);
    var widthSet = GetFastValue(config2, "width", null);
    var result = {
      faces: [],
      verts: []
    };
    tempPosition.set(posX, posY, posZ);
    tempRotation.set(rotateX, rotateY, rotateZ);
    tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);
    if (!texture && mesh) {
      texture = mesh.texture;
    } else if (mesh && typeof texture === "string") {
      texture = mesh.scene.sys.textures.get(texture);
    } else {
      return result;
    }
    var textureFrame = texture.get(frame);
    if (!widthSet && isOrtho && texture && mesh) {
      width = textureFrame.width / mesh.height;
      height = textureFrame.height / mesh.height;
    }
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var gridX = Math.floor(widthSegments);
    var gridY = Math.floor(heightSegments);
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var segmentWidth = width / gridX;
    var segmentHeight = height / gridY;
    var uvs = [];
    var vertices = [];
    var ix;
    var iy;
    var frameU0 = 0;
    var frameU1 = 1;
    var frameV0 = 0;
    var frameV1 = 1;
    if (textureFrame) {
      frameU0 = textureFrame.u0;
      frameU1 = textureFrame.u1;
      if (!flipY) {
        frameV0 = textureFrame.v0;
        frameV1 = textureFrame.v1;
      } else {
        frameV0 = textureFrame.v1;
        frameV1 = textureFrame.v0;
      }
    }
    var frameU = frameU1 - frameU0;
    var frameV = frameV1 - frameV0;
    for (iy = 0; iy < gridY1; iy++) {
      var y = iy * segmentHeight - halfHeight;
      for (ix = 0; ix < gridX1; ix++) {
        var x = ix * segmentWidth - halfWidth;
        vertices.push(x, -y);
        var tu = frameU0 + frameU * (ix / gridX);
        var tv = frameV0 + frameV * (iy / gridY);
        uvs.push(tu, tv);
      }
    }
    if (!Array.isArray(colors)) {
      colors = [colors];
    }
    if (!Array.isArray(alphas)) {
      alphas = [alphas];
    }
    var alphaIndex = 0;
    var colorIndex = 0;
    for (iy = 0; iy < gridY; iy++) {
      for (ix = 0; ix < gridX; ix++) {
        var a = (ix + gridX1 * iy) * 2;
        var b = (ix + gridX1 * (iy + 1)) * 2;
        var c = (ix + 1 + gridX1 * (iy + 1)) * 2;
        var d = (ix + 1 + gridX1 * iy) * 2;
        var color = colors[colorIndex];
        var alpha = alphas[alphaIndex];
        var vert1 = new Vertex(vertices[a], vertices[a + 1], 0, uvs[a], uvs[a + 1], color, alpha).transformMat4(tempMatrix);
        var vert2 = new Vertex(vertices[b], vertices[b + 1], 0, uvs[b], uvs[b + 1], color, alpha).transformMat4(tempMatrix);
        var vert3 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);
        var vert4 = new Vertex(vertices[b], vertices[b + 1], 0, uvs[b], uvs[b + 1], color, alpha).transformMat4(tempMatrix);
        var vert5 = new Vertex(vertices[c], vertices[c + 1], 0, uvs[c], uvs[c + 1], color, alpha).transformMat4(tempMatrix);
        var vert6 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);
        if (tile) {
          vert1.setUVs(frameU0, frameV1);
          vert2.setUVs(frameU0, frameV0);
          vert3.setUVs(frameU1, frameV1);
          vert4.setUVs(frameU0, frameV0);
          vert5.setUVs(frameU1, frameV0);
          vert6.setUVs(frameU1, frameV1);
        }
        colorIndex++;
        if (colorIndex === colors.length) {
          colorIndex = 0;
        }
        alphaIndex++;
        if (alphaIndex === alphas.length) {
          alphaIndex = 0;
        }
        result.verts.push(vert1, vert2, vert3, vert4, vert5, vert6);
        result.faces.push(new Face(vert1, vert2, vert3), new Face(vert4, vert5, vert6));
      }
    }
    if (mesh) {
      mesh.faces = mesh.faces.concat(result.faces);
      mesh.vertices = mesh.vertices.concat(result.verts);
    }
    return result;
  };
  module2.exports = GenerateGridVerts;
});

// node_modules/phaser/src/geom/mesh/ParseObj.js
var require_ParseObj = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var flip = true;
  var defaultModelName = "untitled";
  var currentGroup = "";
  var currentMaterial = "";
  function stripComments(line) {
    var idx = line.indexOf("#");
    return idx > -1 ? line.substring(0, idx) : line;
  }
  function currentModel(result) {
    if (result.models.length === 0) {
      result.models.push({
        faces: [],
        name: defaultModelName,
        textureCoords: [],
        vertexNormals: [],
        vertices: []
      });
    }
    currentGroup = "";
    return result.models[result.models.length - 1];
  }
  function parseObject(lineItems, result) {
    var modelName = lineItems.length >= 2 ? lineItems[1] : defaultModelName;
    result.models.push({
      faces: [],
      name: modelName,
      textureCoords: [],
      vertexNormals: [],
      vertices: []
    });
    currentGroup = "";
  }
  function parseGroup(lineItems) {
    if (lineItems.length === 2) {
      currentGroup = lineItems[1];
    }
  }
  function parseVertexCoords(lineItems, result) {
    var len = lineItems.length;
    var x = len >= 2 ? parseFloat(lineItems[1]) : 0;
    var y = len >= 3 ? parseFloat(lineItems[2]) : 0;
    var z = len >= 4 ? parseFloat(lineItems[3]) : 0;
    currentModel(result).vertices.push({x, y, z});
  }
  function parseTextureCoords(lineItems, result) {
    var len = lineItems.length;
    var u = len >= 2 ? parseFloat(lineItems[1]) : 0;
    var v = len >= 3 ? parseFloat(lineItems[2]) : 0;
    var w = len >= 4 ? parseFloat(lineItems[3]) : 0;
    if (isNaN(u)) {
      u = 0;
    }
    if (isNaN(v)) {
      v = 0;
    }
    if (isNaN(w)) {
      w = 0;
    }
    if (flip) {
      v = 1 - v;
    }
    currentModel(result).textureCoords.push({u, v, w});
  }
  function parseVertexNormal(lineItems, result) {
    var len = lineItems.length;
    var x = len >= 2 ? parseFloat(lineItems[1]) : 0;
    var y = len >= 3 ? parseFloat(lineItems[2]) : 0;
    var z = len >= 4 ? parseFloat(lineItems[3]) : 0;
    currentModel(result).vertexNormals.push({x, y, z});
  }
  function parsePolygon(lineItems, result) {
    var totalVertices = lineItems.length - 1;
    if (totalVertices < 3) {
      return;
    }
    var face = {
      group: currentGroup,
      material: currentMaterial,
      vertices: []
    };
    for (var i = 0; i < totalVertices; i++) {
      var vertexString = lineItems[i + 1];
      var vertexValues = vertexString.split("/");
      var vvLen = vertexValues.length;
      if (vvLen < 1 || vvLen > 3) {
        continue;
      }
      var vertexIndex = 0;
      var textureCoordsIndex = 0;
      var vertexNormalIndex = 0;
      vertexIndex = parseInt(vertexValues[0], 10);
      if (vvLen > 1 && vertexValues[1] !== "") {
        textureCoordsIndex = parseInt(vertexValues[1], 10);
      }
      if (vvLen > 2) {
        vertexNormalIndex = parseInt(vertexValues[2], 10);
      }
      if (vertexIndex !== 0) {
        if (vertexIndex < 0) {
          vertexIndex = currentModel(result).vertices.length + 1 + vertexIndex;
        }
        textureCoordsIndex -= 1;
        vertexIndex -= 1;
        vertexNormalIndex -= 1;
        face.vertices.push({
          textureCoordsIndex,
          vertexIndex,
          vertexNormalIndex
        });
      }
    }
    currentModel(result).faces.push(face);
  }
  function parseMtlLib(lineItems, result) {
    if (lineItems.length >= 2) {
      result.materialLibraries.push(lineItems[1]);
    }
  }
  function parseUseMtl(lineItems) {
    if (lineItems.length >= 2) {
      currentMaterial = lineItems[1];
    }
  }
  var ParseObj = function(data, flipUV) {
    if (flipUV === void 0) {
      flipUV = true;
    }
    flip = flipUV;
    var result = {
      materials: {},
      materialLibraries: [],
      models: []
    };
    currentGroup = "";
    currentMaterial = "";
    var lines = data.split("\n");
    for (var i = 0; i < lines.length; i++) {
      var line = stripComments(lines[i]);
      var lineItems = line.replace(/\s\s+/g, " ").trim().split(" ");
      switch (lineItems[0].toLowerCase()) {
        case "o":
          parseObject(lineItems, result);
          break;
        case "g":
          parseGroup(lineItems);
          break;
        case "v":
          parseVertexCoords(lineItems, result);
          break;
        case "vt":
          parseTextureCoords(lineItems, result);
          break;
        case "vn":
          parseVertexNormal(lineItems, result);
          break;
        case "f":
          parsePolygon(lineItems, result);
          break;
        case "mtllib":
          parseMtlLib(lineItems, result);
          break;
        case "usemtl":
          parseUseMtl(lineItems);
          break;
      }
    }
    return result;
  };
  module2.exports = ParseObj;
});

// node_modules/phaser/src/geom/mesh/ParseObjMaterial.js
var require_ParseObjMaterial = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetColor = require_GetColor();
  var ParseObjMaterial = function(mtl) {
    var output = {};
    var lines = mtl.split("\n");
    var currentMaterial = "";
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i].trim();
      if (line.indexOf("#") === 0 || line === "") {
        continue;
      }
      var lineItems = line.replace(/\s\s+/g, " ").trim().split(" ");
      switch (lineItems[0].toLowerCase()) {
        case "newmtl": {
          currentMaterial = lineItems[1];
          break;
        }
        case "kd": {
          var r = Math.floor(lineItems[1] * 255);
          var g = lineItems.length >= 2 ? Math.floor(lineItems[2] * 255) : r;
          var b = lineItems.length >= 3 ? Math.floor(lineItems[3] * 255) : r;
          output[currentMaterial] = GetColor(r, g, b);
          break;
        }
      }
    }
    return output;
  };
  module2.exports = ParseObjMaterial;
});

// node_modules/phaser/src/geom/mesh/RotateFace.js
var require_RotateFace = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateFace = function(face, angle, cx, cy) {
    var x;
    var y;
    if (cx === void 0 && cy === void 0) {
      var inCenter = face.getInCenter();
      x = inCenter.x;
      y = inCenter.y;
    }
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var v1 = face.vertex1;
    var v2 = face.vertex2;
    var v3 = face.vertex3;
    var tx = v1.x - x;
    var ty = v1.y - y;
    v1.set(tx * c - ty * s + x, tx * s + ty * c + y);
    tx = v2.x - x;
    ty = v2.y - y;
    v2.set(tx * c - ty * s + x, tx * s + ty * c + y);
    tx = v3.x - x;
    ty = v3.y - y;
    v3.set(tx * c - ty * s + x, tx * s + ty * c + y);
  };
  module2.exports = RotateFace;
});

// node_modules/phaser/src/geom/mesh/index.js
var require_mesh = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Mesh = {
    Face: require_Face(),
    GenerateGridVerts: require_GenerateGridVerts(),
    GenerateObjVerts: require_GenerateObjVerts(),
    GenerateVerts: require_GenerateVerts(),
    ParseObj: require_ParseObj(),
    ParseObjMaterial: require_ParseObjMaterial(),
    RotateFace: require_RotateFace(),
    Vertex: require_Vertex()
  };
  module2.exports = Mesh;
});

// node_modules/phaser/src/geom/point/Ceil.js
var require_Ceil2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Ceil = function(point) {
    return point.setTo(Math.ceil(point.x), Math.ceil(point.y));
  };
  module2.exports = Ceil;
});

// node_modules/phaser/src/geom/point/Clone.js
var require_Clone5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var Clone = function(source) {
    return new Point(source.x, source.y);
  };
  module2.exports = Clone;
});

// node_modules/phaser/src/geom/point/CopyFrom.js
var require_CopyFrom4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CopyFrom = function(source, dest) {
    return dest.setTo(source.x, source.y);
  };
  module2.exports = CopyFrom;
});

// node_modules/phaser/src/geom/point/Equals.js
var require_Equals4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Equals = function(point, toCompare) {
    return point.x === toCompare.x && point.y === toCompare.y;
  };
  module2.exports = Equals;
});

// node_modules/phaser/src/geom/point/Floor.js
var require_Floor2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Floor = function(point) {
    return point.setTo(Math.floor(point.x), Math.floor(point.y));
  };
  module2.exports = Floor;
});

// node_modules/phaser/src/geom/point/GetCentroid.js
var require_GetCentroid = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var GetCentroid = function(points, out) {
    if (out === void 0) {
      out = new Point();
    }
    if (!Array.isArray(points)) {
      throw new Error("GetCentroid points argument must be an array");
    }
    var len = points.length;
    if (len < 1) {
      throw new Error("GetCentroid points array must not be empty");
    } else if (len === 1) {
      out.x = points[0].x;
      out.y = points[0].y;
    } else {
      for (var i = 0; i < len; i++) {
        out.x += points[i].x;
        out.y += points[i].y;
      }
      out.x /= len;
      out.y /= len;
    }
    return out;
  };
  module2.exports = GetCentroid;
});

// node_modules/phaser/src/geom/point/GetMagnitude.js
var require_GetMagnitude = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetMagnitude = function(point) {
    return Math.sqrt(point.x * point.x + point.y * point.y);
  };
  module2.exports = GetMagnitude;
});

// node_modules/phaser/src/geom/point/GetMagnitudeSq.js
var require_GetMagnitudeSq = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetMagnitudeSq = function(point) {
    return point.x * point.x + point.y * point.y;
  };
  module2.exports = GetMagnitudeSq;
});

// node_modules/phaser/src/geom/point/GetRectangleFromPoints.js
var require_GetRectangleFromPoints = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  var GetRectangleFromPoints = function(points, out) {
    if (out === void 0) {
      out = new Rectangle();
    }
    var xMax = Number.NEGATIVE_INFINITY;
    var xMin = Number.POSITIVE_INFINITY;
    var yMax = Number.NEGATIVE_INFINITY;
    var yMin = Number.POSITIVE_INFINITY;
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      if (point.x > xMax) {
        xMax = point.x;
      }
      if (point.x < xMin) {
        xMin = point.x;
      }
      if (point.y > yMax) {
        yMax = point.y;
      }
      if (point.y < yMin) {
        yMin = point.y;
      }
    }
    out.x = xMin;
    out.y = yMin;
    out.width = xMax - xMin;
    out.height = yMax - yMin;
    return out;
  };
  module2.exports = GetRectangleFromPoints;
});

// node_modules/phaser/src/geom/point/Interpolate.js
var require_Interpolate2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var Interpolate = function(pointA, pointB, t, out) {
    if (t === void 0) {
      t = 0;
    }
    if (out === void 0) {
      out = new Point();
    }
    out.x = pointA.x + (pointB.x - pointA.x) * t;
    out.y = pointA.y + (pointB.y - pointA.y) * t;
    return out;
  };
  module2.exports = Interpolate;
});

// node_modules/phaser/src/geom/point/Invert.js
var require_Invert = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Invert = function(point) {
    return point.setTo(point.y, point.x);
  };
  module2.exports = Invert;
});

// node_modules/phaser/src/geom/point/Negative.js
var require_Negative = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var Negative = function(point, out) {
    if (out === void 0) {
      out = new Point();
    }
    return out.setTo(-point.x, -point.y);
  };
  module2.exports = Negative;
});

// node_modules/phaser/src/geom/point/Project.js
var require_Project = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var GetMagnitudeSq = require_GetMagnitudeSq();
  var Project = function(pointA, pointB, out) {
    if (out === void 0) {
      out = new Point();
    }
    var dot = pointA.x * pointB.x + pointA.y * pointB.y;
    var amt = dot / GetMagnitudeSq(pointB);
    if (amt !== 0) {
      out.x = amt * pointB.x;
      out.y = amt * pointB.y;
    }
    return out;
  };
  module2.exports = Project;
});

// node_modules/phaser/src/geom/point/ProjectUnit.js
var require_ProjectUnit = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var ProjectUnit = function(pointA, pointB, out) {
    if (out === void 0) {
      out = new Point();
    }
    var amt = pointA.x * pointB.x + pointA.y * pointB.y;
    if (amt !== 0) {
      out.x = amt * pointB.x;
      out.y = amt * pointB.y;
    }
    return out;
  };
  module2.exports = ProjectUnit;
});

// node_modules/phaser/src/geom/point/SetMagnitude.js
var require_SetMagnitude = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetMagnitude = require_GetMagnitude();
  var SetMagnitude = function(point, magnitude) {
    if (point.x !== 0 || point.y !== 0) {
      var m = GetMagnitude(point);
      point.x /= m;
      point.y /= m;
    }
    point.x *= magnitude;
    point.y *= magnitude;
    return point;
  };
  module2.exports = SetMagnitude;
});

// node_modules/phaser/src/geom/point/index.js
var require_point = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  Point.Ceil = require_Ceil2();
  Point.Clone = require_Clone5();
  Point.CopyFrom = require_CopyFrom4();
  Point.Equals = require_Equals4();
  Point.Floor = require_Floor2();
  Point.GetCentroid = require_GetCentroid();
  Point.GetMagnitude = require_GetMagnitude();
  Point.GetMagnitudeSq = require_GetMagnitudeSq();
  Point.GetRectangleFromPoints = require_GetRectangleFromPoints();
  Point.Interpolate = require_Interpolate2();
  Point.Invert = require_Invert();
  Point.Negative = require_Negative();
  Point.Project = require_Project();
  Point.ProjectUnit = require_ProjectUnit();
  Point.SetMagnitude = require_SetMagnitude();
  module2.exports = Point;
});

// node_modules/phaser/src/geom/polygon/Clone.js
var require_Clone6 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Polygon = require_Polygon();
  var Clone = function(polygon) {
    return new Polygon(polygon.points);
  };
  module2.exports = Clone;
});

// node_modules/phaser/src/geom/polygon/ContainsPoint.js
var require_ContainsPoint3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = require_Contains4();
  var ContainsPoint = function(polygon, point) {
    return Contains(polygon, point.x, point.y);
  };
  module2.exports = ContainsPoint;
});

// node_modules/phaser/src/geom/polygon/GetNumberArray.js
var require_GetNumberArray = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetNumberArray = function(polygon, output) {
    if (output === void 0) {
      output = [];
    }
    for (var i = 0; i < polygon.points.length; i++) {
      output.push(polygon.points[i].x);
      output.push(polygon.points[i].y);
    }
    return output;
  };
  module2.exports = GetNumberArray;
});

// node_modules/phaser/src/geom/polygon/Reverse.js
var require_Reverse2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Reverse = function(polygon) {
    polygon.points.reverse();
    return polygon;
  };
  module2.exports = Reverse;
});

// node_modules/phaser/src/geom/polygon/Simplify.js
var require_Simplify = __commonJS((exports2, module2) => {
  function getSqDist(p1, p2) {
    var dx = p1.x - p2.x, dy = p1.y - p2.y;
    return dx * dx + dy * dy;
  }
  function getSqSegDist(p, p1, p2) {
    var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y;
    if (dx !== 0 || dy !== 0) {
      var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
      if (t > 1) {
        x = p2.x;
        y = p2.y;
      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }
    dx = p.x - x;
    dy = p.y - y;
    return dx * dx + dy * dy;
  }
  function simplifyRadialDist(points, sqTolerance) {
    var prevPoint = points[0], newPoints = [prevPoint], point;
    for (var i = 1, len = points.length; i < len; i++) {
      point = points[i];
      if (getSqDist(point, prevPoint) > sqTolerance) {
        newPoints.push(point);
        prevPoint = point;
      }
    }
    if (prevPoint !== point) {
      newPoints.push(point);
    }
    return newPoints;
  }
  function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance, index;
    for (var i = first + 1; i < last; i++) {
      var sqDist = getSqSegDist(points[i], points[first], points[last]);
      if (sqDist > maxSqDist) {
        index = i;
        maxSqDist = sqDist;
      }
    }
    if (maxSqDist > sqTolerance) {
      if (index - first > 1) {
        simplifyDPStep(points, first, index, sqTolerance, simplified);
      }
      simplified.push(points[index]);
      if (last - index > 1) {
        simplifyDPStep(points, index, last, sqTolerance, simplified);
      }
    }
  }
  function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;
    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);
    return simplified;
  }
  var Simplify = function(polygon, tolerance, highestQuality) {
    if (tolerance === void 0) {
      tolerance = 1;
    }
    if (highestQuality === void 0) {
      highestQuality = false;
    }
    var points = polygon.points;
    if (points.length > 2) {
      var sqTolerance = tolerance * tolerance;
      if (!highestQuality) {
        points = simplifyRadialDist(points, sqTolerance);
      }
      polygon.setTo(simplifyDouglasPeucker(points, sqTolerance));
    }
    return polygon;
  };
  module2.exports = Simplify;
});

// node_modules/phaser/src/geom/polygon/Translate.js
var require_Translate = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Translate = function(polygon, x, y) {
    var points = polygon.points;
    for (var i = 0; i < points.length; i++) {
      points[i].x += x;
      points[i].y += y;
    }
    return polygon;
  };
  module2.exports = Translate;
});

// node_modules/phaser/src/geom/polygon/index.js
var require_polygon = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Polygon = require_Polygon();
  Polygon.Clone = require_Clone6();
  Polygon.Contains = require_Contains4();
  Polygon.ContainsPoint = require_ContainsPoint3();
  Polygon.Earcut = require_Earcut();
  Polygon.GetAABB = require_GetAABB();
  Polygon.GetNumberArray = require_GetNumberArray();
  Polygon.GetPoints = require_GetPoints5();
  Polygon.Perimeter = require_Perimeter2();
  Polygon.Reverse = require_Reverse2();
  Polygon.Simplify = require_Simplify();
  Polygon.Smooth = require_Smooth();
  Polygon.Translate = require_Translate();
  module2.exports = Polygon;
});

// node_modules/phaser/src/geom/rectangle/Area.js
var require_Area3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Area = function(rect) {
    return rect.width * rect.height;
  };
  module2.exports = Area;
});

// node_modules/phaser/src/geom/rectangle/Ceil.js
var require_Ceil3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Ceil = function(rect) {
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);
    return rect;
  };
  module2.exports = Ceil;
});

// node_modules/phaser/src/geom/rectangle/CeilAll.js
var require_CeilAll = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CeilAll = function(rect) {
    rect.x = Math.ceil(rect.x);
    rect.y = Math.ceil(rect.y);
    rect.width = Math.ceil(rect.width);
    rect.height = Math.ceil(rect.height);
    return rect;
  };
  module2.exports = CeilAll;
});

// node_modules/phaser/src/geom/rectangle/Clone.js
var require_Clone7 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  var Clone = function(source) {
    return new Rectangle(source.x, source.y, source.width, source.height);
  };
  module2.exports = Clone;
});

// node_modules/phaser/src/geom/rectangle/ContainsPoint.js
var require_ContainsPoint4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = require_Contains2();
  var ContainsPoint = function(rect, point) {
    return Contains(rect, point.x, point.y);
  };
  module2.exports = ContainsPoint;
});

// node_modules/phaser/src/geom/rectangle/ContainsRect.js
var require_ContainsRect3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ContainsRect = function(rectA, rectB) {
    if (rectB.width * rectB.height > rectA.width * rectA.height) {
      return false;
    }
    return rectB.x > rectA.x && rectB.x < rectA.right && (rectB.right > rectA.x && rectB.right < rectA.right) && (rectB.y > rectA.y && rectB.y < rectA.bottom) && (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom);
  };
  module2.exports = ContainsRect;
});

// node_modules/phaser/src/geom/rectangle/CopyFrom.js
var require_CopyFrom5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CopyFrom = function(source, dest) {
    return dest.setTo(source.x, source.y, source.width, source.height);
  };
  module2.exports = CopyFrom;
});

// node_modules/phaser/src/geom/rectangle/Equals.js
var require_Equals5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Equals = function(rect, toCompare) {
    return rect.x === toCompare.x && rect.y === toCompare.y && rect.width === toCompare.width && rect.height === toCompare.height;
  };
  module2.exports = Equals;
});

// node_modules/phaser/src/geom/rectangle/GetAspectRatio.js
var require_GetAspectRatio = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetAspectRatio = function(rect) {
    return rect.height === 0 ? NaN : rect.width / rect.height;
  };
  module2.exports = GetAspectRatio;
});

// node_modules/phaser/src/geom/rectangle/FitInside.js
var require_FitInside = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetAspectRatio = require_GetAspectRatio();
  var FitInside = function(target, source) {
    var ratio = GetAspectRatio(target);
    if (ratio < GetAspectRatio(source)) {
      target.setSize(source.height * ratio, source.height);
    } else {
      target.setSize(source.width, source.width / ratio);
    }
    return target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
  };
  module2.exports = FitInside;
});

// node_modules/phaser/src/geom/rectangle/FitOutside.js
var require_FitOutside = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetAspectRatio = require_GetAspectRatio();
  var FitOutside = function(target, source) {
    var ratio = GetAspectRatio(target);
    if (ratio > GetAspectRatio(source)) {
      target.setSize(source.height * ratio, source.height);
    } else {
      target.setSize(source.width, source.width / ratio);
    }
    return target.setPosition(source.centerX - target.width / 2, source.centerY - target.height / 2);
  };
  module2.exports = FitOutside;
});

// node_modules/phaser/src/geom/rectangle/Floor.js
var require_Floor3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Floor = function(rect) {
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);
    return rect;
  };
  module2.exports = Floor;
});

// node_modules/phaser/src/geom/rectangle/FloorAll.js
var require_FloorAll = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FloorAll = function(rect) {
    rect.x = Math.floor(rect.x);
    rect.y = Math.floor(rect.y);
    rect.width = Math.floor(rect.width);
    rect.height = Math.floor(rect.height);
    return rect;
  };
  module2.exports = FloorAll;
});

// node_modules/phaser/src/geom/rectangle/FromXY.js
var require_FromXY = __commonJS((exports2, module2) => {
  /**
   * @author       samme
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  var FromXY = function(x1, y1, x2, y2, out) {
    if (out === void 0) {
      out = new Rectangle();
    }
    return out.setTo(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));
  };
  module2.exports = FromXY;
});

// node_modules/phaser/src/geom/rectangle/GetCenter.js
var require_GetCenter = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var GetCenter = function(rect, out) {
    if (out === void 0) {
      out = new Point();
    }
    out.x = rect.centerX;
    out.y = rect.centerY;
    return out;
  };
  module2.exports = GetCenter;
});

// node_modules/phaser/src/geom/rectangle/GetSize.js
var require_GetSize = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var GetSize = function(rect, out) {
    if (out === void 0) {
      out = new Point();
    }
    out.x = rect.width;
    out.y = rect.height;
    return out;
  };
  module2.exports = GetSize;
});

// node_modules/phaser/src/geom/rectangle/Inflate.js
var require_Inflate = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CenterOn = require_CenterOn2();
  var Inflate = function(rect, x, y) {
    var cx = rect.centerX;
    var cy = rect.centerY;
    rect.setSize(rect.width + x * 2, rect.height + y * 2);
    return CenterOn(rect, cx, cy);
  };
  module2.exports = Inflate;
});

// node_modules/phaser/src/geom/rectangle/Intersection.js
var require_Intersection = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  var Intersects = require_RectangleToRectangle();
  var Intersection = function(rectA, rectB, out) {
    if (out === void 0) {
      out = new Rectangle();
    }
    if (Intersects(rectA, rectB)) {
      out.x = Math.max(rectA.x, rectB.x);
      out.y = Math.max(rectA.y, rectB.y);
      out.width = Math.min(rectA.right, rectB.right) - out.x;
      out.height = Math.min(rectA.bottom, rectB.bottom) - out.y;
    } else {
      out.setEmpty();
    }
    return out;
  };
  module2.exports = Intersection;
});

// node_modules/phaser/src/geom/rectangle/MergePoints.js
var require_MergePoints = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MergePoints = function(target, points) {
    var minX = target.x;
    var maxX = target.right;
    var minY = target.y;
    var maxY = target.bottom;
    for (var i = 0; i < points.length; i++) {
      minX = Math.min(minX, points[i].x);
      maxX = Math.max(maxX, points[i].x);
      minY = Math.min(minY, points[i].y);
      maxY = Math.max(maxY, points[i].y);
    }
    target.x = minX;
    target.y = minY;
    target.width = maxX - minX;
    target.height = maxY - minY;
    return target;
  };
  module2.exports = MergePoints;
});

// node_modules/phaser/src/geom/rectangle/MergeRect.js
var require_MergeRect = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MergeRect = function(target, source) {
    var minX = Math.min(target.x, source.x);
    var maxX = Math.max(target.right, source.right);
    target.x = minX;
    target.width = maxX - minX;
    var minY = Math.min(target.y, source.y);
    var maxY = Math.max(target.bottom, source.bottom);
    target.y = minY;
    target.height = maxY - minY;
    return target;
  };
  module2.exports = MergeRect;
});

// node_modules/phaser/src/geom/rectangle/MergeXY.js
var require_MergeXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MergeXY = function(target, x, y) {
    var minX = Math.min(target.x, x);
    var maxX = Math.max(target.right, x);
    target.x = minX;
    target.width = maxX - minX;
    var minY = Math.min(target.y, y);
    var maxY = Math.max(target.bottom, y);
    target.y = minY;
    target.height = maxY - minY;
    return target;
  };
  module2.exports = MergeXY;
});

// node_modules/phaser/src/geom/rectangle/Offset.js
var require_Offset4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Offset = function(rect, x, y) {
    rect.x += x;
    rect.y += y;
    return rect;
  };
  module2.exports = Offset;
});

// node_modules/phaser/src/geom/rectangle/OffsetPoint.js
var require_OffsetPoint3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var OffsetPoint = function(rect, point) {
    rect.x += point.x;
    rect.y += point.y;
    return rect;
  };
  module2.exports = OffsetPoint;
});

// node_modules/phaser/src/geom/rectangle/Overlaps.js
var require_Overlaps = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Overlaps = function(rectA, rectB) {
    return rectA.x < rectB.right && rectA.right > rectB.x && rectA.y < rectB.bottom && rectA.bottom > rectB.y;
  };
  module2.exports = Overlaps;
});

// node_modules/phaser/src/geom/rectangle/PerimeterPoint.js
var require_PerimeterPoint = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var DegToRad = require_DegToRad();
  var PerimeterPoint = function(rectangle, angle, out) {
    if (out === void 0) {
      out = new Point();
    }
    angle = DegToRad(angle);
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    var dx = c > 0 ? rectangle.width / 2 : rectangle.width / -2;
    var dy = s > 0 ? rectangle.height / 2 : rectangle.height / -2;
    if (Math.abs(dx * s) < Math.abs(dy * c)) {
      dy = dx * s / c;
    } else {
      dx = dy * c / s;
    }
    out.x = dx + rectangle.centerX;
    out.y = dy + rectangle.centerY;
    return out;
  };
  module2.exports = PerimeterPoint;
});

// node_modules/phaser/src/geom/rectangle/RandomOutside.js
var require_RandomOutside = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Between = require_Between2();
  var ContainsRect = require_ContainsRect3();
  var Point = require_Point();
  var RandomOutside = function(outer, inner, out) {
    if (out === void 0) {
      out = new Point();
    }
    if (ContainsRect(outer, inner)) {
      switch (Between(0, 3)) {
        case 0:
          out.x = outer.x + Math.random() * (inner.right - outer.x);
          out.y = outer.y + Math.random() * (inner.top - outer.y);
          break;
        case 1:
          out.x = inner.x + Math.random() * (outer.right - inner.x);
          out.y = inner.bottom + Math.random() * (outer.bottom - inner.bottom);
          break;
        case 2:
          out.x = outer.x + Math.random() * (inner.x - outer.x);
          out.y = inner.y + Math.random() * (outer.bottom - inner.y);
          break;
        case 3:
          out.x = inner.right + Math.random() * (outer.right - inner.right);
          out.y = outer.y + Math.random() * (inner.bottom - outer.y);
          break;
      }
    }
    return out;
  };
  module2.exports = RandomOutside;
});

// node_modules/phaser/src/geom/rectangle/SameDimensions.js
var require_SameDimensions = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SameDimensions = function(rect, toCompare) {
    return rect.width === toCompare.width && rect.height === toCompare.height;
  };
  module2.exports = SameDimensions;
});

// node_modules/phaser/src/geom/rectangle/Scale.js
var require_Scale = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Scale = function(rect, x, y) {
    if (y === void 0) {
      y = x;
    }
    rect.width *= x;
    rect.height *= y;
    return rect;
  };
  module2.exports = Scale;
});

// node_modules/phaser/src/geom/rectangle/index.js
var require_rectangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  Rectangle.Area = require_Area3();
  Rectangle.Ceil = require_Ceil3();
  Rectangle.CeilAll = require_CeilAll();
  Rectangle.CenterOn = require_CenterOn2();
  Rectangle.Clone = require_Clone7();
  Rectangle.Contains = require_Contains2();
  Rectangle.ContainsPoint = require_ContainsPoint4();
  Rectangle.ContainsRect = require_ContainsRect3();
  Rectangle.CopyFrom = require_CopyFrom5();
  Rectangle.Decompose = require_Decompose();
  Rectangle.Equals = require_Equals5();
  Rectangle.FitInside = require_FitInside();
  Rectangle.FitOutside = require_FitOutside();
  Rectangle.Floor = require_Floor3();
  Rectangle.FloorAll = require_FloorAll();
  Rectangle.FromPoints = require_FromPoints();
  Rectangle.FromXY = require_FromXY();
  Rectangle.GetAspectRatio = require_GetAspectRatio();
  Rectangle.GetCenter = require_GetCenter();
  Rectangle.GetPoint = require_GetPoint2();
  Rectangle.GetPoints = require_GetPoints2();
  Rectangle.GetSize = require_GetSize();
  Rectangle.Inflate = require_Inflate();
  Rectangle.Intersection = require_Intersection();
  Rectangle.MarchingAnts = require_MarchingAnts();
  Rectangle.MergePoints = require_MergePoints();
  Rectangle.MergeRect = require_MergeRect();
  Rectangle.MergeXY = require_MergeXY();
  Rectangle.Offset = require_Offset4();
  Rectangle.OffsetPoint = require_OffsetPoint3();
  Rectangle.Overlaps = require_Overlaps();
  Rectangle.Perimeter = require_Perimeter();
  Rectangle.PerimeterPoint = require_PerimeterPoint();
  Rectangle.Random = require_Random3();
  Rectangle.RandomOutside = require_RandomOutside();
  Rectangle.SameDimensions = require_SameDimensions();
  Rectangle.Scale = require_Scale();
  Rectangle.Union = require_Union();
  module2.exports = Rectangle;
});

// node_modules/phaser/src/geom/triangle/Area.js
var require_Area4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Area = function(triangle) {
    var x1 = triangle.x1;
    var y1 = triangle.y1;
    var x2 = triangle.x2;
    var y2 = triangle.y2;
    var x3 = triangle.x3;
    var y3 = triangle.y3;
    return Math.abs(((x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)) / 2);
  };
  module2.exports = Area;
});

// node_modules/phaser/src/geom/triangle/BuildEquilateral.js
var require_BuildEquilateral = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Triangle = require_Triangle();
  var BuildEquilateral = function(x, y, length) {
    var height = length * (Math.sqrt(3) / 2);
    var x1 = x;
    var y1 = y;
    var x2 = x + length / 2;
    var y2 = y + height;
    var x3 = x - length / 2;
    var y3 = y + height;
    return new Triangle(x1, y1, x2, y2, x3, y3);
  };
  module2.exports = BuildEquilateral;
});

// node_modules/phaser/src/geom/triangle/BuildFromPolygon.js
var require_BuildFromPolygon = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var EarCut = require_Earcut();
  var Triangle = require_Triangle();
  var BuildFromPolygon = function(data, holes, scaleX, scaleY, out) {
    if (holes === void 0) {
      holes = null;
    }
    if (scaleX === void 0) {
      scaleX = 1;
    }
    if (scaleY === void 0) {
      scaleY = 1;
    }
    if (out === void 0) {
      out = [];
    }
    var tris = EarCut(data, holes);
    var a;
    var b;
    var c;
    var x1;
    var y1;
    var x2;
    var y2;
    var x3;
    var y3;
    for (var i = 0; i < tris.length; i += 3) {
      a = tris[i];
      b = tris[i + 1];
      c = tris[i + 2];
      x1 = data[a * 2] * scaleX;
      y1 = data[a * 2 + 1] * scaleY;
      x2 = data[b * 2] * scaleX;
      y2 = data[b * 2 + 1] * scaleY;
      x3 = data[c * 2] * scaleX;
      y3 = data[c * 2 + 1] * scaleY;
      out.push(new Triangle(x1, y1, x2, y2, x3, y3));
    }
    return out;
  };
  module2.exports = BuildFromPolygon;
});

// node_modules/phaser/src/geom/triangle/BuildRight.js
var require_BuildRight = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Triangle = require_Triangle();
  var BuildRight = function(x, y, width, height) {
    if (height === void 0) {
      height = width;
    }
    var x1 = x;
    var y1 = y;
    var x2 = x;
    var y2 = y - height;
    var x3 = x + width;
    var y3 = y;
    return new Triangle(x1, y1, x2, y2, x3, y3);
  };
  module2.exports = BuildRight;
});

// node_modules/phaser/src/geom/triangle/Centroid.js
var require_Centroid = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  var Centroid = function(triangle, out) {
    if (out === void 0) {
      out = new Point();
    }
    out.x = (triangle.x1 + triangle.x2 + triangle.x3) / 3;
    out.y = (triangle.y1 + triangle.y2 + triangle.y3) / 3;
    return out;
  };
  module2.exports = Centroid;
});

// node_modules/phaser/src/geom/triangle/Offset.js
var require_Offset5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Offset = function(triangle, x, y) {
    triangle.x1 += x;
    triangle.y1 += y;
    triangle.x2 += x;
    triangle.y2 += y;
    triangle.x3 += x;
    triangle.y3 += y;
    return triangle;
  };
  module2.exports = Offset;
});

// node_modules/phaser/src/geom/triangle/CenterOn.js
var require_CenterOn4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Centroid = require_Centroid();
  var Offset = require_Offset5();
  var CenterOn = function(triangle, x, y, centerFunc) {
    if (centerFunc === void 0) {
      centerFunc = Centroid;
    }
    var center = centerFunc(triangle);
    var diffX = x - center.x;
    var diffY = y - center.y;
    return Offset(triangle, diffX, diffY);
  };
  module2.exports = CenterOn;
});

// node_modules/phaser/src/geom/triangle/CircumCenter.js
var require_CircumCenter = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector2 = require_Vector2();
  function det(m00, m01, m10, m11) {
    return m00 * m11 - m01 * m10;
  }
  var CircumCenter = function(triangle, out) {
    if (out === void 0) {
      out = new Vector2();
    }
    var cx = triangle.x3;
    var cy = triangle.y3;
    var ax = triangle.x1 - cx;
    var ay = triangle.y1 - cy;
    var bx = triangle.x2 - cx;
    var by = triangle.y2 - cy;
    var denom = 2 * det(ax, ay, bx, by);
    var numx = det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
    var numy = det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
    out.x = cx - numx / denom;
    out.y = cy + numy / denom;
    return out;
  };
  module2.exports = CircumCenter;
});

// node_modules/phaser/src/geom/triangle/CircumCircle.js
var require_CircumCircle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Circle = require_Circle();
  var CircumCircle = function(triangle, out) {
    if (out === void 0) {
      out = new Circle();
    }
    var x1 = triangle.x1;
    var y1 = triangle.y1;
    var x2 = triangle.x2;
    var y2 = triangle.y2;
    var x3 = triangle.x3;
    var y3 = triangle.y3;
    var A = x2 - x1;
    var B = y2 - y1;
    var C = x3 - x1;
    var D = y3 - y1;
    var E = A * (x1 + x2) + B * (y1 + y2);
    var F = C * (x1 + x3) + D * (y1 + y3);
    var G = 2 * (A * (y3 - y2) - B * (x3 - x2));
    var dx;
    var dy;
    if (Math.abs(G) < 1e-6) {
      var minX = Math.min(x1, x2, x3);
      var minY = Math.min(y1, y2, y3);
      dx = (Math.max(x1, x2, x3) - minX) * 0.5;
      dy = (Math.max(y1, y2, y3) - minY) * 0.5;
      out.x = minX + dx;
      out.y = minY + dy;
      out.radius = Math.sqrt(dx * dx + dy * dy);
    } else {
      out.x = (D * E - B * F) / G;
      out.y = (A * F - C * E) / G;
      dx = out.x - x1;
      dy = out.y - y1;
      out.radius = Math.sqrt(dx * dx + dy * dy);
    }
    return out;
  };
  module2.exports = CircumCircle;
});

// node_modules/phaser/src/geom/triangle/Clone.js
var require_Clone8 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Triangle = require_Triangle();
  var Clone = function(source) {
    return new Triangle(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
  };
  module2.exports = Clone;
});

// node_modules/phaser/src/geom/triangle/ContainsPoint.js
var require_ContainsPoint5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Contains = require_Contains5();
  var ContainsPoint = function(triangle, point) {
    return Contains(triangle, point.x, point.y);
  };
  module2.exports = ContainsPoint;
});

// node_modules/phaser/src/geom/triangle/CopyFrom.js
var require_CopyFrom6 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CopyFrom = function(source, dest) {
    return dest.setTo(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);
  };
  module2.exports = CopyFrom;
});

// node_modules/phaser/src/geom/triangle/Equals.js
var require_Equals6 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Equals = function(triangle, toCompare) {
    return triangle.x1 === toCompare.x1 && triangle.y1 === toCompare.y1 && triangle.x2 === toCompare.x2 && triangle.y2 === toCompare.y2 && triangle.x3 === toCompare.x3 && triangle.y3 === toCompare.y3;
  };
  module2.exports = Equals;
});

// node_modules/phaser/src/geom/triangle/InCenter.js
var require_InCenter = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Point = require_Point();
  function getLength(x1, y1, x2, y2) {
    var x = x1 - x2;
    var y = y1 - y2;
    var magnitude = x * x + y * y;
    return Math.sqrt(magnitude);
  }
  var InCenter = function(triangle, out) {
    if (out === void 0) {
      out = new Point();
    }
    var x1 = triangle.x1;
    var y1 = triangle.y1;
    var x2 = triangle.x2;
    var y2 = triangle.y2;
    var x3 = triangle.x3;
    var y3 = triangle.y3;
    var d1 = getLength(x3, y3, x2, y2);
    var d2 = getLength(x1, y1, x3, y3);
    var d3 = getLength(x2, y2, x1, y1);
    var p = d1 + d2 + d3;
    out.x = (x1 * d1 + x2 * d2 + x3 * d3) / p;
    out.y = (y1 * d1 + y2 * d2 + y3 * d3) / p;
    return out;
  };
  module2.exports = InCenter;
});

// node_modules/phaser/src/geom/triangle/Perimeter.js
var require_Perimeter3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Length = require_Length();
  var Perimeter = function(triangle) {
    var line1 = triangle.getLineA();
    var line2 = triangle.getLineB();
    var line3 = triangle.getLineC();
    return Length(line1) + Length(line2) + Length(line3);
  };
  module2.exports = Perimeter;
});

// node_modules/phaser/src/geom/triangle/RotateAroundXY.js
var require_RotateAroundXY2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateAroundXY = function(triangle, x, y, angle) {
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var tx = triangle.x1 - x;
    var ty = triangle.y1 - y;
    triangle.x1 = tx * c - ty * s + x;
    triangle.y1 = tx * s + ty * c + y;
    tx = triangle.x2 - x;
    ty = triangle.y2 - y;
    triangle.x2 = tx * c - ty * s + x;
    triangle.y2 = tx * s + ty * c + y;
    tx = triangle.x3 - x;
    ty = triangle.y3 - y;
    triangle.x3 = tx * c - ty * s + x;
    triangle.y3 = tx * s + ty * c + y;
    return triangle;
  };
  module2.exports = RotateAroundXY;
});

// node_modules/phaser/src/geom/triangle/Rotate.js
var require_Rotate4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateAroundXY = require_RotateAroundXY2();
  var InCenter = require_InCenter();
  var Rotate = function(triangle, angle) {
    var point = InCenter(triangle);
    return RotateAroundXY(triangle, point.x, point.y, angle);
  };
  module2.exports = Rotate;
});

// node_modules/phaser/src/geom/triangle/RotateAroundPoint.js
var require_RotateAroundPoint2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RotateAroundXY = require_RotateAroundXY2();
  var RotateAroundPoint = function(triangle, point, angle) {
    return RotateAroundXY(triangle, point.x, point.y, angle);
  };
  module2.exports = RotateAroundPoint;
});

// node_modules/phaser/src/geom/triangle/index.js
var require_triangle = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Triangle = require_Triangle();
  Triangle.Area = require_Area4();
  Triangle.BuildEquilateral = require_BuildEquilateral();
  Triangle.BuildFromPolygon = require_BuildFromPolygon();
  Triangle.BuildRight = require_BuildRight();
  Triangle.CenterOn = require_CenterOn4();
  Triangle.Centroid = require_Centroid();
  Triangle.CircumCenter = require_CircumCenter();
  Triangle.CircumCircle = require_CircumCircle();
  Triangle.Clone = require_Clone8();
  Triangle.Contains = require_Contains5();
  Triangle.ContainsArray = require_ContainsArray();
  Triangle.ContainsPoint = require_ContainsPoint5();
  Triangle.CopyFrom = require_CopyFrom6();
  Triangle.Decompose = require_Decompose2();
  Triangle.Equals = require_Equals6();
  Triangle.GetPoint = require_GetPoint5();
  Triangle.GetPoints = require_GetPoints6();
  Triangle.InCenter = require_InCenter();
  Triangle.Perimeter = require_Perimeter3();
  Triangle.Offset = require_Offset5();
  Triangle.Random = require_Random5();
  Triangle.Rotate = require_Rotate4();
  Triangle.RotateAroundPoint = require_RotateAroundPoint2();
  Triangle.RotateAroundXY = require_RotateAroundXY2();
  module2.exports = Triangle;
});

// node_modules/phaser/src/geom/index.js
var require_geom = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const3();
  var Extend = require_Extend();
  var Geom = {
    Circle: require_circle(),
    Ellipse: require_ellipse(),
    Intersects: require_intersects(),
    Line: require_line(),
    Mesh: require_mesh(),
    Point: require_point(),
    Polygon: require_polygon(),
    Rectangle: require_rectangle(),
    Triangle: require_triangle()
  };
  Geom = Extend(false, Geom, CONST);
  module2.exports = Geom;
});

// node_modules/phaser/src/input/CreatePixelPerfectHandler.js
var require_CreatePixelPerfectHandler = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CreatePixelPerfectHandler = function(textureManager, alphaTolerance) {
    return function(hitArea, x, y, gameObject) {
      var alpha = textureManager.getPixelAlpha(x, y, gameObject.texture.key, gameObject.frame.name);
      return alpha && alpha >= alphaTolerance;
    };
  };
  module2.exports = CreatePixelPerfectHandler;
});

// node_modules/phaser/src/input/CreateInteractiveObject.js
var require_CreateInteractiveObject = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CreateInteractiveObject = function(gameObject, hitArea, hitAreaCallback) {
    return {
      gameObject,
      enabled: true,
      alwaysEnabled: false,
      draggable: false,
      dropZone: false,
      cursor: false,
      target: null,
      camera: null,
      hitArea,
      hitAreaCallback,
      hitAreaDebug: null,
      customHitArea: false,
      localX: 0,
      localY: 0,
      dragState: 0,
      dragStartX: 0,
      dragStartY: 0,
      dragStartXGlobal: 0,
      dragStartYGlobal: 0,
      dragX: 0,
      dragY: 0
    };
  };
  module2.exports = CreateInteractiveObject;
});

// node_modules/phaser/src/input/gamepad/Axis.js
var require_Axis = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Axis = new Class({
    initialize: function Axis2(pad, index) {
      this.pad = pad;
      this.events = pad.events;
      this.index = index;
      this.value = 0;
      this.threshold = 0.1;
    },
    update: function(value) {
      this.value = value;
    },
    getValue: function() {
      return Math.abs(this.value) < this.threshold ? 0 : this.value;
    },
    destroy: function() {
      this.pad = null;
      this.events = null;
    }
  });
  module2.exports = Axis;
});

// node_modules/phaser/src/input/gamepad/events/BUTTON_DOWN_EVENT.js
var require_BUTTON_DOWN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "down";
});

// node_modules/phaser/src/input/gamepad/events/BUTTON_UP_EVENT.js
var require_BUTTON_UP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "up";
});

// node_modules/phaser/src/input/gamepad/events/CONNECTED_EVENT.js
var require_CONNECTED_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "connected";
});

// node_modules/phaser/src/input/gamepad/events/DISCONNECTED_EVENT.js
var require_DISCONNECTED_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "disconnected";
});

// node_modules/phaser/src/input/gamepad/events/GAMEPAD_BUTTON_DOWN_EVENT.js
var require_GAMEPAD_BUTTON_DOWN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "down";
});

// node_modules/phaser/src/input/gamepad/events/GAMEPAD_BUTTON_UP_EVENT.js
var require_GAMEPAD_BUTTON_UP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "up";
});

// node_modules/phaser/src/input/gamepad/events/index.js
var require_events17 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    BUTTON_DOWN: require_BUTTON_DOWN_EVENT(),
    BUTTON_UP: require_BUTTON_UP_EVENT(),
    CONNECTED: require_CONNECTED_EVENT(),
    DISCONNECTED: require_DISCONNECTED_EVENT(),
    GAMEPAD_BUTTON_DOWN: require_GAMEPAD_BUTTON_DOWN_EVENT(),
    GAMEPAD_BUTTON_UP: require_GAMEPAD_BUTTON_UP_EVENT()
  };
});

// node_modules/phaser/src/input/gamepad/Button.js
var require_Button = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Events = require_events17();
  var Button = new Class({
    initialize: function Button2(pad, index) {
      this.pad = pad;
      this.events = pad.manager;
      this.index = index;
      this.value = 0;
      this.threshold = 1;
      this.pressed = false;
    },
    update: function(value) {
      this.value = value;
      var pad = this.pad;
      var index = this.index;
      if (value >= this.threshold) {
        if (!this.pressed) {
          this.pressed = true;
          this.events.emit(Events.BUTTON_DOWN, pad, this, value);
          this.pad.emit(Events.GAMEPAD_BUTTON_DOWN, index, value, this);
        }
      } else if (this.pressed) {
        this.pressed = false;
        this.events.emit(Events.BUTTON_UP, pad, this, value);
        this.pad.emit(Events.GAMEPAD_BUTTON_UP, index, value, this);
      }
    },
    destroy: function() {
      this.pad = null;
      this.events = null;
    }
  });
  module2.exports = Button;
});

// node_modules/phaser/src/input/gamepad/Gamepad.js
var require_Gamepad = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Axis = require_Axis();
  var Button = require_Button();
  var Class = require_Class();
  var EventEmitter = require_eventemitter3();
  var Vector2 = require_Vector2();
  var Gamepad = new Class({
    Extends: EventEmitter,
    initialize: function Gamepad2(manager, pad) {
      EventEmitter.call(this);
      this.manager = manager;
      this.pad = pad;
      this.id = pad.id;
      this.index = pad.index;
      var buttons = [];
      for (var i = 0; i < pad.buttons.length; i++) {
        buttons.push(new Button(this, i));
      }
      this.buttons = buttons;
      var axes = [];
      for (i = 0; i < pad.axes.length; i++) {
        axes.push(new Axis(this, i));
      }
      this.axes = axes;
      this.vibration = pad.vibrationActuator;
      var _noButton = {value: 0, pressed: false};
      this._LCLeft = buttons[14] ? buttons[14] : _noButton;
      this._LCRight = buttons[15] ? buttons[15] : _noButton;
      this._LCTop = buttons[12] ? buttons[12] : _noButton;
      this._LCBottom = buttons[13] ? buttons[13] : _noButton;
      this._RCLeft = buttons[2] ? buttons[2] : _noButton;
      this._RCRight = buttons[1] ? buttons[1] : _noButton;
      this._RCTop = buttons[3] ? buttons[3] : _noButton;
      this._RCBottom = buttons[0] ? buttons[0] : _noButton;
      this._FBLeftTop = buttons[4] ? buttons[4] : _noButton;
      this._FBLeftBottom = buttons[6] ? buttons[6] : _noButton;
      this._FBRightTop = buttons[5] ? buttons[5] : _noButton;
      this._FBRightBottom = buttons[7] ? buttons[7] : _noButton;
      var _noAxis = {value: 0};
      this._HAxisLeft = axes[0] ? axes[0] : _noAxis;
      this._VAxisLeft = axes[1] ? axes[1] : _noAxis;
      this._HAxisRight = axes[2] ? axes[2] : _noAxis;
      this._VAxisRight = axes[3] ? axes[3] : _noAxis;
      this.leftStick = new Vector2();
      this.rightStick = new Vector2();
      this._created = performance.now();
    },
    getAxisTotal: function() {
      return this.axes.length;
    },
    getAxisValue: function(index) {
      return this.axes[index].getValue();
    },
    setAxisThreshold: function(value) {
      for (var i = 0; i < this.axes.length; i++) {
        this.axes[i].threshold = value;
      }
    },
    getButtonTotal: function() {
      return this.buttons.length;
    },
    getButtonValue: function(index) {
      return this.buttons[index].value;
    },
    isButtonDown: function(index) {
      return this.buttons[index].pressed;
    },
    update: function(pad) {
      if (pad.timestamp < this._created) {
        return;
      }
      var i;
      var localButtons = this.buttons;
      var gamepadButtons = pad.buttons;
      var len = localButtons.length;
      for (i = 0; i < len; i++) {
        localButtons[i].update(gamepadButtons[i].value);
      }
      var localAxes = this.axes;
      var gamepadAxes = pad.axes;
      len = localAxes.length;
      for (i = 0; i < len; i++) {
        localAxes[i].update(gamepadAxes[i]);
      }
      if (len >= 2) {
        this.leftStick.set(localAxes[0].getValue(), localAxes[1].getValue());
        if (len >= 4) {
          this.rightStick.set(localAxes[2].getValue(), localAxes[3].getValue());
        }
      }
    },
    destroy: function() {
      this.removeAllListeners();
      this.manager = null;
      this.pad = null;
      var i;
      for (i = 0; i < this.buttons.length; i++) {
        this.buttons[i].destroy();
      }
      for (i = 0; i < this.axes.length; i++) {
        this.axes[i].destroy();
      }
      this.buttons = [];
      this.axes = [];
    },
    connected: {
      get: function() {
        return this.pad.connected;
      }
    },
    timestamp: {
      get: function() {
        return this.pad.timestamp;
      }
    },
    left: {
      get: function() {
        return this._LCLeft.pressed;
      }
    },
    right: {
      get: function() {
        return this._LCRight.pressed;
      }
    },
    up: {
      get: function() {
        return this._LCTop.pressed;
      }
    },
    down: {
      get: function() {
        return this._LCBottom.pressed;
      }
    },
    A: {
      get: function() {
        return this._RCBottom.pressed;
      }
    },
    Y: {
      get: function() {
        return this._RCTop.pressed;
      }
    },
    X: {
      get: function() {
        return this._RCLeft.pressed;
      }
    },
    B: {
      get: function() {
        return this._RCRight.pressed;
      }
    },
    L1: {
      get: function() {
        return this._FBLeftTop.value;
      }
    },
    L2: {
      get: function() {
        return this._FBLeftBottom.value;
      }
    },
    R1: {
      get: function() {
        return this._FBRightTop.value;
      }
    },
    R2: {
      get: function() {
        return this._FBRightBottom.value;
      }
    }
  });
  module2.exports = Gamepad;
});

// node_modules/phaser/src/input/InputPluginCache.js
var require_InputPluginCache = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetValue = require_GetValue();
  var inputPlugins = {};
  var InputPluginCache = {};
  InputPluginCache.register = function(key, plugin, mapping, settingsKey, configKey) {
    inputPlugins[key] = {plugin, mapping, settingsKey, configKey};
  };
  InputPluginCache.getPlugin = function(key) {
    return inputPlugins[key];
  };
  InputPluginCache.install = function(target) {
    var sys = target.scene.sys;
    var settings = sys.settings.input;
    var config2 = sys.game.config;
    for (var key in inputPlugins) {
      var source = inputPlugins[key].plugin;
      var mapping = inputPlugins[key].mapping;
      var settingsKey = inputPlugins[key].settingsKey;
      var configKey = inputPlugins[key].configKey;
      if (GetValue(settings, settingsKey, config2[configKey])) {
        target[mapping] = new source(target);
      }
    }
  };
  InputPluginCache.remove = function(key) {
    if (inputPlugins.hasOwnProperty(key)) {
      delete inputPlugins[key];
    }
  };
  module2.exports = InputPluginCache;
});

// node_modules/phaser/src/input/gamepad/GamepadPlugin.js
var require_GamepadPlugin = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var EventEmitter = require_eventemitter3();
  var Events = require_events17();
  var Gamepad = require_Gamepad();
  var GetValue = require_GetValue();
  var InputPluginCache = require_InputPluginCache();
  var InputEvents = require_events13();
  var GamepadPlugin = new Class({
    Extends: EventEmitter,
    initialize: function GamepadPlugin2(sceneInputPlugin) {
      EventEmitter.call(this);
      this.scene = sceneInputPlugin.scene;
      this.settings = this.scene.sys.settings;
      this.sceneInputPlugin = sceneInputPlugin;
      this.enabled = true;
      this.target;
      this.gamepads = [];
      this.queue = [];
      this.onGamepadHandler;
      this._pad1;
      this._pad2;
      this._pad3;
      this._pad4;
      sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
      sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
    },
    boot: function() {
      var game2 = this.scene.sys.game;
      var settings = this.settings.input;
      var config2 = game2.config;
      this.enabled = GetValue(settings, "gamepad", config2.inputGamepad) && game2.device.input.gamepads;
      this.target = GetValue(settings, "gamepad.target", config2.inputGamepadEventTarget);
      this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
    },
    start: function() {
      if (this.enabled) {
        this.startListeners();
        this.refreshPads();
      }
      this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
    },
    isActive: function() {
      return this.enabled && this.scene.sys.isActive();
    },
    startListeners: function() {
      var _this = this;
      var target = this.target;
      var handler = function(event) {
        if (event.defaultPrevented || !_this.isActive()) {
          return;
        }
        _this.refreshPads();
        _this.queue.push(event);
      };
      this.onGamepadHandler = handler;
      target.addEventListener("gamepadconnected", handler, false);
      target.addEventListener("gamepaddisconnected", handler, false);
      this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);
    },
    stopListeners: function() {
      this.target.removeEventListener("gamepadconnected", this.onGamepadHandler);
      this.target.removeEventListener("gamepaddisconnected", this.onGamepadHandler);
      this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update);
      for (var i = 0; i < this.gamepads.length; i++) {
        this.gamepads[i].removeAllListeners();
      }
    },
    disconnectAll: function() {
      for (var i = 0; i < this.gamepads.length; i++) {
        this.gamepads[i].pad.connected = false;
      }
    },
    refreshPads: function() {
      var connectedPads = navigator.getGamepads();
      if (!connectedPads) {
        this.disconnectAll();
      } else {
        var currentPads = this.gamepads;
        for (var i = 0; i < connectedPads.length; i++) {
          var livePad = connectedPads[i];
          if (!livePad) {
            continue;
          }
          var id = livePad.id;
          var index = livePad.index;
          var currentPad = currentPads[index];
          if (!currentPad) {
            var newPad = new Gamepad(this, livePad);
            currentPads[index] = newPad;
            if (!this._pad1) {
              this._pad1 = newPad;
            } else if (!this._pad2) {
              this._pad2 = newPad;
            } else if (!this._pad3) {
              this._pad3 = newPad;
            } else if (!this._pad4) {
              this._pad4 = newPad;
            }
          } else if (currentPad.id !== id) {
            currentPad.destroy();
            currentPads[index] = new Gamepad(this, livePad);
          } else {
            currentPad.update(livePad);
          }
        }
      }
    },
    getAll: function() {
      var out = [];
      var pads = this.gamepads;
      for (var i = 0; i < pads.length; i++) {
        if (pads[i]) {
          out.push(pads[i]);
        }
      }
      return out;
    },
    getPad: function(index) {
      var pads = this.gamepads;
      for (var i = 0; i < pads.length; i++) {
        if (pads[i] && pads[i].index === index) {
          return pads[i];
        }
      }
    },
    update: function() {
      if (!this.enabled) {
        return;
      }
      this.refreshPads();
      var len = this.queue.length;
      if (len === 0) {
        return;
      }
      var queue = this.queue.splice(0, len);
      for (var i = 0; i < len; i++) {
        var event = queue[i];
        var pad = this.getPad(event.gamepad.index);
        if (event.type === "gamepadconnected") {
          this.emit(Events.CONNECTED, pad, event);
        } else if (event.type === "gamepaddisconnected") {
          this.emit(Events.DISCONNECTED, pad, event);
        }
      }
    },
    shutdown: function() {
      this.stopListeners();
      this.removeAllListeners();
    },
    destroy: function() {
      this.shutdown();
      for (var i = 0; i < this.gamepads.length; i++) {
        if (this.gamepads[i]) {
          this.gamepads[i].destroy();
        }
      }
      this.gamepads = [];
      this.scene = null;
      this.settings = null;
      this.sceneInputPlugin = null;
      this.target = null;
    },
    total: {
      get: function() {
        return this.gamepads.length;
      }
    },
    pad1: {
      get: function() {
        return this._pad1;
      }
    },
    pad2: {
      get: function() {
        return this._pad2;
      }
    },
    pad3: {
      get: function() {
        return this._pad3;
      }
    },
    pad4: {
      get: function() {
        return this._pad4;
      }
    }
  });
  InputPluginCache.register("GamepadPlugin", GamepadPlugin, "gamepad", "gamepad", "inputGamepad");
  module2.exports = GamepadPlugin;
});

// node_modules/phaser/src/input/gamepad/configs/Sony_PlayStation_DualShock_4.js
var require_Sony_PlayStation_DualShock_4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    UP: 12,
    DOWN: 13,
    LEFT: 14,
    RIGHT: 15,
    SHARE: 8,
    OPTIONS: 9,
    PS: 16,
    TOUCHBAR: 17,
    X: 0,
    CIRCLE: 1,
    SQUARE: 2,
    TRIANGLE: 3,
    L1: 4,
    R1: 5,
    L2: 6,
    R2: 7,
    L3: 10,
    R3: 11,
    LEFT_STICK_H: 0,
    LEFT_STICK_V: 1,
    RIGHT_STICK_H: 2,
    RIGHT_STICK_V: 3
  };
});

// node_modules/phaser/src/input/gamepad/configs/SNES_USB_Controller.js
var require_SNES_USB_Controller = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    UP: 12,
    DOWN: 13,
    LEFT: 14,
    RIGHT: 15,
    SELECT: 8,
    START: 9,
    B: 0,
    A: 1,
    Y: 2,
    X: 3,
    LEFT_SHOULDER: 4,
    RIGHT_SHOULDER: 5
  };
});

// node_modules/phaser/src/input/gamepad/configs/XBox360_Controller.js
var require_XBox360_Controller = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    UP: 12,
    DOWN: 13,
    LEFT: 14,
    RIGHT: 15,
    MENU: 16,
    A: 0,
    B: 1,
    X: 2,
    Y: 3,
    LB: 4,
    RB: 5,
    LT: 6,
    RT: 7,
    BACK: 8,
    START: 9,
    LS: 10,
    RS: 11,
    LEFT_STICK_H: 0,
    LEFT_STICK_V: 1,
    RIGHT_STICK_H: 2,
    RIGHT_STICK_V: 3
  };
});

// node_modules/phaser/src/input/gamepad/configs/index.js
var require_configs = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    DUALSHOCK_4: require_Sony_PlayStation_DualShock_4(),
    SNES_USB: require_SNES_USB_Controller(),
    XBOX_360: require_XBox360_Controller()
  };
});

// node_modules/phaser/src/input/gamepad/index.js
var require_gamepad = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Axis: require_Axis(),
    Button: require_Button(),
    Events: require_events17(),
    Gamepad: require_Gamepad(),
    GamepadPlugin: require_GamepadPlugin(),
    Configs: require_configs()
  };
});

// node_modules/phaser/src/input/InputPlugin.js
var require_InputPlugin = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Circle = require_Circle();
  var CircleContains = require_Contains();
  var Class = require_Class();
  var CONST = require_const9();
  var CreateInteractiveObject = require_CreateInteractiveObject();
  var CreatePixelPerfectHandler = require_CreatePixelPerfectHandler();
  var DistanceBetween = require_DistanceBetween();
  var Ellipse = require_Ellipse();
  var EllipseContains = require_Contains3();
  var Events = require_events13();
  var EventEmitter = require_eventemitter3();
  var GetFastValue = require_GetFastValue();
  var GEOM_CONST = require_const3();
  var InputPluginCache = require_InputPluginCache();
  var IsPlainObject = require_IsPlainObject();
  var PluginCache = require_PluginCache();
  var Rectangle = require_Rectangle();
  var RectangleContains = require_Contains2();
  var SceneEvents = require_events5();
  var Triangle = require_Triangle();
  var TriangleContains = require_Contains5();
  var InputPlugin = new Class({
    Extends: EventEmitter,
    initialize: function InputPlugin2(scene) {
      EventEmitter.call(this);
      this.scene = scene;
      this.systems = scene.sys;
      this.settings = scene.sys.settings;
      this.manager = scene.sys.game.input;
      this.pluginEvents = new EventEmitter();
      this.enabled = true;
      this.displayList;
      this.cameras;
      InputPluginCache.install(this);
      this.mouse = this.manager.mouse;
      this.topOnly = true;
      this.pollRate = -1;
      this._pollTimer = 0;
      var _eventData = {cancelled: false};
      this._eventContainer = {
        stopPropagation: function() {
          _eventData.cancelled = true;
        }
      };
      this._eventData = _eventData;
      this.dragDistanceThreshold = 0;
      this.dragTimeThreshold = 0;
      this._temp = [];
      this._tempZones = [];
      this._list = [];
      this._pendingInsertion = [];
      this._pendingRemoval = [];
      this._draggable = [];
      this._drag = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: []};
      this._dragState = [];
      this._over = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: []};
      this._validTypes = ["onDown", "onUp", "onOver", "onOut", "onMove", "onDragStart", "onDrag", "onDragEnd", "onDragEnter", "onDragLeave", "onDragOver", "onDrop"];
      this._updatedThisFrame = false;
      scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
      scene.sys.events.on(SceneEvents.START, this.start, this);
    },
    boot: function() {
      this.cameras = this.systems.cameras;
      this.displayList = this.systems.displayList;
      this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
      this.pluginEvents.emit(Events.BOOT);
    },
    start: function() {
      var eventEmitter = this.systems.events;
      eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);
      eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
      eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
      eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
      eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
      this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);
      this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);
      this.enabled = true;
      this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.pluginEvents.emit(Events.START);
    },
    onGameOver: function(event) {
      if (this.isActive()) {
        this.emit(Events.GAME_OVER, event.timeStamp, event);
      }
    },
    onGameOut: function(event) {
      if (this.isActive()) {
        this.emit(Events.GAME_OUT, event.timeStamp, event);
      }
    },
    preUpdate: function() {
      this.pluginEvents.emit(Events.PRE_UPDATE);
      var removeList = this._pendingRemoval;
      var insertList = this._pendingInsertion;
      var toRemove = removeList.length;
      var toInsert = insertList.length;
      if (toRemove === 0 && toInsert === 0) {
        return;
      }
      var current = this._list;
      for (var i = 0; i < toRemove; i++) {
        var gameObject = removeList[i];
        var index = current.indexOf(gameObject);
        if (index > -1) {
          current.splice(index, 1);
          this.clear(gameObject, true);
        }
      }
      removeList.length = 0;
      this._pendingRemoval.length = 0;
      this._list = current.concat(insertList.splice(0));
    },
    isActive: function() {
      return this.enabled && this.scene.sys.isActive();
    },
    updatePoll: function(time, delta) {
      if (!this.isActive()) {
        return false;
      }
      this.pluginEvents.emit(Events.UPDATE, time, delta);
      if (this._updatedThisFrame) {
        this._updatedThisFrame = false;
        return false;
      }
      var i;
      var manager = this.manager;
      var pointers = manager.pointers;
      var pointersTotal = manager.pointersTotal;
      for (i = 0; i < pointersTotal; i++) {
        pointers[i].updateMotion();
      }
      if (this._list.length === 0) {
        return false;
      }
      var rate = this.pollRate;
      if (rate === -1) {
        return false;
      } else if (rate > 0) {
        this._pollTimer -= delta;
        if (this._pollTimer < 0) {
          this._pollTimer = this.pollRate;
        } else {
          return false;
        }
      }
      var captured = false;
      for (i = 0; i < pointersTotal; i++) {
        var total = 0;
        var pointer = pointers[i];
        this._tempZones = [];
        this._temp = this.hitTestPointer(pointer);
        this.sortGameObjects(this._temp, pointer);
        this.sortDropZones(this._tempZones);
        if (this.topOnly) {
          if (this._temp.length) {
            this._temp.splice(1);
          }
          if (this._tempZones.length) {
            this._tempZones.splice(1);
          }
        }
        total += this.processOverOutEvents(pointer);
        if (this.getDragState(pointer) === 2) {
          this.processDragThresholdEvent(pointer, time);
        }
        if (total > 0) {
          captured = true;
        }
      }
      return captured;
    },
    update: function(type, pointers) {
      if (!this.isActive()) {
        return false;
      }
      var pointersTotal = pointers.length;
      var captured = false;
      for (var i = 0; i < pointersTotal; i++) {
        var total = 0;
        var pointer = pointers[i];
        this._tempZones = [];
        this._temp = this.hitTestPointer(pointer);
        this.sortGameObjects(this._temp, pointer);
        this.sortDropZones(this._tempZones);
        if (this.topOnly) {
          if (this._temp.length) {
            this._temp.splice(1);
          }
          if (this._tempZones.length) {
            this._tempZones.splice(1);
          }
        }
        switch (type) {
          case CONST.MOUSE_DOWN:
            total += this.processDragDownEvent(pointer);
            total += this.processDownEvents(pointer);
            total += this.processOverOutEvents(pointer);
            break;
          case CONST.MOUSE_UP:
            total += this.processDragUpEvent(pointer);
            total += this.processUpEvents(pointer);
            total += this.processOverOutEvents(pointer);
            break;
          case CONST.TOUCH_START:
            total += this.processDragDownEvent(pointer);
            total += this.processDownEvents(pointer);
            total += this.processOverEvents(pointer);
            break;
          case CONST.TOUCH_END:
          case CONST.TOUCH_CANCEL:
            total += this.processDragUpEvent(pointer);
            total += this.processUpEvents(pointer);
            total += this.processOutEvents(pointer);
            break;
          case CONST.MOUSE_MOVE:
          case CONST.TOUCH_MOVE:
            total += this.processDragMoveEvent(pointer);
            total += this.processMoveEvents(pointer);
            total += this.processOverOutEvents(pointer);
            break;
          case CONST.MOUSE_WHEEL:
            total += this.processWheelEvent(pointer);
            break;
        }
        if (total > 0) {
          captured = true;
        }
      }
      this._updatedThisFrame = true;
      return captured;
    },
    clear: function(gameObject, skipQueue) {
      if (skipQueue === void 0) {
        skipQueue = false;
      }
      var input = gameObject.input;
      if (!input) {
        return;
      }
      if (!skipQueue) {
        this.queueForRemoval(gameObject);
      }
      input.gameObject = void 0;
      input.target = void 0;
      input.hitArea = void 0;
      input.hitAreaCallback = void 0;
      input.callbackContext = void 0;
      gameObject.input = null;
      var index = this._draggable.indexOf(gameObject);
      if (index > -1) {
        this._draggable.splice(index, 1);
      }
      index = this._drag[0].indexOf(gameObject);
      if (index > -1) {
        this._drag[0].splice(index, 1);
      }
      index = this._over[0].indexOf(gameObject);
      if (index > -1) {
        this._over[0].splice(index, 1);
        this.manager.resetCursor(input);
      }
      return gameObject;
    },
    disable: function(gameObject) {
      gameObject.input.enabled = false;
    },
    enable: function(gameObject, hitArea, hitAreaCallback, dropZone) {
      if (dropZone === void 0) {
        dropZone = false;
      }
      if (gameObject.input) {
        gameObject.input.enabled = true;
      } else {
        this.setHitArea(gameObject, hitArea, hitAreaCallback);
      }
      if (gameObject.input && dropZone && !gameObject.input.dropZone) {
        gameObject.input.dropZone = dropZone;
      }
      return this;
    },
    hitTestPointer: function(pointer) {
      var cameras = this.cameras.getCamerasBelowPointer(pointer);
      for (var c = 0; c < cameras.length; c++) {
        var camera = cameras[c];
        var over = this.manager.hitTest(pointer, this._list, camera);
        for (var i = 0; i < over.length; i++) {
          var obj = over[i];
          if (obj.input.dropZone) {
            this._tempZones.push(obj);
          }
        }
        if (over.length > 0) {
          pointer.camera = camera;
          return over;
        }
      }
      pointer.camera = cameras[0];
      return [];
    },
    processDownEvents: function(pointer) {
      var total = 0;
      var currentlyOver = this._temp;
      var _eventData = this._eventData;
      var _eventContainer = this._eventContainer;
      _eventData.cancelled = false;
      var aborted = false;
      for (var i = 0; i < currentlyOver.length; i++) {
        var gameObject = currentlyOver[i];
        if (!gameObject.input) {
          continue;
        }
        total++;
        gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
        if (_eventData.cancelled || !gameObject.input) {
          aborted = true;
          break;
        }
        this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);
        if (_eventData.cancelled || !gameObject.input) {
          aborted = true;
          break;
        }
      }
      if (!aborted && this.manager) {
        if (pointer.downElement === this.manager.game.canvas) {
          this.emit(Events.POINTER_DOWN, pointer, currentlyOver);
        } else {
          this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);
        }
      }
      return total;
    },
    getDragState: function(pointer) {
      return this._dragState[pointer.id];
    },
    setDragState: function(pointer, state) {
      this._dragState[pointer.id] = state;
    },
    processDragThresholdEvent: function(pointer, time) {
      var passed = false;
      var timeThreshold = this.dragTimeThreshold;
      var distanceThreshold = this.dragDistanceThreshold;
      if (distanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold) {
        passed = true;
      } else if (timeThreshold > 0 && time >= pointer.downTime + timeThreshold) {
        passed = true;
      }
      if (passed) {
        this.setDragState(pointer, 3);
        return this.processDragStartList(pointer);
      }
    },
    processDragStartList: function(pointer) {
      if (this.getDragState(pointer) !== 3) {
        return 0;
      }
      var list = this._drag[pointer.id];
      for (var i = 0; i < list.length; i++) {
        var gameObject = list[i];
        var input = gameObject.input;
        input.dragState = 2;
        input.dragStartX = gameObject.x;
        input.dragStartY = gameObject.y;
        input.dragStartXGlobal = pointer.worldX;
        input.dragStartYGlobal = pointer.worldY;
        input.dragX = input.dragStartXGlobal - input.dragStartX;
        input.dragY = input.dragStartYGlobal - input.dragStartY;
        gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);
        this.emit(Events.DRAG_START, pointer, gameObject);
      }
      this.setDragState(pointer, 4);
      return list.length;
    },
    processDragDownEvent: function(pointer) {
      var currentlyOver = this._temp;
      if (this._draggable.length === 0 || currentlyOver.length === 0 || !pointer.primaryDown || this.getDragState(pointer) !== 0) {
        return 0;
      }
      this.setDragState(pointer, 1);
      var draglist = [];
      for (var i = 0; i < currentlyOver.length; i++) {
        var gameObject = currentlyOver[i];
        if (gameObject.input.draggable && gameObject.input.dragState === 0) {
          draglist.push(gameObject);
        }
      }
      if (draglist.length === 0) {
        this.setDragState(pointer, 0);
        return 0;
      } else if (draglist.length > 1) {
        this.sortGameObjects(draglist, pointer);
        if (this.topOnly) {
          draglist.splice(1);
        }
      }
      this._drag[pointer.id] = draglist;
      if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0) {
        this.setDragState(pointer, 3);
        return this.processDragStartList(pointer);
      } else {
        this.setDragState(pointer, 2);
        return 0;
      }
    },
    processDragMoveEvent: function(pointer) {
      if (this.getDragState(pointer) === 2) {
        this.processDragThresholdEvent(pointer, this.manager.game.loop.now);
      }
      if (this.getDragState(pointer) !== 4) {
        return 0;
      }
      var dropZones = this._tempZones;
      var list = this._drag[pointer.id];
      for (var i = 0; i < list.length; i++) {
        var gameObject = list[i];
        var input = gameObject.input;
        var target = input.target;
        if (target) {
          var index = dropZones.indexOf(target);
          if (index === 0) {
            gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, target);
            this.emit(Events.DRAG_OVER, pointer, gameObject, target);
          } else if (index > 0) {
            gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);
            this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);
            input.target = dropZones[0];
            target = input.target;
            gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
            this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
          } else {
            gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);
            this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);
            if (dropZones[0]) {
              input.target = dropZones[0];
              target = input.target;
              gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
              this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
            } else {
              input.target = null;
            }
          }
        } else if (!target && dropZones[0]) {
          input.target = dropZones[0];
          target = input.target;
          gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);
          this.emit(Events.DRAG_ENTER, pointer, gameObject, target);
        }
        var dragX;
        var dragY;
        if (!gameObject.parentContainer) {
          dragX = pointer.worldX - input.dragX;
          dragY = pointer.worldY - input.dragY;
        } else {
          var dx = pointer.worldX - input.dragStartXGlobal;
          var dy = pointer.worldY - input.dragStartYGlobal;
          var rotation = gameObject.getParentRotation();
          var dxRotated = dx * Math.cos(rotation) + dy * Math.sin(rotation);
          var dyRotated = dy * Math.cos(rotation) - dx * Math.sin(rotation);
          dxRotated *= 1 / gameObject.parentContainer.scaleX;
          dyRotated *= 1 / gameObject.parentContainer.scaleY;
          dragX = dxRotated + input.dragStartX;
          dragY = dyRotated + input.dragStartY;
        }
        gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);
        this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);
      }
      return list.length;
    },
    processDragUpEvent: function(pointer) {
      var list = this._drag[pointer.id];
      for (var i = 0; i < list.length; i++) {
        var gameObject = list[i];
        var input = gameObject.input;
        if (input && input.dragState === 2) {
          input.dragState = 0;
          input.dragX = input.localX - gameObject.displayOriginX;
          input.dragY = input.localY - gameObject.displayOriginY;
          var dropped = false;
          var target = input.target;
          if (target) {
            gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target);
            this.emit(Events.DROP, pointer, gameObject, target);
            input.target = null;
            dropped = true;
          }
          if (gameObject.input) {
            gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);
            this.emit(Events.DRAG_END, pointer, gameObject, dropped);
          }
        }
      }
      this.setDragState(pointer, 0);
      list.splice(0);
      return 0;
    },
    processMoveEvents: function(pointer) {
      var total = 0;
      var currentlyOver = this._temp;
      var _eventData = this._eventData;
      var _eventContainer = this._eventContainer;
      _eventData.cancelled = false;
      var aborted = false;
      for (var i = 0; i < currentlyOver.length; i++) {
        var gameObject = currentlyOver[i];
        if (!gameObject.input) {
          continue;
        }
        total++;
        gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
        if (_eventData.cancelled || !gameObject.input) {
          aborted = true;
          break;
        }
        this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);
        if (_eventData.cancelled || !gameObject.input) {
          aborted = true;
          break;
        }
        if (this.topOnly) {
          break;
        }
      }
      if (!aborted) {
        this.emit(Events.POINTER_MOVE, pointer, currentlyOver);
      }
      return total;
    },
    processWheelEvent: function(pointer) {
      var total = 0;
      var currentlyOver = this._temp;
      var _eventData = this._eventData;
      var _eventContainer = this._eventContainer;
      _eventData.cancelled = false;
      var aborted = false;
      var dx = pointer.deltaX;
      var dy = pointer.deltaY;
      var dz = pointer.deltaZ;
      for (var i = 0; i < currentlyOver.length; i++) {
        var gameObject = currentlyOver[i];
        if (!gameObject.input) {
          continue;
        }
        total++;
        gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer);
        if (_eventData.cancelled || !gameObject.input) {
          aborted = true;
          break;
        }
        this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer);
        if (_eventData.cancelled || !gameObject.input) {
          aborted = true;
          break;
        }
      }
      if (!aborted) {
        this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz);
      }
      return total;
    },
    processOverEvents: function(pointer) {
      var currentlyOver = this._temp;
      var totalInteracted = 0;
      var total = currentlyOver.length;
      var justOver = [];
      if (total > 0) {
        var manager = this.manager;
        var _eventData = this._eventData;
        var _eventContainer = this._eventContainer;
        _eventData.cancelled = false;
        var aborted = false;
        for (var i = 0; i < total; i++) {
          var gameObject = currentlyOver[i];
          if (!gameObject.input) {
            continue;
          }
          justOver.push(gameObject);
          manager.setCursor(gameObject.input);
          gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
          totalInteracted++;
          if (_eventData.cancelled || !gameObject.input) {
            aborted = true;
            break;
          }
          this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);
          if (_eventData.cancelled || !gameObject.input) {
            aborted = true;
            break;
          }
        }
        if (!aborted) {
          this.emit(Events.POINTER_OVER, pointer, justOver);
        }
      }
      this._over[pointer.id] = justOver;
      return totalInteracted;
    },
    processOutEvents: function(pointer) {
      var previouslyOver = this._over[pointer.id];
      var totalInteracted = 0;
      var total = previouslyOver.length;
      if (total > 0) {
        var manager = this.manager;
        var _eventData = this._eventData;
        var _eventContainer = this._eventContainer;
        _eventData.cancelled = false;
        var aborted = false;
        this.sortGameObjects(previouslyOver, pointer);
        for (var i = 0; i < total; i++) {
          var gameObject = previouslyOver[i];
          gameObject = previouslyOver[i];
          if (!gameObject.input) {
            continue;
          }
          manager.resetCursor(gameObject.input);
          gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);
          totalInteracted++;
          if (_eventData.cancelled || !gameObject.input) {
            aborted = true;
            break;
          }
          this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);
          if (_eventData.cancelled || !gameObject.input) {
            aborted = true;
            break;
          }
          if (!aborted) {
            this.emit(Events.POINTER_OUT, pointer, previouslyOver);
          }
        }
        this._over[pointer.id] = [];
      }
      return totalInteracted;
    },
    processOverOutEvents: function(pointer) {
      var currentlyOver = this._temp;
      var i;
      var gameObject;
      var justOut = [];
      var justOver = [];
      var stillOver = [];
      var previouslyOver = this._over[pointer.id];
      var currentlyDragging = this._drag[pointer.id];
      var manager = this.manager;
      for (i = 0; i < previouslyOver.length; i++) {
        gameObject = previouslyOver[i];
        if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1) {
          justOut.push(gameObject);
        } else {
          stillOver.push(gameObject);
        }
      }
      for (i = 0; i < currentlyOver.length; i++) {
        gameObject = currentlyOver[i];
        if (previouslyOver.indexOf(gameObject) === -1) {
          justOver.push(gameObject);
        }
      }
      var total = justOut.length;
      var totalInteracted = 0;
      var _eventData = this._eventData;
      var _eventContainer = this._eventContainer;
      _eventData.cancelled = false;
      var aborted = false;
      if (total > 0) {
        this.sortGameObjects(justOut, pointer);
        for (i = 0; i < total; i++) {
          gameObject = justOut[i];
          if (!gameObject.input) {
            continue;
          }
          manager.resetCursor(gameObject.input);
          gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);
          totalInteracted++;
          if (_eventData.cancelled || !gameObject.input) {
            aborted = true;
            break;
          }
          this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);
          if (_eventData.cancelled || !gameObject.input) {
            aborted = true;
            break;
          }
        }
        if (!aborted) {
          this.emit(Events.POINTER_OUT, pointer, justOut);
        }
      }
      total = justOver.length;
      _eventData.cancelled = false;
      aborted = false;
      if (total > 0) {
        this.sortGameObjects(justOver, pointer);
        for (i = 0; i < total; i++) {
          gameObject = justOver[i];
          if (!gameObject.input) {
            continue;
          }
          manager.setCursor(gameObject.input);
          gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
          totalInteracted++;
          if (_eventData.cancelled || !gameObject.input) {
            aborted = true;
            break;
          }
          this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);
          if (_eventData.cancelled || !gameObject.input) {
            aborted = true;
            break;
          }
        }
        if (!aborted) {
          this.emit(Events.POINTER_OVER, pointer, justOver);
        }
      }
      previouslyOver = stillOver.concat(justOver);
      this._over[pointer.id] = this.sortGameObjects(previouslyOver, pointer);
      return totalInteracted;
    },
    processUpEvents: function(pointer) {
      var currentlyOver = this._temp;
      var _eventData = this._eventData;
      var _eventContainer = this._eventContainer;
      _eventData.cancelled = false;
      var aborted = false;
      for (var i = 0; i < currentlyOver.length; i++) {
        var gameObject = currentlyOver[i];
        if (!gameObject.input) {
          continue;
        }
        gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);
        if (_eventData.cancelled || !gameObject.input) {
          aborted = true;
          break;
        }
        this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);
        if (_eventData.cancelled || !gameObject.input) {
          aborted = true;
          break;
        }
      }
      if (!aborted && this.manager) {
        if (pointer.upElement === this.manager.game.canvas) {
          this.emit(Events.POINTER_UP, pointer, currentlyOver);
        } else {
          this.emit(Events.POINTER_UP_OUTSIDE, pointer);
        }
      }
      return currentlyOver.length;
    },
    queueForInsertion: function(child) {
      if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1) {
        this._pendingInsertion.push(child);
      }
      return this;
    },
    queueForRemoval: function(child) {
      this._pendingRemoval.push(child);
      return this;
    },
    setDraggable: function(gameObjects, value) {
      if (value === void 0) {
        value = true;
      }
      if (!Array.isArray(gameObjects)) {
        gameObjects = [gameObjects];
      }
      for (var i = 0; i < gameObjects.length; i++) {
        var gameObject = gameObjects[i];
        gameObject.input.draggable = value;
        var index = this._draggable.indexOf(gameObject);
        if (value && index === -1) {
          this._draggable.push(gameObject);
        } else if (!value && index > -1) {
          this._draggable.splice(index, 1);
        }
      }
      return this;
    },
    makePixelPerfect: function(alphaTolerance) {
      if (alphaTolerance === void 0) {
        alphaTolerance = 1;
      }
      var textureManager = this.systems.textures;
      return CreatePixelPerfectHandler(textureManager, alphaTolerance);
    },
    setHitArea: function(gameObjects, hitArea, hitAreaCallback) {
      if (hitArea === void 0) {
        return this.setHitAreaFromTexture(gameObjects);
      }
      if (!Array.isArray(gameObjects)) {
        gameObjects = [gameObjects];
      }
      var draggable = false;
      var dropZone = false;
      var cursor = false;
      var useHandCursor = false;
      var pixelPerfect = false;
      var customHitArea = true;
      if (IsPlainObject(hitArea)) {
        var config2 = hitArea;
        hitArea = GetFastValue(config2, "hitArea", null);
        hitAreaCallback = GetFastValue(config2, "hitAreaCallback", null);
        draggable = GetFastValue(config2, "draggable", false);
        dropZone = GetFastValue(config2, "dropZone", false);
        cursor = GetFastValue(config2, "cursor", false);
        useHandCursor = GetFastValue(config2, "useHandCursor", false);
        pixelPerfect = GetFastValue(config2, "pixelPerfect", false);
        var alphaTolerance = GetFastValue(config2, "alphaTolerance", 1);
        if (pixelPerfect) {
          hitArea = {};
          hitAreaCallback = this.makePixelPerfect(alphaTolerance);
        }
        if (!hitArea || !hitAreaCallback) {
          this.setHitAreaFromTexture(gameObjects);
          customHitArea = false;
        }
      } else if (typeof hitArea === "function" && !hitAreaCallback) {
        hitAreaCallback = hitArea;
        hitArea = {};
      }
      for (var i = 0; i < gameObjects.length; i++) {
        var gameObject = gameObjects[i];
        if (pixelPerfect && gameObject.type === "Container") {
          console.warn("Cannot pixelPerfect test a Container. Use a custom callback.");
          continue;
        }
        var io = !gameObject.input ? CreateInteractiveObject(gameObject, hitArea, hitAreaCallback) : gameObject.input;
        io.customHitArea = customHitArea;
        io.dropZone = dropZone;
        io.cursor = useHandCursor ? "pointer" : cursor;
        gameObject.input = io;
        if (draggable) {
          this.setDraggable(gameObject);
        }
        this.queueForInsertion(gameObject);
      }
      return this;
    },
    setHitAreaCircle: function(gameObjects, x, y, radius, callback) {
      if (callback === void 0) {
        callback = CircleContains;
      }
      var shape = new Circle(x, y, radius);
      return this.setHitArea(gameObjects, shape, callback);
    },
    setHitAreaEllipse: function(gameObjects, x, y, width, height, callback) {
      if (callback === void 0) {
        callback = EllipseContains;
      }
      var shape = new Ellipse(x, y, width, height);
      return this.setHitArea(gameObjects, shape, callback);
    },
    setHitAreaFromTexture: function(gameObjects, callback) {
      if (callback === void 0) {
        callback = RectangleContains;
      }
      if (!Array.isArray(gameObjects)) {
        gameObjects = [gameObjects];
      }
      for (var i = 0; i < gameObjects.length; i++) {
        var gameObject = gameObjects[i];
        var frame = gameObject.frame;
        var width = 0;
        var height = 0;
        if (gameObject.width) {
          width = gameObject.width;
          height = gameObject.height;
        } else if (frame) {
          width = frame.realWidth;
          height = frame.realHeight;
        }
        if (gameObject.type === "Container" && (width === 0 || height === 0)) {
          console.warn("Container.setInteractive must specify a Shape or call setSize() first");
          continue;
        }
        if (width !== 0 && height !== 0) {
          gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);
          this.queueForInsertion(gameObject);
        }
      }
      return this;
    },
    setHitAreaRectangle: function(gameObjects, x, y, width, height, callback) {
      if (callback === void 0) {
        callback = RectangleContains;
      }
      var shape = new Rectangle(x, y, width, height);
      return this.setHitArea(gameObjects, shape, callback);
    },
    setHitAreaTriangle: function(gameObjects, x1, y1, x2, y2, x3, y3, callback) {
      if (callback === void 0) {
        callback = TriangleContains;
      }
      var shape = new Triangle(x1, y1, x2, y2, x3, y3);
      return this.setHitArea(gameObjects, shape, callback);
    },
    enableDebug: function(gameObject, color) {
      if (color === void 0) {
        color = 65280;
      }
      var input = gameObject.input;
      if (!input || !input.hitArea) {
        return this;
      }
      var shape = input.hitArea;
      var shapeType = shape.type;
      var debug = input.hitAreaDebug;
      var factory = this.systems.add;
      var updateList = this.systems.updateList;
      if (debug) {
        updateList.remove(debug);
        debug.destroy();
        debug = null;
      }
      var offsetx = 0;
      var offsety = 0;
      switch (shapeType) {
        case GEOM_CONST.CIRCLE:
          debug = factory.arc(0, 0, shape.radius);
          offsetx = shape.x - shape.radius;
          offsety = shape.y - shape.radius;
          break;
        case GEOM_CONST.ELLIPSE:
          debug = factory.ellipse(0, 0, shape.width, shape.height);
          offsetx = shape.x - shape.width / 2;
          offsety = shape.y - shape.height / 2;
          break;
        case GEOM_CONST.LINE:
          debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);
          break;
        case GEOM_CONST.POLYGON:
          debug = factory.polygon(0, 0, shape.points);
          break;
        case GEOM_CONST.RECTANGLE:
          debug = factory.rectangle(0, 0, shape.width, shape.height);
          offsetx = shape.x;
          offsety = shape.y;
          break;
        case GEOM_CONST.TRIANGLE:
          debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);
          break;
      }
      if (debug) {
        debug.isFilled = false;
        debug.preUpdate = function() {
          debug.setStrokeStyle(1 / gameObject.scale, color);
          debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);
          var x = gameObject.x;
          var y = gameObject.y;
          var rotation = gameObject.rotation;
          var scaleX = gameObject.scaleX;
          var scaleY = gameObject.scaleY;
          if (gameObject.parentContainer) {
            var matrix = gameObject.getWorldTransformMatrix();
            x = matrix.tx;
            y = matrix.ty;
            rotation = matrix.rotation;
            scaleX = matrix.scaleX;
            scaleY = matrix.scaleY;
          }
          debug.setRotation(rotation);
          debug.setScale(scaleX, scaleY);
          debug.setPosition(x + offsetx, y + offsety);
          debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY);
          debug.setDepth(gameObject.depth);
        };
        updateList.add(debug);
        input.hitAreaDebug = debug;
      }
      return this;
    },
    removeDebug: function(gameObject) {
      var input = gameObject.input;
      if (input && input.hitAreaDebug) {
        var debug = input.hitAreaDebug;
        this.systems.updateList.remove(debug);
        debug.destroy();
        input.hitAreaDebug = null;
      }
      return this;
    },
    setPollAlways: function() {
      return this.setPollRate(0);
    },
    setPollOnMove: function() {
      return this.setPollRate(-1);
    },
    setPollRate: function(value) {
      this.pollRate = value;
      this._pollTimer = 0;
      return this;
    },
    setGlobalTopOnly: function(value) {
      this.manager.globalTopOnly = value;
      return this;
    },
    setTopOnly: function(value) {
      this.topOnly = value;
      return this;
    },
    sortGameObjects: function(gameObjects, pointer) {
      if (gameObjects.length < 2) {
        return gameObjects;
      }
      var list = pointer.camera.renderList;
      return gameObjects.sort(function(childA, childB) {
        return list.indexOf(childB) - list.indexOf(childA);
      });
    },
    sortDropZones: function(gameObjects) {
      if (gameObjects.length < 2) {
        return gameObjects;
      }
      this.scene.sys.depthSort();
      return gameObjects.sort(this.sortDropZoneHandler.bind(this));
    },
    sortDropZoneHandler: function(childA, childB) {
      if (!childA.parentContainer && !childB.parentContainer) {
        return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);
      } else if (childA.parentContainer === childB.parentContainer) {
        return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);
      } else if (childA.parentContainer === childB) {
        return -1;
      } else if (childB.parentContainer === childA) {
        return 1;
      } else {
        var listA = childA.getIndexList();
        var listB = childB.getIndexList();
        var len = Math.min(listA.length, listB.length);
        for (var i = 0; i < len; i++) {
          var indexA = listA[i];
          var indexB = listB[i];
          if (indexA === indexB) {
            continue;
          } else {
            return indexB - indexA;
          }
        }
        return listB.length - listA.length;
      }
      return 0;
    },
    stopPropagation: function() {
      this.manager._tempSkip = true;
      return this;
    },
    addPointer: function(quantity) {
      return this.manager.addPointer(quantity);
    },
    setDefaultCursor: function(cursor) {
      this.manager.setDefaultCursor(cursor);
      return this;
    },
    transitionIn: function() {
      this.enabled = this.settings.transitionAllowInput;
    },
    transitionComplete: function() {
      if (!this.settings.transitionAllowInput) {
        this.enabled = true;
      }
    },
    transitionOut: function() {
      this.enabled = this.settings.transitionAllowInput;
    },
    shutdown: function() {
      this.pluginEvents.emit(Events.SHUTDOWN);
      this._temp.length = 0;
      this._list.length = 0;
      this._draggable.length = 0;
      this._pendingRemoval.length = 0;
      this._pendingInsertion.length = 0;
      this._dragState.length = 0;
      for (var i = 0; i < 10; i++) {
        this._drag[i] = [];
        this._over[i] = [];
      }
      this.removeAllListeners();
      var manager = this.manager;
      manager.canvas.style.cursor = manager.defaultCursor;
      var eventEmitter = this.systems.events;
      eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);
      eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);
      eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);
      eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
      manager.events.off(Events.GAME_OUT, this.onGameOut, this);
      manager.events.off(Events.GAME_OVER, this.onGameOver, this);
      eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    destroy: function() {
      this.shutdown();
      this.pluginEvents.emit(Events.DESTROY);
      this.pluginEvents.removeAllListeners();
      this.scene.sys.events.off(SceneEvents.START, this.start, this);
      this.scene = null;
      this.cameras = null;
      this.manager = null;
      this.events = null;
      this.mouse = null;
    },
    x: {
      get: function() {
        return this.manager.activePointer.x;
      }
    },
    y: {
      get: function() {
        return this.manager.activePointer.y;
      }
    },
    isOver: {
      get: function() {
        return this.manager.isOver;
      }
    },
    mousePointer: {
      get: function() {
        return this.manager.mousePointer;
      }
    },
    activePointer: {
      get: function() {
        return this.manager.activePointer;
      }
    },
    pointer1: {
      get: function() {
        return this.manager.pointers[1];
      }
    },
    pointer2: {
      get: function() {
        return this.manager.pointers[2];
      }
    },
    pointer3: {
      get: function() {
        return this.manager.pointers[3];
      }
    },
    pointer4: {
      get: function() {
        return this.manager.pointers[4];
      }
    },
    pointer5: {
      get: function() {
        return this.manager.pointers[5];
      }
    },
    pointer6: {
      get: function() {
        return this.manager.pointers[6];
      }
    },
    pointer7: {
      get: function() {
        return this.manager.pointers[7];
      }
    },
    pointer8: {
      get: function() {
        return this.manager.pointers[8];
      }
    },
    pointer9: {
      get: function() {
        return this.manager.pointers[9];
      }
    },
    pointer10: {
      get: function() {
        return this.manager.pointers[10];
      }
    }
  });
  PluginCache.register("InputPlugin", InputPlugin, "input");
  module2.exports = InputPlugin;
});

// node_modules/phaser/src/input/keyboard/events/ANY_KEY_DOWN_EVENT.js
var require_ANY_KEY_DOWN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "keydown";
});

// node_modules/phaser/src/input/keyboard/events/ANY_KEY_UP_EVENT.js
var require_ANY_KEY_UP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "keyup";
});

// node_modules/phaser/src/input/keyboard/events/COMBO_MATCH_EVENT.js
var require_COMBO_MATCH_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "keycombomatch";
});

// node_modules/phaser/src/input/keyboard/events/DOWN_EVENT.js
var require_DOWN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "down";
});

// node_modules/phaser/src/input/keyboard/events/KEY_DOWN_EVENT.js
var require_KEY_DOWN_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "keydown-";
});

// node_modules/phaser/src/input/keyboard/events/KEY_UP_EVENT.js
var require_KEY_UP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "keyup-";
});

// node_modules/phaser/src/input/keyboard/events/UP_EVENT.js
var require_UP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "up";
});

// node_modules/phaser/src/input/keyboard/events/index.js
var require_events18 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ANY_KEY_DOWN: require_ANY_KEY_DOWN_EVENT(),
    ANY_KEY_UP: require_ANY_KEY_UP_EVENT(),
    COMBO_MATCH: require_COMBO_MATCH_EVENT(),
    DOWN: require_DOWN_EVENT(),
    KEY_DOWN: require_KEY_DOWN_EVENT(),
    KEY_UP: require_KEY_UP_EVENT(),
    UP: require_UP_EVENT()
  };
});

// node_modules/phaser/src/input/keyboard/keys/Key.js
var require_Key = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var EventEmitter = require_eventemitter3();
  var Events = require_events18();
  var Key = new Class({
    Extends: EventEmitter,
    initialize: function Key2(plugin, keyCode) {
      EventEmitter.call(this);
      this.plugin = plugin;
      this.keyCode = keyCode;
      this.originalEvent = void 0;
      this.enabled = true;
      this.isDown = false;
      this.isUp = true;
      this.altKey = false;
      this.ctrlKey = false;
      this.shiftKey = false;
      this.metaKey = false;
      this.location = 0;
      this.timeDown = 0;
      this.duration = 0;
      this.timeUp = 0;
      this.emitOnRepeat = false;
      this.repeats = 0;
      this._justDown = false;
      this._justUp = false;
      this._tick = -1;
    },
    setEmitOnRepeat: function(value) {
      this.emitOnRepeat = value;
      return this;
    },
    onDown: function(event) {
      this.originalEvent = event;
      if (!this.enabled) {
        return;
      }
      this.altKey = event.altKey;
      this.ctrlKey = event.ctrlKey;
      this.shiftKey = event.shiftKey;
      this.metaKey = event.metaKey;
      this.location = event.location;
      this.repeats++;
      if (!this.isDown) {
        this.isDown = true;
        this.isUp = false;
        this.timeDown = event.timeStamp;
        this.duration = 0;
        this._justDown = true;
        this._justUp = false;
        this.emit(Events.DOWN, this, event);
      } else if (this.emitOnRepeat) {
        this.emit(Events.DOWN, this, event);
      }
    },
    onUp: function(event) {
      this.originalEvent = event;
      if (!this.enabled) {
        return;
      }
      this.isDown = false;
      this.isUp = true;
      this.timeUp = event.timeStamp;
      this.duration = this.timeUp - this.timeDown;
      this.repeats = 0;
      this._justDown = false;
      this._justUp = true;
      this._tick = -1;
      this.emit(Events.UP, this, event);
    },
    reset: function() {
      this.preventDefault = true;
      this.enabled = true;
      this.isDown = false;
      this.isUp = true;
      this.altKey = false;
      this.ctrlKey = false;
      this.shiftKey = false;
      this.metaKey = false;
      this.timeDown = 0;
      this.duration = 0;
      this.timeUp = 0;
      this.repeats = 0;
      this._justDown = false;
      this._justUp = false;
      this._tick = -1;
      return this;
    },
    getDuration: function() {
      if (this.isDown) {
        return this.plugin.game.loop.time - this.timeDown;
      } else {
        return 0;
      }
    },
    destroy: function() {
      this.removeAllListeners();
      this.originalEvent = null;
      this.plugin = null;
    }
  });
  module2.exports = Key;
});

// node_modules/phaser/src/input/keyboard/combo/AdvanceKeyCombo.js
var require_AdvanceKeyCombo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AdvanceKeyCombo = function(event, combo) {
    combo.timeLastMatched = event.timeStamp;
    combo.index++;
    if (combo.index === combo.size) {
      return true;
    } else {
      combo.current = combo.keyCodes[combo.index];
      return false;
    }
  };
  module2.exports = AdvanceKeyCombo;
});

// node_modules/phaser/src/input/keyboard/combo/ProcessKeyCombo.js
var require_ProcessKeyCombo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AdvanceKeyCombo = require_AdvanceKeyCombo();
  var ProcessKeyCombo = function(event, combo) {
    if (combo.matched) {
      return true;
    }
    var comboMatched = false;
    var keyMatched = false;
    if (event.keyCode === combo.current) {
      if (combo.index > 0 && combo.maxKeyDelay > 0) {
        var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;
        if (event.timeStamp <= timeLimit) {
          keyMatched = true;
          comboMatched = AdvanceKeyCombo(event, combo);
        }
      } else {
        keyMatched = true;
        comboMatched = AdvanceKeyCombo(event, combo);
      }
    }
    if (!keyMatched && combo.resetOnWrongKey) {
      combo.index = 0;
      combo.current = combo.keyCodes[0];
    }
    if (comboMatched) {
      combo.timeLastMatched = event.timeStamp;
      combo.matched = true;
      combo.timeMatched = event.timeStamp;
    }
    return comboMatched;
  };
  module2.exports = ProcessKeyCombo;
});

// node_modules/phaser/src/input/keyboard/combo/ResetKeyCombo.js
var require_ResetKeyCombo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ResetKeyCombo = function(combo) {
    combo.current = combo.keyCodes[0];
    combo.index = 0;
    combo.timeLastMatched = 0;
    combo.matched = false;
    combo.timeMatched = 0;
    return combo;
  };
  module2.exports = ResetKeyCombo;
});

// node_modules/phaser/src/input/keyboard/combo/KeyCombo.js
var require_KeyCombo = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Events = require_events18();
  var GetFastValue = require_GetFastValue();
  var ProcessKeyCombo = require_ProcessKeyCombo();
  var ResetKeyCombo = require_ResetKeyCombo();
  var KeyCombo = new Class({
    initialize: function KeyCombo2(keyboardPlugin, keys, config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      if (keys.length < 2) {
        return false;
      }
      this.manager = keyboardPlugin;
      this.enabled = true;
      this.keyCodes = [];
      for (var i = 0; i < keys.length; i++) {
        var char = keys[i];
        if (typeof char === "string") {
          this.keyCodes.push(char.toUpperCase().charCodeAt(0));
        } else if (typeof char === "number") {
          this.keyCodes.push(char);
        } else if (char.hasOwnProperty("keyCode")) {
          this.keyCodes.push(char.keyCode);
        }
      }
      this.current = this.keyCodes[0];
      this.index = 0;
      this.size = this.keyCodes.length;
      this.timeLastMatched = 0;
      this.matched = false;
      this.timeMatched = 0;
      this.resetOnWrongKey = GetFastValue(config2, "resetOnWrongKey", true);
      this.maxKeyDelay = GetFastValue(config2, "maxKeyDelay", 0);
      this.resetOnMatch = GetFastValue(config2, "resetOnMatch", false);
      this.deleteOnMatch = GetFastValue(config2, "deleteOnMatch", false);
      var _this = this;
      var onKeyDownHandler = function(event) {
        if (_this.matched || !_this.enabled) {
          return;
        }
        var matched = ProcessKeyCombo(event, _this);
        if (matched) {
          _this.manager.emit(Events.COMBO_MATCH, _this, event);
          if (_this.resetOnMatch) {
            ResetKeyCombo(_this);
          } else if (_this.deleteOnMatch) {
            _this.destroy();
          }
        }
      };
      this.onKeyDown = onKeyDownHandler;
      this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);
    },
    progress: {
      get: function() {
        return this.index / this.size;
      }
    },
    destroy: function() {
      this.enabled = false;
      this.keyCodes = [];
      this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown);
      this.manager = null;
    }
  });
  module2.exports = KeyCombo;
});

// node_modules/phaser/src/input/keyboard/keys/KeyMap.js
var require_KeyMap = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var KeyCodes = require_KeyCodes();
  var KeyMap = {};
  for (var key in KeyCodes) {
    KeyMap[KeyCodes[key]] = key;
  }
  module2.exports = KeyMap;
});

// node_modules/phaser/src/input/keyboard/KeyboardPlugin.js
var require_KeyboardPlugin = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var EventEmitter = require_eventemitter3();
  var Events = require_events18();
  var GameEvents = require_events();
  var GetValue = require_GetValue();
  var InputEvents = require_events13();
  var InputPluginCache = require_InputPluginCache();
  var Key = require_Key();
  var KeyCodes = require_KeyCodes();
  var KeyCombo = require_KeyCombo();
  var KeyMap = require_KeyMap();
  var SceneEvents = require_events5();
  var SnapFloor = require_SnapFloor();
  var KeyboardPlugin = new Class({
    Extends: EventEmitter,
    initialize: function KeyboardPlugin2(sceneInputPlugin) {
      EventEmitter.call(this);
      this.game = sceneInputPlugin.systems.game;
      this.scene = sceneInputPlugin.scene;
      this.settings = this.scene.sys.settings;
      this.sceneInputPlugin = sceneInputPlugin;
      this.manager = sceneInputPlugin.manager.keyboard;
      this.enabled = true;
      this.keys = [];
      this.combos = [];
      this.prevCode = null;
      this.prevTime = 0;
      this.prevType = null;
      sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);
      sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);
    },
    boot: function() {
      var settings = this.settings.input;
      this.enabled = GetValue(settings, "keyboard", true);
      var captures = GetValue(settings, "keyboard.capture", null);
      if (captures) {
        this.addCaptures(captures);
      }
      this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);
    },
    start: function() {
      this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this);
      this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);
      this.game.events.on(GameEvents.BLUR, this.resetKeys, this);
      this.scene.sys.events.on(SceneEvents.PAUSE, this.resetKeys, this);
      this.scene.sys.events.on(SceneEvents.SLEEP, this.resetKeys, this);
    },
    isActive: function() {
      return this.enabled && this.scene.sys.isActive();
    },
    addCapture: function(keycode) {
      this.manager.addCapture(keycode);
      return this;
    },
    removeCapture: function(keycode) {
      this.manager.removeCapture(keycode);
      return this;
    },
    getCaptures: function() {
      return this.manager.captures;
    },
    enableGlobalCapture: function() {
      this.manager.preventDefault = true;
      return this;
    },
    disableGlobalCapture: function() {
      this.manager.preventDefault = false;
      return this;
    },
    clearCaptures: function() {
      this.manager.clearCaptures();
      return this;
    },
    createCursorKeys: function() {
      return this.addKeys({
        up: KeyCodes.UP,
        down: KeyCodes.DOWN,
        left: KeyCodes.LEFT,
        right: KeyCodes.RIGHT,
        space: KeyCodes.SPACE,
        shift: KeyCodes.SHIFT
      });
    },
    addKeys: function(keys, enableCapture, emitOnRepeat) {
      if (enableCapture === void 0) {
        enableCapture = true;
      }
      if (emitOnRepeat === void 0) {
        emitOnRepeat = false;
      }
      var output = {};
      if (typeof keys === "string") {
        keys = keys.split(",");
        for (var i = 0; i < keys.length; i++) {
          var currentKey = keys[i].trim();
          if (currentKey) {
            output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat);
          }
        }
      } else {
        for (var key in keys) {
          output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);
        }
      }
      return output;
    },
    addKey: function(key, enableCapture, emitOnRepeat) {
      if (enableCapture === void 0) {
        enableCapture = true;
      }
      if (emitOnRepeat === void 0) {
        emitOnRepeat = false;
      }
      var keys = this.keys;
      if (key instanceof Key) {
        var idx = keys.indexOf(key);
        if (idx > -1) {
          keys[idx] = key;
        } else {
          keys[key.keyCode] = key;
        }
        if (enableCapture) {
          this.addCapture(key.keyCode);
        }
        key.setEmitOnRepeat(emitOnRepeat);
        return key;
      }
      if (typeof key === "string") {
        key = KeyCodes[key.toUpperCase()];
      }
      if (!keys[key]) {
        keys[key] = new Key(this, key);
        if (enableCapture) {
          this.addCapture(key);
        }
        keys[key].setEmitOnRepeat(emitOnRepeat);
      }
      return keys[key];
    },
    removeKey: function(key, destroy) {
      if (destroy === void 0) {
        destroy = false;
      }
      var keys = this.keys;
      var ref;
      if (key instanceof Key) {
        var idx = keys.indexOf(key);
        if (idx > -1) {
          ref = this.keys[idx];
          this.keys[idx] = void 0;
        }
      } else if (typeof key === "string") {
        key = KeyCodes[key.toUpperCase()];
      }
      if (keys[key]) {
        ref = keys[key];
        keys[key] = void 0;
      }
      if (ref) {
        ref.plugin = null;
        if (destroy) {
          ref.destroy();
        }
      }
      return this;
    },
    removeAllKeys: function(destroy) {
      var keys = this.keys;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key) {
          keys[i] = void 0;
          if (destroy) {
            key.destroy();
          }
        }
      }
      return this;
    },
    createCombo: function(keys, config2) {
      return new KeyCombo(this, keys, config2);
    },
    checkDown: function(key, duration) {
      if (duration === void 0) {
        duration = 0;
      }
      if (this.enabled && key.isDown) {
        var t = SnapFloor(this.time - key.timeDown, duration);
        if (t > key._tick) {
          key._tick = t;
          return true;
        }
      }
      return false;
    },
    update: function() {
      var queue = this.manager.queue;
      var len = queue.length;
      if (!this.isActive() || len === 0) {
        return;
      }
      var keys = this.keys;
      for (var i = 0; i < len; i++) {
        var event = queue[i];
        var code = event.keyCode;
        var key = keys[code];
        var repeat = false;
        if (event.cancelled === void 0) {
          event.cancelled = 0;
          event.stopImmediatePropagation = function() {
            event.cancelled = 1;
          };
          event.stopPropagation = function() {
            event.cancelled = -1;
          };
        }
        if (event.cancelled === -1) {
          continue;
        }
        if (code === this.prevCode && event.timeStamp === this.prevTime && event.type === this.prevType) {
          continue;
        }
        this.prevCode = code;
        this.prevTime = event.timeStamp;
        this.prevType = event.type;
        if (event.type === "keydown") {
          if (key) {
            repeat = key.isDown;
            key.onDown(event);
          }
          if (!event.cancelled && (!key || !repeat)) {
            if (KeyMap[code]) {
              this.emit(Events.KEY_DOWN + KeyMap[code], event);
            }
            if (!event.cancelled) {
              this.emit(Events.ANY_KEY_DOWN, event);
            }
          }
        } else {
          if (key) {
            key.onUp(event);
          }
          if (!event.cancelled) {
            if (KeyMap[code]) {
              this.emit(Events.KEY_UP + KeyMap[code], event);
            }
            if (!event.cancelled) {
              this.emit(Events.ANY_KEY_UP, event);
            }
          }
        }
        if (event.cancelled === 1) {
          event.cancelled = 0;
        }
      }
    },
    resetKeys: function() {
      var keys = this.keys;
      for (var i = 0; i < keys.length; i++) {
        if (keys[i]) {
          keys[i].reset();
        }
      }
      return this;
    },
    shutdown: function() {
      this.removeAllKeys(true);
      this.removeAllListeners();
      this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this);
      this.game.events.off(GameEvents.BLUR, this.resetKeys);
      this.scene.sys.events.off(SceneEvents.PAUSE, this.resetKeys, this);
      this.scene.sys.events.off(SceneEvents.SLEEP, this.resetKeys, this);
      this.queue = [];
    },
    destroy: function() {
      this.shutdown();
      var keys = this.keys;
      for (var i = 0; i < keys.length; i++) {
        if (keys[i]) {
          keys[i].destroy();
        }
      }
      this.keys = [];
      this.combos = [];
      this.queue = [];
      this.scene = null;
      this.settings = null;
      this.sceneInputPlugin = null;
      this.manager = null;
    },
    time: {
      get: function() {
        return this.sceneInputPlugin.manager.time;
      }
    }
  });
  InputPluginCache.register("KeyboardPlugin", KeyboardPlugin, "keyboard", "keyboard", "inputKeyboard");
  module2.exports = KeyboardPlugin;
});

// node_modules/phaser/src/input/keyboard/keys/JustDown.js
var require_JustDown = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var JustDown = function(key) {
    if (key._justDown) {
      key._justDown = false;
      return true;
    } else {
      return false;
    }
  };
  module2.exports = JustDown;
});

// node_modules/phaser/src/input/keyboard/keys/JustUp.js
var require_JustUp = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var JustUp = function(key) {
    if (key._justUp) {
      key._justUp = false;
      return true;
    } else {
      return false;
    }
  };
  module2.exports = JustUp;
});

// node_modules/phaser/src/input/keyboard/keys/DownDuration.js
var require_DownDuration = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var DownDuration = function(key, duration) {
    if (duration === void 0) {
      duration = 50;
    }
    var current = key.plugin.game.loop.time - key.timeDown;
    return key.isDown && current < duration;
  };
  module2.exports = DownDuration;
});

// node_modules/phaser/src/input/keyboard/keys/UpDuration.js
var require_UpDuration = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var UpDuration = function(key, duration) {
    if (duration === void 0) {
      duration = 50;
    }
    var current = key.plugin.game.loop.time - key.timeUp;
    return key.isUp && current < duration;
  };
  module2.exports = UpDuration;
});

// node_modules/phaser/src/input/keyboard/index.js
var require_keyboard = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Events: require_events18(),
    KeyboardManager: require_KeyboardManager(),
    KeyboardPlugin: require_KeyboardPlugin(),
    Key: require_Key(),
    KeyCodes: require_KeyCodes(),
    KeyCombo: require_KeyCombo(),
    AdvanceKeyCombo: require_AdvanceKeyCombo(),
    ProcessKeyCombo: require_ProcessKeyCombo(),
    ResetKeyCombo: require_ResetKeyCombo(),
    JustDown: require_JustDown(),
    JustUp: require_JustUp(),
    DownDuration: require_DownDuration(),
    UpDuration: require_UpDuration()
  };
});

// node_modules/phaser/src/input/mouse/index.js
var require_mouse = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    MouseManager: require_MouseManager()
  };
});

// node_modules/phaser/src/input/touch/index.js
var require_touch = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    TouchManager: require_TouchManager()
  };
});

// node_modules/phaser/src/input/index.js
var require_input = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const9();
  var Extend = require_Extend();
  var Input = {
    CreatePixelPerfectHandler: require_CreatePixelPerfectHandler(),
    CreateInteractiveObject: require_CreateInteractiveObject(),
    Events: require_events13(),
    Gamepad: require_gamepad(),
    InputManager: require_InputManager(),
    InputPlugin: require_InputPlugin(),
    InputPluginCache: require_InputPluginCache(),
    Keyboard: require_keyboard(),
    Mouse: require_mouse(),
    Pointer: require_Pointer(),
    Touch: require_touch()
  };
  Input = Extend(false, Input, CONST);
  module2.exports = Input;
});

// node_modules/phaser/src/loader/const.js
var require_const12 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FILE_CONST = {
    LOADER_IDLE: 0,
    LOADER_LOADING: 1,
    LOADER_PROCESSING: 2,
    LOADER_COMPLETE: 3,
    LOADER_SHUTDOWN: 4,
    LOADER_DESTROYED: 5,
    FILE_PENDING: 10,
    FILE_LOADING: 11,
    FILE_LOADED: 12,
    FILE_FAILED: 13,
    FILE_PROCESSING: 14,
    FILE_ERRORED: 16,
    FILE_COMPLETE: 17,
    FILE_DESTROYED: 18,
    FILE_POPULATED: 19
  };
  module2.exports = FILE_CONST;
});

// node_modules/phaser/src/loader/GetURL.js
var require_GetURL = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetURL = function(file, baseURL) {
    if (!file.url) {
      return false;
    }
    if (file.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)) {
      return file.url;
    } else {
      return baseURL + file.url;
    }
  };
  module2.exports = GetURL;
});

// node_modules/phaser/src/loader/XHRSettings.js
var require_XHRSettings = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var XHRSettings = function(responseType, async, user, password, timeout, withCredentials) {
    if (responseType === void 0) {
      responseType = "";
    }
    if (async === void 0) {
      async = true;
    }
    if (user === void 0) {
      user = "";
    }
    if (password === void 0) {
      password = "";
    }
    if (timeout === void 0) {
      timeout = 0;
    }
    if (withCredentials === void 0) {
      withCredentials = false;
    }
    return {
      responseType,
      async,
      user,
      password,
      timeout,
      headers: void 0,
      header: void 0,
      headerValue: void 0,
      requestedWith: false,
      overrideMimeType: void 0,
      withCredentials
    };
  };
  module2.exports = XHRSettings;
});

// node_modules/phaser/src/loader/MergeXHRSettings.js
var require_MergeXHRSettings = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Extend = require_Extend();
  var XHRSettings = require_XHRSettings();
  var MergeXHRSettings = function(global2, local) {
    var output = global2 === void 0 ? XHRSettings() : Extend({}, global2);
    if (local) {
      for (var setting in local) {
        if (local[setting] !== void 0) {
          output[setting] = local[setting];
        }
      }
    }
    return output;
  };
  module2.exports = MergeXHRSettings;
});

// node_modules/phaser/src/loader/XHRLoader.js
var require_XHRLoader = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MergeXHRSettings = require_MergeXHRSettings();
  var XHRLoader = function(file, globalXHRSettings) {
    var config2 = MergeXHRSettings(globalXHRSettings, file.xhrSettings);
    var xhr = new XMLHttpRequest();
    xhr.open("GET", file.src, config2.async, config2.user, config2.password);
    xhr.responseType = file.xhrSettings.responseType;
    xhr.timeout = config2.timeout;
    if (config2.headers) {
      for (var key in config2.headers) {
        xhr.setRequestHeader(key, config2.headers[key]);
      }
    }
    if (config2.header && config2.headerValue) {
      xhr.setRequestHeader(config2.header, config2.headerValue);
    }
    if (config2.requestedWith) {
      xhr.setRequestHeader("X-Requested-With", config2.requestedWith);
    }
    if (config2.overrideMimeType) {
      xhr.overrideMimeType(config2.overrideMimeType);
    }
    if (config2.withCredentials) {
      xhr.withCredentials = true;
    }
    xhr.onload = file.onLoad.bind(file, xhr);
    xhr.onerror = file.onError.bind(file, xhr);
    xhr.onprogress = file.onProgress.bind(file);
    xhr.send();
    return xhr;
  };
  module2.exports = XHRLoader;
});

// node_modules/phaser/src/loader/File.js
var require_File = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var Events = require_events14();
  var GetFastValue = require_GetFastValue();
  var GetURL = require_GetURL();
  var MergeXHRSettings = require_MergeXHRSettings();
  var XHRLoader = require_XHRLoader();
  var XHRSettings = require_XHRSettings();
  var File = new Class({
    initialize: function File2(loader, fileConfig) {
      this.loader = loader;
      this.cache = GetFastValue(fileConfig, "cache", false);
      this.type = GetFastValue(fileConfig, "type", false);
      this.key = GetFastValue(fileConfig, "key", false);
      var loadKey = this.key;
      if (loader.prefix && loader.prefix !== "") {
        this.key = loader.prefix + loadKey;
      }
      if (!this.type || !this.key) {
        throw new Error("Invalid Loader." + this.type + " key");
      }
      var url = GetFastValue(fileConfig, "url");
      if (url === void 0) {
        url = loader.path + loadKey + "." + GetFastValue(fileConfig, "extension", "");
      } else if (typeof url === "string" && !url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)) {
        url = loader.path + url;
      }
      this.url = url;
      this.src = "";
      this.xhrSettings = XHRSettings(GetFastValue(fileConfig, "responseType", void 0));
      if (GetFastValue(fileConfig, "xhrSettings", false)) {
        this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, "xhrSettings", {}));
      }
      this.xhrLoader = null;
      this.state = typeof this.url === "function" ? CONST.FILE_POPULATED : CONST.FILE_PENDING;
      this.bytesTotal = 0;
      this.bytesLoaded = -1;
      this.percentComplete = -1;
      this.crossOrigin = void 0;
      this.data = void 0;
      this.config = GetFastValue(fileConfig, "config", {});
      this.multiFile;
      this.linkFile;
    },
    setLink: function(fileB) {
      this.linkFile = fileB;
      fileB.linkFile = this;
    },
    resetXHR: function() {
      if (this.xhrLoader) {
        this.xhrLoader.onload = void 0;
        this.xhrLoader.onerror = void 0;
        this.xhrLoader.onprogress = void 0;
      }
    },
    load: function() {
      if (this.state === CONST.FILE_POPULATED) {
        this.loader.nextFile(this, true);
      } else {
        this.state = CONST.FILE_LOADING;
        this.src = GetURL(this, this.loader.baseURL);
        if (this.src.indexOf("data:") === 0) {
          console.warn("Local data URIs are not supported: " + this.key);
        } else {
          this.xhrLoader = XHRLoader(this, this.loader.xhr);
        }
      }
    },
    onLoad: function(xhr, event) {
      var isLocalFile = xhr.responseURL && (xhr.responseURL.indexOf("file://") === 0 || xhr.responseURL.indexOf("capacitor://") === 0);
      var localFileOk = isLocalFile && event.target.status === 0;
      var success = !(event.target && event.target.status !== 200) || localFileOk;
      if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599) {
        success = false;
      }
      this.state = CONST.FILE_LOADED;
      this.resetXHR();
      this.loader.nextFile(this, success);
    },
    onError: function() {
      this.resetXHR();
      this.loader.nextFile(this, false);
    },
    onProgress: function(event) {
      if (event.lengthComputable) {
        this.bytesLoaded = event.loaded;
        this.bytesTotal = event.total;
        this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1);
        this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);
      }
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      this.onProcessComplete();
    },
    onProcessComplete: function() {
      this.state = CONST.FILE_COMPLETE;
      if (this.multiFile) {
        this.multiFile.onFileComplete(this);
      }
      this.loader.fileProcessComplete(this);
    },
    onProcessError: function() {
      this.state = CONST.FILE_ERRORED;
      if (this.multiFile) {
        this.multiFile.onFileFailed(this);
      }
      this.loader.fileProcessComplete(this);
    },
    hasCacheConflict: function() {
      return this.cache && this.cache.exists(this.key);
    },
    addToCache: function() {
      if (this.cache) {
        this.cache.add(this.key, this.data);
      }
      this.pendingDestroy();
    },
    pendingDestroy: function(data) {
      if (data === void 0) {
        data = this.data;
      }
      var key = this.key;
      var type = this.type;
      this.loader.emit(Events.FILE_COMPLETE, key, type, data);
      this.loader.emit(Events.FILE_KEY_COMPLETE + type + "-" + key, key, type, data);
      this.loader.flagForRemoval(this);
    },
    destroy: function() {
      this.loader = null;
      this.cache = null;
      this.xhrSettings = null;
      this.multiFile = null;
      this.linkFile = null;
      this.data = null;
    }
  });
  File.createObjectURL = function(image, blob, defaultType) {
    if (typeof URL === "function") {
      image.src = URL.createObjectURL(blob);
    } else {
      var reader = new FileReader();
      reader.onload = function() {
        image.removeAttribute("crossOrigin");
        image.src = "data:" + (blob.type || defaultType) + ";base64," + reader.result.split(",")[1];
      };
      reader.onerror = image.onerror;
      reader.readAsDataURL(blob);
    }
  };
  File.revokeObjectURL = function(image) {
    if (typeof URL === "function") {
      URL.revokeObjectURL(image.src);
    }
  };
  module2.exports = File;
});

// node_modules/phaser/src/loader/filetypes/JSONFile.js
var require_JSONFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var GetValue = require_GetValue();
  var IsPlainObject = require_IsPlainObject();
  var JSONFile = new Class({
    Extends: File,
    initialize: function JSONFile2(loader, key, url, xhrSettings, dataKey) {
      var extension = "json";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
        dataKey = GetFastValue(config2, "dataKey", dataKey);
      }
      var fileConfig = {
        type: "json",
        cache: loader.cacheManager.json,
        extension,
        responseType: "text",
        key,
        url,
        xhrSettings,
        config: dataKey
      };
      File.call(this, loader, fileConfig);
      if (IsPlainObject(url)) {
        if (dataKey) {
          this.data = GetValue(url, dataKey);
        } else {
          this.data = url;
        }
        this.state = CONST.FILE_POPULATED;
      }
    },
    onProcess: function() {
      if (this.state !== CONST.FILE_POPULATED) {
        this.state = CONST.FILE_PROCESSING;
        try {
          var json = JSON.parse(this.xhrLoader.responseText);
        } catch (e) {
          console.warn("Invalid JSON: " + this.key);
          this.onProcessError();
          throw e;
        }
        var key = this.config;
        if (typeof key === "string") {
          this.data = GetValue(json, key, json);
        } else {
          this.data = json;
        }
      }
      this.onProcessComplete();
    }
  });
  FileTypesManager.register("json", function(key, url, dataKey, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new JSONFile(this, key[i]));
      }
    } else {
      this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));
    }
    return this;
  });
  module2.exports = JSONFile;
});

// node_modules/phaser/src/loader/filetypes/AnimationJSONFile.js
var require_AnimationJSONFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var JSONFile = require_JSONFile();
  var LoaderEvents = require_events14();
  var AnimationJSONFile = new Class({
    Extends: JSONFile,
    initialize: function AnimationJSONFile2(loader, key, url, xhrSettings, dataKey) {
      JSONFile.call(this, loader, key, url, xhrSettings, dataKey);
      this.type = "animationJSON";
    },
    onProcess: function() {
      this.loader.once(LoaderEvents.POST_PROCESS, this.onLoadComplete, this);
      JSONFile.prototype.onProcess.call(this);
    },
    onLoadComplete: function() {
      this.loader.systems.anims.fromJSON(this.data);
    }
  });
  FileTypesManager.register("animation", function(key, url, dataKey, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new AnimationJSONFile(this, key[i]));
      }
    } else {
      this.addFile(new AnimationJSONFile(this, key, url, xhrSettings, dataKey));
    }
    return this;
  });
  module2.exports = AnimationJSONFile;
});

// node_modules/phaser/src/loader/filetypes/ImageFile.js
var require_ImageFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var ImageFile = new Class({
    Extends: File,
    initialize: function ImageFile2(loader, key, url, xhrSettings, frameConfig) {
      var extension = "png";
      var normalMapURL;
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        normalMapURL = GetFastValue(config2, "normalMap");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
        frameConfig = GetFastValue(config2, "frameConfig");
      }
      if (Array.isArray(url)) {
        normalMapURL = url[1];
        url = url[0];
      }
      var fileConfig = {
        type: "image",
        cache: loader.textureManager,
        extension,
        responseType: "blob",
        key,
        url,
        xhrSettings,
        config: frameConfig
      };
      File.call(this, loader, fileConfig);
      if (normalMapURL) {
        var normalMap = new ImageFile2(loader, this.key, normalMapURL, xhrSettings, frameConfig);
        normalMap.type = "normalMap";
        this.setLink(normalMap);
        loader.addFile(normalMap);
      }
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      this.data = new Image();
      this.data.crossOrigin = this.crossOrigin;
      var _this = this;
      this.data.onload = function() {
        File.revokeObjectURL(_this.data);
        _this.onProcessComplete();
      };
      this.data.onerror = function() {
        File.revokeObjectURL(_this.data);
        _this.onProcessError();
      };
      File.createObjectURL(this.data, this.xhrLoader.response, "image/png");
    },
    addToCache: function() {
      var texture;
      var linkFile = this.linkFile;
      if (linkFile && linkFile.state === CONST.FILE_COMPLETE) {
        if (this.type === "image") {
          texture = this.cache.addImage(this.key, this.data, linkFile.data);
        } else {
          texture = this.cache.addImage(linkFile.key, linkFile.data, this.data);
        }
        this.pendingDestroy(texture);
        linkFile.pendingDestroy(texture);
      } else if (!linkFile) {
        texture = this.cache.addImage(this.key, this.data);
        this.pendingDestroy(texture);
      }
    }
  });
  FileTypesManager.register("image", function(key, url, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new ImageFile(this, key[i]));
      }
    } else {
      this.addFile(new ImageFile(this, key, url, xhrSettings));
    }
    return this;
  });
  module2.exports = ImageFile;
});

// node_modules/phaser/src/loader/MultiFile.js
var require_MultiFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var MultiFile = new Class({
    initialize: function MultiFile2(loader, type, key, files) {
      var finalFiles = [];
      files.forEach(function(file) {
        if (file) {
          finalFiles.push(file);
        }
      });
      this.loader = loader;
      this.type = type;
      this.key = key;
      this.multiKeyIndex = loader.multiKeyIndex++;
      this.files = finalFiles;
      this.complete = false;
      this.pending = finalFiles.length;
      this.failed = 0;
      this.config = {};
      this.baseURL = loader.baseURL;
      this.path = loader.path;
      this.prefix = loader.prefix;
      for (var i = 0; i < finalFiles.length; i++) {
        finalFiles[i].multiFile = this;
      }
    },
    isReadyToProcess: function() {
      return this.pending === 0 && this.failed === 0 && !this.complete;
    },
    addToMultiFile: function(file) {
      this.files.push(file);
      file.multiFile = this;
      this.pending++;
      this.complete = false;
      return this;
    },
    onFileComplete: function(file) {
      var index = this.files.indexOf(file);
      if (index !== -1) {
        this.pending--;
      }
    },
    onFileFailed: function(file) {
      var index = this.files.indexOf(file);
      if (index !== -1) {
        this.failed++;
      }
    }
  });
  module2.exports = MultiFile;
});

// node_modules/phaser/src/loader/filetypes/AsepriteFile.js
var require_AsepriteFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var ImageFile = require_ImageFile();
  var IsPlainObject = require_IsPlainObject();
  var JSONFile = require_JSONFile();
  var MultiFile = require_MultiFile();
  var AsepriteFile = new Class({
    Extends: MultiFile,
    initialize: function AsepriteFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
      var image;
      var data;
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        image = new ImageFile(loader, {
          key,
          url: GetFastValue(config2, "textureURL"),
          extension: GetFastValue(config2, "textureExtension", "png"),
          normalMap: GetFastValue(config2, "normalMap"),
          xhrSettings: GetFastValue(config2, "textureXhrSettings")
        });
        data = new JSONFile(loader, {
          key,
          url: GetFastValue(config2, "atlasURL"),
          extension: GetFastValue(config2, "atlasExtension", "json"),
          xhrSettings: GetFastValue(config2, "atlasXhrSettings")
        });
      } else {
        image = new ImageFile(loader, key, textureURL, textureXhrSettings);
        data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
      }
      if (image.linkFile) {
        MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]);
      } else {
        MultiFile.call(this, loader, "atlasjson", key, [image, data]);
      }
    },
    addToCache: function() {
      if (this.isReadyToProcess()) {
        var image = this.files[0];
        var json = this.files[1];
        var normalMap = this.files[2] ? this.files[2].data : null;
        this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);
        json.addToCache();
        this.complete = true;
      }
    }
  });
  FileTypesManager.register("aseprite", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
    var multifile;
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        multifile = new AsepriteFile(this, key[i]);
        this.addFile(multifile.files);
      }
    } else {
      multifile = new AsepriteFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
      this.addFile(multifile.files);
    }
    return this;
  });
  module2.exports = AsepriteFile;
});

// node_modules/phaser/src/loader/filetypes/AtlasJSONFile.js
var require_AtlasJSONFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var ImageFile = require_ImageFile();
  var IsPlainObject = require_IsPlainObject();
  var JSONFile = require_JSONFile();
  var MultiFile = require_MultiFile();
  var AtlasJSONFile = new Class({
    Extends: MultiFile,
    initialize: function AtlasJSONFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
      var image;
      var data;
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        image = new ImageFile(loader, {
          key,
          url: GetFastValue(config2, "textureURL"),
          extension: GetFastValue(config2, "textureExtension", "png"),
          normalMap: GetFastValue(config2, "normalMap"),
          xhrSettings: GetFastValue(config2, "textureXhrSettings")
        });
        data = new JSONFile(loader, {
          key,
          url: GetFastValue(config2, "atlasURL"),
          extension: GetFastValue(config2, "atlasExtension", "json"),
          xhrSettings: GetFastValue(config2, "atlasXhrSettings")
        });
      } else {
        image = new ImageFile(loader, key, textureURL, textureXhrSettings);
        data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
      }
      if (image.linkFile) {
        MultiFile.call(this, loader, "atlasjson", key, [image, data, image.linkFile]);
      } else {
        MultiFile.call(this, loader, "atlasjson", key, [image, data]);
      }
    },
    addToCache: function() {
      if (this.isReadyToProcess()) {
        var image = this.files[0];
        var json = this.files[1];
        var normalMap = this.files[2] ? this.files[2].data : null;
        this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);
        json.pendingDestroy();
        this.complete = true;
      }
    }
  });
  FileTypesManager.register("atlas", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
    var multifile;
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        multifile = new AtlasJSONFile(this, key[i]);
        this.addFile(multifile.files);
      }
    } else {
      multifile = new AtlasJSONFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
      this.addFile(multifile.files);
    }
    return this;
  });
  module2.exports = AtlasJSONFile;
});

// node_modules/phaser/src/loader/filetypes/XMLFile.js
var require_XMLFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var ParseXML = require_ParseXML();
  var XMLFile = new Class({
    Extends: File,
    initialize: function XMLFile2(loader, key, url, xhrSettings) {
      var extension = "xml";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
      }
      var fileConfig = {
        type: "xml",
        cache: loader.cacheManager.xml,
        extension,
        responseType: "text",
        key,
        url,
        xhrSettings
      };
      File.call(this, loader, fileConfig);
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      this.data = ParseXML(this.xhrLoader.responseText);
      if (this.data) {
        this.onProcessComplete();
      } else {
        console.warn("Invalid XMLFile: " + this.key);
        this.onProcessError();
      }
    }
  });
  FileTypesManager.register("xml", function(key, url, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new XMLFile(this, key[i]));
      }
    } else {
      this.addFile(new XMLFile(this, key, url, xhrSettings));
    }
    return this;
  });
  module2.exports = XMLFile;
});

// node_modules/phaser/src/loader/filetypes/AtlasXMLFile.js
var require_AtlasXMLFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var ImageFile = require_ImageFile();
  var IsPlainObject = require_IsPlainObject();
  var MultiFile = require_MultiFile();
  var XMLFile = require_XMLFile();
  var AtlasXMLFile = new Class({
    Extends: MultiFile,
    initialize: function AtlasXMLFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
      var image;
      var data;
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        image = new ImageFile(loader, {
          key,
          url: GetFastValue(config2, "textureURL"),
          extension: GetFastValue(config2, "textureExtension", "png"),
          normalMap: GetFastValue(config2, "normalMap"),
          xhrSettings: GetFastValue(config2, "textureXhrSettings")
        });
        data = new XMLFile(loader, {
          key,
          url: GetFastValue(config2, "atlasURL"),
          extension: GetFastValue(config2, "atlasExtension", "xml"),
          xhrSettings: GetFastValue(config2, "atlasXhrSettings")
        });
      } else {
        image = new ImageFile(loader, key, textureURL, textureXhrSettings);
        data = new XMLFile(loader, key, atlasURL, atlasXhrSettings);
      }
      if (image.linkFile) {
        MultiFile.call(this, loader, "atlasxml", key, [image, data, image.linkFile]);
      } else {
        MultiFile.call(this, loader, "atlasxml", key, [image, data]);
      }
    },
    addToCache: function() {
      if (this.isReadyToProcess()) {
        var image = this.files[0];
        var xml = this.files[1];
        var normalMap = this.files[2] ? this.files[2].data : null;
        this.loader.textureManager.addAtlasXML(image.key, image.data, xml.data, normalMap);
        xml.pendingDestroy();
        this.complete = true;
      }
    }
  });
  FileTypesManager.register("atlasXML", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
    var multifile;
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        multifile = new AtlasXMLFile(this, key[i]);
        this.addFile(multifile.files);
      }
    } else {
      multifile = new AtlasXMLFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
      this.addFile(multifile.files);
    }
    return this;
  });
  module2.exports = AtlasXMLFile;
});

// node_modules/phaser/src/loader/filetypes/HTML5AudioFile.js
var require_HTML5AudioFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Events = require_events14();
  var File = require_File();
  var GetFastValue = require_GetFastValue();
  var GetURL = require_GetURL();
  var IsPlainObject = require_IsPlainObject();
  var HTML5AudioFile = new Class({
    Extends: File,
    initialize: function HTML5AudioFile2(loader, key, urlConfig, audioConfig) {
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        audioConfig = GetFastValue(config2, "config", audioConfig);
      }
      var fileConfig = {
        type: "audio",
        cache: loader.cacheManager.audio,
        extension: urlConfig.type,
        key,
        url: urlConfig.url,
        config: audioConfig
      };
      File.call(this, loader, fileConfig);
      this.locked = "ontouchstart" in window;
      this.loaded = false;
      this.filesLoaded = 0;
      this.filesTotal = 0;
    },
    onLoad: function() {
      if (this.loaded) {
        return;
      }
      this.loaded = true;
      this.loader.nextFile(this, true);
    },
    onError: function() {
      for (var i = 0; i < this.data.length; i++) {
        var audio = this.data[i];
        audio.oncanplaythrough = null;
        audio.onerror = null;
      }
      this.loader.nextFile(this, false);
    },
    onProgress: function(event) {
      var audio = event.target;
      audio.oncanplaythrough = null;
      audio.onerror = null;
      this.filesLoaded++;
      this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1);
      this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);
      if (this.filesLoaded === this.filesTotal) {
        this.onLoad();
      }
    },
    load: function() {
      this.data = [];
      var instances = this.config && this.config.instances || 1;
      this.filesTotal = instances;
      this.filesLoaded = 0;
      this.percentComplete = 0;
      for (var i = 0; i < instances; i++) {
        var audio = new Audio();
        if (!audio.dataset) {
          audio.dataset = {};
        }
        audio.dataset.name = this.key + ("0" + i).slice(-2);
        audio.dataset.used = "false";
        if (this.locked) {
          audio.dataset.locked = "true";
        } else {
          audio.dataset.locked = "false";
          audio.preload = "auto";
          audio.oncanplaythrough = this.onProgress.bind(this);
          audio.onerror = this.onError.bind(this);
        }
        this.data.push(audio);
      }
      for (i = 0; i < this.data.length; i++) {
        audio = this.data[i];
        audio.src = GetURL(this, this.loader.baseURL);
        if (!this.locked) {
          audio.load();
        }
      }
      if (this.locked) {
        setTimeout(this.onLoad.bind(this));
      }
    }
  });
  module2.exports = HTML5AudioFile;
});

// node_modules/phaser/src/loader/filetypes/AudioFile.js
var require_AudioFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var HTML5AudioFile = require_HTML5AudioFile();
  var IsPlainObject = require_IsPlainObject();
  var AudioFile = new Class({
    Extends: File,
    initialize: function AudioFile2(loader, key, urlConfig, xhrSettings, audioContext) {
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        audioContext = GetFastValue(config2, "context", audioContext);
      }
      var fileConfig = {
        type: "audio",
        cache: loader.cacheManager.audio,
        extension: urlConfig.type,
        responseType: "arraybuffer",
        key,
        url: urlConfig.url,
        xhrSettings,
        config: {context: audioContext}
      };
      File.call(this, loader, fileConfig);
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      var _this = this;
      this.config.context.decodeAudioData(this.xhrLoader.response, function(audioBuffer) {
        _this.data = audioBuffer;
        _this.onProcessComplete();
      }, function(e) {
        console.error("Error decoding audio: " + _this.key + " - ", e ? e.message : null);
        _this.onProcessError();
      });
      this.config.context = null;
    }
  });
  AudioFile.create = function(loader, key, urls, config2, xhrSettings) {
    var game2 = loader.systems.game;
    var audioConfig = game2.config.audio;
    var deviceAudio = game2.device.audio;
    if (IsPlainObject(key)) {
      urls = GetFastValue(key, "url", []);
      config2 = GetFastValue(key, "config", {});
    }
    var urlConfig = AudioFile.getAudioURL(game2, urls);
    if (!urlConfig) {
      return null;
    }
    if (deviceAudio.webAudio && !audioConfig.disableWebAudio) {
      return new AudioFile(loader, key, urlConfig, xhrSettings, game2.sound.context);
    } else {
      return new HTML5AudioFile(loader, key, urlConfig, config2);
    }
  };
  AudioFile.getAudioURL = function(game2, urls) {
    if (!Array.isArray(urls)) {
      urls = [urls];
    }
    for (var i = 0; i < urls.length; i++) {
      var url = GetFastValue(urls[i], "url", urls[i]);
      if (url.indexOf("blob:") === 0 || url.indexOf("data:") === 0) {
        return {
          url,
          type: ""
        };
      }
      var audioType = url.match(/\.([a-zA-Z0-9]+)($|\?)/);
      audioType = GetFastValue(urls[i], "type", audioType ? audioType[1] : "").toLowerCase();
      if (game2.device.audio[audioType]) {
        return {
          url,
          type: audioType
        };
      }
    }
    return null;
  };
  FileTypesManager.register("audio", function(key, urls, config2, xhrSettings) {
    var game2 = this.systems.game;
    var audioConfig = game2.config.audio;
    var deviceAudio = game2.device.audio;
    if (audioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
      return this;
    }
    var audioFile;
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        audioFile = AudioFile.create(this, key[i]);
        if (audioFile) {
          this.addFile(audioFile);
        }
      }
    } else {
      audioFile = AudioFile.create(this, key, urls, config2, xhrSettings);
      if (audioFile) {
        this.addFile(audioFile);
      }
    }
    return this;
  });
  module2.exports = AudioFile;
});

// node_modules/phaser/src/loader/filetypes/AudioSpriteFile.js
var require_AudioSpriteFile = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AudioFile = require_AudioFile();
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var JSONFile = require_JSONFile();
  var MultiFile = require_MultiFile();
  var AudioSpriteFile = new Class({
    Extends: MultiFile,
    initialize: function AudioSpriteFile2(loader, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) {
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        jsonURL = GetFastValue(config2, "jsonURL");
        audioURL = GetFastValue(config2, "audioURL");
        audioConfig = GetFastValue(config2, "audioConfig");
        audioXhrSettings = GetFastValue(config2, "audioXhrSettings");
        jsonXhrSettings = GetFastValue(config2, "jsonXhrSettings");
      }
      var data;
      if (!audioURL) {
        data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);
        MultiFile.call(this, loader, "audiosprite", key, [data]);
        this.config.resourceLoad = true;
        this.config.audioConfig = audioConfig;
        this.config.audioXhrSettings = audioXhrSettings;
      } else {
        var audio = AudioFile.create(loader, key, audioURL, audioConfig, audioXhrSettings);
        if (audio) {
          data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);
          MultiFile.call(this, loader, "audiosprite", key, [audio, data]);
          this.config.resourceLoad = false;
        }
      }
    },
    onFileComplete: function(file) {
      var index = this.files.indexOf(file);
      if (index !== -1) {
        this.pending--;
        if (this.config.resourceLoad && file.type === "json" && file.data.hasOwnProperty("resources")) {
          var urls = file.data.resources;
          var audioConfig = GetFastValue(this.config, "audioConfig");
          var audioXhrSettings = GetFastValue(this.config, "audioXhrSettings");
          var audio = AudioFile.create(this.loader, file.key, urls, audioConfig, audioXhrSettings);
          if (audio) {
            this.addToMultiFile(audio);
            this.loader.addFile(audio);
          }
        }
      }
    },
    addToCache: function() {
      if (this.isReadyToProcess()) {
        var fileA = this.files[0];
        var fileB = this.files[1];
        fileA.addToCache();
        fileB.addToCache();
        this.complete = true;
      }
    }
  });
  FileTypesManager.register("audioSprite", function(key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) {
    var game2 = this.systems.game;
    var gameAudioConfig = game2.config.audio;
    var deviceAudio = game2.device.audio;
    if (gameAudioConfig && gameAudioConfig.noAudio || !deviceAudio.webAudio && !deviceAudio.audioData) {
      return this;
    }
    var multifile;
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        multifile = new AudioSpriteFile(this, key[i]);
        if (multifile.files) {
          this.addFile(multifile.files);
        }
      }
    } else {
      multifile = new AudioSpriteFile(this, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings);
      if (multifile.files) {
        this.addFile(multifile.files);
      }
    }
    return this;
  });
});

// node_modules/phaser/src/loader/filetypes/BinaryFile.js
var require_BinaryFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var BinaryFile = new Class({
    Extends: File,
    initialize: function BinaryFile2(loader, key, url, xhrSettings, dataType) {
      var extension = "bin";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
        dataType = GetFastValue(config2, "dataType", dataType);
      }
      var fileConfig = {
        type: "binary",
        cache: loader.cacheManager.binary,
        extension,
        responseType: "arraybuffer",
        key,
        url,
        xhrSettings,
        config: {dataType}
      };
      File.call(this, loader, fileConfig);
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      var ctor = this.config.dataType;
      this.data = ctor ? new ctor(this.xhrLoader.response) : this.xhrLoader.response;
      this.onProcessComplete();
    }
  });
  FileTypesManager.register("binary", function(key, url, dataType, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new BinaryFile(this, key[i]));
      }
    } else {
      this.addFile(new BinaryFile(this, key, url, xhrSettings, dataType));
    }
    return this;
  });
  module2.exports = BinaryFile;
});

// node_modules/phaser/src/loader/filetypes/BitmapFontFile.js
var require_BitmapFontFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var ImageFile = require_ImageFile();
  var IsPlainObject = require_IsPlainObject();
  var MultiFile = require_MultiFile();
  var ParseXMLBitmapFont = require_ParseXMLBitmapFont();
  var XMLFile = require_XMLFile();
  var BitmapFontFile = new Class({
    Extends: MultiFile,
    initialize: function BitmapFontFile2(loader, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
      var image;
      var data;
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        image = new ImageFile(loader, {
          key,
          url: GetFastValue(config2, "textureURL"),
          extension: GetFastValue(config2, "textureExtension", "png"),
          normalMap: GetFastValue(config2, "normalMap"),
          xhrSettings: GetFastValue(config2, "textureXhrSettings")
        });
        data = new XMLFile(loader, {
          key,
          url: GetFastValue(config2, "fontDataURL"),
          extension: GetFastValue(config2, "fontDataExtension", "xml"),
          xhrSettings: GetFastValue(config2, "fontDataXhrSettings")
        });
      } else {
        image = new ImageFile(loader, key, textureURL, textureXhrSettings);
        data = new XMLFile(loader, key, fontDataURL, fontDataXhrSettings);
      }
      if (image.linkFile) {
        MultiFile.call(this, loader, "bitmapfont", key, [image, data, image.linkFile]);
      } else {
        MultiFile.call(this, loader, "bitmapfont", key, [image, data]);
      }
    },
    addToCache: function() {
      if (this.isReadyToProcess()) {
        var image = this.files[0];
        var xml = this.files[1];
        image.addToCache();
        xml.pendingDestroy();
        var texture = image.cache.get(image.key);
        var data = ParseXMLBitmapFont(xml.data, image.cache.getFrame(image.key), 0, 0, texture);
        this.loader.cacheManager.bitmapFont.add(image.key, {data, texture: image.key, frame: null});
        this.complete = true;
      }
    }
  });
  FileTypesManager.register("bitmapFont", function(key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) {
    var multifile;
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        multifile = new BitmapFontFile(this, key[i]);
        this.addFile(multifile.files);
      }
    } else {
      multifile = new BitmapFontFile(this, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings);
      this.addFile(multifile.files);
    }
    return this;
  });
  module2.exports = BitmapFontFile;
});

// node_modules/phaser/src/loader/filetypes/CSSFile.js
var require_CSSFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var CSSFile = new Class({
    Extends: File,
    initialize: function CSSFile2(loader, key, url, xhrSettings) {
      var extension = "css";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
      }
      var fileConfig = {
        type: "script",
        cache: false,
        extension,
        responseType: "text",
        key,
        url,
        xhrSettings
      };
      File.call(this, loader, fileConfig);
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      this.data = document.createElement("style");
      this.data.defer = false;
      this.data.innerHTML = this.xhrLoader.responseText;
      document.head.appendChild(this.data);
      this.onProcessComplete();
    }
  });
  FileTypesManager.register("css", function(key, url, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new CSSFile(this, key[i]));
      }
    } else {
      this.addFile(new CSSFile(this, key, url, xhrSettings));
    }
    return this;
  });
  module2.exports = CSSFile;
});

// node_modules/phaser/src/loader/filetypes/GLSLFile.js
var require_GLSLFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var Shader = require_BaseShader();
  var GLSLFile = new Class({
    Extends: File,
    initialize: function GLSLFile2(loader, key, url, shaderType, xhrSettings) {
      var extension = "glsl";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        shaderType = GetFastValue(config2, "shaderType", "fragment");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
      } else if (shaderType === void 0) {
        shaderType = "fragment";
      }
      var fileConfig = {
        type: "glsl",
        cache: loader.cacheManager.shader,
        extension,
        responseType: "text",
        key,
        url,
        config: {
          shaderType
        },
        xhrSettings
      };
      File.call(this, loader, fileConfig);
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      this.data = this.xhrLoader.responseText;
      this.onProcessComplete();
    },
    addToCache: function() {
      var data = this.data.split("\n");
      var block = this.extractBlock(data, 0);
      if (block) {
        while (block) {
          var key = this.getShaderName(block.header);
          var shaderType = this.getShaderType(block.header);
          var uniforms = this.getShaderUniforms(block.header);
          var shaderSrc = block.shader;
          if (this.cache.has(key)) {
            var shader = this.cache.get(key);
            if (shaderType === "fragment") {
              shader.fragmentSrc = shaderSrc;
            } else {
              shader.vertexSrc = shaderSrc;
            }
            if (!shader.uniforms) {
              shader.uniforms = uniforms;
            }
          } else if (shaderType === "fragment") {
            this.cache.add(key, new Shader(key, shaderSrc, "", uniforms));
          } else {
            this.cache.add(key, new Shader(key, "", shaderSrc, uniforms));
          }
          block = this.extractBlock(data, block.offset);
        }
      } else if (this.config.shaderType === "fragment") {
        this.cache.add(this.key, new Shader(this.key, this.data));
      } else {
        this.cache.add(this.key, new Shader(this.key, "", this.data));
      }
      this.pendingDestroy();
    },
    getShaderName: function(headerSource) {
      for (var i = 0; i < headerSource.length; i++) {
        var line = headerSource[i].trim();
        if (line.substring(0, 5) === "name:") {
          return line.substring(5).trim();
        }
      }
      return this.key;
    },
    getShaderType: function(headerSource) {
      for (var i = 0; i < headerSource.length; i++) {
        var line = headerSource[i].trim();
        if (line.substring(0, 5) === "type:") {
          return line.substring(5).trim();
        }
      }
      return this.config.shaderType;
    },
    getShaderUniforms: function(headerSource) {
      var uniforms = {};
      for (var i = 0; i < headerSource.length; i++) {
        var line = headerSource[i].trim();
        if (line.substring(0, 8) === "uniform.") {
          var pos = line.indexOf(":");
          if (pos) {
            var key = line.substring(8, pos);
            try {
              uniforms[key] = JSON.parse(line.substring(pos + 1));
            } catch (e) {
              console.warn("Invalid uniform JSON: " + key);
            }
          }
        }
      }
      return uniforms;
    },
    extractBlock: function(data, offset) {
      var headerStart = -1;
      var headerEnd = -1;
      var blockEnd = -1;
      var headerOpen = false;
      var captureSource = false;
      var headerSource = [];
      var shaderSource = [];
      for (var i = offset; i < data.length; i++) {
        var line = data[i].trim();
        if (line === "---") {
          if (headerStart === -1) {
            headerStart = i;
            headerOpen = true;
          } else if (headerOpen) {
            headerEnd = i;
            headerOpen = false;
            captureSource = true;
          } else {
            captureSource = false;
            break;
          }
        } else if (headerOpen) {
          headerSource.push(line);
        } else if (captureSource) {
          shaderSource.push(line);
          blockEnd = i;
        }
      }
      if (!headerOpen && headerEnd !== -1) {
        return {header: headerSource, shader: shaderSource.join("\n"), offset: blockEnd};
      } else {
        return null;
      }
    }
  });
  FileTypesManager.register("glsl", function(key, url, shaderType, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new GLSLFile(this, key[i]));
      }
    } else {
      this.addFile(new GLSLFile(this, key, url, shaderType, xhrSettings));
    }
    return this;
  });
  module2.exports = GLSLFile;
});

// node_modules/phaser/src/loader/filetypes/HTMLFile.js
var require_HTMLFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var HTMLFile = new Class({
    Extends: File,
    initialize: function HTMLFile2(loader, key, url, xhrSettings) {
      var extension = "html";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
      }
      var fileConfig = {
        type: "text",
        cache: loader.cacheManager.html,
        extension,
        responseType: "text",
        key,
        url,
        xhrSettings
      };
      File.call(this, loader, fileConfig);
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      this.data = this.xhrLoader.responseText;
      this.onProcessComplete();
    }
  });
  FileTypesManager.register("html", function(key, url, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new HTMLFile(this, key[i]));
      }
    } else {
      this.addFile(new HTMLFile(this, key, url, xhrSettings));
    }
    return this;
  });
  module2.exports = HTMLFile;
});

// node_modules/phaser/src/loader/filetypes/HTMLTextureFile.js
var require_HTMLTextureFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var HTMLTextureFile = new Class({
    Extends: File,
    initialize: function HTMLTextureFile2(loader, key, url, width, height, xhrSettings) {
      if (width === void 0) {
        width = 512;
      }
      if (height === void 0) {
        height = 512;
      }
      var extension = "html";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
        width = GetFastValue(config2, "width", width);
        height = GetFastValue(config2, "height", height);
      }
      var fileConfig = {
        type: "html",
        cache: loader.textureManager,
        extension,
        responseType: "text",
        key,
        url,
        xhrSettings,
        config: {
          width,
          height
        }
      };
      File.call(this, loader, fileConfig);
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      var w = this.config.width;
      var h = this.config.height;
      var data = [];
      data.push('<svg width="' + w + 'px" height="' + h + 'px" viewBox="0 0 ' + w + " " + h + '" xmlns="http://www.w3.org/2000/svg">');
      data.push('<foreignObject width="100%" height="100%">');
      data.push('<body xmlns="http://www.w3.org/1999/xhtml">');
      data.push(this.xhrLoader.responseText);
      data.push("</body>");
      data.push("</foreignObject>");
      data.push("</svg>");
      var svg = [data.join("\n")];
      var _this = this;
      try {
        var blob = new window.Blob(svg, {type: "image/svg+xml;charset=utf-8"});
      } catch (e) {
        _this.state = CONST.FILE_ERRORED;
        _this.onProcessComplete();
        return;
      }
      this.data = new Image();
      this.data.crossOrigin = this.crossOrigin;
      this.data.onload = function() {
        File.revokeObjectURL(_this.data);
        _this.onProcessComplete();
      };
      this.data.onerror = function() {
        File.revokeObjectURL(_this.data);
        _this.onProcessError();
      };
      File.createObjectURL(this.data, blob, "image/svg+xml");
    },
    addToCache: function() {
      var texture = this.cache.addImage(this.key, this.data);
      this.pendingDestroy(texture);
    }
  });
  FileTypesManager.register("htmlTexture", function(key, url, width, height, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new HTMLTextureFile(this, key[i]));
      }
    } else {
      this.addFile(new HTMLTextureFile(this, key, url, width, height, xhrSettings));
    }
    return this;
  });
  module2.exports = HTMLTextureFile;
});

// node_modules/phaser/src/loader/filetypes/MultiAtlasFile.js
var require_MultiAtlasFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var ImageFile = require_ImageFile();
  var IsPlainObject = require_IsPlainObject();
  var JSONFile = require_JSONFile();
  var MultiFile = require_MultiFile();
  var MultiAtlasFile = new Class({
    Extends: MultiFile,
    initialize: function MultiAtlasFile2(loader, key, atlasURL, path, baseURL, atlasXhrSettings, textureXhrSettings) {
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        if (GetFastValue(config2, "url", false)) {
          atlasURL = GetFastValue(config2, "url");
        } else {
          atlasURL = GetFastValue(config2, "atlasURL");
        }
        atlasXhrSettings = GetFastValue(config2, "xhrSettings");
        path = GetFastValue(config2, "path");
        baseURL = GetFastValue(config2, "baseURL");
        textureXhrSettings = GetFastValue(config2, "textureXhrSettings");
      }
      var data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);
      MultiFile.call(this, loader, "multiatlas", key, [data]);
      this.config.path = path;
      this.config.baseURL = baseURL;
      this.config.textureXhrSettings = textureXhrSettings;
    },
    onFileComplete: function(file) {
      var index = this.files.indexOf(file);
      if (index !== -1) {
        this.pending--;
        if (file.type === "json" && file.data.hasOwnProperty("textures")) {
          var textures = file.data.textures;
          var config2 = this.config;
          var loader = this.loader;
          var currentBaseURL = loader.baseURL;
          var currentPath = loader.path;
          var currentPrefix = loader.prefix;
          var baseURL = GetFastValue(config2, "baseURL", this.baseURL);
          var path = GetFastValue(config2, "path", this.path);
          var prefix = GetFastValue(config2, "prefix", this.prefix);
          var textureXhrSettings = GetFastValue(config2, "textureXhrSettings");
          loader.setBaseURL(baseURL);
          loader.setPath(path);
          loader.setPrefix(prefix);
          for (var i = 0; i < textures.length; i++) {
            var textureURL = textures[i].image;
            var key = "MA" + this.multiKeyIndex + "_" + textureURL;
            var image = new ImageFile(loader, key, textureURL, textureXhrSettings);
            this.addToMultiFile(image);
            loader.addFile(image);
            if (textures[i].normalMap) {
              var normalMap = new ImageFile(loader, key, textures[i].normalMap, textureXhrSettings);
              normalMap.type = "normalMap";
              image.setLink(normalMap);
              this.addToMultiFile(normalMap);
              loader.addFile(normalMap);
            }
          }
          loader.setBaseURL(currentBaseURL);
          loader.setPath(currentPath);
          loader.setPrefix(currentPrefix);
        }
      }
    },
    addToCache: function() {
      if (this.isReadyToProcess()) {
        var fileJSON = this.files[0];
        var data = [];
        var images = [];
        var normalMaps = [];
        for (var i = 1; i < this.files.length; i++) {
          var file = this.files[i];
          if (file.type === "normalMap") {
            continue;
          }
          var pos = file.key.indexOf("_");
          var key = file.key.substr(pos + 1);
          var image = file.data;
          for (var t = 0; t < fileJSON.data.textures.length; t++) {
            var item = fileJSON.data.textures[t];
            if (item.image === key) {
              images.push(image);
              data.push(item);
              if (file.linkFile) {
                normalMaps.push(file.linkFile.data);
              }
              break;
            }
          }
        }
        if (normalMaps.length === 0) {
          normalMaps = void 0;
        }
        this.loader.textureManager.addAtlasJSONArray(this.key, images, data, normalMaps);
        this.complete = true;
        for (i = 0; i < this.files.length; i++) {
          this.files[i].pendingDestroy();
        }
      }
    }
  });
  FileTypesManager.register("multiatlas", function(key, atlasURL, path, baseURL, atlasXhrSettings) {
    var multifile;
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        multifile = new MultiAtlasFile(this, key[i]);
        this.addFile(multifile.files);
      }
    } else {
      multifile = new MultiAtlasFile(this, key, atlasURL, path, baseURL, atlasXhrSettings);
      this.addFile(multifile.files);
    }
    return this;
  });
  module2.exports = MultiAtlasFile;
});

// node_modules/phaser/src/loader/filetypes/ScriptFile.js
var require_ScriptFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var ScriptFile = new Class({
    Extends: File,
    initialize: function ScriptFile2(loader, key, url, xhrSettings) {
      var extension = "js";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
      }
      var fileConfig = {
        type: "script",
        cache: false,
        extension,
        responseType: "text",
        key,
        url,
        xhrSettings
      };
      File.call(this, loader, fileConfig);
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      this.data = document.createElement("script");
      this.data.language = "javascript";
      this.data.type = "text/javascript";
      this.data.defer = false;
      this.data.text = this.xhrLoader.responseText;
      document.head.appendChild(this.data);
      this.onProcessComplete();
    }
  });
  FileTypesManager.register("script", function(key, url, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new ScriptFile(this, key[i]));
      }
    } else {
      this.addFile(new ScriptFile(this, key, url, xhrSettings));
    }
    return this;
  });
  module2.exports = ScriptFile;
});

// node_modules/phaser/src/loader/filetypes/MultiScriptFile.js
var require_MultiScriptFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var MultiFile = require_MultiFile();
  var ScriptFile = require_ScriptFile();
  var MultiScriptFile = new Class({
    Extends: MultiFile,
    initialize: function MultiScriptFile2(loader, key, url, xhrSettings) {
      var extension = "js";
      var files = [];
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
      }
      if (!Array.isArray(url)) {
        url = [url];
      }
      for (var i = 0; i < url.length; i++) {
        var scriptFile = new ScriptFile(loader, {
          key: key + "_" + i.toString(),
          url: url[i],
          extension,
          xhrSettings
        });
        scriptFile.onProcess = function() {
          this.onProcessComplete();
        };
        files.push(scriptFile);
      }
      MultiFile.call(this, loader, "scripts", key, files);
    },
    addToCache: function() {
      if (this.isReadyToProcess()) {
        for (var i = 0; i < this.files.length; i++) {
          var file = this.files[i];
          file.data = document.createElement("script");
          file.data.language = "javascript";
          file.data.type = "text/javascript";
          file.data.defer = false;
          file.data.text = file.xhrLoader.responseText;
          document.head.appendChild(file.data);
        }
        this.complete = true;
      }
    }
  });
  FileTypesManager.register("scripts", function(key, url, xhrSettings) {
    var multifile;
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        multifile = new MultiScriptFile(this, key[i]);
        this.addFile(multifile.files);
      }
    } else {
      multifile = new MultiScriptFile(this, key, url, xhrSettings);
      this.addFile(multifile.files);
    }
    return this;
  });
  module2.exports = MultiScriptFile;
});

// node_modules/phaser/src/loader/filetypes/TextFile.js
var require_TextFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var TextFile = new Class({
    Extends: File,
    initialize: function TextFile2(loader, key, url, xhrSettings) {
      var type = "text";
      var extension = "txt";
      var cache = loader.cacheManager.text;
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
        type = GetFastValue(config2, "type", type);
        cache = GetFastValue(config2, "cache", cache);
      }
      var fileConfig = {
        type,
        cache,
        extension,
        responseType: "text",
        key,
        url,
        xhrSettings
      };
      File.call(this, loader, fileConfig);
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      this.data = this.xhrLoader.responseText;
      this.onProcessComplete();
    }
  });
  FileTypesManager.register("text", function(key, url, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new TextFile(this, key[i]));
      }
    } else {
      this.addFile(new TextFile(this, key, url, xhrSettings));
    }
    return this;
  });
  module2.exports = TextFile;
});

// node_modules/phaser/src/loader/filetypes/OBJFile.js
var require_OBJFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var MultiFile = require_MultiFile();
  var ParseObj = require_ParseObj();
  var ParseObjMaterial = require_ParseObjMaterial();
  var TextFile = require_TextFile();
  var OBJFile = new Class({
    Extends: MultiFile,
    initialize: function OBJFile2(loader, key, objURL, matURL, flipUV, xhrSettings) {
      var obj;
      var mat;
      var cache = loader.cacheManager.obj;
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        obj = new TextFile(loader, {
          key,
          type: "obj",
          cache,
          url: GetFastValue(config2, "url"),
          extension: GetFastValue(config2, "extension", "obj"),
          xhrSettings: GetFastValue(config2, "xhrSettings"),
          config: {
            flipUV: GetFastValue(config2, "flipUV", flipUV)
          }
        });
        matURL = GetFastValue(config2, "matURL");
        if (matURL) {
          mat = new TextFile(loader, {
            key,
            type: "mat",
            cache,
            url: matURL,
            extension: GetFastValue(config2, "matExtension", "mat"),
            xhrSettings: GetFastValue(config2, "xhrSettings")
          });
        }
      } else {
        obj = new TextFile(loader, {
          key,
          url: objURL,
          type: "obj",
          cache,
          extension: "obj",
          xhrSettings,
          config: {
            flipUV
          }
        });
        if (matURL) {
          mat = new TextFile(loader, {
            key,
            url: matURL,
            type: "mat",
            cache,
            extension: "mat",
            xhrSettings
          });
        }
      }
      MultiFile.call(this, loader, "obj", key, [obj, mat]);
    },
    addToCache: function() {
      if (this.isReadyToProcess()) {
        var obj = this.files[0];
        var mat = this.files[1];
        var objData = ParseObj(obj.data, obj.config.flipUV);
        if (mat) {
          objData.materials = ParseObjMaterial(mat.data);
        }
        obj.cache.add(obj.key, objData);
        this.complete = true;
      }
    }
  });
  FileTypesManager.register("obj", function(key, objURL, matURL, flipUVs, xhrSettings) {
    var multifile;
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        multifile = new OBJFile(this, key[i]);
        this.addFile(multifile.files);
      }
    } else {
      multifile = new OBJFile(this, key, objURL, matURL, flipUVs, xhrSettings);
      this.addFile(multifile.files);
    }
    return this;
  });
  module2.exports = OBJFile;
});

// node_modules/phaser/src/loader/filetypes/PackFile.js
var require_PackFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var FileTypesManager = require_FileTypesManager();
  var JSONFile = require_JSONFile();
  var PackFile = new Class({
    Extends: JSONFile,
    initialize: function PackFile2(loader, key, url, xhrSettings, dataKey) {
      JSONFile.call(this, loader, key, url, xhrSettings, dataKey);
      this.type = "packfile";
    },
    onProcess: function() {
      if (this.state !== CONST.FILE_POPULATED) {
        this.state = CONST.FILE_PROCESSING;
        this.data = JSON.parse(this.xhrLoader.responseText);
      }
      this.loader.addPack(this.data, this.config);
      this.onProcessComplete();
    }
  });
  FileTypesManager.register("pack", function(key, url, packKey, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new PackFile(this, key[i]));
      }
    } else {
      this.addFile(new PackFile(this, key, url, xhrSettings, packKey));
    }
    return this;
  });
  module2.exports = PackFile;
});

// node_modules/phaser/src/loader/filetypes/PluginFile.js
var require_PluginFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var PluginFile = new Class({
    Extends: File,
    initialize: function PluginFile2(loader, key, url, start, mapping, xhrSettings) {
      var extension = "js";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
        start = GetFastValue(config2, "start");
        mapping = GetFastValue(config2, "mapping");
      }
      var fileConfig = {
        type: "plugin",
        cache: false,
        extension,
        responseType: "text",
        key,
        url,
        xhrSettings,
        config: {
          start,
          mapping
        }
      };
      File.call(this, loader, fileConfig);
      if (typeof url === "function") {
        this.data = url;
        this.state = CONST.FILE_POPULATED;
      }
    },
    onProcess: function() {
      var pluginManager = this.loader.systems.plugins;
      var config2 = this.config;
      var start = GetFastValue(config2, "start", false);
      var mapping = GetFastValue(config2, "mapping", null);
      if (this.state === CONST.FILE_POPULATED) {
        pluginManager.install(this.key, this.data, start, mapping);
      } else {
        this.state = CONST.FILE_PROCESSING;
        this.data = document.createElement("script");
        this.data.language = "javascript";
        this.data.type = "text/javascript";
        this.data.defer = false;
        this.data.text = this.xhrLoader.responseText;
        document.head.appendChild(this.data);
        var plugin = pluginManager.install(this.key, window[this.key], start, mapping);
        if (start || mapping) {
          this.loader.systems[mapping] = plugin;
          this.loader.scene[mapping] = plugin;
        }
      }
      this.onProcessComplete();
    }
  });
  FileTypesManager.register("plugin", function(key, url, start, mapping, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new PluginFile(this, key[i]));
      }
    } else {
      this.addFile(new PluginFile(this, key, url, start, mapping, xhrSettings));
    }
    return this;
  });
  module2.exports = PluginFile;
});

// node_modules/phaser/src/loader/filetypes/SceneFile.js
var require_SceneFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var SceneFile = new Class({
    Extends: File,
    initialize: function SceneFile2(loader, key, url, xhrSettings) {
      var extension = "js";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
      }
      var fileConfig = {
        type: "text",
        extension,
        responseType: "text",
        key,
        url,
        xhrSettings
      };
      File.call(this, loader, fileConfig);
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      this.data = this.xhrLoader.responseText;
      this.onProcessComplete();
    },
    addToCache: function() {
      var code = this.data.concat("(function(){\nreturn new " + this.key + "();\n}).call(this);");
      var eval2 = eval;
      this.loader.sceneManager.add(this.key, eval2(code));
      this.complete = true;
    }
  });
  FileTypesManager.register("sceneFile", function(key, url, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new SceneFile(this, key[i]));
      }
    } else {
      this.addFile(new SceneFile(this, key, url, xhrSettings));
    }
    return this;
  });
  module2.exports = SceneFile;
});

// node_modules/phaser/src/loader/filetypes/ScenePluginFile.js
var require_ScenePluginFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var ScenePluginFile = new Class({
    Extends: File,
    initialize: function ScenePluginFile2(loader, key, url, systemKey, sceneKey, xhrSettings) {
      var extension = "js";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
        systemKey = GetFastValue(config2, "systemKey");
        sceneKey = GetFastValue(config2, "sceneKey");
      }
      var fileConfig = {
        type: "scenePlugin",
        cache: false,
        extension,
        responseType: "text",
        key,
        url,
        xhrSettings,
        config: {
          systemKey,
          sceneKey
        }
      };
      File.call(this, loader, fileConfig);
      if (typeof url === "function") {
        this.data = url;
        this.state = CONST.FILE_POPULATED;
      }
    },
    onProcess: function() {
      var pluginManager = this.loader.systems.plugins;
      var config2 = this.config;
      var key = this.key;
      var systemKey = GetFastValue(config2, "systemKey", key);
      var sceneKey = GetFastValue(config2, "sceneKey", key);
      if (this.state === CONST.FILE_POPULATED) {
        pluginManager.installScenePlugin(systemKey, this.data, sceneKey, this.loader.scene, true);
      } else {
        this.state = CONST.FILE_PROCESSING;
        this.data = document.createElement("script");
        this.data.language = "javascript";
        this.data.type = "text/javascript";
        this.data.defer = false;
        this.data.text = this.xhrLoader.responseText;
        document.head.appendChild(this.data);
        pluginManager.installScenePlugin(systemKey, window[this.key], sceneKey, this.loader.scene, true);
      }
      this.onProcessComplete();
    }
  });
  FileTypesManager.register("scenePlugin", function(key, url, systemKey, sceneKey, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new ScenePluginFile(this, key[i]));
      }
    } else {
      this.addFile(new ScenePluginFile(this, key, url, systemKey, sceneKey, xhrSettings));
    }
    return this;
  });
  module2.exports = ScenePluginFile;
});

// node_modules/phaser/src/loader/filetypes/SpriteSheetFile.js
var require_SpriteSheetFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var ImageFile = require_ImageFile();
  var SpriteSheetFile = new Class({
    Extends: ImageFile,
    initialize: function SpriteSheetFile2(loader, key, url, frameConfig, xhrSettings) {
      ImageFile.call(this, loader, key, url, xhrSettings, frameConfig);
      this.type = "spritesheet";
    },
    addToCache: function() {
      var texture = this.cache.addSpriteSheet(this.key, this.data, this.config);
      this.pendingDestroy(texture);
    }
  });
  FileTypesManager.register("spritesheet", function(key, url, frameConfig, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new SpriteSheetFile(this, key[i]));
      }
    } else {
      this.addFile(new SpriteSheetFile(this, key, url, frameConfig, xhrSettings));
    }
    return this;
  });
  module2.exports = SpriteSheetFile;
});

// node_modules/phaser/src/loader/filetypes/SVGFile.js
var require_SVGFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var SVGFile = new Class({
    Extends: File,
    initialize: function SVGFile2(loader, key, url, svgConfig, xhrSettings) {
      var extension = "svg";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        svgConfig = GetFastValue(config2, "svgConfig", {});
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
      }
      var fileConfig = {
        type: "svg",
        cache: loader.textureManager,
        extension,
        responseType: "text",
        key,
        url,
        xhrSettings,
        config: {
          width: GetFastValue(svgConfig, "width"),
          height: GetFastValue(svgConfig, "height"),
          scale: GetFastValue(svgConfig, "scale")
        }
      };
      File.call(this, loader, fileConfig);
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      var text = this.xhrLoader.responseText;
      var svg = [text];
      var width = this.config.width;
      var height = this.config.height;
      var scale = this.config.scale;
      resize:
        if (width && height || scale) {
          var xml = null;
          var parser = new DOMParser();
          xml = parser.parseFromString(text, "text/xml");
          var svgXML = xml.getElementsByTagName("svg")[0];
          var hasViewBox = svgXML.hasAttribute("viewBox");
          var svgWidth = parseFloat(svgXML.getAttribute("width"));
          var svgHeight = parseFloat(svgXML.getAttribute("height"));
          if (!hasViewBox && svgWidth && svgHeight) {
            svgXML.setAttribute("viewBox", "0  0 " + svgWidth + " " + svgHeight);
          } else if (hasViewBox && !svgWidth && !svgHeight) {
            var viewBox = svgXML.getAttribute("viewBox").split(/\s+|,/);
            svgWidth = viewBox[2];
            svgHeight = viewBox[3];
          }
          if (scale) {
            if (svgWidth && svgHeight) {
              width = svgWidth * scale;
              height = svgHeight * scale;
            } else {
              break resize;
            }
          }
          svgXML.setAttribute("width", width.toString() + "px");
          svgXML.setAttribute("height", height.toString() + "px");
          svg = [new XMLSerializer().serializeToString(svgXML)];
        }
      try {
        var blob = new window.Blob(svg, {type: "image/svg+xml;charset=utf-8"});
      } catch (e) {
        this.onProcessError();
        return;
      }
      this.data = new Image();
      this.data.crossOrigin = this.crossOrigin;
      var _this = this;
      var retry = false;
      this.data.onload = function() {
        if (!retry) {
          File.revokeObjectURL(_this.data);
        }
        _this.onProcessComplete();
      };
      this.data.onerror = function() {
        if (!retry) {
          retry = true;
          File.revokeObjectURL(_this.data);
          _this.data.src = "data:image/svg+xml," + encodeURIComponent(svg.join(""));
        } else {
          _this.onProcessError();
        }
      };
      File.createObjectURL(this.data, blob, "image/svg+xml");
    },
    addToCache: function() {
      var texture = this.cache.addImage(this.key, this.data);
      this.pendingDestroy(texture);
    }
  });
  FileTypesManager.register("svg", function(key, url, svgConfig, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new SVGFile(this, key[i]));
      }
    } else {
      this.addFile(new SVGFile(this, key, url, svgConfig, xhrSettings));
    }
    return this;
  });
  module2.exports = SVGFile;
});

// node_modules/phaser/src/tilemaps/Formats.js
var require_Formats = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    CSV: 0,
    TILED_JSON: 1,
    ARRAY_2D: 2,
    WELTMEISTER: 3
  };
});

// node_modules/phaser/src/loader/filetypes/TilemapCSVFile.js
var require_TilemapCSVFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var TILEMAP_FORMATS = require_Formats();
  var TilemapCSVFile = new Class({
    Extends: File,
    initialize: function TilemapCSVFile2(loader, key, url, xhrSettings) {
      var extension = "csv";
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        url = GetFastValue(config2, "url");
        xhrSettings = GetFastValue(config2, "xhrSettings");
        extension = GetFastValue(config2, "extension", extension);
      }
      var fileConfig = {
        type: "tilemapCSV",
        cache: loader.cacheManager.tilemap,
        extension,
        responseType: "text",
        key,
        url,
        xhrSettings
      };
      File.call(this, loader, fileConfig);
      this.tilemapFormat = TILEMAP_FORMATS.CSV;
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      this.data = this.xhrLoader.responseText;
      this.onProcessComplete();
    },
    addToCache: function() {
      var tiledata = {format: this.tilemapFormat, data: this.data};
      this.cache.add(this.key, tiledata);
      this.pendingDestroy(tiledata);
    }
  });
  FileTypesManager.register("tilemapCSV", function(key, url, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new TilemapCSVFile(this, key[i]));
      }
    } else {
      this.addFile(new TilemapCSVFile(this, key, url, xhrSettings));
    }
    return this;
  });
  module2.exports = TilemapCSVFile;
});

// node_modules/phaser/src/loader/filetypes/TilemapImpactFile.js
var require_TilemapImpactFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var JSONFile = require_JSONFile();
  var TILEMAP_FORMATS = require_Formats();
  var TilemapImpactFile = new Class({
    Extends: JSONFile,
    initialize: function TilemapImpactFile2(loader, key, url, xhrSettings) {
      JSONFile.call(this, loader, key, url, xhrSettings);
      this.type = "tilemapJSON";
      this.cache = loader.cacheManager.tilemap;
    },
    addToCache: function() {
      var tiledata = {format: TILEMAP_FORMATS.WELTMEISTER, data: this.data};
      this.cache.add(this.key, tiledata);
      this.pendingDestroy(tiledata);
    }
  });
  FileTypesManager.register("tilemapImpact", function(key, url, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new TilemapImpactFile(this, key[i]));
      }
    } else {
      this.addFile(new TilemapImpactFile(this, key, url, xhrSettings));
    }
    return this;
  });
  module2.exports = TilemapImpactFile;
});

// node_modules/phaser/src/loader/filetypes/TilemapJSONFile.js
var require_TilemapJSONFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var JSONFile = require_JSONFile();
  var TILEMAP_FORMATS = require_Formats();
  var TilemapJSONFile = new Class({
    Extends: JSONFile,
    initialize: function TilemapJSONFile2(loader, key, url, xhrSettings) {
      JSONFile.call(this, loader, key, url, xhrSettings);
      this.type = "tilemapJSON";
      this.cache = loader.cacheManager.tilemap;
    },
    addToCache: function() {
      var tiledata = {format: TILEMAP_FORMATS.TILED_JSON, data: this.data};
      this.cache.add(this.key, tiledata);
      this.pendingDestroy(tiledata);
    }
  });
  FileTypesManager.register("tilemapTiledJSON", function(key, url, xhrSettings) {
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        this.addFile(new TilemapJSONFile(this, key[i]));
      }
    } else {
      this.addFile(new TilemapJSONFile(this, key, url, xhrSettings));
    }
    return this;
  });
  module2.exports = TilemapJSONFile;
});

// node_modules/phaser/src/loader/filetypes/UnityAtlasFile.js
var require_UnityAtlasFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var ImageFile = require_ImageFile();
  var IsPlainObject = require_IsPlainObject();
  var MultiFile = require_MultiFile();
  var TextFile = require_TextFile();
  var UnityAtlasFile = new Class({
    Extends: MultiFile,
    initialize: function UnityAtlasFile2(loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
      var image;
      var data;
      if (IsPlainObject(key)) {
        var config2 = key;
        key = GetFastValue(config2, "key");
        image = new ImageFile(loader, {
          key,
          url: GetFastValue(config2, "textureURL"),
          extension: GetFastValue(config2, "textureExtension", "png"),
          normalMap: GetFastValue(config2, "normalMap"),
          xhrSettings: GetFastValue(config2, "textureXhrSettings")
        });
        data = new TextFile(loader, {
          key,
          url: GetFastValue(config2, "atlasURL"),
          extension: GetFastValue(config2, "atlasExtension", "txt"),
          xhrSettings: GetFastValue(config2, "atlasXhrSettings")
        });
      } else {
        image = new ImageFile(loader, key, textureURL, textureXhrSettings);
        data = new TextFile(loader, key, atlasURL, atlasXhrSettings);
      }
      if (image.linkFile) {
        MultiFile.call(this, loader, "unityatlas", key, [image, data, image.linkFile]);
      } else {
        MultiFile.call(this, loader, "unityatlas", key, [image, data]);
      }
    },
    addToCache: function() {
      if (this.isReadyToProcess()) {
        var image = this.files[0];
        var text = this.files[1];
        var normalMap = this.files[2] ? this.files[2].data : null;
        this.loader.textureManager.addUnityAtlas(image.key, image.data, text.data, normalMap);
        text.pendingDestroy();
        this.complete = true;
      }
    }
  });
  FileTypesManager.register("unityAtlas", function(key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) {
    var multifile;
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        multifile = new UnityAtlasFile(this, key[i]);
        this.addFile(multifile.files);
      }
    } else {
      multifile = new UnityAtlasFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);
      this.addFile(multifile.files);
    }
    return this;
  });
  module2.exports = UnityAtlasFile;
});

// node_modules/phaser/src/loader/filetypes/VideoFile.js
var require_VideoFile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var File = require_File();
  var FileTypesManager = require_FileTypesManager();
  var GetURL = require_GetURL();
  var GetFastValue = require_GetFastValue();
  var IsPlainObject = require_IsPlainObject();
  var VideoFile = new Class({
    Extends: File,
    initialize: function VideoFile2(loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings) {
      if (loadEvent === void 0) {
        loadEvent = "loadeddata";
      }
      if (asBlob === void 0) {
        asBlob = false;
      }
      if (noAudio === void 0) {
        noAudio = false;
      }
      if (loadEvent !== "loadeddata" && loadEvent !== "canplay" && loadEvent !== "canplaythrough") {
        loadEvent = "loadeddata";
      }
      var fileConfig = {
        type: "video",
        cache: loader.cacheManager.video,
        extension: urlConfig.type,
        responseType: "blob",
        key,
        url: urlConfig.url,
        xhrSettings,
        config: {
          loadEvent,
          asBlob,
          noAudio
        }
      };
      this.onLoadCallback = this.onVideoLoadHandler.bind(this);
      this.onErrorCallback = this.onVideoErrorHandler.bind(this);
      File.call(this, loader, fileConfig);
    },
    onProcess: function() {
      this.state = CONST.FILE_PROCESSING;
      if (!this.config.asBlob) {
        this.onProcessComplete();
        return;
      }
      var video = this.createVideoElement();
      this.data = video;
      var _this = this;
      this.data.onloadeddata = function() {
        _this.onProcessComplete();
      };
      this.data.onerror = function() {
        File.revokeObjectURL(_this.data);
        _this.onProcessError();
      };
      File.createObjectURL(video, this.xhrLoader.response, "");
      video.load();
    },
    createVideoElement: function() {
      var video = document.createElement("video");
      video.controls = false;
      video.crossOrigin = this.loader.crossOrigin;
      if (this.config.noAudio) {
        video.muted = true;
        video.defaultMuted = true;
        video.setAttribute("autoplay", "autoplay");
      }
      video.setAttribute("playsinline", "playsinline");
      video.setAttribute("preload", "auto");
      return video;
    },
    onVideoLoadHandler: function(event) {
      var video = event.target;
      video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);
      video.removeEventListener("error", this.onErrorCallback, true);
      this.data = video;
      this.resetXHR();
      this.loader.nextFile(this, true);
    },
    onVideoErrorHandler: function(event) {
      var video = event.target;
      if (video) {
        video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);
        video.removeEventListener("error", this.onErrorCallback, true);
      }
      this.resetXHR();
      this.loader.nextFile(this, false);
    },
    load: function() {
      var loadEvent = this.config.loadEvent;
      if (this.config.asBlob) {
        File.prototype.load.call(this);
      } else {
        this.percentComplete = 0;
        var video = this.createVideoElement();
        video.addEventListener(loadEvent, this.onLoadCallback, true);
        video.addEventListener("error", this.onErrorCallback, true);
        video.src = GetURL(this, this.loader.baseURL);
        video.load();
      }
    }
  });
  VideoFile.create = function(loader, key, urls, loadEvent, asBlob, noAudio, xhrSettings) {
    var game2 = loader.systems.game;
    if (IsPlainObject(key)) {
      urls = GetFastValue(key, "url", []);
      loadEvent = GetFastValue(key, "loadEvent", "loadeddata");
      asBlob = GetFastValue(key, "asBlob", false);
      noAudio = GetFastValue(key, "noAudio", false);
      xhrSettings = GetFastValue(key, "xhrSettings");
      key = GetFastValue(key, "key");
    }
    var urlConfig = VideoFile.getVideoURL(game2, urls);
    if (urlConfig) {
      return new VideoFile(loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings);
    }
  };
  VideoFile.getVideoURL = function(game2, urls) {
    if (!Array.isArray(urls)) {
      urls = [urls];
    }
    for (var i = 0; i < urls.length; i++) {
      var url = GetFastValue(urls[i], "url", urls[i]);
      if (url.indexOf("blob:") === 0) {
        return {
          url,
          type: ""
        };
      }
      var videoType;
      if (url.indexOf("data:") === 0) {
        videoType = url.split(",")[0].match(/\/(.*?);/);
      } else {
        videoType = url.match(/\.([a-zA-Z0-9]+)($|\?)/);
      }
      videoType = GetFastValue(urls[i], "type", videoType ? videoType[1] : "").toLowerCase();
      if (game2.device.video[videoType]) {
        return {
          url,
          type: videoType
        };
      }
    }
    return null;
  };
  FileTypesManager.register("video", function(key, urls, loadEvent, asBlob, noAudio, xhrSettings) {
    var videoFile;
    if (Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        videoFile = VideoFile.create(this, key[i]);
        if (videoFile) {
          this.addFile(videoFile);
        }
      }
    } else {
      videoFile = VideoFile.create(this, key, urls, loadEvent, asBlob, noAudio, xhrSettings);
      if (videoFile) {
        this.addFile(videoFile);
      }
    }
    return this;
  });
  module2.exports = VideoFile;
});

// node_modules/phaser/src/loader/filetypes/index.js
var require_filetypes = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    AnimationJSONFile: require_AnimationJSONFile(),
    AsepriteFile: require_AsepriteFile(),
    AtlasJSONFile: require_AtlasJSONFile(),
    AtlasXMLFile: require_AtlasXMLFile(),
    AudioFile: require_AudioFile(),
    AudioSpriteFile: require_AudioSpriteFile(),
    BinaryFile: require_BinaryFile(),
    BitmapFontFile: require_BitmapFontFile(),
    CSSFile: require_CSSFile(),
    GLSLFile: require_GLSLFile(),
    HTML5AudioFile: require_HTML5AudioFile(),
    HTMLFile: require_HTMLFile(),
    HTMLTextureFile: require_HTMLTextureFile(),
    ImageFile: require_ImageFile(),
    JSONFile: require_JSONFile(),
    MultiAtlasFile: require_MultiAtlasFile(),
    MultiScriptFile: require_MultiScriptFile(),
    OBJFile: require_OBJFile(),
    PackFile: require_PackFile(),
    PluginFile: require_PluginFile(),
    SceneFile: require_SceneFile(),
    ScenePluginFile: require_ScenePluginFile(),
    ScriptFile: require_ScriptFile(),
    SpriteSheetFile: require_SpriteSheetFile(),
    SVGFile: require_SVGFile(),
    TextFile: require_TextFile(),
    TilemapCSVFile: require_TilemapCSVFile(),
    TilemapImpactFile: require_TilemapImpactFile(),
    TilemapJSONFile: require_TilemapJSONFile(),
    UnityAtlasFile: require_UnityAtlasFile(),
    VideoFile: require_VideoFile(),
    XMLFile: require_XMLFile()
  };
});

// node_modules/phaser/src/loader/LoaderPlugin.js
var require_LoaderPlugin = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const12();
  var CustomSet = require_Set();
  var EventEmitter = require_eventemitter3();
  var Events = require_events14();
  var FileTypesManager = require_FileTypesManager();
  var GetFastValue = require_GetFastValue();
  var PluginCache = require_PluginCache();
  var SceneEvents = require_events5();
  var XHRSettings = require_XHRSettings();
  var LoaderPlugin = new Class({
    Extends: EventEmitter,
    initialize: function LoaderPlugin2(scene) {
      EventEmitter.call(this);
      var gameConfig = scene.sys.game.config;
      var sceneConfig = scene.sys.settings.loader;
      this.scene = scene;
      this.systems = scene.sys;
      this.cacheManager = scene.sys.cache;
      this.textureManager = scene.sys.textures;
      this.sceneManager = scene.sys.game.scene;
      FileTypesManager.install(this);
      this.prefix = "";
      this.path = "";
      this.baseURL = "";
      this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL));
      this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath));
      this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix));
      this.maxParallelDownloads = GetFastValue(sceneConfig, "maxParallelDownloads", gameConfig.loaderMaxParallelDownloads);
      this.xhr = XHRSettings(GetFastValue(sceneConfig, "responseType", gameConfig.loaderResponseType), GetFastValue(sceneConfig, "async", gameConfig.loaderAsync), GetFastValue(sceneConfig, "user", gameConfig.loaderUser), GetFastValue(sceneConfig, "password", gameConfig.loaderPassword), GetFastValue(sceneConfig, "timeout", gameConfig.loaderTimeout), GetFastValue(sceneConfig, "withCredentials", gameConfig.loaderWithCredentials));
      this.crossOrigin = GetFastValue(sceneConfig, "crossOrigin", gameConfig.loaderCrossOrigin);
      this.totalToLoad = 0;
      this.progress = 0;
      this.list = new CustomSet();
      this.inflight = new CustomSet();
      this.queue = new CustomSet();
      this._deleteQueue = new CustomSet();
      this.totalFailed = 0;
      this.totalComplete = 0;
      this.state = CONST.LOADER_IDLE;
      this.multiKeyIndex = 0;
      scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
      scene.sys.events.on(SceneEvents.START, this.pluginStart, this);
    },
    boot: function() {
      this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
    },
    pluginStart: function() {
      this.systems.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    setBaseURL: function(url) {
      if (url === void 0) {
        url = "";
      }
      if (url !== "" && url.substr(-1) !== "/") {
        url = url.concat("/");
      }
      this.baseURL = url;
      return this;
    },
    setPath: function(path) {
      if (path === void 0) {
        path = "";
      }
      if (path !== "" && path.substr(-1) !== "/") {
        path = path.concat("/");
      }
      this.path = path;
      return this;
    },
    setPrefix: function(prefix) {
      if (prefix === void 0) {
        prefix = "";
      }
      this.prefix = prefix;
      return this;
    },
    setCORS: function(crossOrigin) {
      this.crossOrigin = crossOrigin;
      return this;
    },
    addFile: function(file) {
      if (!Array.isArray(file)) {
        file = [file];
      }
      for (var i = 0; i < file.length; i++) {
        var item = file[i];
        if (!this.keyExists(item)) {
          this.list.set(item);
          this.emit(Events.ADD, item.key, item.type, this, item);
          if (this.isLoading()) {
            this.totalToLoad++;
            this.updateProgress();
          }
        }
      }
    },
    keyExists: function(file) {
      var keyConflict = file.hasCacheConflict();
      if (!keyConflict) {
        this.list.iterate(function(item) {
          if (item.type === file.type && item.key === file.key) {
            keyConflict = true;
            return false;
          }
        });
      }
      if (!keyConflict && this.isLoading()) {
        this.inflight.iterate(function(item) {
          if (item.type === file.type && item.key === file.key) {
            keyConflict = true;
            return false;
          }
        });
        this.queue.iterate(function(item) {
          if (item.type === file.type && item.key === file.key) {
            keyConflict = true;
            return false;
          }
        });
      }
      return keyConflict;
    },
    addPack: function(pack, packKey) {
      if (packKey && pack.hasOwnProperty(packKey)) {
        pack = {packKey: pack[packKey]};
      }
      var total = 0;
      var currentBaseURL = this.baseURL;
      var currentPath = this.path;
      var currentPrefix = this.prefix;
      for (var key in pack) {
        if (!Object.prototype.hasOwnProperty.call(pack, key)) {
          continue;
        }
        var config2 = pack[key];
        var baseURL = GetFastValue(config2, "baseURL", currentBaseURL);
        var path = GetFastValue(config2, "path", currentPath);
        var prefix = GetFastValue(config2, "prefix", currentPrefix);
        var files = GetFastValue(config2, "files", null);
        var defaultType = GetFastValue(config2, "defaultType", "void");
        if (Array.isArray(files)) {
          this.setBaseURL(baseURL);
          this.setPath(path);
          this.setPrefix(prefix);
          for (var i = 0; i < files.length; i++) {
            var file = files[i];
            var type = file.hasOwnProperty("type") ? file.type : defaultType;
            if (this[type]) {
              this[type](file);
              total++;
            }
          }
        }
      }
      this.setBaseURL(currentBaseURL);
      this.setPath(currentPath);
      this.setPrefix(currentPrefix);
      return total > 0;
    },
    isLoading: function() {
      return this.state === CONST.LOADER_LOADING || this.state === CONST.LOADER_PROCESSING;
    },
    isReady: function() {
      return this.state === CONST.LOADER_IDLE || this.state === CONST.LOADER_COMPLETE;
    },
    start: function() {
      if (!this.isReady()) {
        return;
      }
      this.progress = 0;
      this.totalFailed = 0;
      this.totalComplete = 0;
      this.totalToLoad = this.list.size;
      this.emit(Events.START, this);
      if (this.list.size === 0) {
        this.loadComplete();
      } else {
        this.state = CONST.LOADER_LOADING;
        this.inflight.clear();
        this.queue.clear();
        this.updateProgress();
        this.checkLoadQueue();
        this.systems.events.on(SceneEvents.UPDATE, this.update, this);
      }
    },
    updateProgress: function() {
      this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad;
      this.emit(Events.PROGRESS, this.progress);
    },
    update: function() {
      if (this.state === CONST.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads) {
        this.checkLoadQueue();
      }
    },
    checkLoadQueue: function() {
      this.list.each(function(file) {
        if (file.state === CONST.FILE_POPULATED || file.state === CONST.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) {
          this.inflight.set(file);
          this.list.delete(file);
          if (!file.crossOrigin) {
            file.crossOrigin = this.crossOrigin;
          }
          file.load();
        }
        if (this.inflight.size === this.maxParallelDownloads) {
          return false;
        }
      }, this);
    },
    nextFile: function(file, success) {
      if (!this.inflight) {
        return;
      }
      this.inflight.delete(file);
      this.updateProgress();
      if (success) {
        this.totalComplete++;
        this.queue.set(file);
        this.emit(Events.FILE_LOAD, file);
        file.onProcess();
      } else {
        this.totalFailed++;
        this._deleteQueue.set(file);
        this.emit(Events.FILE_LOAD_ERROR, file);
        this.fileProcessComplete(file);
      }
    },
    fileProcessComplete: function(file) {
      if (!this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy) {
        return;
      }
      if (file.state === CONST.FILE_ERRORED) {
        if (file.multiFile) {
          file.multiFile.onFileFailed(file);
        }
      } else if (file.state === CONST.FILE_COMPLETE) {
        if (file.multiFile) {
          if (file.multiFile.isReadyToProcess()) {
            file.multiFile.addToCache();
          }
        } else {
          file.addToCache();
        }
      }
      this.queue.delete(file);
      if (this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0) {
        this.loadComplete();
      }
    },
    loadComplete: function() {
      this.emit(Events.POST_PROCESS, this);
      this.list.clear();
      this.inflight.clear();
      this.queue.clear();
      this.progress = 1;
      this.state = CONST.LOADER_COMPLETE;
      this.systems.events.off(SceneEvents.UPDATE, this.update, this);
      this._deleteQueue.iterateLocal("destroy");
      this._deleteQueue.clear();
      this.emit(Events.COMPLETE, this, this.totalComplete, this.totalFailed);
    },
    flagForRemoval: function(file) {
      this._deleteQueue.set(file);
    },
    saveJSON: function(data, filename) {
      return this.save(JSON.stringify(data), filename);
    },
    save: function(data, filename, filetype) {
      if (filename === void 0) {
        filename = "file.json";
      }
      if (filetype === void 0) {
        filetype = "application/json";
      }
      var blob = new Blob([data], {type: filetype});
      var url = URL.createObjectURL(blob);
      var a = document.createElement("a");
      a.download = filename;
      a.textContent = "Download " + filename;
      a.href = url;
      a.click();
      return this;
    },
    reset: function() {
      this.list.clear();
      this.inflight.clear();
      this.queue.clear();
      var gameConfig = this.systems.game.config;
      var sceneConfig = this.systems.settings.loader;
      this.setBaseURL(GetFastValue(sceneConfig, "baseURL", gameConfig.loaderBaseURL));
      this.setPath(GetFastValue(sceneConfig, "path", gameConfig.loaderPath));
      this.setPrefix(GetFastValue(sceneConfig, "prefix", gameConfig.loaderPrefix));
      this.state = CONST.LOADER_IDLE;
    },
    shutdown: function() {
      this.reset();
      this.state = CONST.LOADER_SHUTDOWN;
      this.systems.events.off(SceneEvents.UPDATE, this.update, this);
      this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    destroy: function() {
      this.shutdown();
      this.state = CONST.LOADER_DESTROYED;
      this.systems.events.off(SceneEvents.UPDATE, this.update, this);
      this.systems.events.off(SceneEvents.START, this.pluginStart, this);
      this.list = null;
      this.inflight = null;
      this.queue = null;
      this.scene = null;
      this.systems = null;
      this.textureManager = null;
      this.cacheManager = null;
      this.sceneManager = null;
    }
  });
  PluginCache.register("Loader", LoaderPlugin, "load");
  module2.exports = LoaderPlugin;
});

// node_modules/phaser/src/loader/index.js
var require_loader = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const12();
  var Extend = require_Extend();
  var Loader = {
    Events: require_events14(),
    FileTypes: require_filetypes(),
    File: require_File(),
    FileTypesManager: require_FileTypesManager(),
    GetURL: require_GetURL(),
    LoaderPlugin: require_LoaderPlugin(),
    MergeXHRSettings: require_MergeXHRSettings(),
    MultiFile: require_MultiFile(),
    XHRLoader: require_XHRLoader(),
    XHRSettings: require_XHRSettings()
  };
  Loader = Extend(false, Loader, CONST);
  module2.exports = Loader;
});

// node_modules/phaser/src/physics/arcade/const.js
var require_const13 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = {
    DYNAMIC_BODY: 0,
    STATIC_BODY: 1,
    GROUP: 2,
    TILEMAPLAYER: 3,
    FACING_NONE: 10,
    FACING_UP: 11,
    FACING_DOWN: 12,
    FACING_LEFT: 13,
    FACING_RIGHT: 14
  };
  module2.exports = CONST;
});

// node_modules/phaser/src/physics/arcade/components/Acceleration.js
var require_Acceleration = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Acceleration = {
    setAcceleration: function(x, y) {
      this.body.acceleration.set(x, y);
      return this;
    },
    setAccelerationX: function(value) {
      this.body.acceleration.x = value;
      return this;
    },
    setAccelerationY: function(value) {
      this.body.acceleration.y = value;
      return this;
    }
  };
  module2.exports = Acceleration;
});

// node_modules/phaser/src/physics/arcade/components/Angular.js
var require_Angular = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Angular = {
    setAngularVelocity: function(value) {
      this.body.angularVelocity = value;
      return this;
    },
    setAngularAcceleration: function(value) {
      this.body.angularAcceleration = value;
      return this;
    },
    setAngularDrag: function(value) {
      this.body.angularDrag = value;
      return this;
    }
  };
  module2.exports = Angular;
});

// node_modules/phaser/src/physics/arcade/components/Bounce.js
var require_Bounce = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Bounce = {
    setBounce: function(x, y) {
      this.body.bounce.set(x, y);
      return this;
    },
    setBounceX: function(value) {
      this.body.bounce.x = value;
      return this;
    },
    setBounceY: function(value) {
      this.body.bounce.y = value;
      return this;
    },
    setCollideWorldBounds: function(value, bounceX, bounceY) {
      this.body.setCollideWorldBounds(value, bounceX, bounceY);
      return this;
    }
  };
  module2.exports = Bounce;
});

// node_modules/phaser/src/physics/arcade/components/Debug.js
var require_Debug = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Debug = {
    setDebug: function(showBody, showVelocity, bodyColor) {
      this.debugShowBody = showBody;
      this.debugShowVelocity = showVelocity;
      this.debugBodyColor = bodyColor;
      return this;
    },
    setDebugBodyColor: function(value) {
      this.body.debugBodyColor = value;
      return this;
    },
    debugShowBody: {
      get: function() {
        return this.body.debugShowBody;
      },
      set: function(value) {
        this.body.debugShowBody = value;
      }
    },
    debugShowVelocity: {
      get: function() {
        return this.body.debugShowVelocity;
      },
      set: function(value) {
        this.body.debugShowVelocity = value;
      }
    },
    debugBodyColor: {
      get: function() {
        return this.body.debugBodyColor;
      },
      set: function(value) {
        this.body.debugBodyColor = value;
      }
    }
  };
  module2.exports = Debug;
});

// node_modules/phaser/src/physics/arcade/components/Drag.js
var require_Drag = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Drag = {
    setDrag: function(x, y) {
      this.body.drag.set(x, y);
      return this;
    },
    setDragX: function(value) {
      this.body.drag.x = value;
      return this;
    },
    setDragY: function(value) {
      this.body.drag.y = value;
      return this;
    },
    setDamping: function(value) {
      this.body.useDamping = value;
      return this;
    }
  };
  module2.exports = Drag;
});

// node_modules/phaser/src/physics/arcade/components/Enable.js
var require_Enable = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Enable = {
    enableBody: function(reset, x, y, enableGameObject, showGameObject) {
      if (reset) {
        this.body.reset(x, y);
      }
      if (enableGameObject) {
        this.body.gameObject.active = true;
      }
      if (showGameObject) {
        this.body.gameObject.visible = true;
      }
      this.body.enable = true;
      return this;
    },
    disableBody: function(disableGameObject, hideGameObject) {
      if (disableGameObject === void 0) {
        disableGameObject = false;
      }
      if (hideGameObject === void 0) {
        hideGameObject = false;
      }
      this.body.stop();
      this.body.enable = false;
      if (disableGameObject) {
        this.body.gameObject.active = false;
      }
      if (hideGameObject) {
        this.body.gameObject.visible = false;
      }
      return this;
    },
    refreshBody: function() {
      this.body.updateFromGameObject();
      return this;
    }
  };
  module2.exports = Enable;
});

// node_modules/phaser/src/physics/arcade/components/Friction.js
var require_Friction = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Friction = {
    setFriction: function(x, y) {
      this.body.friction.set(x, y);
      return this;
    },
    setFrictionX: function(x) {
      this.body.friction.x = x;
      return this;
    },
    setFrictionY: function(y) {
      this.body.friction.y = y;
      return this;
    }
  };
  module2.exports = Friction;
});

// node_modules/phaser/src/physics/arcade/components/Gravity.js
var require_Gravity = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Gravity = {
    setGravity: function(x, y) {
      this.body.gravity.set(x, y);
      return this;
    },
    setGravityX: function(x) {
      this.body.gravity.x = x;
      return this;
    },
    setGravityY: function(y) {
      this.body.gravity.y = y;
      return this;
    }
  };
  module2.exports = Gravity;
});

// node_modules/phaser/src/physics/arcade/components/Immovable.js
var require_Immovable = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Immovable = {
    setImmovable: function(value) {
      if (value === void 0) {
        value = true;
      }
      this.body.immovable = value;
      return this;
    }
  };
  module2.exports = Immovable;
});

// node_modules/phaser/src/physics/arcade/components/Mass.js
var require_Mass = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Mass = {
    setMass: function(value) {
      this.body.mass = value;
      return this;
    }
  };
  module2.exports = Mass;
});

// node_modules/phaser/src/physics/arcade/components/OverlapRect.js
var require_OverlapRect = __commonJS((exports2, module2) => {
  var OverlapRect = function(world, x, y, width, height, includeDynamic, includeStatic) {
    if (includeDynamic === void 0) {
      includeDynamic = true;
    }
    if (includeStatic === void 0) {
      includeStatic = false;
    }
    var dynamicBodies = [];
    var staticBodies = [];
    var minMax = world.treeMinMax;
    minMax.minX = x;
    minMax.minY = y;
    minMax.maxX = x + width;
    minMax.maxY = y + height;
    if (includeStatic) {
      staticBodies = world.staticTree.search(minMax);
    }
    if (includeDynamic && world.useTree) {
      dynamicBodies = world.tree.search(minMax);
    } else if (includeDynamic) {
      var bodies = world.bodies;
      var fakeBody = {
        position: {
          x,
          y
        },
        left: x,
        top: y,
        right: x + width,
        bottom: y + height,
        isCircle: false
      };
      var intersects = world.intersects;
      bodies.iterate(function(target) {
        if (intersects(target, fakeBody)) {
          dynamicBodies.push(target);
        }
      });
    }
    return staticBodies.concat(dynamicBodies);
  };
  module2.exports = OverlapRect;
});

// node_modules/phaser/src/physics/arcade/components/OverlapCirc.js
var require_OverlapCirc = __commonJS((exports2, module2) => {
  var OverlapRect = require_OverlapRect();
  var Circle = require_Circle();
  var CircleToCircle = require_CircleToCircle();
  var CircleToRectangle = require_CircleToRectangle();
  var OverlapCirc = function(world, x, y, radius, includeDynamic, includeStatic) {
    var bodiesInRect = OverlapRect(world, x - radius, y - radius, 2 * radius, 2 * radius, includeDynamic, includeStatic);
    if (bodiesInRect.length === 0) {
      return bodiesInRect;
    }
    var area = new Circle(x, y, radius);
    var circFromBody = new Circle();
    var bodiesInArea = [];
    for (var i = 0; i < bodiesInRect.length; i++) {
      var body = bodiesInRect[i];
      if (body.isCircle) {
        circFromBody.setTo(body.center.x, body.center.y, body.halfWidth);
        if (CircleToCircle(area, circFromBody)) {
          bodiesInArea.push(body);
        }
      } else if (CircleToRectangle(area, body)) {
        bodiesInArea.push(body);
      }
    }
    return bodiesInArea;
  };
  module2.exports = OverlapCirc;
});

// node_modules/phaser/src/physics/arcade/components/Pushable.js
var require_Pushable = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Pushable = {
    setPushable: function(value) {
      if (value === void 0) {
        value = true;
      }
      this.body.pushable = value;
      return this;
    }
  };
  module2.exports = Pushable;
});

// node_modules/phaser/src/physics/arcade/components/Size.js
var require_Size3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Size = {
    setOffset: function(x, y) {
      this.body.setOffset(x, y);
      return this;
    },
    setSize: function(width, height, center) {
      this.body.setSize(width, height, center);
      return this;
    },
    setBodySize: function(width, height, center) {
      this.body.setSize(width, height, center);
      return this;
    },
    setCircle: function(radius, offsetX, offsetY) {
      this.body.setCircle(radius, offsetX, offsetY);
      return this;
    }
  };
  module2.exports = Size;
});

// node_modules/phaser/src/physics/arcade/components/Velocity.js
var require_Velocity = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Velocity = {
    setVelocity: function(x, y) {
      this.body.setVelocity(x, y);
      return this;
    },
    setVelocityX: function(x) {
      this.body.setVelocityX(x);
      return this;
    },
    setVelocityY: function(y) {
      this.body.setVelocityY(y);
      return this;
    },
    setMaxVelocity: function(x, y) {
      this.body.maxVelocity.set(x, y);
      return this;
    }
  };
  module2.exports = Velocity;
});

// node_modules/phaser/src/physics/arcade/components/index.js
var require_components2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Acceleration: require_Acceleration(),
    Angular: require_Angular(),
    Bounce: require_Bounce(),
    Debug: require_Debug(),
    Drag: require_Drag(),
    Enable: require_Enable(),
    Friction: require_Friction(),
    Gravity: require_Gravity(),
    Immovable: require_Immovable(),
    Mass: require_Mass(),
    OverlapCirc: require_OverlapCirc(),
    OverlapRect: require_OverlapRect(),
    Pushable: require_Pushable(),
    Size: require_Size3(),
    Velocity: require_Velocity()
  };
});

// node_modules/phaser/src/physics/arcade/ArcadeImage.js
var require_ArcadeImage = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components2();
  var Image2 = require_Image2();
  var ArcadeImage = new Class({
    Extends: Image2,
    Mixins: [
      Components.Acceleration,
      Components.Angular,
      Components.Bounce,
      Components.Debug,
      Components.Drag,
      Components.Enable,
      Components.Friction,
      Components.Gravity,
      Components.Immovable,
      Components.Mass,
      Components.Pushable,
      Components.Size,
      Components.Velocity
    ],
    initialize: function ArcadeImage2(scene, x, y, texture, frame) {
      Image2.call(this, scene, x, y, texture, frame);
      this.body = null;
    }
  });
  module2.exports = ArcadeImage;
});

// node_modules/phaser/src/physics/arcade/ArcadeSprite.js
var require_ArcadeSprite = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components2();
  var Sprite = require_Sprite();
  var ArcadeSprite = new Class({
    Extends: Sprite,
    Mixins: [
      Components.Acceleration,
      Components.Angular,
      Components.Bounce,
      Components.Debug,
      Components.Drag,
      Components.Enable,
      Components.Friction,
      Components.Gravity,
      Components.Immovable,
      Components.Mass,
      Components.Pushable,
      Components.Size,
      Components.Velocity
    ],
    initialize: function ArcadeSprite2(scene, x, y, texture, frame) {
      Sprite.call(this, scene, x, y, texture, frame);
      this.body = null;
    }
  });
  module2.exports = ArcadeSprite;
});

// node_modules/phaser/src/physics/arcade/PhysicsGroup.js
var require_PhysicsGroup = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ArcadeSprite = require_ArcadeSprite();
  var Class = require_Class();
  var CONST = require_const13();
  var GetFastValue = require_GetFastValue();
  var Group = require_Group();
  var IsPlainObject = require_IsPlainObject();
  var PhysicsGroup = new Class({
    Extends: Group,
    initialize: function PhysicsGroup2(world, scene, children, config2) {
      if (!children && !config2) {
        config2 = {
          internalCreateCallback: this.createCallbackHandler,
          internalRemoveCallback: this.removeCallbackHandler
        };
      } else if (IsPlainObject(children)) {
        config2 = children;
        children = null;
        config2.internalCreateCallback = this.createCallbackHandler;
        config2.internalRemoveCallback = this.removeCallbackHandler;
      } else if (Array.isArray(children) && IsPlainObject(children[0])) {
        config2 = children[0];
        var _this = this;
        children.forEach(function(singleConfig) {
          singleConfig.internalCreateCallback = _this.createCallbackHandler;
          singleConfig.internalRemoveCallback = _this.removeCallbackHandler;
        });
        children = null;
      } else {
        config2 = {
          internalCreateCallback: this.createCallbackHandler,
          internalRemoveCallback: this.removeCallbackHandler
        };
      }
      this.world = world;
      config2.classType = GetFastValue(config2, "classType", ArcadeSprite);
      this.physicsType = CONST.DYNAMIC_BODY;
      this.defaults = {
        setCollideWorldBounds: GetFastValue(config2, "collideWorldBounds", false),
        setBoundsRectangle: GetFastValue(config2, "customBoundsRectangle", null),
        setAccelerationX: GetFastValue(config2, "accelerationX", 0),
        setAccelerationY: GetFastValue(config2, "accelerationY", 0),
        setAllowDrag: GetFastValue(config2, "allowDrag", true),
        setAllowGravity: GetFastValue(config2, "allowGravity", true),
        setAllowRotation: GetFastValue(config2, "allowRotation", true),
        setBounceX: GetFastValue(config2, "bounceX", 0),
        setBounceY: GetFastValue(config2, "bounceY", 0),
        setDragX: GetFastValue(config2, "dragX", 0),
        setDragY: GetFastValue(config2, "dragY", 0),
        setEnable: GetFastValue(config2, "enable", true),
        setGravityX: GetFastValue(config2, "gravityX", 0),
        setGravityY: GetFastValue(config2, "gravityY", 0),
        setFrictionX: GetFastValue(config2, "frictionX", 0),
        setFrictionY: GetFastValue(config2, "frictionY", 0),
        setMaxVelocityX: GetFastValue(config2, "maxVelocityX", 1e4),
        setMaxVelocityY: GetFastValue(config2, "maxVelocityY", 1e4),
        setVelocityX: GetFastValue(config2, "velocityX", 0),
        setVelocityY: GetFastValue(config2, "velocityY", 0),
        setAngularVelocity: GetFastValue(config2, "angularVelocity", 0),
        setAngularAcceleration: GetFastValue(config2, "angularAcceleration", 0),
        setAngularDrag: GetFastValue(config2, "angularDrag", 0),
        setMass: GetFastValue(config2, "mass", 1),
        setImmovable: GetFastValue(config2, "immovable", false)
      };
      Group.call(this, scene, children, config2);
      this.type = "PhysicsGroup";
    },
    createCallbackHandler: function(child) {
      if (!child.body) {
        this.world.enableBody(child, CONST.DYNAMIC_BODY);
      }
      var body = child.body;
      for (var key in this.defaults) {
        body[key](this.defaults[key]);
      }
    },
    removeCallbackHandler: function(child) {
      if (child.body) {
        this.world.disableBody(child);
      }
    },
    setVelocity: function(x, y, step) {
      if (step === void 0) {
        step = 0;
      }
      var items = this.getChildren();
      for (var i = 0; i < items.length; i++) {
        items[i].body.velocity.set(x + i * step, y + i * step);
      }
      return this;
    },
    setVelocityX: function(value, step) {
      if (step === void 0) {
        step = 0;
      }
      var items = this.getChildren();
      for (var i = 0; i < items.length; i++) {
        items[i].body.velocity.x = value + i * step;
      }
      return this;
    },
    setVelocityY: function(value, step) {
      if (step === void 0) {
        step = 0;
      }
      var items = this.getChildren();
      for (var i = 0; i < items.length; i++) {
        items[i].body.velocity.y = value + i * step;
      }
      return this;
    }
  });
  module2.exports = PhysicsGroup;
});

// node_modules/phaser/src/physics/arcade/StaticPhysicsGroup.js
var require_StaticPhysicsGroup = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ArcadeSprite = require_ArcadeSprite();
  var Class = require_Class();
  var CONST = require_const13();
  var GetFastValue = require_GetFastValue();
  var Group = require_Group();
  var IsPlainObject = require_IsPlainObject();
  var StaticPhysicsGroup = new Class({
    Extends: Group,
    initialize: function StaticPhysicsGroup2(world, scene, children, config2) {
      if (!children && !config2) {
        config2 = {
          internalCreateCallback: this.createCallbackHandler,
          internalRemoveCallback: this.removeCallbackHandler,
          createMultipleCallback: this.createMultipleCallbackHandler,
          classType: ArcadeSprite
        };
      } else if (IsPlainObject(children)) {
        config2 = children;
        children = null;
        config2.internalCreateCallback = this.createCallbackHandler;
        config2.internalRemoveCallback = this.removeCallbackHandler;
        config2.createMultipleCallback = this.createMultipleCallbackHandler;
        config2.classType = GetFastValue(config2, "classType", ArcadeSprite);
      } else if (Array.isArray(children) && IsPlainObject(children[0])) {
        config2 = children;
        children = null;
        config2.forEach(function(singleConfig) {
          singleConfig.internalCreateCallback = this.createCallbackHandler;
          singleConfig.internalRemoveCallback = this.removeCallbackHandler;
          singleConfig.createMultipleCallback = this.createMultipleCallbackHandler;
          singleConfig.classType = GetFastValue(singleConfig, "classType", ArcadeSprite);
        });
      } else {
        config2 = {
          internalCreateCallback: this.createCallbackHandler,
          internalRemoveCallback: this.removeCallbackHandler
        };
      }
      this.world = world;
      this.physicsType = CONST.STATIC_BODY;
      Group.call(this, scene, children, config2);
      this.type = "StaticPhysicsGroup";
    },
    createCallbackHandler: function(child) {
      if (!child.body) {
        this.world.enableBody(child, CONST.STATIC_BODY);
      }
    },
    removeCallbackHandler: function(child) {
      if (child.body) {
        this.world.disableBody(child);
      }
    },
    createMultipleCallbackHandler: function() {
      this.refresh();
    },
    refresh: function() {
      var children = this.children.entries;
      for (var i = 0; i < children.length; i++) {
        children[i].body.reset();
      }
      return this;
    }
  });
  module2.exports = StaticPhysicsGroup;
});

// node_modules/phaser/src/physics/arcade/Factory.js
var require_Factory = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ArcadeImage = require_ArcadeImage();
  var ArcadeSprite = require_ArcadeSprite();
  var Class = require_Class();
  var CONST = require_const13();
  var PhysicsGroup = require_PhysicsGroup();
  var StaticPhysicsGroup = require_StaticPhysicsGroup();
  var Factory = new Class({
    initialize: function Factory2(world) {
      this.world = world;
      this.scene = world.scene;
      this.sys = world.scene.sys;
    },
    collider: function(object1, object2, collideCallback, processCallback, callbackContext) {
      return this.world.addCollider(object1, object2, collideCallback, processCallback, callbackContext);
    },
    overlap: function(object1, object2, collideCallback, processCallback, callbackContext) {
      return this.world.addOverlap(object1, object2, collideCallback, processCallback, callbackContext);
    },
    existing: function(gameObject, isStatic) {
      var type = isStatic ? CONST.STATIC_BODY : CONST.DYNAMIC_BODY;
      this.world.enableBody(gameObject, type);
      return gameObject;
    },
    staticImage: function(x, y, key, frame) {
      var image = new ArcadeImage(this.scene, x, y, key, frame);
      this.sys.displayList.add(image);
      this.world.enableBody(image, CONST.STATIC_BODY);
      return image;
    },
    image: function(x, y, key, frame) {
      var image = new ArcadeImage(this.scene, x, y, key, frame);
      this.sys.displayList.add(image);
      this.world.enableBody(image, CONST.DYNAMIC_BODY);
      return image;
    },
    staticSprite: function(x, y, key, frame) {
      var sprite = new ArcadeSprite(this.scene, x, y, key, frame);
      this.sys.displayList.add(sprite);
      this.sys.updateList.add(sprite);
      this.world.enableBody(sprite, CONST.STATIC_BODY);
      return sprite;
    },
    sprite: function(x, y, key, frame) {
      var sprite = new ArcadeSprite(this.scene, x, y, key, frame);
      this.sys.displayList.add(sprite);
      this.sys.updateList.add(sprite);
      this.world.enableBody(sprite, CONST.DYNAMIC_BODY);
      return sprite;
    },
    staticGroup: function(children, config2) {
      return this.sys.updateList.add(new StaticPhysicsGroup(this.world, this.world.scene, children, config2));
    },
    group: function(children, config2) {
      return this.sys.updateList.add(new PhysicsGroup(this.world, this.world.scene, children, config2));
    },
    destroy: function() {
      this.world = null;
      this.scene = null;
      this.sys = null;
    }
  });
  module2.exports = Factory;
});

// node_modules/phaser/src/physics/arcade/events/COLLIDE_EVENT.js
var require_COLLIDE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "collide";
});

// node_modules/phaser/src/physics/arcade/events/OVERLAP_EVENT.js
var require_OVERLAP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "overlap";
});

// node_modules/phaser/src/physics/arcade/events/PAUSE_EVENT.js
var require_PAUSE_EVENT4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pause";
});

// node_modules/phaser/src/physics/arcade/events/RESUME_EVENT.js
var require_RESUME_EVENT4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "resume";
});

// node_modules/phaser/src/physics/arcade/events/TILE_COLLIDE_EVENT.js
var require_TILE_COLLIDE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "tilecollide";
});

// node_modules/phaser/src/physics/arcade/events/TILE_OVERLAP_EVENT.js
var require_TILE_OVERLAP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "tileoverlap";
});

// node_modules/phaser/src/physics/arcade/events/WORLD_BOUNDS_EVENT.js
var require_WORLD_BOUNDS_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "worldbounds";
});

// node_modules/phaser/src/physics/arcade/events/WORLD_STEP_EVENT.js
var require_WORLD_STEP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "worldstep";
});

// node_modules/phaser/src/physics/arcade/events/index.js
var require_events19 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    COLLIDE: require_COLLIDE_EVENT(),
    OVERLAP: require_OVERLAP_EVENT(),
    PAUSE: require_PAUSE_EVENT4(),
    RESUME: require_RESUME_EVENT4(),
    TILE_COLLIDE: require_TILE_COLLIDE_EVENT(),
    TILE_OVERLAP: require_TILE_OVERLAP_EVENT(),
    WORLD_BOUNDS: require_WORLD_BOUNDS_EVENT(),
    WORLD_STEP: require_WORLD_STEP_EVENT()
  };
});

// node_modules/phaser/src/physics/arcade/Body.js
var require_Body = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Benjamin D. Richards <benjamindrichards@gmail.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_const13();
  var Events = require_events19();
  var RadToDeg = require_RadToDeg();
  var Rectangle = require_Rectangle();
  var RectangleContains = require_Contains2();
  var Vector2 = require_Vector2();
  var Body = new Class({
    initialize: function Body2(world, gameObject) {
      var width = gameObject.displayWidth ? gameObject.displayWidth : 64;
      var height = gameObject.displayHeight ? gameObject.displayHeight : 64;
      this.world = world;
      this.gameObject = gameObject;
      this.transform = {
        x: gameObject.x,
        y: gameObject.y,
        rotation: gameObject.angle,
        scaleX: gameObject.scaleX,
        scaleY: gameObject.scaleY,
        displayOriginX: gameObject.displayOriginX,
        displayOriginY: gameObject.displayOriginY
      };
      this.debugShowBody = world.defaults.debugShowBody;
      this.debugShowVelocity = world.defaults.debugShowVelocity;
      this.debugBodyColor = world.defaults.bodyDebugColor;
      this.enable = true;
      this.isCircle = false;
      this.radius = 0;
      this.offset = new Vector2();
      this.position = new Vector2(gameObject.x - gameObject.scaleX * gameObject.displayOriginX, gameObject.y - gameObject.scaleY * gameObject.displayOriginY);
      this.prev = this.position.clone();
      this.prevFrame = this.position.clone();
      this.allowRotation = true;
      this.rotation = gameObject.angle;
      this.preRotation = gameObject.angle;
      this.width = width;
      this.height = height;
      this.sourceWidth = width;
      this.sourceHeight = height;
      if (gameObject.frame) {
        this.sourceWidth = gameObject.frame.realWidth;
        this.sourceHeight = gameObject.frame.realHeight;
      }
      this.halfWidth = Math.abs(width / 2);
      this.halfHeight = Math.abs(height / 2);
      this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
      this.velocity = new Vector2();
      this.newVelocity = new Vector2();
      this.deltaMax = new Vector2();
      this.acceleration = new Vector2();
      this.allowDrag = true;
      this.drag = new Vector2();
      this.allowGravity = true;
      this.gravity = new Vector2();
      this.bounce = new Vector2();
      this.worldBounce = null;
      this.customBoundsRectangle = world.bounds;
      this.onWorldBounds = false;
      this.onCollide = false;
      this.onOverlap = false;
      this.maxVelocity = new Vector2(1e4, 1e4);
      this.maxSpeed = -1;
      this.friction = new Vector2(1, 0);
      this.useDamping = false;
      this.angularVelocity = 0;
      this.angularAcceleration = 0;
      this.angularDrag = 0;
      this.maxAngular = 1e3;
      this.mass = 1;
      this.angle = 0;
      this.speed = 0;
      this.facing = CONST.FACING_NONE;
      this.immovable = false;
      this.pushable = true;
      this.moves = true;
      this.customSeparateX = false;
      this.customSeparateY = false;
      this.overlapX = 0;
      this.overlapY = 0;
      this.overlapR = 0;
      this.embedded = false;
      this.collideWorldBounds = false;
      this.checkCollision = {none: false, up: true, down: true, left: true, right: true};
      this.touching = {none: true, up: false, down: false, left: false, right: false};
      this.wasTouching = {none: true, up: false, down: false, left: false, right: false};
      this.blocked = {none: true, up: false, down: false, left: false, right: false};
      this.syncBounds = false;
      this.physicsType = CONST.DYNAMIC_BODY;
      this._sx = gameObject.scaleX;
      this._sy = gameObject.scaleY;
      this._dx = 0;
      this._dy = 0;
      this._tx = 0;
      this._ty = 0;
      this._bounds = new Rectangle();
    },
    updateBounds: function() {
      var sprite = this.gameObject;
      var transform = this.transform;
      if (sprite.parentContainer) {
        var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);
        transform.x = matrix.tx;
        transform.y = matrix.ty;
        transform.rotation = RadToDeg(matrix.rotation);
        transform.scaleX = matrix.scaleX;
        transform.scaleY = matrix.scaleY;
        transform.displayOriginX = sprite.displayOriginX;
        transform.displayOriginY = sprite.displayOriginY;
      } else {
        transform.x = sprite.x;
        transform.y = sprite.y;
        transform.rotation = sprite.angle;
        transform.scaleX = sprite.scaleX;
        transform.scaleY = sprite.scaleY;
        transform.displayOriginX = sprite.displayOriginX;
        transform.displayOriginY = sprite.displayOriginY;
      }
      var recalc = false;
      if (this.syncBounds) {
        var b = sprite.getBounds(this._bounds);
        this.width = b.width;
        this.height = b.height;
        recalc = true;
      } else {
        var asx = Math.abs(transform.scaleX);
        var asy = Math.abs(transform.scaleY);
        if (this._sx !== asx || this._sy !== asy) {
          this.width = this.sourceWidth * asx;
          this.height = this.sourceHeight * asy;
          this._sx = asx;
          this._sy = asy;
          recalc = true;
        }
      }
      if (recalc) {
        this.halfWidth = Math.floor(this.width / 2);
        this.halfHeight = Math.floor(this.height / 2);
        this.updateCenter();
      }
    },
    updateCenter: function() {
      this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
    },
    updateFromGameObject: function() {
      this.updateBounds();
      var transform = this.transform;
      this.position.x = transform.x + transform.scaleX * (this.offset.x - transform.displayOriginX);
      this.position.y = transform.y + transform.scaleY * (this.offset.y - transform.displayOriginY);
      this.updateCenter();
    },
    resetFlags: function(clear) {
      if (clear === void 0) {
        clear = false;
      }
      var wasTouching = this.wasTouching;
      var touching = this.touching;
      var blocked = this.blocked;
      if (clear) {
        wasTouching.none = true;
        wasTouching.up = false;
        wasTouching.down = false;
        wasTouching.left = false;
        wasTouching.right = false;
      } else {
        wasTouching.none = touching.none;
        wasTouching.up = touching.up;
        wasTouching.down = touching.down;
        wasTouching.left = touching.left;
        wasTouching.right = touching.right;
      }
      touching.none = true;
      touching.up = false;
      touching.down = false;
      touching.left = false;
      touching.right = false;
      blocked.none = true;
      blocked.up = false;
      blocked.down = false;
      blocked.left = false;
      blocked.right = false;
      this.overlapR = 0;
      this.overlapX = 0;
      this.overlapY = 0;
      this.embedded = false;
    },
    preUpdate: function(willStep, delta) {
      if (willStep) {
        this.resetFlags();
      }
      this.updateFromGameObject();
      this.rotation = this.transform.rotation;
      this.preRotation = this.rotation;
      if (this.moves) {
        this.prev.x = this.position.x;
        this.prev.y = this.position.y;
        this.prevFrame.x = this.position.x;
        this.prevFrame.y = this.position.y;
      }
      if (willStep) {
        this.update(delta);
      }
    },
    update: function(delta) {
      this.prev.x = this.position.x;
      this.prev.y = this.position.y;
      if (this.moves) {
        this.world.updateMotion(this, delta);
        var vx = this.velocity.x;
        var vy = this.velocity.y;
        this.newVelocity.set(vx * delta, vy * delta);
        this.position.add(this.newVelocity);
        this.updateCenter();
        this.angle = Math.atan2(vy, vx);
        this.speed = Math.sqrt(vx * vx + vy * vy);
        if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds) {
          this.world.emit(Events.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);
        }
      }
      this._dx = this.position.x - this.prev.x;
      this._dy = this.position.y - this.prev.y;
    },
    postUpdate: function() {
      var dx = this.position.x - this.prevFrame.x;
      var dy = this.position.y - this.prevFrame.y;
      if (this.moves) {
        var mx = this.deltaMax.x;
        var my = this.deltaMax.y;
        if (mx !== 0 && dx !== 0) {
          if (dx < 0 && dx < -mx) {
            dx = -mx;
          } else if (dx > 0 && dx > mx) {
            dx = mx;
          }
        }
        if (my !== 0 && dy !== 0) {
          if (dy < 0 && dy < -my) {
            dy = -my;
          } else if (dy > 0 && dy > my) {
            dy = my;
          }
        }
        this.gameObject.x += dx;
        this.gameObject.y += dy;
      }
      if (dx < 0) {
        this.facing = CONST.FACING_LEFT;
      } else if (dx > 0) {
        this.facing = CONST.FACING_RIGHT;
      }
      if (dy < 0) {
        this.facing = CONST.FACING_UP;
      } else if (dy > 0) {
        this.facing = CONST.FACING_DOWN;
      }
      if (this.allowRotation) {
        this.gameObject.angle += this.deltaZ();
      }
      this._tx = dx;
      this._ty = dy;
    },
    setBoundsRectangle: function(bounds) {
      this.customBoundsRectangle = !bounds ? this.world.bounds : bounds;
      return this;
    },
    checkWorldBounds: function() {
      var pos = this.position;
      var bounds = this.customBoundsRectangle;
      var check = this.world.checkCollision;
      var bx = this.worldBounce ? -this.worldBounce.x : -this.bounce.x;
      var by = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
      var wasSet = false;
      if (pos.x < bounds.x && check.left) {
        pos.x = bounds.x;
        this.velocity.x *= bx;
        this.blocked.left = true;
        wasSet = true;
      } else if (this.right > bounds.right && check.right) {
        pos.x = bounds.right - this.width;
        this.velocity.x *= bx;
        this.blocked.right = true;
        wasSet = true;
      }
      if (pos.y < bounds.y && check.up) {
        pos.y = bounds.y;
        this.velocity.y *= by;
        this.blocked.up = true;
        wasSet = true;
      } else if (this.bottom > bounds.bottom && check.down) {
        pos.y = bounds.bottom - this.height;
        this.velocity.y *= by;
        this.blocked.down = true;
        wasSet = true;
      }
      if (wasSet) {
        this.blocked.none = false;
        this.updateCenter();
      }
      return wasSet;
    },
    setOffset: function(x, y) {
      if (y === void 0) {
        y = x;
      }
      this.offset.set(x, y);
      return this;
    },
    setSize: function(width, height, center) {
      if (center === void 0) {
        center = true;
      }
      var gameObject = this.gameObject;
      if (!width && gameObject.frame) {
        width = gameObject.frame.realWidth;
      }
      if (!height && gameObject.frame) {
        height = gameObject.frame.realHeight;
      }
      this.sourceWidth = width;
      this.sourceHeight = height;
      this.width = this.sourceWidth * this._sx;
      this.height = this.sourceHeight * this._sy;
      this.halfWidth = Math.floor(this.width / 2);
      this.halfHeight = Math.floor(this.height / 2);
      this.updateCenter();
      if (center && gameObject.getCenter) {
        var ox = (gameObject.width - width) / 2;
        var oy = (gameObject.height - height) / 2;
        this.offset.set(ox, oy);
      }
      this.isCircle = false;
      this.radius = 0;
      return this;
    },
    setCircle: function(radius, offsetX, offsetY) {
      if (offsetX === void 0) {
        offsetX = this.offset.x;
      }
      if (offsetY === void 0) {
        offsetY = this.offset.y;
      }
      if (radius > 0) {
        this.isCircle = true;
        this.radius = radius;
        this.sourceWidth = radius * 2;
        this.sourceHeight = radius * 2;
        this.width = this.sourceWidth * this._sx;
        this.height = this.sourceHeight * this._sy;
        this.halfWidth = Math.floor(this.width / 2);
        this.halfHeight = Math.floor(this.height / 2);
        this.offset.set(offsetX, offsetY);
        this.updateCenter();
      } else {
        this.isCircle = false;
      }
      return this;
    },
    reset: function(x, y) {
      this.stop();
      var gameObject = this.gameObject;
      gameObject.setPosition(x, y);
      if (gameObject.getTopLeft) {
        gameObject.getTopLeft(this.position);
      } else {
        this.position.set(x, y);
      }
      this.prev.copy(this.position);
      this.prevFrame.copy(this.position);
      this.rotation = gameObject.angle;
      this.preRotation = gameObject.angle;
      this.updateBounds();
      this.updateCenter();
      this.resetFlags(true);
    },
    stop: function() {
      this.velocity.set(0);
      this.acceleration.set(0);
      this.speed = 0;
      this.angularVelocity = 0;
      this.angularAcceleration = 0;
      return this;
    },
    getBounds: function(obj) {
      obj.x = this.x;
      obj.y = this.y;
      obj.right = this.right;
      obj.bottom = this.bottom;
      return obj;
    },
    hitTest: function(x, y) {
      if (!this.isCircle) {
        return RectangleContains(this, x, y);
      }
      if (this.radius > 0 && x >= this.left && x <= this.right && y >= this.top && y <= this.bottom) {
        var dx = (this.center.x - x) * (this.center.x - x);
        var dy = (this.center.y - y) * (this.center.y - y);
        return dx + dy <= this.radius * this.radius;
      }
      return false;
    },
    onFloor: function() {
      return this.blocked.down;
    },
    onCeiling: function() {
      return this.blocked.up;
    },
    onWall: function() {
      return this.blocked.left || this.blocked.right;
    },
    deltaAbsX: function() {
      return this._dx > 0 ? this._dx : -this._dx;
    },
    deltaAbsY: function() {
      return this._dy > 0 ? this._dy : -this._dy;
    },
    deltaX: function() {
      return this._dx;
    },
    deltaY: function() {
      return this._dy;
    },
    deltaXFinal: function() {
      return this._tx;
    },
    deltaYFinal: function() {
      return this._ty;
    },
    deltaZ: function() {
      return this.rotation - this.preRotation;
    },
    destroy: function() {
      this.enable = false;
      if (this.world) {
        this.world.pendingDestroy.set(this);
      }
    },
    drawDebug: function(graphic) {
      var pos = this.position;
      var x = pos.x + this.halfWidth;
      var y = pos.y + this.halfHeight;
      if (this.debugShowBody) {
        graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor);
        if (this.isCircle) {
          graphic.strokeCircle(x, y, this.width / 2);
        } else {
          if (this.checkCollision.up) {
            graphic.lineBetween(pos.x, pos.y, pos.x + this.width, pos.y);
          }
          if (this.checkCollision.right) {
            graphic.lineBetween(pos.x + this.width, pos.y, pos.x + this.width, pos.y + this.height);
          }
          if (this.checkCollision.down) {
            graphic.lineBetween(pos.x, pos.y + this.height, pos.x + this.width, pos.y + this.height);
          }
          if (this.checkCollision.left) {
            graphic.lineBetween(pos.x, pos.y, pos.x, pos.y + this.height);
          }
        }
      }
      if (this.debugShowVelocity) {
        graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1);
        graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);
      }
    },
    willDrawDebug: function() {
      return this.debugShowBody || this.debugShowVelocity;
    },
    setCollideWorldBounds: function(value, bounceX, bounceY, onWorldBounds) {
      if (value === void 0) {
        value = true;
      }
      this.collideWorldBounds = value;
      var setBounceX = bounceX !== void 0;
      var setBounceY = bounceY !== void 0;
      if (setBounceX || setBounceY) {
        if (!this.worldBounce) {
          this.worldBounce = new Vector2();
        }
        if (setBounceX) {
          this.worldBounce.x = bounceX;
        }
        if (setBounceY) {
          this.worldBounce.y = bounceY;
        }
      }
      if (onWorldBounds !== void 0) {
        this.onWorldBounds = onWorldBounds;
      }
      return this;
    },
    setVelocity: function(x, y) {
      this.velocity.set(x, y);
      x = this.velocity.x;
      y = this.velocity.y;
      this.speed = Math.sqrt(x * x + y * y);
      return this;
    },
    setVelocityX: function(value) {
      this.velocity.x = value;
      var x = value;
      var y = this.velocity.y;
      this.speed = Math.sqrt(x * x + y * y);
      return this;
    },
    setVelocityY: function(value) {
      this.velocity.y = value;
      var x = this.velocity.x;
      var y = value;
      this.speed = Math.sqrt(x * x + y * y);
      return this;
    },
    setMaxVelocity: function(x, y) {
      this.maxVelocity.set(x, y);
      return this;
    },
    setMaxVelocityX: function(value) {
      this.maxVelocity.x = value;
      return this;
    },
    setMaxVelocityY: function(value) {
      this.maxVelocity.y = value;
      return this;
    },
    setMaxSpeed: function(value) {
      this.maxSpeed = value;
      return this;
    },
    setBounce: function(x, y) {
      this.bounce.set(x, y);
      return this;
    },
    setBounceX: function(value) {
      this.bounce.x = value;
      return this;
    },
    setBounceY: function(value) {
      this.bounce.y = value;
      return this;
    },
    setAcceleration: function(x, y) {
      this.acceleration.set(x, y);
      return this;
    },
    setAccelerationX: function(value) {
      this.acceleration.x = value;
      return this;
    },
    setAccelerationY: function(value) {
      this.acceleration.y = value;
      return this;
    },
    setAllowDrag: function(value) {
      if (value === void 0) {
        value = true;
      }
      this.allowDrag = value;
      return this;
    },
    setAllowGravity: function(value) {
      if (value === void 0) {
        value = true;
      }
      this.allowGravity = value;
      return this;
    },
    setAllowRotation: function(value) {
      if (value === void 0) {
        value = true;
      }
      this.allowRotation = value;
      return this;
    },
    setDrag: function(x, y) {
      this.drag.set(x, y);
      return this;
    },
    setDamping: function(value) {
      this.useDamping = value;
      return this;
    },
    setDragX: function(value) {
      this.drag.x = value;
      return this;
    },
    setDragY: function(value) {
      this.drag.y = value;
      return this;
    },
    setGravity: function(x, y) {
      this.gravity.set(x, y);
      return this;
    },
    setGravityX: function(value) {
      this.gravity.x = value;
      return this;
    },
    setGravityY: function(value) {
      this.gravity.y = value;
      return this;
    },
    setFriction: function(x, y) {
      this.friction.set(x, y);
      return this;
    },
    setFrictionX: function(value) {
      this.friction.x = value;
      return this;
    },
    setFrictionY: function(value) {
      this.friction.y = value;
      return this;
    },
    setAngularVelocity: function(value) {
      this.angularVelocity = value;
      return this;
    },
    setAngularAcceleration: function(value) {
      this.angularAcceleration = value;
      return this;
    },
    setAngularDrag: function(value) {
      this.angularDrag = value;
      return this;
    },
    setMass: function(value) {
      this.mass = value;
      return this;
    },
    setImmovable: function(value) {
      if (value === void 0) {
        value = true;
      }
      this.immovable = value;
      return this;
    },
    setEnable: function(value) {
      if (value === void 0) {
        value = true;
      }
      this.enable = value;
      return this;
    },
    processX: function(x, vx, left, right) {
      this.x += x;
      this.updateCenter();
      if (vx !== null) {
        this.velocity.x = vx;
      }
      var blocked = this.blocked;
      if (left) {
        blocked.left = true;
      }
      if (right) {
        blocked.right = true;
      }
    },
    processY: function(y, vy, up, down) {
      this.y += y;
      this.updateCenter();
      if (vy !== null) {
        this.velocity.y = vy;
      }
      var blocked = this.blocked;
      if (up) {
        blocked.up = true;
      }
      if (down) {
        blocked.down = true;
      }
    },
    x: {
      get: function() {
        return this.position.x;
      },
      set: function(value) {
        this.position.x = value;
      }
    },
    y: {
      get: function() {
        return this.position.y;
      },
      set: function(value) {
        this.position.y = value;
      }
    },
    left: {
      get: function() {
        return this.position.x;
      }
    },
    right: {
      get: function() {
        return this.position.x + this.width;
      }
    },
    top: {
      get: function() {
        return this.position.y;
      }
    },
    bottom: {
      get: function() {
        return this.position.y + this.height;
      }
    }
  });
  module2.exports = Body;
});

// node_modules/phaser/src/physics/arcade/Collider.js
var require_Collider = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Collider = new Class({
    initialize: function Collider2(world, overlapOnly, object1, object2, collideCallback, processCallback, callbackContext) {
      this.world = world;
      this.name = "";
      this.active = true;
      this.overlapOnly = overlapOnly;
      this.object1 = object1;
      this.object2 = object2;
      this.collideCallback = collideCallback;
      this.processCallback = processCallback;
      this.callbackContext = callbackContext;
    },
    setName: function(name) {
      this.name = name;
      return this;
    },
    update: function() {
      this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly);
    },
    destroy: function() {
      this.world.removeCollider(this);
      this.active = false;
      this.world = null;
      this.object1 = null;
      this.object2 = null;
      this.collideCallback = null;
      this.processCallback = null;
      this.callbackContext = null;
    }
  });
  module2.exports = Collider;
});

// node_modules/phaser/src/physics/arcade/GetOverlapX.js
var require_GetOverlapX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const13();
  var GetOverlapX = function(body1, body2, overlapOnly, bias) {
    var overlap = 0;
    var maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + bias;
    if (body1._dx === 0 && body2._dx === 0) {
      body1.embedded = true;
      body2.embedded = true;
    } else if (body1._dx > body2._dx) {
      overlap = body1.right - body2.x;
      if (overlap > maxOverlap && !overlapOnly || body1.checkCollision.right === false || body2.checkCollision.left === false) {
        overlap = 0;
      } else {
        body1.touching.none = false;
        body1.touching.right = true;
        body2.touching.none = false;
        body2.touching.left = true;
        if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
          body1.blocked.none = false;
          body1.blocked.right = true;
        }
        if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
          body2.blocked.none = false;
          body2.blocked.left = true;
        }
      }
    } else if (body1._dx < body2._dx) {
      overlap = body1.x - body2.width - body2.x;
      if (-overlap > maxOverlap && !overlapOnly || body1.checkCollision.left === false || body2.checkCollision.right === false) {
        overlap = 0;
      } else {
        body1.touching.none = false;
        body1.touching.left = true;
        body2.touching.none = false;
        body2.touching.right = true;
        if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
          body1.blocked.none = false;
          body1.blocked.left = true;
        }
        if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
          body2.blocked.none = false;
          body2.blocked.right = true;
        }
      }
    }
    body1.overlapX = overlap;
    body2.overlapX = overlap;
    return overlap;
  };
  module2.exports = GetOverlapX;
});

// node_modules/phaser/src/physics/arcade/GetOverlapY.js
var require_GetOverlapY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const13();
  var GetOverlapY = function(body1, body2, overlapOnly, bias) {
    var overlap = 0;
    var maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + bias;
    if (body1._dy === 0 && body2._dy === 0) {
      body1.embedded = true;
      body2.embedded = true;
    } else if (body1._dy > body2._dy) {
      overlap = body1.bottom - body2.y;
      if (overlap > maxOverlap && !overlapOnly || body1.checkCollision.down === false || body2.checkCollision.up === false) {
        overlap = 0;
      } else {
        body1.touching.none = false;
        body1.touching.down = true;
        body2.touching.none = false;
        body2.touching.up = true;
        if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
          body1.blocked.none = false;
          body1.blocked.down = true;
        }
        if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
          body2.blocked.none = false;
          body2.blocked.up = true;
        }
      }
    } else if (body1._dy < body2._dy) {
      overlap = body1.y - body2.bottom;
      if (-overlap > maxOverlap && !overlapOnly || body1.checkCollision.up === false || body2.checkCollision.down === false) {
        overlap = 0;
      } else {
        body1.touching.none = false;
        body1.touching.up = true;
        body2.touching.none = false;
        body2.touching.down = true;
        if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly) {
          body1.blocked.none = false;
          body1.blocked.up = true;
        }
        if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly) {
          body2.blocked.none = false;
          body2.blocked.down = true;
        }
      }
    }
    body1.overlapY = overlap;
    body2.overlapY = overlap;
    return overlap;
  };
  module2.exports = GetOverlapY;
});

// node_modules/phaser/src/tilemaps/components/GetTilesWithin.js
var require_GetTilesWithin = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetFastValue = require_GetFastValue();
  var GetTilesWithin = function(tileX, tileY, width, height, filteringOptions, layer) {
    if (tileX === void 0) {
      tileX = 0;
    }
    if (tileY === void 0) {
      tileY = 0;
    }
    if (width === void 0) {
      width = layer.width;
    }
    if (height === void 0) {
      height = layer.height;
    }
    if (!filteringOptions) {
      filteringOptions = {};
    }
    var isNotEmpty = GetFastValue(filteringOptions, "isNotEmpty", false);
    var isColliding = GetFastValue(filteringOptions, "isColliding", false);
    var hasInterestingFace = GetFastValue(filteringOptions, "hasInterestingFace", false);
    if (tileX < 0) {
      width += tileX;
      tileX = 0;
    }
    if (tileY < 0) {
      height += tileY;
      tileY = 0;
    }
    if (tileX + width > layer.width) {
      width = Math.max(layer.width - tileX, 0);
    }
    if (tileY + height > layer.height) {
      height = Math.max(layer.height - tileY, 0);
    }
    var results = [];
    for (var ty = tileY; ty < tileY + height; ty++) {
      for (var tx = tileX; tx < tileX + width; tx++) {
        var tile = layer.data[ty][tx];
        if (tile !== null) {
          if (isNotEmpty && tile.index === -1) {
            continue;
          }
          if (isColliding && !tile.collides) {
            continue;
          }
          if (hasInterestingFace && !tile.hasInterestingFace) {
            continue;
          }
          results.push(tile);
        }
      }
    }
    return results;
  };
  module2.exports = GetTilesWithin;
});

// node_modules/phaser/src/tilemaps/components/GetTilesWithinWorldXY.js
var require_GetTilesWithinWorldXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var Vector2 = require_Vector2();
  var pointStart = new Vector2();
  var pointEnd = new Vector2();
  var GetTilesWithinWorldXY = function(worldX, worldY, width, height, filteringOptions, camera, layer) {
    var worldToTileXY = layer.tilemapLayer.tilemap._convert.WorldToTileXY;
    worldToTileXY(worldX, worldY, true, pointStart, camera, layer);
    var xStart = pointStart.x;
    var yStart = pointStart.y;
    worldToTileXY(worldX + width, worldY + height, false, pointEnd, camera, layer);
    var xEnd = Math.ceil(pointEnd.x);
    var yEnd = Math.ceil(pointEnd.y);
    return GetTilesWithin(xStart, yStart, xEnd - xStart, yEnd - yStart, filteringOptions, layer);
  };
  module2.exports = GetTilesWithinWorldXY;
});

// node_modules/phaser/src/physics/arcade/tilemap/ProcessTileCallbacks.js
var require_ProcessTileCallbacks = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ProcessTileCallbacks = function(tile, sprite) {
    if (tile.collisionCallback) {
      return !tile.collisionCallback.call(tile.collisionCallbackContext, sprite, tile);
    } else if (tile.layer.callbacks[tile.index]) {
      return !tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext, sprite, tile);
    }
    return true;
  };
  module2.exports = ProcessTileCallbacks;
});

// node_modules/phaser/src/structs/RTree.js
var require_RTree = __commonJS((exports2, module2) => {
  /**
   * @author       Vladimir Agafonkin
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var quickselect = require_QuickSelect();
  function rbush(maxEntries) {
    var format = [".left", ".top", ".right", ".bottom"];
    if (!(this instanceof rbush))
      return new rbush(maxEntries, format);
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  rbush.prototype = {
    all: function() {
      return this._all(this.data, []);
    },
    search: function(bbox) {
      var node = this.data, result = [], toBBox = this.toBBox;
      if (!intersects(bbox, node))
        return result;
      var nodesToSearch = [], i, len, child, childBBox;
      while (node) {
        for (i = 0, len = node.children.length; i < len; i++) {
          child = node.children[i];
          childBBox = node.leaf ? toBBox(child) : child;
          if (intersects(bbox, childBBox)) {
            if (node.leaf)
              result.push(child);
            else if (contains(bbox, childBBox))
              this._all(child, result);
            else
              nodesToSearch.push(child);
          }
        }
        node = nodesToSearch.pop();
      }
      return result;
    },
    collides: function(bbox) {
      var node = this.data, toBBox = this.toBBox;
      if (!intersects(bbox, node))
        return false;
      var nodesToSearch = [], i, len, child, childBBox;
      while (node) {
        for (i = 0, len = node.children.length; i < len; i++) {
          child = node.children[i];
          childBBox = node.leaf ? toBBox(child) : child;
          if (intersects(bbox, childBBox)) {
            if (node.leaf || contains(bbox, childBBox))
              return true;
            nodesToSearch.push(child);
          }
        }
        node = nodesToSearch.pop();
      }
      return false;
    },
    load: function(data) {
      if (!(data && data.length))
        return this;
      if (data.length < this._minEntries) {
        for (var i = 0, len = data.length; i < len; i++) {
          this.insert(data[i]);
        }
        return this;
      }
      var node = this._build(data.slice(), 0, data.length - 1, 0);
      if (!this.data.children.length) {
        this.data = node;
      } else if (this.data.height === node.height) {
        this._splitRoot(this.data, node);
      } else {
        if (this.data.height < node.height) {
          var tmpNode = this.data;
          this.data = node;
          node = tmpNode;
        }
        this._insert(node, this.data.height - node.height - 1, true);
      }
      return this;
    },
    insert: function(item) {
      if (item)
        this._insert(item, this.data.height - 1);
      return this;
    },
    clear: function() {
      this.data = createNode([]);
      return this;
    },
    remove: function(item, equalsFn) {
      if (!item)
        return this;
      var node = this.data, bbox = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
      while (node || path.length) {
        if (!node) {
          node = path.pop();
          parent = path[path.length - 1];
          i = indexes.pop();
          goingUp = true;
        }
        if (node.leaf) {
          index = findItem(item, node.children, equalsFn);
          if (index !== -1) {
            node.children.splice(index, 1);
            path.push(node);
            this._condense(path);
            return this;
          }
        }
        if (!goingUp && !node.leaf && contains(node, bbox)) {
          path.push(node);
          indexes.push(i);
          i = 0;
          parent = node;
          node = node.children[0];
        } else if (parent) {
          i++;
          node = parent.children[i];
          goingUp = false;
        } else
          node = null;
      }
      return this;
    },
    toBBox: function(item) {
      return item;
    },
    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,
    toJSON: function() {
      return this.data;
    },
    fromJSON: function(data) {
      this.data = data;
      return this;
    },
    _all: function(node, result) {
      var nodesToSearch = [];
      while (node) {
        if (node.leaf)
          result.push.apply(result, node.children);
        else
          nodesToSearch.push.apply(nodesToSearch, node.children);
        node = nodesToSearch.pop();
      }
      return result;
    },
    _build: function(items, left, right, height) {
      var N = right - left + 1, M = this._maxEntries, node;
      if (N <= M) {
        node = createNode(items.slice(left, right + 1));
        calcBBox(node, this.toBBox);
        return node;
      }
      if (!height) {
        height = Math.ceil(Math.log(N) / Math.log(M));
        M = Math.ceil(N / Math.pow(M, height - 1));
      }
      node = createNode([]);
      node.leaf = false;
      node.height = height;
      var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
      multiSelect(items, left, right, N1, this.compareMinX);
      for (i = left; i <= right; i += N1) {
        right2 = Math.min(i + N1 - 1, right);
        multiSelect(items, i, right2, N2, this.compareMinY);
        for (j = i; j <= right2; j += N2) {
          right3 = Math.min(j + N2 - 1, right2);
          node.children.push(this._build(items, j, right3, height - 1));
        }
      }
      calcBBox(node, this.toBBox);
      return node;
    },
    _chooseSubtree: function(bbox, node, level, path) {
      var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
      while (true) {
        path.push(node);
        if (node.leaf || path.length - 1 === level)
          break;
        minArea = minEnlargement = Infinity;
        for (i = 0, len = node.children.length; i < len; i++) {
          child = node.children[i];
          area = bboxArea(child);
          enlargement = enlargedArea(bbox, child) - area;
          if (enlargement < minEnlargement) {
            minEnlargement = enlargement;
            minArea = area < minArea ? area : minArea;
            targetNode = child;
          } else if (enlargement === minEnlargement) {
            if (area < minArea) {
              minArea = area;
              targetNode = child;
            }
          }
        }
        node = targetNode || node.children[0];
      }
      return node;
    },
    _insert: function(item, level, isNode) {
      var toBBox = this.toBBox, bbox = isNode ? item : toBBox(item), insertPath = [];
      var node = this._chooseSubtree(bbox, this.data, level, insertPath);
      node.children.push(item);
      extend(node, bbox);
      while (level >= 0) {
        if (insertPath[level].children.length > this._maxEntries) {
          this._split(insertPath, level);
          level--;
        } else
          break;
      }
      this._adjustParentBBoxes(bbox, insertPath, level);
    },
    _split: function(insertPath, level) {
      var node = insertPath[level], M = node.children.length, m = this._minEntries;
      this._chooseSplitAxis(node, m, M);
      var splitIndex = this._chooseSplitIndex(node, m, M);
      var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
      newNode.height = node.height;
      newNode.leaf = node.leaf;
      calcBBox(node, this.toBBox);
      calcBBox(newNode, this.toBBox);
      if (level)
        insertPath[level - 1].children.push(newNode);
      else
        this._splitRoot(node, newNode);
    },
    _splitRoot: function(node, newNode) {
      this.data = createNode([node, newNode]);
      this.data.height = node.height + 1;
      this.data.leaf = false;
      calcBBox(this.data, this.toBBox);
    },
    _chooseSplitIndex: function(node, m, M) {
      var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
      minOverlap = minArea = Infinity;
      for (i = m; i <= M - m; i++) {
        bbox1 = distBBox(node, 0, i, this.toBBox);
        bbox2 = distBBox(node, i, M, this.toBBox);
        overlap = intersectionArea(bbox1, bbox2);
        area = bboxArea(bbox1) + bboxArea(bbox2);
        if (overlap < minOverlap) {
          minOverlap = overlap;
          index = i;
          minArea = area < minArea ? area : minArea;
        } else if (overlap === minOverlap) {
          if (area < minArea) {
            minArea = area;
            index = i;
          }
        }
      }
      return index;
    },
    _chooseSplitAxis: function(node, m, M) {
      var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
      if (xMargin < yMargin)
        node.children.sort(compareMinX);
    },
    _allDistMargin: function(node, m, M, compare) {
      node.children.sort(compare);
      var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
      for (i = m; i < M - m; i++) {
        child = node.children[i];
        extend(leftBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(leftBBox);
      }
      for (i = M - m - 1; i >= m; i--) {
        child = node.children[i];
        extend(rightBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(rightBBox);
      }
      return margin;
    },
    _adjustParentBBoxes: function(bbox, path, level) {
      for (var i = level; i >= 0; i--) {
        extend(path[i], bbox);
      }
    },
    _condense: function(path) {
      for (var i = path.length - 1, siblings; i >= 0; i--) {
        if (path[i].children.length === 0) {
          if (i > 0) {
            siblings = path[i - 1].children;
            siblings.splice(siblings.indexOf(path[i]), 1);
          } else
            this.clear();
        } else
          calcBBox(path[i], this.toBBox);
      }
    },
    compareMinX: function(a, b) {
      return a.left - b.left;
    },
    compareMinY: function(a, b) {
      return a.top - b.top;
    },
    toBBox: function(a) {
      return {
        minX: a.left,
        minY: a.top,
        maxX: a.right,
        maxY: a.bottom
      };
    }
  };
  function findItem(item, items, equalsFn) {
    if (!equalsFn)
      return items.indexOf(item);
    for (var i = 0; i < items.length; i++) {
      if (equalsFn(item, items[i]))
        return i;
    }
    return -1;
  }
  function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
  }
  function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode)
      destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;
    for (var i = k, child; i < p; i++) {
      child = node.children[i];
      extend(destNode, node.leaf ? toBBox(child) : child);
    }
    return destNode;
  }
  function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
  }
  function compareNodeMinX(a, b) {
    return a.minX - b.minX;
  }
  function compareNodeMinY(a, b) {
    return a.minY - b.minY;
  }
  function bboxArea(a) {
    return (a.maxX - a.minX) * (a.maxY - a.minY);
  }
  function bboxMargin(a) {
    return a.maxX - a.minX + (a.maxY - a.minY);
  }
  function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
  }
  function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
  }
  function contains(a, b) {
    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
  }
  function intersects(a, b) {
    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
  }
  function createNode(children) {
    return {
      children,
      height: 1,
      leaf: true,
      minX: Infinity,
      minY: Infinity,
      maxX: -Infinity,
      maxY: -Infinity
    };
  }
  function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right], mid;
    while (stack.length) {
      right = stack.pop();
      left = stack.pop();
      if (right - left <= n)
        continue;
      mid = left + Math.ceil((right - left) / n / 2) * n;
      quickselect(arr, mid, left, right, compare);
      stack.push(left, mid, mid, right);
    }
  }
  module2.exports = rbush;
});

// node_modules/phaser/src/physics/arcade/tilemap/ProcessTileSeparationX.js
var require_ProcessTileSeparationX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ProcessTileSeparationX = function(body, x) {
    if (x < 0) {
      body.blocked.none = false;
      body.blocked.left = true;
    } else if (x > 0) {
      body.blocked.none = false;
      body.blocked.right = true;
    }
    body.position.x -= x;
    if (body.bounce.x === 0) {
      body.velocity.x = 0;
    } else {
      body.velocity.x = -body.velocity.x * body.bounce.x;
    }
  };
  module2.exports = ProcessTileSeparationX;
});

// node_modules/phaser/src/physics/arcade/tilemap/TileCheckX.js
var require_TileCheckX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ProcessTileSeparationX = require_ProcessTileSeparationX();
  var TileCheckX = function(body, tile, tileLeft, tileRight, tileBias, isLayer) {
    var ox = 0;
    var faceLeft = tile.faceLeft;
    var faceRight = tile.faceRight;
    var collideLeft = tile.collideLeft;
    var collideRight = tile.collideRight;
    if (!isLayer) {
      faceLeft = true;
      faceRight = true;
      collideLeft = true;
      collideRight = true;
    }
    if (body.deltaX() < 0 && collideRight && body.checkCollision.left) {
      if (faceRight && body.x < tileRight) {
        ox = body.x - tileRight;
        if (ox < -tileBias) {
          ox = 0;
        }
      }
    } else if (body.deltaX() > 0 && collideLeft && body.checkCollision.right) {
      if (faceLeft && body.right > tileLeft) {
        ox = body.right - tileLeft;
        if (ox > tileBias) {
          ox = 0;
        }
      }
    }
    if (ox !== 0) {
      if (body.customSeparateX) {
        body.overlapX = ox;
      } else {
        ProcessTileSeparationX(body, ox);
      }
    }
    return ox;
  };
  module2.exports = TileCheckX;
});

// node_modules/phaser/src/physics/arcade/tilemap/ProcessTileSeparationY.js
var require_ProcessTileSeparationY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ProcessTileSeparationY = function(body, y) {
    if (y < 0) {
      body.blocked.none = false;
      body.blocked.up = true;
    } else if (y > 0) {
      body.blocked.none = false;
      body.blocked.down = true;
    }
    body.position.y -= y;
    if (body.bounce.y === 0) {
      body.velocity.y = 0;
    } else {
      body.velocity.y = -body.velocity.y * body.bounce.y;
    }
  };
  module2.exports = ProcessTileSeparationY;
});

// node_modules/phaser/src/physics/arcade/tilemap/TileCheckY.js
var require_TileCheckY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ProcessTileSeparationY = require_ProcessTileSeparationY();
  var TileCheckY = function(body, tile, tileTop, tileBottom, tileBias, isLayer) {
    var oy = 0;
    var faceTop = tile.faceTop;
    var faceBottom = tile.faceBottom;
    var collideUp = tile.collideUp;
    var collideDown = tile.collideDown;
    if (!isLayer) {
      faceTop = true;
      faceBottom = true;
      collideUp = true;
      collideDown = true;
    }
    if (body.deltaY() < 0 && collideDown && body.checkCollision.up) {
      if (faceBottom && body.y < tileBottom) {
        oy = body.y - tileBottom;
        if (oy < -tileBias) {
          oy = 0;
        }
      }
    } else if (body.deltaY() > 0 && collideUp && body.checkCollision.down) {
      if (faceTop && body.bottom > tileTop) {
        oy = body.bottom - tileTop;
        if (oy > tileBias) {
          oy = 0;
        }
      }
    }
    if (oy !== 0) {
      if (body.customSeparateY) {
        body.overlapY = oy;
      } else {
        ProcessTileSeparationY(body, oy);
      }
    }
    return oy;
  };
  module2.exports = TileCheckY;
});

// node_modules/phaser/src/physics/arcade/tilemap/TileIntersectsBody.js
var require_TileIntersectsBody = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TileIntersectsBody = function(tileWorldRect, body) {
    return !(body.right <= tileWorldRect.left || body.bottom <= tileWorldRect.top || body.position.x >= tileWorldRect.right || body.position.y >= tileWorldRect.bottom);
  };
  module2.exports = TileIntersectsBody;
});

// node_modules/phaser/src/physics/arcade/tilemap/SeparateTile.js
var require_SeparateTile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TileCheckX = require_TileCheckX();
  var TileCheckY = require_TileCheckY();
  var TileIntersectsBody = require_TileIntersectsBody();
  var SeparateTile = function(i, body, tile, tileWorldRect, tilemapLayer, tileBias, isLayer) {
    var tileLeft = tileWorldRect.left;
    var tileTop = tileWorldRect.top;
    var tileRight = tileWorldRect.right;
    var tileBottom = tileWorldRect.bottom;
    var faceHorizontal = tile.faceLeft || tile.faceRight;
    var faceVertical = tile.faceTop || tile.faceBottom;
    if (!isLayer) {
      faceHorizontal = true;
      faceVertical = true;
    }
    if (!faceHorizontal && !faceVertical) {
      return false;
    }
    var ox = 0;
    var oy = 0;
    var minX = 0;
    var minY = 1;
    if (body.deltaAbsX() > body.deltaAbsY()) {
      minX = -1;
    } else if (body.deltaAbsX() < body.deltaAbsY()) {
      minY = -1;
    }
    if (body.deltaX() !== 0 && body.deltaY() !== 0 && faceHorizontal && faceVertical) {
      minX = Math.min(Math.abs(body.position.x - tileRight), Math.abs(body.right - tileLeft));
      minY = Math.min(Math.abs(body.position.y - tileBottom), Math.abs(body.bottom - tileTop));
    }
    if (minX < minY) {
      if (faceHorizontal) {
        ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);
        if (ox !== 0 && !TileIntersectsBody(tileWorldRect, body)) {
          return true;
        }
      }
      if (faceVertical) {
        oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);
      }
    } else {
      if (faceVertical) {
        oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);
        if (oy !== 0 && !TileIntersectsBody(tileWorldRect, body)) {
          return true;
        }
      }
      if (faceHorizontal) {
        ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);
      }
    }
    return ox !== 0 || oy !== 0;
  };
  module2.exports = SeparateTile;
});

// node_modules/phaser/src/physics/arcade/ProcessX.js
var require_ProcessX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var body1;
  var body2;
  var body1Pushable;
  var body2Pushable;
  var body1MassImpact;
  var body2MassImpact;
  var body1FullImpact;
  var body2FullImpact;
  var body1MovingLeft;
  var body1MovingRight;
  var body1Stationary;
  var body2MovingLeft;
  var body2MovingRight;
  var body2Stationary;
  var body1OnLeft;
  var body2OnLeft;
  var overlap;
  var Set = function(b1, b2, ov) {
    body1 = b1;
    body2 = b2;
    var v1 = body1.velocity.x;
    var v2 = body2.velocity.x;
    body1Pushable = body1.pushable;
    body1MovingLeft = body1._dx < 0;
    body1MovingRight = body1._dx > 0;
    body1Stationary = body1._dx === 0;
    body1OnLeft = Math.abs(body1.right - body2.x) <= Math.abs(body2.right - body1.x);
    body1FullImpact = v2 - v1 * body1.bounce.x;
    body2Pushable = body2.pushable;
    body2MovingLeft = body2._dx < 0;
    body2MovingRight = body2._dx > 0;
    body2Stationary = body2._dx === 0;
    body2OnLeft = !body1OnLeft;
    body2FullImpact = v1 - v2 * body2.bounce.x;
    overlap = Math.abs(ov);
    return BlockCheck();
  };
  var BlockCheck = function() {
    if (body1MovingRight && body1OnLeft && body2.blocked.right) {
      body1.processX(-overlap, body1FullImpact, false, true);
      return 1;
    }
    if (body1MovingLeft && body2OnLeft && body2.blocked.left) {
      body1.processX(overlap, body1FullImpact, true);
      return 1;
    }
    if (body2MovingRight && body2OnLeft && body1.blocked.right) {
      body2.processX(-overlap, body2FullImpact, false, true);
      return 2;
    }
    if (body2MovingLeft && body1OnLeft && body1.blocked.left) {
      body2.processX(overlap, body2FullImpact, true);
      return 2;
    }
    return 0;
  };
  var Check = function() {
    var v1 = body1.velocity.x;
    var v2 = body2.velocity.x;
    var nv1 = Math.sqrt(v2 * v2 * body2.mass / body1.mass) * (v2 > 0 ? 1 : -1);
    var nv2 = Math.sqrt(v1 * v1 * body1.mass / body2.mass) * (v1 > 0 ? 1 : -1);
    var avg = (nv1 + nv2) * 0.5;
    nv1 -= avg;
    nv2 -= avg;
    body1MassImpact = avg + nv1 * body1.bounce.x;
    body2MassImpact = avg + nv2 * body2.bounce.x;
    if (body1MovingLeft && body2OnLeft) {
      return Run(0);
    }
    if (body2MovingLeft && body1OnLeft) {
      return Run(1);
    }
    if (body1MovingRight && body1OnLeft) {
      return Run(2);
    }
    if (body2MovingRight && body2OnLeft) {
      return Run(3);
    }
    return false;
  };
  var Run = function(side) {
    if (body1Pushable && body2Pushable) {
      overlap *= 0.5;
      if (side === 0 || side === 3) {
        body1.processX(overlap, body1MassImpact);
        body2.processX(-overlap, body2MassImpact);
      } else {
        body1.processX(-overlap, body1MassImpact);
        body2.processX(overlap, body2MassImpact);
      }
    } else if (body1Pushable && !body2Pushable) {
      if (side === 0 || side === 3) {
        body1.processX(overlap, body1FullImpact, true);
      } else {
        body1.processX(-overlap, body1FullImpact, false, true);
      }
    } else if (!body1Pushable && body2Pushable) {
      if (side === 0 || side === 3) {
        body2.processX(-overlap, body2FullImpact, false, true);
      } else {
        body2.processX(overlap, body2FullImpact, true);
      }
    } else {
      var halfOverlap = overlap * 0.5;
      if (side === 0) {
        if (body2Stationary) {
          body1.processX(overlap, 0, true);
          body2.processX(0, null, false, true);
        } else if (body2MovingRight) {
          body1.processX(halfOverlap, 0, true);
          body2.processX(-halfOverlap, 0, false, true);
        } else {
          body1.processX(halfOverlap, body2.velocity.x, true);
          body2.processX(-halfOverlap, null, false, true);
        }
      } else if (side === 1) {
        if (body1Stationary) {
          body1.processX(0, null, false, true);
          body2.processX(overlap, 0, true);
        } else if (body1MovingRight) {
          body1.processX(-halfOverlap, 0, false, true);
          body2.processX(halfOverlap, 0, true);
        } else {
          body1.processX(-halfOverlap, null, false, true);
          body2.processX(halfOverlap, body1.velocity.x, true);
        }
      } else if (side === 2) {
        if (body2Stationary) {
          body1.processX(-overlap, 0, false, true);
          body2.processX(0, null, true);
        } else if (body2MovingLeft) {
          body1.processX(-halfOverlap, 0, false, true);
          body2.processX(halfOverlap, 0, true);
        } else {
          body1.processX(-halfOverlap, body2.velocity.x, false, true);
          body2.processX(halfOverlap, null, true);
        }
      } else if (side === 3) {
        if (body1Stationary) {
          body1.processX(0, null, true);
          body2.processX(-overlap, 0, false, true);
        } else if (body1MovingLeft) {
          body1.processX(halfOverlap, 0, true);
          body2.processX(-halfOverlap, 0, false, true);
        } else {
          body1.processX(halfOverlap, body2.velocity.y, true);
          body2.processX(-halfOverlap, null, false, true);
        }
      }
    }
    return true;
  };
  var RunImmovableBody1 = function(blockedState) {
    if (blockedState === 1) {
      body2.velocity.x = 0;
    } else if (body1OnLeft) {
      body2.processX(overlap, body2FullImpact, true);
    } else {
      body2.processX(-overlap, body2FullImpact, false, true);
    }
    if (body1.moves) {
      body2.y += (body1.y - body1.prev.y) * body1.friction.y;
      body2._dy = body2.y - body2.prev.y;
    }
  };
  var RunImmovableBody2 = function(blockedState) {
    if (blockedState === 2) {
      body1.velocity.x = 0;
    } else if (body2OnLeft) {
      body1.processX(overlap, body1FullImpact, true);
    } else {
      body1.processX(-overlap, body1FullImpact, false, true);
    }
    if (body2.moves) {
      body1.y += (body2.y - body2.prev.y) * body2.friction.y;
      body1._dy = body1.y - body1.prev.y;
    }
  };
  module2.exports = {
    BlockCheck,
    Check,
    Set,
    Run,
    RunImmovableBody1,
    RunImmovableBody2
  };
});

// node_modules/phaser/src/physics/arcade/SeparateX.js
var require_SeparateX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetOverlapX = require_GetOverlapX();
  var ProcessX = require_ProcessX();
  var SeparateX = function(body1, body2, overlapOnly, bias) {
    var overlap = GetOverlapX(body1, body2, overlapOnly, bias);
    var body1Immovable = body1.immovable;
    var body2Immovable = body2.immovable;
    if (overlapOnly || overlap === 0 || body1Immovable && body2Immovable || body1.customSeparateX || body2.customSeparateX) {
      return overlap !== 0 || body1.embedded && body2.embedded;
    }
    var blockedState = ProcessX.Set(body1, body2, overlap);
    if (!body1Immovable && !body2Immovable) {
      if (blockedState > 0) {
        return true;
      }
      return ProcessX.Check();
    } else if (body1Immovable) {
      ProcessX.RunImmovableBody1(blockedState);
    } else if (body2Immovable) {
      ProcessX.RunImmovableBody2(blockedState);
    }
    return true;
  };
  module2.exports = SeparateX;
});

// node_modules/phaser/src/physics/arcade/ProcessY.js
var require_ProcessY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var body1;
  var body2;
  var body1Pushable;
  var body2Pushable;
  var body1MassImpact;
  var body2MassImpact;
  var body1FullImpact;
  var body2FullImpact;
  var body1MovingUp;
  var body1MovingDown;
  var body1Stationary;
  var body2MovingUp;
  var body2MovingDown;
  var body2Stationary;
  var body1OnTop;
  var body2OnTop;
  var overlap;
  var Set = function(b1, b2, ov) {
    body1 = b1;
    body2 = b2;
    var v1 = body1.velocity.y;
    var v2 = body2.velocity.y;
    body1Pushable = body1.pushable;
    body1MovingUp = body1._dy < 0;
    body1MovingDown = body1._dy > 0;
    body1Stationary = body1._dy === 0;
    body1OnTop = Math.abs(body1.bottom - body2.y) <= Math.abs(body2.bottom - body1.y);
    body1FullImpact = v2 - v1 * body1.bounce.y;
    body2Pushable = body2.pushable;
    body2MovingUp = body2._dy < 0;
    body2MovingDown = body2._dy > 0;
    body2Stationary = body2._dy === 0;
    body2OnTop = !body1OnTop;
    body2FullImpact = v1 - v2 * body2.bounce.y;
    overlap = Math.abs(ov);
    return BlockCheck();
  };
  var BlockCheck = function() {
    if (body1MovingDown && body1OnTop && body2.blocked.down) {
      body1.processY(-overlap, body1FullImpact, false, true);
      return 1;
    }
    if (body1MovingUp && body2OnTop && body2.blocked.up) {
      body1.processY(overlap, body1FullImpact, true);
      return 1;
    }
    if (body2MovingDown && body2OnTop && body1.blocked.down) {
      body2.processY(-overlap, body2FullImpact, false, true);
      return 2;
    }
    if (body2MovingUp && body1OnTop && body1.blocked.up) {
      body2.processY(overlap, body2FullImpact, true);
      return 2;
    }
    return 0;
  };
  var Check = function() {
    var v1 = body1.velocity.y;
    var v2 = body2.velocity.y;
    var nv1 = Math.sqrt(v2 * v2 * body2.mass / body1.mass) * (v2 > 0 ? 1 : -1);
    var nv2 = Math.sqrt(v1 * v1 * body1.mass / body2.mass) * (v1 > 0 ? 1 : -1);
    var avg = (nv1 + nv2) * 0.5;
    nv1 -= avg;
    nv2 -= avg;
    body1MassImpact = avg + nv1 * body1.bounce.y;
    body2MassImpact = avg + nv2 * body2.bounce.y;
    if (body1MovingUp && body2OnTop) {
      return Run(0);
    }
    if (body2MovingUp && body1OnTop) {
      return Run(1);
    }
    if (body1MovingDown && body1OnTop) {
      return Run(2);
    }
    if (body2MovingDown && body2OnTop) {
      return Run(3);
    }
    return false;
  };
  var Run = function(side) {
    if (body1Pushable && body2Pushable) {
      overlap *= 0.5;
      if (side === 0 || side === 3) {
        body1.processY(overlap, body1MassImpact);
        body2.processY(-overlap, body2MassImpact);
      } else {
        body1.processY(-overlap, body1MassImpact);
        body2.processY(overlap, body2MassImpact);
      }
    } else if (body1Pushable && !body2Pushable) {
      if (side === 0 || side === 3) {
        body1.processY(overlap, body1FullImpact, true);
      } else {
        body1.processY(-overlap, body1FullImpact, false, true);
      }
    } else if (!body1Pushable && body2Pushable) {
      if (side === 0 || side === 3) {
        body2.processY(-overlap, body2FullImpact, false, true);
      } else {
        body2.processY(overlap, body2FullImpact, true);
      }
    } else {
      var halfOverlap = overlap * 0.5;
      if (side === 0) {
        if (body2Stationary) {
          body1.processY(overlap, 0, true);
          body2.processY(0, null, false, true);
        } else if (body2MovingDown) {
          body1.processY(halfOverlap, 0, true);
          body2.processY(-halfOverlap, 0, false, true);
        } else {
          body1.processY(halfOverlap, body2.velocity.y, true);
          body2.processY(-halfOverlap, null, false, true);
        }
      } else if (side === 1) {
        if (body1Stationary) {
          body1.processY(0, null, false, true);
          body2.processY(overlap, 0, true);
        } else if (body1MovingDown) {
          body1.processY(-halfOverlap, 0, false, true);
          body2.processY(halfOverlap, 0, true);
        } else {
          body1.processY(-halfOverlap, null, false, true);
          body2.processY(halfOverlap, body1.velocity.y, true);
        }
      } else if (side === 2) {
        if (body2Stationary) {
          body1.processY(-overlap, 0, false, true);
          body2.processY(0, null, true);
        } else if (body2MovingUp) {
          body1.processY(-halfOverlap, 0, false, true);
          body2.processY(halfOverlap, 0, true);
        } else {
          body1.processY(-halfOverlap, body2.velocity.y, false, true);
          body2.processY(halfOverlap, null, true);
        }
      } else if (side === 3) {
        if (body1Stationary) {
          body1.processY(0, null, true);
          body2.processY(-overlap, 0, false, true);
        } else if (body1MovingUp) {
          body1.processY(halfOverlap, 0, true);
          body2.processY(-halfOverlap, 0, false, true);
        } else {
          body1.processY(halfOverlap, body2.velocity.y, true);
          body2.processY(-halfOverlap, null, false, true);
        }
      }
    }
    return true;
  };
  var RunImmovableBody1 = function(blockedState) {
    if (blockedState === 1) {
      body2.velocity.y = 0;
    } else if (body1OnTop) {
      body2.processY(overlap, body2FullImpact, true);
    } else {
      body2.processY(-overlap, body2FullImpact, false, true);
    }
    if (body1.moves) {
      body2.x += (body1.x - body1.prev.x) * body1.friction.x;
      body2._dx = body2.x - body2.prev.x;
    }
  };
  var RunImmovableBody2 = function(blockedState) {
    if (blockedState === 2) {
      body1.velocity.y = 0;
    } else if (body2OnTop) {
      body1.processY(overlap, body1FullImpact, true);
    } else {
      body1.processY(-overlap, body1FullImpact, false, true);
    }
    if (body2.moves) {
      body1.x += (body2.x - body2.prev.x) * body2.friction.x;
      body1._dx = body1.x - body1.prev.x;
    }
  };
  module2.exports = {
    BlockCheck,
    Check,
    Set,
    Run,
    RunImmovableBody1,
    RunImmovableBody2
  };
});

// node_modules/phaser/src/physics/arcade/SeparateY.js
var require_SeparateY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetOverlapY = require_GetOverlapY();
  var ProcessY = require_ProcessY();
  var SeparateY = function(body1, body2, overlapOnly, bias) {
    var overlap = GetOverlapY(body1, body2, overlapOnly, bias);
    var body1Immovable = body1.immovable;
    var body2Immovable = body2.immovable;
    if (overlapOnly || overlap === 0 || body1Immovable && body2Immovable || body1.customSeparateY || body2.customSeparateY) {
      return overlap !== 0 || body1.embedded && body2.embedded;
    }
    var blockedState = ProcessY.Set(body1, body2, overlap);
    if (!body1Immovable && !body2Immovable) {
      if (blockedState > 0) {
        return true;
      }
      return ProcessY.Check();
    } else if (body1Immovable) {
      ProcessY.RunImmovableBody1(blockedState);
    } else if (body2Immovable) {
      ProcessY.RunImmovableBody2(blockedState);
    }
    return true;
  };
  module2.exports = SeparateY;
});

// node_modules/phaser/src/physics/arcade/StaticBody.js
var require_StaticBody = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CircleContains = require_Contains();
  var Class = require_Class();
  var CONST = require_const13();
  var RectangleContains = require_Contains2();
  var Vector2 = require_Vector2();
  var StaticBody = new Class({
    initialize: function StaticBody2(world, gameObject) {
      var width = gameObject.displayWidth ? gameObject.displayWidth : 64;
      var height = gameObject.displayHeight ? gameObject.displayHeight : 64;
      this.world = world;
      this.gameObject = gameObject;
      this.debugShowBody = world.defaults.debugShowStaticBody;
      this.debugBodyColor = world.defaults.staticBodyDebugColor;
      this.enable = true;
      this.isCircle = false;
      this.radius = 0;
      this.offset = new Vector2();
      this.position = new Vector2(gameObject.x - width * gameObject.originX, gameObject.y - height * gameObject.originY);
      this.width = width;
      this.height = height;
      this.halfWidth = Math.abs(this.width / 2);
      this.halfHeight = Math.abs(this.height / 2);
      this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
      this.velocity = Vector2.ZERO;
      this.allowGravity = false;
      this.gravity = Vector2.ZERO;
      this.bounce = Vector2.ZERO;
      this.onWorldBounds = false;
      this.onCollide = false;
      this.onOverlap = false;
      this.mass = 1;
      this.immovable = true;
      this.pushable = false;
      this.customSeparateX = false;
      this.customSeparateY = false;
      this.overlapX = 0;
      this.overlapY = 0;
      this.overlapR = 0;
      this.embedded = false;
      this.collideWorldBounds = false;
      this.checkCollision = {none: false, up: true, down: true, left: true, right: true};
      this.touching = {none: true, up: false, down: false, left: false, right: false};
      this.wasTouching = {none: true, up: false, down: false, left: false, right: false};
      this.blocked = {none: true, up: false, down: false, left: false, right: false};
      this.physicsType = CONST.STATIC_BODY;
      this._dx = 0;
      this._dy = 0;
    },
    setGameObject: function(gameObject, update) {
      if (gameObject && gameObject !== this.gameObject) {
        this.gameObject.body = null;
        gameObject.body = this;
        this.gameObject = gameObject;
      }
      if (update) {
        this.updateFromGameObject();
      }
      return this;
    },
    updateFromGameObject: function() {
      this.world.staticTree.remove(this);
      var gameObject = this.gameObject;
      gameObject.getTopLeft(this.position);
      this.width = gameObject.displayWidth;
      this.height = gameObject.displayHeight;
      this.halfWidth = Math.abs(this.width / 2);
      this.halfHeight = Math.abs(this.height / 2);
      this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
      this.world.staticTree.insert(this);
      return this;
    },
    setOffset: function(x, y) {
      if (y === void 0) {
        y = x;
      }
      this.world.staticTree.remove(this);
      this.position.x -= this.offset.x;
      this.position.y -= this.offset.y;
      this.offset.set(x, y);
      this.position.x += this.offset.x;
      this.position.y += this.offset.y;
      this.updateCenter();
      this.world.staticTree.insert(this);
      return this;
    },
    setSize: function(width, height, center) {
      if (center === void 0) {
        center = true;
      }
      var gameObject = this.gameObject;
      if (!width && gameObject.frame) {
        width = gameObject.frame.realWidth;
      }
      if (!height && gameObject.frame) {
        height = gameObject.frame.realHeight;
      }
      this.world.staticTree.remove(this);
      this.width = width;
      this.height = height;
      this.halfWidth = Math.floor(width / 2);
      this.halfHeight = Math.floor(height / 2);
      if (center && gameObject.getCenter) {
        var ox = gameObject.displayWidth / 2;
        var oy = gameObject.displayHeight / 2;
        this.position.x -= this.offset.x;
        this.position.y -= this.offset.y;
        this.offset.set(ox - this.halfWidth, oy - this.halfHeight);
        this.position.x += this.offset.x;
        this.position.y += this.offset.y;
      }
      this.updateCenter();
      this.isCircle = false;
      this.radius = 0;
      this.world.staticTree.insert(this);
      return this;
    },
    setCircle: function(radius, offsetX, offsetY) {
      if (offsetX === void 0) {
        offsetX = this.offset.x;
      }
      if (offsetY === void 0) {
        offsetY = this.offset.y;
      }
      if (radius > 0) {
        this.world.staticTree.remove(this);
        this.isCircle = true;
        this.radius = radius;
        this.width = radius * 2;
        this.height = radius * 2;
        this.halfWidth = Math.floor(this.width / 2);
        this.halfHeight = Math.floor(this.height / 2);
        this.offset.set(offsetX, offsetY);
        this.updateCenter();
        this.world.staticTree.insert(this);
      } else {
        this.isCircle = false;
      }
      return this;
    },
    updateCenter: function() {
      this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
    },
    reset: function(x, y) {
      var gameObject = this.gameObject;
      if (x === void 0) {
        x = gameObject.x;
      }
      if (y === void 0) {
        y = gameObject.y;
      }
      this.world.staticTree.remove(this);
      gameObject.setPosition(x, y);
      gameObject.getTopLeft(this.position);
      this.updateCenter();
      this.world.staticTree.insert(this);
    },
    stop: function() {
      return this;
    },
    getBounds: function(obj) {
      obj.x = this.x;
      obj.y = this.y;
      obj.right = this.right;
      obj.bottom = this.bottom;
      return obj;
    },
    hitTest: function(x, y) {
      return this.isCircle ? CircleContains(this, x, y) : RectangleContains(this, x, y);
    },
    postUpdate: function() {
    },
    deltaAbsX: function() {
      return 0;
    },
    deltaAbsY: function() {
      return 0;
    },
    deltaX: function() {
      return 0;
    },
    deltaY: function() {
      return 0;
    },
    deltaZ: function() {
      return 0;
    },
    destroy: function() {
      this.enable = false;
      this.world.pendingDestroy.set(this);
    },
    drawDebug: function(graphic) {
      var pos = this.position;
      var x = pos.x + this.halfWidth;
      var y = pos.y + this.halfHeight;
      if (this.debugShowBody) {
        graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor, 1);
        if (this.isCircle) {
          graphic.strokeCircle(x, y, this.width / 2);
        } else {
          graphic.strokeRect(pos.x, pos.y, this.width, this.height);
        }
      }
    },
    willDrawDebug: function() {
      return this.debugShowBody;
    },
    setMass: function(value) {
      if (value <= 0) {
        value = 0.1;
      }
      this.mass = value;
      return this;
    },
    x: {
      get: function() {
        return this.position.x;
      },
      set: function(value) {
        this.world.staticTree.remove(this);
        this.position.x = value;
        this.world.staticTree.insert(this);
      }
    },
    y: {
      get: function() {
        return this.position.y;
      },
      set: function(value) {
        this.world.staticTree.remove(this);
        this.position.y = value;
        this.world.staticTree.insert(this);
      }
    },
    left: {
      get: function() {
        return this.position.x;
      }
    },
    right: {
      get: function() {
        return this.position.x + this.width;
      }
    },
    top: {
      get: function() {
        return this.position.y;
      }
    },
    bottom: {
      get: function() {
        return this.position.y + this.height;
      }
    }
  });
  module2.exports = StaticBody;
});

// node_modules/phaser/src/physics/arcade/World.js
var require_World = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AngleBetweenPoints = require_BetweenPoints();
  var Body = require_Body();
  var Clamp = require_Clamp();
  var Class = require_Class();
  var Collider = require_Collider();
  var CONST = require_const13();
  var DistanceBetween = require_DistanceBetween();
  var EventEmitter = require_eventemitter3();
  var Events = require_events19();
  var FuzzyEqual = require_Equal();
  var FuzzyGreaterThan = require_GreaterThan();
  var FuzzyLessThan = require_LessThan();
  var GetOverlapX = require_GetOverlapX();
  var GetOverlapY = require_GetOverlapY();
  var GetTilesWithinWorldXY = require_GetTilesWithinWorldXY();
  var GetValue = require_GetValue();
  var MATH_CONST = require_const4();
  var ProcessQueue = require_ProcessQueue();
  var ProcessTileCallbacks = require_ProcessTileCallbacks();
  var Rectangle = require_Rectangle();
  var RTree = require_RTree();
  var SeparateTile = require_SeparateTile();
  var SeparateX = require_SeparateX();
  var SeparateY = require_SeparateY();
  var Set = require_Set();
  var StaticBody = require_StaticBody();
  var TileIntersectsBody = require_TileIntersectsBody();
  var TransformMatrix = require_TransformMatrix();
  var Vector2 = require_Vector2();
  var Wrap = require_Wrap();
  var World = new Class({
    Extends: EventEmitter,
    initialize: function World2(scene, config2) {
      EventEmitter.call(this);
      this.scene = scene;
      this.bodies = new Set();
      this.staticBodies = new Set();
      this.pendingDestroy = new Set();
      this.colliders = new ProcessQueue();
      this.gravity = new Vector2(GetValue(config2, "gravity.x", 0), GetValue(config2, "gravity.y", 0));
      this.bounds = new Rectangle(GetValue(config2, "x", 0), GetValue(config2, "y", 0), GetValue(config2, "width", scene.sys.scale.width), GetValue(config2, "height", scene.sys.scale.height));
      this.checkCollision = {
        up: GetValue(config2, "checkCollision.up", true),
        down: GetValue(config2, "checkCollision.down", true),
        left: GetValue(config2, "checkCollision.left", true),
        right: GetValue(config2, "checkCollision.right", true)
      };
      this.fps = GetValue(config2, "fps", 60);
      this.fixedStep = GetValue(config2, "fixedStep", true);
      this._elapsed = 0;
      this._frameTime = 1 / this.fps;
      this._frameTimeMS = 1e3 * this._frameTime;
      this.stepsLastFrame = 0;
      this.timeScale = GetValue(config2, "timeScale", 1);
      this.OVERLAP_BIAS = GetValue(config2, "overlapBias", 4);
      this.TILE_BIAS = GetValue(config2, "tileBias", 16);
      this.forceX = GetValue(config2, "forceX", false);
      this.isPaused = GetValue(config2, "isPaused", false);
      this._total = 0;
      this.drawDebug = GetValue(config2, "debug", false);
      this.debugGraphic;
      this.defaults = {
        debugShowBody: GetValue(config2, "debugShowBody", true),
        debugShowStaticBody: GetValue(config2, "debugShowStaticBody", true),
        debugShowVelocity: GetValue(config2, "debugShowVelocity", true),
        bodyDebugColor: GetValue(config2, "debugBodyColor", 16711935),
        staticBodyDebugColor: GetValue(config2, "debugStaticBodyColor", 255),
        velocityDebugColor: GetValue(config2, "debugVelocityColor", 65280)
      };
      this.maxEntries = GetValue(config2, "maxEntries", 16);
      this.useTree = GetValue(config2, "useTree", true);
      this.tree = new RTree(this.maxEntries);
      this.staticTree = new RTree(this.maxEntries);
      this.treeMinMax = {minX: 0, minY: 0, maxX: 0, maxY: 0};
      this._tempMatrix = new TransformMatrix();
      this._tempMatrix2 = new TransformMatrix();
      if (this.drawDebug) {
        this.createDebugGraphic();
      }
    },
    enable: function(object, bodyType) {
      if (bodyType === void 0) {
        bodyType = CONST.DYNAMIC_BODY;
      }
      if (!Array.isArray(object)) {
        object = [object];
      }
      for (var i = 0; i < object.length; i++) {
        var entry = object[i];
        if (entry.isParent) {
          var children = entry.getChildren();
          for (var c = 0; c < children.length; c++) {
            var child = children[c];
            if (child.isParent) {
              this.enable(child, bodyType);
            } else {
              this.enableBody(child, bodyType);
            }
          }
        } else {
          this.enableBody(entry, bodyType);
        }
      }
    },
    enableBody: function(object, bodyType) {
      if (bodyType === void 0) {
        bodyType = CONST.DYNAMIC_BODY;
      }
      if (!object.body) {
        if (bodyType === CONST.DYNAMIC_BODY) {
          object.body = new Body(this, object);
        } else if (bodyType === CONST.STATIC_BODY) {
          object.body = new StaticBody(this, object);
        }
      }
      this.add(object.body);
      return object;
    },
    add: function(body) {
      if (body.physicsType === CONST.DYNAMIC_BODY) {
        this.bodies.set(body);
      } else if (body.physicsType === CONST.STATIC_BODY) {
        this.staticBodies.set(body);
        this.staticTree.insert(body);
      }
      body.enable = true;
      return body;
    },
    disable: function(object) {
      if (!Array.isArray(object)) {
        object = [object];
      }
      for (var i = 0; i < object.length; i++) {
        var entry = object[i];
        if (entry.isParent) {
          var children = entry.getChildren();
          for (var c = 0; c < children.length; c++) {
            var child = children[c];
            if (child.isParent) {
              this.disable(child);
            } else {
              this.disableBody(child.body);
            }
          }
        } else {
          this.disableBody(entry.body);
        }
      }
    },
    disableBody: function(body) {
      this.remove(body);
      body.enable = false;
    },
    remove: function(body) {
      if (body.physicsType === CONST.DYNAMIC_BODY) {
        this.tree.remove(body);
        this.bodies.delete(body);
      } else if (body.physicsType === CONST.STATIC_BODY) {
        this.staticBodies.delete(body);
        this.staticTree.remove(body);
      }
    },
    createDebugGraphic: function() {
      var graphic = this.scene.sys.add.graphics({x: 0, y: 0});
      graphic.setDepth(Number.MAX_VALUE);
      this.debugGraphic = graphic;
      this.drawDebug = true;
      return graphic;
    },
    setBounds: function(x, y, width, height, checkLeft, checkRight, checkUp, checkDown) {
      this.bounds.setTo(x, y, width, height);
      if (checkLeft !== void 0) {
        this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown);
      }
      return this;
    },
    setBoundsCollision: function(left, right, up, down) {
      if (left === void 0) {
        left = true;
      }
      if (right === void 0) {
        right = true;
      }
      if (up === void 0) {
        up = true;
      }
      if (down === void 0) {
        down = true;
      }
      this.checkCollision.left = left;
      this.checkCollision.right = right;
      this.checkCollision.up = up;
      this.checkCollision.down = down;
      return this;
    },
    pause: function() {
      this.isPaused = true;
      this.emit(Events.PAUSE);
      return this;
    },
    resume: function() {
      this.isPaused = false;
      this.emit(Events.RESUME);
      return this;
    },
    addCollider: function(object1, object2, collideCallback, processCallback, callbackContext) {
      if (collideCallback === void 0) {
        collideCallback = null;
      }
      if (processCallback === void 0) {
        processCallback = null;
      }
      if (callbackContext === void 0) {
        callbackContext = collideCallback;
      }
      var collider = new Collider(this, false, object1, object2, collideCallback, processCallback, callbackContext);
      this.colliders.add(collider);
      return collider;
    },
    addOverlap: function(object1, object2, collideCallback, processCallback, callbackContext) {
      if (collideCallback === void 0) {
        collideCallback = null;
      }
      if (processCallback === void 0) {
        processCallback = null;
      }
      if (callbackContext === void 0) {
        callbackContext = collideCallback;
      }
      var collider = new Collider(this, true, object1, object2, collideCallback, processCallback, callbackContext);
      this.colliders.add(collider);
      return collider;
    },
    removeCollider: function(collider) {
      this.colliders.remove(collider);
      return this;
    },
    setFPS: function(framerate) {
      this.fps = framerate;
      this._frameTime = 1 / this.fps;
      this._frameTimeMS = 1e3 * this._frameTime;
      return this;
    },
    update: function(time, delta) {
      if (this.isPaused || this.bodies.size === 0) {
        return;
      }
      var i;
      var fixedDelta = this._frameTime;
      var msPerFrame = this._frameTimeMS * this.timeScale;
      this._elapsed += delta;
      var body;
      var bodies = this.bodies.entries;
      var willStep = this._elapsed >= msPerFrame;
      if (!this.fixedStep) {
        fixedDelta = delta * 1e-3;
        willStep = true;
        this._elapsed = 0;
      }
      for (i = 0; i < bodies.length; i++) {
        body = bodies[i];
        if (body.enable) {
          body.preUpdate(willStep, fixedDelta);
        }
      }
      if (willStep) {
        this._elapsed -= msPerFrame;
        this.stepsLastFrame = 1;
        if (this.useTree) {
          this.tree.clear();
          this.tree.load(bodies);
        }
        var colliders = this.colliders.update();
        for (i = 0; i < colliders.length; i++) {
          var collider = colliders[i];
          if (collider.active) {
            collider.update();
          }
        }
        this.emit(Events.WORLD_STEP, fixedDelta);
      }
      while (this._elapsed >= msPerFrame) {
        this._elapsed -= msPerFrame;
        this.step(fixedDelta);
      }
    },
    step: function(delta) {
      var i;
      var body;
      var bodies = this.bodies.entries;
      var len = bodies.length;
      for (i = 0; i < len; i++) {
        body = bodies[i];
        if (body.enable) {
          body.update(delta);
        }
      }
      if (this.useTree) {
        this.tree.clear();
        this.tree.load(bodies);
      }
      var colliders = this.colliders.update();
      for (i = 0; i < colliders.length; i++) {
        var collider = colliders[i];
        if (collider.active) {
          collider.update();
        }
      }
      this.emit(Events.WORLD_STEP, delta);
      this.stepsLastFrame++;
    },
    postUpdate: function() {
      var i;
      var body;
      var bodies = this.bodies.entries;
      var len = bodies.length;
      var dynamic = this.bodies;
      var staticBodies = this.staticBodies;
      if (this.stepsLastFrame) {
        this.stepsLastFrame = 0;
        for (i = 0; i < len; i++) {
          body = bodies[i];
          if (body.enable) {
            body.postUpdate();
          }
        }
      }
      if (this.drawDebug) {
        var graphics = this.debugGraphic;
        graphics.clear();
        for (i = 0; i < len; i++) {
          body = bodies[i];
          if (body.willDrawDebug()) {
            body.drawDebug(graphics);
          }
        }
        bodies = staticBodies.entries;
        len = bodies.length;
        for (i = 0; i < len; i++) {
          body = bodies[i];
          if (body.willDrawDebug()) {
            body.drawDebug(graphics);
          }
        }
      }
      var pending = this.pendingDestroy;
      if (pending.size > 0) {
        var dynamicTree = this.tree;
        var staticTree = this.staticTree;
        bodies = pending.entries;
        len = bodies.length;
        for (i = 0; i < len; i++) {
          body = bodies[i];
          if (body.physicsType === CONST.DYNAMIC_BODY) {
            dynamicTree.remove(body);
            dynamic.delete(body);
          } else if (body.physicsType === CONST.STATIC_BODY) {
            staticTree.remove(body);
            staticBodies.delete(body);
          }
          body.world = void 0;
          body.gameObject = void 0;
        }
        pending.clear();
      }
    },
    updateMotion: function(body, delta) {
      if (body.allowRotation) {
        this.computeAngularVelocity(body, delta);
      }
      this.computeVelocity(body, delta);
    },
    computeAngularVelocity: function(body, delta) {
      var velocity = body.angularVelocity;
      var acceleration = body.angularAcceleration;
      var drag = body.angularDrag;
      var max = body.maxAngular;
      if (acceleration) {
        velocity += acceleration * delta;
      } else if (body.allowDrag && drag) {
        drag *= delta;
        if (FuzzyGreaterThan(velocity - drag, 0, 0.1)) {
          velocity -= drag;
        } else if (FuzzyLessThan(velocity + drag, 0, 0.1)) {
          velocity += drag;
        } else {
          velocity = 0;
        }
      }
      velocity = Clamp(velocity, -max, max);
      var velocityDelta = velocity - body.angularVelocity;
      body.angularVelocity += velocityDelta;
      body.rotation += body.angularVelocity * delta;
    },
    computeVelocity: function(body, delta) {
      var velocityX = body.velocity.x;
      var accelerationX = body.acceleration.x;
      var dragX = body.drag.x;
      var maxX = body.maxVelocity.x;
      var velocityY = body.velocity.y;
      var accelerationY = body.acceleration.y;
      var dragY = body.drag.y;
      var maxY = body.maxVelocity.y;
      var speed = body.speed;
      var maxSpeed = body.maxSpeed;
      var allowDrag = body.allowDrag;
      var useDamping = body.useDamping;
      if (body.allowGravity) {
        velocityX += (this.gravity.x + body.gravity.x) * delta;
        velocityY += (this.gravity.y + body.gravity.y) * delta;
      }
      if (accelerationX) {
        velocityX += accelerationX * delta;
      } else if (allowDrag && dragX) {
        if (useDamping) {
          dragX = Math.pow(dragX, delta);
          velocityX *= dragX;
          speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
          if (FuzzyEqual(speed, 0, 1e-3)) {
            velocityX = 0;
          }
        } else {
          dragX *= delta;
          if (FuzzyGreaterThan(velocityX - dragX, 0, 0.01)) {
            velocityX -= dragX;
          } else if (FuzzyLessThan(velocityX + dragX, 0, 0.01)) {
            velocityX += dragX;
          } else {
            velocityX = 0;
          }
        }
      }
      if (accelerationY) {
        velocityY += accelerationY * delta;
      } else if (allowDrag && dragY) {
        if (useDamping) {
          dragY = Math.pow(dragY, delta);
          velocityY *= dragY;
          speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
          if (FuzzyEqual(speed, 0, 1e-3)) {
            velocityY = 0;
          }
        } else {
          dragY *= delta;
          if (FuzzyGreaterThan(velocityY - dragY, 0, 0.01)) {
            velocityY -= dragY;
          } else if (FuzzyLessThan(velocityY + dragY, 0, 0.01)) {
            velocityY += dragY;
          } else {
            velocityY = 0;
          }
        }
      }
      velocityX = Clamp(velocityX, -maxX, maxX);
      velocityY = Clamp(velocityY, -maxY, maxY);
      body.velocity.set(velocityX, velocityY);
      if (maxSpeed > -1 && speed > maxSpeed) {
        body.velocity.normalize().scale(maxSpeed);
        speed = maxSpeed;
      }
      body.speed = speed;
    },
    separate: function(body1, body2, processCallback, callbackContext, overlapOnly, intersects) {
      if (!intersects && !body1.enable || !body2.enable || body1.checkCollision.none || body2.checkCollision.none || !this.intersects(body1, body2)) {
        return false;
      }
      if (processCallback && processCallback.call(callbackContext, body1.gameObject, body2.gameObject) === false) {
        return false;
      }
      if (body1.isCircle && body2.isCircle) {
        return this.separateCircle(body1, body2, overlapOnly);
      }
      if (body1.isCircle !== body2.isCircle) {
        var bodyRect = body1.isCircle ? body2 : body1;
        var bodyCircle = body1.isCircle ? body1 : body2;
        var rect = {
          x: bodyRect.x,
          y: bodyRect.y,
          right: bodyRect.right,
          bottom: bodyRect.bottom
        };
        var circle = bodyCircle.center;
        if (circle.y < rect.y || circle.y > rect.bottom) {
          if (circle.x < rect.x || circle.x > rect.right) {
            return this.separateCircle(body1, body2, overlapOnly);
          }
        }
      }
      var resultX = false;
      var resultY = false;
      if (overlapOnly) {
        resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);
        resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);
      } else if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x)) {
        resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);
        if (this.intersects(body1, body2)) {
          resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);
        }
      } else {
        resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);
        if (this.intersects(body1, body2)) {
          resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);
        }
      }
      var result = resultX || resultY;
      if (result) {
        if (overlapOnly) {
          if (body1.onOverlap || body2.onOverlap) {
            this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);
          }
        } else if (body1.onCollide || body2.onCollide) {
          this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);
        }
      }
      return result;
    },
    separateCircle: function(body1, body2, overlapOnly, bias) {
      GetOverlapX(body1, body2, false, bias);
      GetOverlapY(body1, body2, false, bias);
      var overlap = 0;
      if (body1.isCircle !== body2.isCircle) {
        var rect = {
          x: body2.isCircle ? body1.position.x : body2.position.x,
          y: body2.isCircle ? body1.position.y : body2.position.y,
          right: body2.isCircle ? body1.right : body2.right,
          bottom: body2.isCircle ? body1.bottom : body2.bottom
        };
        var circle = {
          x: body1.isCircle ? body1.center.x : body2.center.x,
          y: body1.isCircle ? body1.center.y : body2.center.y,
          radius: body1.isCircle ? body1.halfWidth : body2.halfWidth
        };
        if (circle.y < rect.y) {
          if (circle.x < rect.x) {
            overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.y) - circle.radius;
          } else if (circle.x > rect.right) {
            overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.y) - circle.radius;
          }
        } else if (circle.y > rect.bottom) {
          if (circle.x < rect.x) {
            overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.bottom) - circle.radius;
          } else if (circle.x > rect.right) {
            overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.bottom) - circle.radius;
          }
        }
        overlap *= -1;
      } else {
        overlap = body1.halfWidth + body2.halfWidth - DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y);
      }
      body1.overlapR = overlap;
      body2.overlapR = overlap;
      if (overlapOnly || overlap === 0 || body1.immovable && body2.immovable || body1.customSeparateX || body2.customSeparateX) {
        if (overlap !== 0 && (body1.onOverlap || body2.onOverlap)) {
          this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);
        }
        return overlap !== 0;
      }
      var dx = body1.center.x - body2.center.x;
      var dy = body1.center.y - body2.center.y;
      var d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
      var nx = (body2.center.x - body1.center.x) / d || 0;
      var ny = (body2.center.y - body1.center.y) / d || 0;
      var p = 2 * (body1.velocity.x * nx + body1.velocity.y * ny - body2.velocity.x * nx - body2.velocity.y * ny) / (body1.mass + body2.mass);
      if (body1.immovable || body2.immovable) {
        p *= 2;
      }
      if (!body1.immovable) {
        body1.velocity.x = body1.velocity.x - p / body1.mass * nx;
        body1.velocity.y = body1.velocity.y - p / body1.mass * ny;
      }
      if (!body2.immovable) {
        body2.velocity.x = body2.velocity.x + p / body2.mass * nx;
        body2.velocity.y = body2.velocity.y + p / body2.mass * ny;
      }
      if (!body1.immovable && !body2.immovable) {
        overlap /= 2;
      }
      var angle = AngleBetweenPoints(body1.center, body2.center);
      var overlapX = (overlap + MATH_CONST.EPSILON) * Math.cos(angle);
      var overlapY = (overlap + MATH_CONST.EPSILON) * Math.sin(angle);
      if (!body1.immovable) {
        body1.x -= overlapX;
        body1.y -= overlapY;
        body1.updateCenter();
      }
      if (!body2.immovable) {
        body2.x += overlapX;
        body2.y += overlapY;
        body2.updateCenter();
      }
      body1.velocity.x *= body1.bounce.x;
      body1.velocity.y *= body1.bounce.y;
      body2.velocity.x *= body2.bounce.x;
      body2.velocity.y *= body2.bounce.y;
      if (body1.onCollide || body2.onCollide) {
        this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);
      }
      return true;
    },
    intersects: function(body1, body2) {
      if (body1 === body2) {
        return false;
      }
      if (!body1.isCircle && !body2.isCircle) {
        return !(body1.right <= body2.position.x || body1.bottom <= body2.position.y || body1.position.x >= body2.right || body1.position.y >= body2.bottom);
      } else if (body1.isCircle) {
        if (body2.isCircle) {
          return DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y) <= body1.halfWidth + body2.halfWidth;
        } else {
          return this.circleBodyIntersects(body1, body2);
        }
      } else {
        return this.circleBodyIntersects(body2, body1);
      }
    },
    circleBodyIntersects: function(circle, body) {
      var x = Clamp(circle.center.x, body.left, body.right);
      var y = Clamp(circle.center.y, body.top, body.bottom);
      var dx = (circle.center.x - x) * (circle.center.x - x);
      var dy = (circle.center.y - y) * (circle.center.y - y);
      return dx + dy <= circle.halfWidth * circle.halfWidth;
    },
    overlap: function(object1, object2, overlapCallback, processCallback, callbackContext) {
      if (overlapCallback === void 0) {
        overlapCallback = null;
      }
      if (processCallback === void 0) {
        processCallback = null;
      }
      if (callbackContext === void 0) {
        callbackContext = overlapCallback;
      }
      return this.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);
    },
    collide: function(object1, object2, collideCallback, processCallback, callbackContext) {
      if (collideCallback === void 0) {
        collideCallback = null;
      }
      if (processCallback === void 0) {
        processCallback = null;
      }
      if (callbackContext === void 0) {
        callbackContext = collideCallback;
      }
      return this.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);
    },
    collideObjects: function(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
      var i;
      var j;
      if (object1.isParent && object1.physicsType === void 0) {
        object1 = object1.children.entries;
      }
      if (object2 && object2.isParent && object2.physicsType === void 0) {
        object2 = object2.children.entries;
      }
      var object1isArray = Array.isArray(object1);
      var object2isArray = Array.isArray(object2);
      this._total = 0;
      if (!object1isArray && !object2isArray) {
        this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
      } else if (!object1isArray && object2isArray) {
        for (i = 0; i < object2.length; i++) {
          this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, overlapOnly);
        }
      } else if (object1isArray && !object2isArray) {
        if (!object2) {
          for (i = 0; i < object1.length; i++) {
            var child = object1[i];
            for (j = i + 1; j < object1.length; j++) {
              if (i === j) {
                continue;
              }
              this.collideHandler(child, object1[j], collideCallback, processCallback, callbackContext, overlapOnly);
            }
          }
        } else {
          for (i = 0; i < object1.length; i++) {
            this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, overlapOnly);
          }
        }
      } else {
        for (i = 0; i < object1.length; i++) {
          for (j = 0; j < object2.length; j++) {
            this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, overlapOnly);
          }
        }
      }
      return this._total > 0;
    },
    collideHandler: function(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
      if (object2 === void 0 && object1.isParent) {
        return this.collideGroupVsGroup(object1, object1, collideCallback, processCallback, callbackContext, overlapOnly);
      }
      if (!object1 || !object2) {
        return false;
      }
      if (object1.body) {
        if (object2.body) {
          return this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
        } else if (object2.isParent) {
          return this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
        } else if (object2.isTilemap) {
          return this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
        }
      } else if (object1.isParent) {
        if (object2.body) {
          return this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
        } else if (object2.isParent) {
          return this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
        } else if (object2.isTilemap) {
          return this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
        }
      } else if (object1.isTilemap) {
        if (object2.body) {
          return this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
        } else if (object2.isParent) {
          return this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
        }
      }
    },
    collideSpriteVsSprite: function(sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {
      if (!sprite1.body || !sprite2.body) {
        return false;
      }
      if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {
        if (collideCallback) {
          collideCallback.call(callbackContext, sprite1, sprite2);
        }
        this._total++;
      }
      return true;
    },
    collideSpriteVsGroup: function(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {
      var bodyA = sprite.body;
      if (group.length === 0 || !bodyA || !bodyA.enable || bodyA.checkCollision.none) {
        return;
      }
      var i;
      var len;
      var bodyB;
      if (this.useTree || group.physicsType === CONST.STATIC_BODY) {
        var minMax = this.treeMinMax;
        minMax.minX = bodyA.left;
        minMax.minY = bodyA.top;
        minMax.maxX = bodyA.right;
        minMax.maxY = bodyA.bottom;
        var results = group.physicsType === CONST.DYNAMIC_BODY ? this.tree.search(minMax) : this.staticTree.search(minMax);
        len = results.length;
        for (i = 0; i < len; i++) {
          bodyB = results[i];
          if (bodyA === bodyB || !bodyB.enable || bodyB.checkCollision.none || !group.contains(bodyB.gameObject)) {
            continue;
          }
          if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly, true)) {
            if (collideCallback) {
              collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);
            }
            this._total++;
          }
        }
      } else {
        var children = group.getChildren();
        var skipIndex = group.children.entries.indexOf(sprite);
        len = children.length;
        for (i = 0; i < len; i++) {
          bodyB = children[i].body;
          if (!bodyB || i === skipIndex || !bodyB.enable) {
            continue;
          }
          if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly)) {
            if (collideCallback) {
              collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);
            }
            this._total++;
          }
        }
      }
    },
    collideGroupVsTilemapLayer: function(group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
      var children = group.getChildren();
      if (children.length === 0) {
        return false;
      }
      var didCollide = false;
      for (var i = 0; i < children.length; i++) {
        if (children[i].body) {
          if (this.collideSpriteVsTilemapLayer(children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)) {
            didCollide = true;
          }
        }
      }
      return didCollide;
    },
    collideTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
      if (!sprite.body.enable || tiles.length === 0) {
        return false;
      } else {
        return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, false, false);
      }
    },
    overlapTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
      if (!sprite.body.enable || tiles.length === 0) {
        return false;
      } else {
        return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, true, false);
      }
    },
    collideSpriteVsTilemapLayer: function(sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {
      var body = sprite.body;
      if (!body.enable || body.checkCollision.none) {
        return false;
      }
      var x = body.position.x;
      var y = body.position.y;
      var w = body.width;
      var h = body.height;
      var layerData = tilemapLayer.layer;
      if (layerData.tileWidth > layerData.baseTileWidth) {
        var xDiff = (layerData.tileWidth - layerData.baseTileWidth) * tilemapLayer.scaleX;
        x -= xDiff;
        w += xDiff;
      }
      if (layerData.tileHeight > layerData.baseTileHeight) {
        var yDiff = (layerData.tileHeight - layerData.baseTileHeight) * tilemapLayer.scaleY;
        h += yDiff;
      }
      var mapData = GetTilesWithinWorldXY(x, y, w, h, null, tilemapLayer.scene.cameras.main, tilemapLayer.layer);
      if (mapData.length === 0) {
        return false;
      } else {
        return this.collideSpriteVsTilesHandler(sprite, mapData, collideCallback, processCallback, callbackContext, overlapOnly, true);
      }
    },
    collideSpriteVsTilesHandler: function(sprite, tiles, collideCallback, processCallback, callbackContext, overlapOnly, isLayer) {
      var body = sprite.body;
      var tile;
      var tileWorldRect = {left: 0, right: 0, top: 0, bottom: 0};
      var tilemapLayer;
      var collision = false;
      for (var i = 0; i < tiles.length; i++) {
        tile = tiles[i];
        tilemapLayer = tile.tilemapLayer;
        var point = tilemapLayer.tileToWorldXY(tile.x, tile.y);
        tileWorldRect.left = point.x;
        tileWorldRect.top = point.y;
        if (tile.baseHeight !== tile.height) {
          tileWorldRect.top -= (tile.height - tile.baseHeight) * tilemapLayer.scaleY;
        }
        tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX;
        tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY;
        if (TileIntersectsBody(tileWorldRect, body) && (!processCallback || processCallback.call(callbackContext, sprite, tile)) && ProcessTileCallbacks(tile, sprite) && (overlapOnly || SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS, isLayer))) {
          this._total++;
          collision = true;
          if (collideCallback) {
            collideCallback.call(callbackContext, sprite, tile);
          }
          if (overlapOnly && body.onOverlap) {
            this.emit(Events.TILE_OVERLAP, sprite, tile, body);
          } else if (body.onCollide) {
            this.emit(Events.TILE_COLLIDE, sprite, tile, body);
          }
        }
      }
      return collision;
    },
    collideGroupVsGroup: function(group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {
      if (group1.length === 0 || group2.length === 0) {
        return;
      }
      var children = group1.getChildren();
      for (var i = 0; i < children.length; i++) {
        this.collideSpriteVsGroup(children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);
      }
    },
    wrap: function(object, padding) {
      if (object.body) {
        this.wrapObject(object, padding);
      } else if (object.getChildren) {
        this.wrapArray(object.getChildren(), padding);
      } else if (Array.isArray(object)) {
        this.wrapArray(object, padding);
      } else {
        this.wrapObject(object, padding);
      }
    },
    wrapArray: function(objects, padding) {
      for (var i = 0; i < objects.length; i++) {
        this.wrapObject(objects[i], padding);
      }
    },
    wrapObject: function(object, padding) {
      if (padding === void 0) {
        padding = 0;
      }
      object.x = Wrap(object.x, this.bounds.left - padding, this.bounds.right + padding);
      object.y = Wrap(object.y, this.bounds.top - padding, this.bounds.bottom + padding);
    },
    shutdown: function() {
      this.tree.clear();
      this.staticTree.clear();
      this.bodies.clear();
      this.staticBodies.clear();
      this.colliders.destroy();
      this.removeAllListeners();
    },
    destroy: function() {
      this.shutdown();
      this.scene = null;
    }
  });
  module2.exports = World;
});

// node_modules/phaser/src/physics/arcade/ArcadePhysics.js
var require_ArcadePhysics = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var DegToRad = require_DegToRad();
  var DistanceBetween = require_DistanceBetween();
  var DistanceSquared = require_DistanceSquared();
  var Factory = require_Factory();
  var GetFastValue = require_GetFastValue();
  var Merge = require_Merge();
  var OverlapCirc = require_OverlapCirc();
  var OverlapRect = require_OverlapRect();
  var PluginCache = require_PluginCache();
  var SceneEvents = require_events5();
  var Vector2 = require_Vector2();
  var World = require_World();
  var ArcadePhysics = new Class({
    initialize: function ArcadePhysics2(scene) {
      this.scene = scene;
      this.systems = scene.sys;
      this.config = this.getConfig();
      this.world;
      this.add;
      scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
      scene.sys.events.on(SceneEvents.START, this.start, this);
    },
    boot: function() {
      this.world = new World(this.scene, this.config);
      this.add = new Factory(this.world);
      this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
    },
    start: function() {
      if (!this.world) {
        this.world = new World(this.scene, this.config);
        this.add = new Factory(this.world);
      }
      var eventEmitter = this.systems.events;
      if (!GetFastValue(this.config, "customUpdate", false)) {
        eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);
      }
      eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
      eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    enableUpdate: function() {
      this.systems.events.on(SceneEvents.UPDATE, this.world.update, this.world);
    },
    disableUpdate: function() {
      this.systems.events.off(SceneEvents.UPDATE, this.world.update, this.world);
    },
    getConfig: function() {
      var gameConfig = this.systems.game.config.physics;
      var sceneConfig = this.systems.settings.physics;
      var config2 = Merge(GetFastValue(sceneConfig, "arcade", {}), GetFastValue(gameConfig, "arcade", {}));
      return config2;
    },
    overlap: function(object1, object2, overlapCallback, processCallback, callbackContext) {
      if (overlapCallback === void 0) {
        overlapCallback = null;
      }
      if (processCallback === void 0) {
        processCallback = null;
      }
      if (callbackContext === void 0) {
        callbackContext = overlapCallback;
      }
      return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);
    },
    collide: function(object1, object2, collideCallback, processCallback, callbackContext) {
      if (collideCallback === void 0) {
        collideCallback = null;
      }
      if (processCallback === void 0) {
        processCallback = null;
      }
      if (callbackContext === void 0) {
        callbackContext = collideCallback;
      }
      return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);
    },
    collideTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
      return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
    },
    overlapTiles: function(sprite, tiles, collideCallback, processCallback, callbackContext) {
      return this.world.overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext);
    },
    pause: function() {
      return this.world.pause();
    },
    resume: function() {
      return this.world.resume();
    },
    accelerateTo: function(gameObject, x, y, speed, xSpeedMax, ySpeedMax) {
      if (speed === void 0) {
        speed = 60;
      }
      var angle = Math.atan2(y - gameObject.y, x - gameObject.x);
      gameObject.body.acceleration.setToPolar(angle, speed);
      if (xSpeedMax !== void 0 && ySpeedMax !== void 0) {
        gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);
      }
      return angle;
    },
    accelerateToObject: function(gameObject, destination, speed, xSpeedMax, ySpeedMax) {
      return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);
    },
    closest: function(source, targets) {
      if (!targets) {
        targets = this.world.bodies.entries;
      }
      var min = Number.MAX_VALUE;
      var closest = null;
      var x = source.x;
      var y = source.y;
      var len = targets.length;
      for (var i = 0; i < len; i++) {
        var target = targets[i];
        var body = target.body || target;
        if (source === target || source === body || source === body.gameObject || source === body.center) {
          continue;
        }
        var distance = DistanceSquared(x, y, body.center.x, body.center.y);
        if (distance < min) {
          closest = target;
          min = distance;
        }
      }
      return closest;
    },
    furthest: function(source, targets) {
      if (!targets) {
        targets = this.world.bodies.entries;
      }
      var max = -1;
      var farthest = null;
      var x = source.x;
      var y = source.y;
      var len = targets.length;
      for (var i = 0; i < len; i++) {
        var target = targets[i];
        var body = target.body || target;
        if (source === target || source === body || source === body.gameObject || source === body.center) {
          continue;
        }
        var distance = DistanceSquared(x, y, body.center.x, body.center.y);
        if (distance > max) {
          farthest = target;
          max = distance;
        }
      }
      return farthest;
    },
    moveTo: function(gameObject, x, y, speed, maxTime) {
      if (speed === void 0) {
        speed = 60;
      }
      if (maxTime === void 0) {
        maxTime = 0;
      }
      var angle = Math.atan2(y - gameObject.y, x - gameObject.x);
      if (maxTime > 0) {
        speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1e3);
      }
      gameObject.body.velocity.setToPolar(angle, speed);
      return angle;
    },
    moveToObject: function(gameObject, destination, speed, maxTime) {
      return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);
    },
    velocityFromAngle: function(angle, speed, vec2) {
      if (speed === void 0) {
        speed = 60;
      }
      if (vec2 === void 0) {
        vec2 = new Vector2();
      }
      return vec2.setToPolar(DegToRad(angle), speed);
    },
    velocityFromRotation: function(rotation, speed, vec2) {
      if (speed === void 0) {
        speed = 60;
      }
      if (vec2 === void 0) {
        vec2 = new Vector2();
      }
      return vec2.setToPolar(rotation, speed);
    },
    overlapRect: function(x, y, width, height, includeDynamic, includeStatic) {
      return OverlapRect(this.world, x, y, width, height, includeDynamic, includeStatic);
    },
    overlapCirc: function(x, y, radius, includeDynamic, includeStatic) {
      return OverlapCirc(this.world, x, y, radius, includeDynamic, includeStatic);
    },
    shutdown: function() {
      if (!this.world) {
        return;
      }
      var eventEmitter = this.systems.events;
      eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);
      eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
      eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
      this.add.destroy();
      this.world.destroy();
      this.add = null;
      this.world = null;
    },
    destroy: function() {
      this.shutdown();
      this.scene.sys.events.off(SceneEvents.START, this.start, this);
      this.scene = null;
      this.systems = null;
    }
  });
  PluginCache.register("ArcadePhysics", ArcadePhysics, "arcadePhysics");
  module2.exports = ArcadePhysics;
});

// node_modules/phaser/src/physics/arcade/tilemap/index.js
var require_tilemap = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Tilemap = {
    ProcessTileCallbacks: require_ProcessTileCallbacks(),
    ProcessTileSeparationX: require_ProcessTileSeparationX(),
    ProcessTileSeparationY: require_ProcessTileSeparationY(),
    SeparateTile: require_SeparateTile(),
    TileCheckX: require_TileCheckX(),
    TileCheckY: require_TileCheckY(),
    TileIntersectsBody: require_TileIntersectsBody()
  };
  module2.exports = Tilemap;
});

// node_modules/phaser/src/physics/arcade/index.js
var require_arcade = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const13();
  var Extend = require_Extend();
  var Arcade = {
    ArcadePhysics: require_ArcadePhysics(),
    Body: require_Body(),
    Collider: require_Collider(),
    Components: require_components2(),
    Events: require_events19(),
    Factory: require_Factory(),
    GetOverlapX: require_GetOverlapX(),
    GetOverlapY: require_GetOverlapY(),
    SeparateX: require_SeparateX(),
    SeparateY: require_SeparateY(),
    Group: require_PhysicsGroup(),
    Image: require_ArcadeImage(),
    Sprite: require_ArcadeSprite(),
    StaticBody: require_StaticBody(),
    StaticGroup: require_StaticPhysicsGroup(),
    Tilemap: require_tilemap(),
    World: require_World()
  };
  Arcade = Extend(false, Arcade, CONST);
  module2.exports = Arcade;
});

// node_modules/phaser/src/physics/matter-js/BodyBounds.js
var require_BodyBounds = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Vector2 = require_Vector2();
  var BodyBounds = new Class({
    initialize: function BodyBounds2() {
      this.boundsCenter = new Vector2();
      this.centerDiff = new Vector2();
    },
    parseBody: function(body) {
      body = body.hasOwnProperty("body") ? body.body : body;
      if (!body.hasOwnProperty("bounds") || !body.hasOwnProperty("centerOfMass")) {
        return false;
      }
      var boundsCenter = this.boundsCenter;
      var centerDiff = this.centerDiff;
      var boundsWidth = body.bounds.max.x - body.bounds.min.x;
      var boundsHeight = body.bounds.max.y - body.bounds.min.y;
      var bodyCenterX = boundsWidth * body.centerOfMass.x;
      var bodyCenterY = boundsHeight * body.centerOfMass.y;
      boundsCenter.set(boundsWidth / 2, boundsHeight / 2);
      centerDiff.set(bodyCenterX - boundsCenter.x, bodyCenterY - boundsCenter.y);
      return true;
    },
    getTopLeft: function(body, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (this.parseBody(body)) {
        var center = this.boundsCenter;
        var diff = this.centerDiff;
        return new Vector2(x + center.x + diff.x, y + center.y + diff.y);
      }
      return false;
    },
    getTopCenter: function(body, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (this.parseBody(body)) {
        var center = this.boundsCenter;
        var diff = this.centerDiff;
        return new Vector2(x + diff.x, y + center.y + diff.y);
      }
      return false;
    },
    getTopRight: function(body, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (this.parseBody(body)) {
        var center = this.boundsCenter;
        var diff = this.centerDiff;
        return new Vector2(x - (center.x - diff.x), y + center.y + diff.y);
      }
      return false;
    },
    getLeftCenter: function(body, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (this.parseBody(body)) {
        var center = this.boundsCenter;
        var diff = this.centerDiff;
        return new Vector2(x + center.x + diff.x, y + diff.y);
      }
      return false;
    },
    getCenter: function(body, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (this.parseBody(body)) {
        var diff = this.centerDiff;
        return new Vector2(x + diff.x, y + diff.y);
      }
      return false;
    },
    getRightCenter: function(body, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (this.parseBody(body)) {
        var center = this.boundsCenter;
        var diff = this.centerDiff;
        return new Vector2(x - (center.x - diff.x), y + diff.y);
      }
      return false;
    },
    getBottomLeft: function(body, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (this.parseBody(body)) {
        var center = this.boundsCenter;
        var diff = this.centerDiff;
        return new Vector2(x + center.x + diff.x, y - (center.y - diff.y));
      }
      return false;
    },
    getBottomCenter: function(body, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (this.parseBody(body)) {
        var center = this.boundsCenter;
        var diff = this.centerDiff;
        return new Vector2(x + diff.x, y - (center.y - diff.y));
      }
      return false;
    },
    getBottomRight: function(body, x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (this.parseBody(body)) {
        var center = this.boundsCenter;
        var diff = this.centerDiff;
        return new Vector2(x - (center.x - diff.x), y - (center.y - diff.y));
      }
      return false;
    }
  });
  module2.exports = BodyBounds;
});

// node_modules/phaser/src/physics/matter-js/components/Bounce.js
var require_Bounce2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Bounce = {
    setBounce: function(value) {
      this.body.restitution = value;
      return this;
    }
  };
  module2.exports = Bounce;
});

// node_modules/phaser/src/physics/matter-js/components/Collision.js
var require_Collision = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Collision = {
    setCollisionCategory: function(value) {
      this.body.collisionFilter.category = value;
      return this;
    },
    setCollisionGroup: function(value) {
      this.body.collisionFilter.group = value;
      return this;
    },
    setCollidesWith: function(categories) {
      var flags = 0;
      if (!Array.isArray(categories)) {
        flags = categories;
      } else {
        for (var i = 0; i < categories.length; i++) {
          flags |= categories[i];
        }
      }
      this.body.collisionFilter.mask = flags;
      return this;
    },
    setOnCollide: function(callback) {
      this.body.onCollideCallback = callback;
      return this;
    },
    setOnCollideEnd: function(callback) {
      this.body.onCollideEndCallback = callback;
      return this;
    },
    setOnCollideActive: function(callback) {
      this.body.onCollideActiveCallback = callback;
      return this;
    },
    setOnCollideWith: function(body, callback) {
      if (!Array.isArray(body)) {
        body = [body];
      }
      for (var i = 0; i < body.length; i++) {
        var src = body[i].hasOwnProperty("body") ? body[i].body : body[i];
        this.body.setOnCollideWith(src, callback);
      }
      return this;
    }
  };
  module2.exports = Collision;
});

// node_modules/phaser/src/physics/matter-js/lib/geometry/Vector.js
var require_Vector = __commonJS((exports2, module2) => {
  var Vector = {};
  module2.exports = Vector;
  (function() {
    Vector.create = function(x, y) {
      return {x: x || 0, y: y || 0};
    };
    Vector.clone = function(vector) {
      return {x: vector.x, y: vector.y};
    };
    Vector.magnitude = function(vector) {
      return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
    };
    Vector.magnitudeSquared = function(vector) {
      return vector.x * vector.x + vector.y * vector.y;
    };
    Vector.rotate = function(vector, angle, output) {
      var cos = Math.cos(angle), sin = Math.sin(angle);
      if (!output)
        output = {};
      var x = vector.x * cos - vector.y * sin;
      output.y = vector.x * sin + vector.y * cos;
      output.x = x;
      return output;
    };
    Vector.rotateAbout = function(vector, angle, point, output) {
      var cos = Math.cos(angle), sin = Math.sin(angle);
      if (!output)
        output = {};
      var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
      output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);
      output.x = x;
      return output;
    };
    Vector.normalise = function(vector) {
      var magnitude = Vector.magnitude(vector);
      if (magnitude === 0)
        return {x: 0, y: 0};
      return {x: vector.x / magnitude, y: vector.y / magnitude};
    };
    Vector.dot = function(vectorA, vectorB) {
      return vectorA.x * vectorB.x + vectorA.y * vectorB.y;
    };
    Vector.cross = function(vectorA, vectorB) {
      return vectorA.x * vectorB.y - vectorA.y * vectorB.x;
    };
    Vector.cross3 = function(vectorA, vectorB, vectorC) {
      return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
    };
    Vector.add = function(vectorA, vectorB, output) {
      if (!output)
        output = {};
      output.x = vectorA.x + vectorB.x;
      output.y = vectorA.y + vectorB.y;
      return output;
    };
    Vector.sub = function(vectorA, vectorB, output) {
      if (!output)
        output = {};
      output.x = vectorA.x - vectorB.x;
      output.y = vectorA.y - vectorB.y;
      return output;
    };
    Vector.mult = function(vector, scalar) {
      return {x: vector.x * scalar, y: vector.y * scalar};
    };
    Vector.div = function(vector, scalar) {
      return {x: vector.x / scalar, y: vector.y / scalar};
    };
    Vector.perp = function(vector, negate) {
      negate = negate === true ? -1 : 1;
      return {x: negate * -vector.y, y: negate * vector.x};
    };
    Vector.neg = function(vector) {
      return {x: -vector.x, y: -vector.y};
    };
    Vector.angle = function(vectorA, vectorB) {
      return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
    };
    Vector._temp = [
      Vector.create(),
      Vector.create(),
      Vector.create(),
      Vector.create(),
      Vector.create(),
      Vector.create()
    ];
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/core/Common.js
var require_Common = __commonJS((exports2, module2) => {
  var Common = {};
  module2.exports = Common;
  (function() {
    Common._nextId = 0;
    Common._seed = 0;
    Common._nowStartTime = +new Date();
    Common.extend = function(obj, deep) {
      var argsStart, args, deepClone;
      if (typeof deep === "boolean") {
        argsStart = 2;
        deepClone = deep;
      } else {
        argsStart = 1;
        deepClone = true;
      }
      for (var i = argsStart; i < arguments.length; i++) {
        var source = arguments[i];
        if (source) {
          for (var prop in source) {
            if (deepClone && source[prop] && source[prop].constructor === Object) {
              if (!obj[prop] || obj[prop].constructor === Object) {
                obj[prop] = obj[prop] || {};
                Common.extend(obj[prop], deepClone, source[prop]);
              } else {
                obj[prop] = source[prop];
              }
            } else {
              obj[prop] = source[prop];
            }
          }
        }
      }
      return obj;
    };
    Common.clone = function(obj, deep) {
      return Common.extend({}, deep, obj);
    };
    Common.keys = function(obj) {
      if (Object.keys)
        return Object.keys(obj);
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    Common.values = function(obj) {
      var values = [];
      if (Object.keys) {
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
          values.push(obj[keys[i]]);
        }
        return values;
      }
      for (var key in obj)
        values.push(obj[key]);
      return values;
    };
    Common.get = function(obj, path, begin, end) {
      path = path.split(".").slice(begin, end);
      for (var i = 0; i < path.length; i += 1) {
        obj = obj[path[i]];
      }
      return obj;
    };
    Common.set = function(obj, path, val, begin, end) {
      var parts = path.split(".").slice(begin, end);
      Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;
      return val;
    };
    Common.shuffle = function(array) {
      for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Common.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
      return array;
    };
    Common.choose = function(choices) {
      return choices[Math.floor(Common.random() * choices.length)];
    };
    Common.isElement = function(obj) {
      if (typeof HTMLElement !== "undefined") {
        return obj instanceof HTMLElement;
      }
      return !!(obj && obj.nodeType && obj.nodeName);
    };
    Common.isArray = function(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };
    Common.isFunction = function(obj) {
      return typeof obj === "function";
    };
    Common.isPlainObject = function(obj) {
      return typeof obj === "object" && obj.constructor === Object;
    };
    Common.isString = function(obj) {
      return Object.prototype.toString.call(obj) === "[object String]";
    };
    Common.clamp = function(value, min, max) {
      if (value < min)
        return min;
      if (value > max)
        return max;
      return value;
    };
    Common.sign = function(value) {
      return value < 0 ? -1 : 1;
    };
    Common.now = function() {
      if (typeof window !== "undefined" && window.performance) {
        if (window.performance.now) {
          return window.performance.now();
        } else if (window.performance.webkitNow) {
          return window.performance.webkitNow();
        }
      }
      return new Date() - Common._nowStartTime;
    };
    Common.random = function(min, max) {
      min = typeof min !== "undefined" ? min : 0;
      max = typeof max !== "undefined" ? max : 1;
      return min + _seededRandom() * (max - min);
    };
    var _seededRandom = function() {
      Common._seed = (Common._seed * 9301 + 49297) % 233280;
      return Common._seed / 233280;
    };
    Common.colorToNumber = function(colorString) {
      colorString = colorString.replace("#", "");
      if (colorString.length == 3) {
        colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2);
      }
      return parseInt(colorString, 16);
    };
    Common.logLevel = 1;
    Common.log = function() {
      if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
        console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
      }
    };
    Common.info = function() {
      if (console && Common.logLevel > 0 && Common.logLevel <= 2) {
        console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
      }
    };
    Common.warn = function() {
      if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
        console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
      }
    };
    Common.nextId = function() {
      return Common._nextId++;
    };
    Common.indexOf = function(haystack, needle) {
      if (haystack.indexOf)
        return haystack.indexOf(needle);
      for (var i = 0; i < haystack.length; i++) {
        if (haystack[i] === needle)
          return i;
      }
      return -1;
    };
    Common.map = function(list, func) {
      if (list.map) {
        return list.map(func);
      }
      var mapped = [];
      for (var i = 0; i < list.length; i += 1) {
        mapped.push(func(list[i]));
      }
      return mapped;
    };
    Common.topologicalSort = function(graph) {
      var result = [], visited = [], temp = [];
      for (var node in graph) {
        if (!visited[node] && !temp[node]) {
          Common._topologicalSort(node, visited, temp, graph, result);
        }
      }
      return result;
    };
    Common._topologicalSort = function(node, visited, temp, graph, result) {
      var neighbors = graph[node] || [];
      temp[node] = true;
      for (var i = 0; i < neighbors.length; i += 1) {
        var neighbor = neighbors[i];
        if (temp[neighbor]) {
          continue;
        }
        if (!visited[neighbor]) {
          Common._topologicalSort(neighbor, visited, temp, graph, result);
        }
      }
      temp[node] = false;
      visited[node] = true;
      result.push(node);
    };
    Common.chain = function() {
      var funcs = [];
      for (var i = 0; i < arguments.length; i += 1) {
        var func = arguments[i];
        if (func._chained) {
          funcs.push.apply(funcs, func._chained);
        } else {
          funcs.push(func);
        }
      }
      var chain = function() {
        var lastResult, args = new Array(arguments.length);
        for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
          args[i2] = arguments[i2];
        }
        for (i2 = 0; i2 < funcs.length; i2 += 1) {
          var result = funcs[i2].apply(lastResult, args);
          if (typeof result !== "undefined") {
            lastResult = result;
          }
        }
        return lastResult;
      };
      chain._chained = funcs;
      return chain;
    };
    Common.chainPathBefore = function(base, path, func) {
      return Common.set(base, path, Common.chain(func, Common.get(base, path)));
    };
    Common.chainPathAfter = function(base, path, func) {
      return Common.set(base, path, Common.chain(Common.get(base, path), func));
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/geometry/Vertices.js
var require_Vertices = __commonJS((exports2, module2) => {
  var Vertices = {};
  module2.exports = Vertices;
  var Vector = require_Vector();
  var Common = require_Common();
  (function() {
    Vertices.create = function(points, body) {
      var vertices = [];
      for (var i = 0; i < points.length; i++) {
        var point = points[i], vertex = {
          x: point.x,
          y: point.y,
          index: i,
          body,
          isInternal: false,
          contact: null,
          offset: null
        };
        vertex.contact = {
          vertex,
          normalImpulse: 0,
          tangentImpulse: 0
        };
        vertices.push(vertex);
      }
      return vertices;
    };
    Vertices.fromPath = function(path, body) {
      var pathPattern = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, points = [];
      path.replace(pathPattern, function(match, x, y) {
        points.push({x: parseFloat(x), y: parseFloat(y)});
      });
      return Vertices.create(points, body);
    };
    Vertices.centre = function(vertices) {
      var area = Vertices.area(vertices, true), centre = {x: 0, y: 0}, cross, temp, j;
      for (var i = 0; i < vertices.length; i++) {
        j = (i + 1) % vertices.length;
        cross = Vector.cross(vertices[i], vertices[j]);
        temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);
        centre = Vector.add(centre, temp);
      }
      return Vector.div(centre, 6 * area);
    };
    Vertices.mean = function(vertices) {
      var average = {x: 0, y: 0};
      for (var i = 0; i < vertices.length; i++) {
        average.x += vertices[i].x;
        average.y += vertices[i].y;
      }
      return Vector.div(average, vertices.length);
    };
    Vertices.area = function(vertices, signed) {
      var area = 0, j = vertices.length - 1;
      for (var i = 0; i < vertices.length; i++) {
        area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);
        j = i;
      }
      if (signed)
        return area / 2;
      return Math.abs(area) / 2;
    };
    Vertices.inertia = function(vertices, mass) {
      var numerator = 0, denominator = 0, v = vertices, cross, j;
      for (var n = 0; n < v.length; n++) {
        j = (n + 1) % v.length;
        cross = Math.abs(Vector.cross(v[j], v[n]));
        numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));
        denominator += cross;
      }
      return mass / 6 * (numerator / denominator);
    };
    Vertices.translate = function(vertices, vector, scalar) {
      var i;
      if (scalar) {
        for (i = 0; i < vertices.length; i++) {
          vertices[i].x += vector.x * scalar;
          vertices[i].y += vector.y * scalar;
        }
      } else {
        for (i = 0; i < vertices.length; i++) {
          vertices[i].x += vector.x;
          vertices[i].y += vector.y;
        }
      }
      return vertices;
    };
    Vertices.rotate = function(vertices, angle, point) {
      if (angle === 0)
        return;
      var cos = Math.cos(angle), sin = Math.sin(angle);
      for (var i = 0; i < vertices.length; i++) {
        var vertice = vertices[i], dx = vertice.x - point.x, dy = vertice.y - point.y;
        vertice.x = point.x + (dx * cos - dy * sin);
        vertice.y = point.y + (dx * sin + dy * cos);
      }
      return vertices;
    };
    Vertices.contains = function(vertices, point) {
      for (var i = 0; i < vertices.length; i++) {
        var vertice = vertices[i], nextVertice = vertices[(i + 1) % vertices.length];
        if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {
          return false;
        }
      }
      return true;
    };
    Vertices.scale = function(vertices, scaleX, scaleY, point) {
      if (scaleX === 1 && scaleY === 1)
        return vertices;
      point = point || Vertices.centre(vertices);
      var vertex, delta;
      for (var i = 0; i < vertices.length; i++) {
        vertex = vertices[i];
        delta = Vector.sub(vertex, point);
        vertices[i].x = point.x + delta.x * scaleX;
        vertices[i].y = point.y + delta.y * scaleY;
      }
      return vertices;
    };
    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {
      if (typeof radius === "number") {
        radius = [radius];
      } else {
        radius = radius || [8];
      }
      quality = typeof quality !== "undefined" ? quality : -1;
      qualityMin = qualityMin || 2;
      qualityMax = qualityMax || 14;
      var newVertices = [];
      for (var i = 0; i < vertices.length; i++) {
        var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1], vertex = vertices[i], nextVertex = vertices[(i + 1) % vertices.length], currentRadius = radius[i < radius.length ? i : radius.length - 1];
        if (currentRadius === 0) {
          newVertices.push(vertex);
          continue;
        }
        var prevNormal = Vector.normalise({
          x: vertex.y - prevVertex.y,
          y: prevVertex.x - vertex.x
        });
        var nextNormal = Vector.normalise({
          x: nextVertex.y - vertex.y,
          y: vertex.x - nextVertex.x
        });
        var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)), radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius), midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)), scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));
        var precision = quality;
        if (quality === -1) {
          precision = Math.pow(currentRadius, 0.32) * 1.75;
        }
        precision = Common.clamp(precision, qualityMin, qualityMax);
        if (precision % 2 === 1)
          precision += 1;
        var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)), theta = alpha / precision;
        for (var j = 0; j < precision; j++) {
          newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));
        }
      }
      return newVertices;
    };
    Vertices.clockwiseSort = function(vertices) {
      var centre = Vertices.mean(vertices);
      vertices.sort(function(vertexA, vertexB) {
        return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);
      });
      return vertices;
    };
    Vertices.isConvex = function(vertices) {
      var flag = 0, n = vertices.length, i, j, k, z;
      if (n < 3)
        return null;
      for (i = 0; i < n; i++) {
        j = (i + 1) % n;
        k = (i + 2) % n;
        z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);
        z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);
        if (z < 0) {
          flag |= 1;
        } else if (z > 0) {
          flag |= 2;
        }
        if (flag === 3) {
          return false;
        }
      }
      if (flag !== 0) {
        return true;
      } else {
        return null;
      }
    };
    Vertices.hull = function(vertices) {
      var upper = [], lower = [], vertex, i;
      vertices = vertices.slice(0);
      vertices.sort(function(vertexA, vertexB) {
        var dx = vertexA.x - vertexB.x;
        return dx !== 0 ? dx : vertexA.y - vertexB.y;
      });
      for (i = 0; i < vertices.length; i += 1) {
        vertex = vertices[i];
        while (lower.length >= 2 && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {
          lower.pop();
        }
        lower.push(vertex);
      }
      for (i = vertices.length - 1; i >= 0; i -= 1) {
        vertex = vertices[i];
        while (upper.length >= 2 && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {
          upper.pop();
        }
        upper.push(vertex);
      }
      upper.pop();
      lower.pop();
      return upper.concat(lower);
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/core/Events.js
var require_Events = __commonJS((exports2, module2) => {
  var Events = {};
  module2.exports = Events;
  var Common = require_Common();
  (function() {
    Events.on = function(object, eventNames, callback) {
      var names = eventNames.split(" "), name;
      for (var i = 0; i < names.length; i++) {
        name = names[i];
        object.events = object.events || {};
        object.events[name] = object.events[name] || [];
        object.events[name].push(callback);
      }
      return callback;
    };
    Events.off = function(object, eventNames, callback) {
      if (!eventNames) {
        object.events = {};
        return;
      }
      if (typeof eventNames === "function") {
        callback = eventNames;
        eventNames = Common.keys(object.events).join(" ");
      }
      var names = eventNames.split(" ");
      for (var i = 0; i < names.length; i++) {
        var callbacks = object.events[names[i]], newCallbacks = [];
        if (callback && callbacks) {
          for (var j = 0; j < callbacks.length; j++) {
            if (callbacks[j] !== callback)
              newCallbacks.push(callbacks[j]);
          }
        }
        object.events[names[i]] = newCallbacks;
      }
    };
    Events.trigger = function(object, eventNames, event) {
      var names, name, callbacks, eventClone;
      var events = object.events;
      if (events && Common.keys(events).length > 0) {
        if (!event)
          event = {};
        names = eventNames.split(" ");
        for (var i = 0; i < names.length; i++) {
          name = names[i];
          callbacks = events[name];
          if (callbacks) {
            eventClone = Common.clone(event, false);
            eventClone.name = name;
            eventClone.source = object;
            for (var j = 0; j < callbacks.length; j++) {
              callbacks[j].apply(object, [eventClone]);
            }
          }
        }
      }
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/core/Sleeping.js
var require_Sleeping = __commonJS((exports2, module2) => {
  var Sleeping = {};
  module2.exports = Sleeping;
  var Events = require_Events();
  (function() {
    Sleeping._motionWakeThreshold = 0.18;
    Sleeping._motionSleepThreshold = 0.08;
    Sleeping._minBias = 0.9;
    Sleeping.update = function(bodies, timeScale) {
      var timeFactor = timeScale * timeScale * timeScale;
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i], motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;
        if (body.force.x !== 0 || body.force.y !== 0) {
          Sleeping.set(body, false);
          continue;
        }
        var minMotion = Math.min(body.motion, motion), maxMotion = Math.max(body.motion, motion);
        body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;
        if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {
          body.sleepCounter += 1;
          if (body.sleepCounter >= body.sleepThreshold)
            Sleeping.set(body, true);
        } else if (body.sleepCounter > 0) {
          body.sleepCounter -= 1;
        }
      }
    };
    Sleeping.afterCollisions = function(pairs, timeScale) {
      var timeFactor = timeScale * timeScale * timeScale;
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        if (!pair.isActive)
          continue;
        var collision = pair.collision, bodyA = collision.bodyA.parent, bodyB = collision.bodyB.parent;
        if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic)
          continue;
        if (bodyA.isSleeping || bodyB.isSleeping) {
          var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB, movingBody = sleepingBody === bodyA ? bodyB : bodyA;
          if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {
            Sleeping.set(sleepingBody, false);
          }
        }
      }
    };
    Sleeping.set = function(body, isSleeping) {
      var wasSleeping = body.isSleeping;
      if (isSleeping) {
        body.isSleeping = true;
        body.sleepCounter = body.sleepThreshold;
        body.positionImpulse.x = 0;
        body.positionImpulse.y = 0;
        body.positionPrev.x = body.position.x;
        body.positionPrev.y = body.position.y;
        body.anglePrev = body.angle;
        body.speed = 0;
        body.angularSpeed = 0;
        body.motion = 0;
        if (!wasSleeping) {
          Events.trigger(body, "sleepStart");
        }
      } else {
        body.isSleeping = false;
        body.sleepCounter = 0;
        if (wasSleeping) {
          Events.trigger(body, "sleepEnd");
        }
      }
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/geometry/Bounds.js
var require_Bounds = __commonJS((exports2, module2) => {
  var Bounds = {};
  module2.exports = Bounds;
  (function() {
    Bounds.create = function(vertices) {
      var bounds = {
        min: {x: 0, y: 0},
        max: {x: 0, y: 0}
      };
      if (vertices)
        Bounds.update(bounds, vertices);
      return bounds;
    };
    Bounds.update = function(bounds, vertices, velocity) {
      bounds.min.x = Infinity;
      bounds.max.x = -Infinity;
      bounds.min.y = Infinity;
      bounds.max.y = -Infinity;
      for (var i = 0; i < vertices.length; i++) {
        var vertex = vertices[i];
        if (vertex.x > bounds.max.x)
          bounds.max.x = vertex.x;
        if (vertex.x < bounds.min.x)
          bounds.min.x = vertex.x;
        if (vertex.y > bounds.max.y)
          bounds.max.y = vertex.y;
        if (vertex.y < bounds.min.y)
          bounds.min.y = vertex.y;
      }
      if (velocity) {
        if (velocity.x > 0) {
          bounds.max.x += velocity.x;
        } else {
          bounds.min.x += velocity.x;
        }
        if (velocity.y > 0) {
          bounds.max.y += velocity.y;
        } else {
          bounds.min.y += velocity.y;
        }
      }
    };
    Bounds.contains = function(bounds, point) {
      return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;
    };
    Bounds.overlaps = function(boundsA, boundsB) {
      return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;
    };
    Bounds.translate = function(bounds, vector) {
      bounds.min.x += vector.x;
      bounds.max.x += vector.x;
      bounds.min.y += vector.y;
      bounds.max.y += vector.y;
    };
    Bounds.shift = function(bounds, position) {
      var deltaX = bounds.max.x - bounds.min.x, deltaY = bounds.max.y - bounds.min.y;
      bounds.min.x = position.x;
      bounds.max.x = position.x + deltaX;
      bounds.min.y = position.y;
      bounds.max.y = position.y + deltaY;
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/geometry/Axes.js
var require_Axes = __commonJS((exports2, module2) => {
  var Axes = {};
  module2.exports = Axes;
  var Vector = require_Vector();
  var Common = require_Common();
  (function() {
    Axes.fromVertices = function(vertices) {
      var axes = {};
      for (var i = 0; i < vertices.length; i++) {
        var j = (i + 1) % vertices.length, normal = Vector.normalise({
          x: vertices[j].y - vertices[i].y,
          y: vertices[i].x - vertices[j].x
        }), gradient = normal.y === 0 ? Infinity : normal.x / normal.y;
        gradient = gradient.toFixed(3).toString();
        axes[gradient] = normal;
      }
      return Common.values(axes);
    };
    Axes.rotate = function(axes, angle) {
      if (angle === 0)
        return;
      var cos = Math.cos(angle), sin = Math.sin(angle);
      for (var i = 0; i < axes.length; i++) {
        var axis = axes[i], xx;
        xx = axis.x * cos - axis.y * sin;
        axis.y = axis.x * sin + axis.y * cos;
        axis.x = xx;
      }
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/body/Body.js
var require_Body2 = __commonJS((exports2, module2) => {
  var Body = {};
  module2.exports = Body;
  var Vertices = require_Vertices();
  var Vector = require_Vector();
  var Sleeping = require_Sleeping();
  var Common = require_Common();
  var Bounds = require_Bounds();
  var Axes = require_Axes();
  (function() {
    Body._inertiaScale = 4;
    Body._nextCollidingGroupId = 1;
    Body._nextNonCollidingGroupId = -1;
    Body._nextCategory = 1;
    Body.create = function(options) {
      var defaults = {
        id: Common.nextId(),
        type: "body",
        label: "Body",
        parts: [],
        plugin: {},
        angle: 0,
        vertices: null,
        position: {x: 0, y: 0},
        force: {x: 0, y: 0},
        torque: 0,
        positionImpulse: {x: 0, y: 0},
        previousPositionImpulse: {x: 0, y: 0},
        constraintImpulse: {x: 0, y: 0, angle: 0},
        totalContacts: 0,
        speed: 0,
        angularSpeed: 0,
        velocity: {x: 0, y: 0},
        angularVelocity: 0,
        isSensor: false,
        isStatic: false,
        isSleeping: false,
        motion: 0,
        sleepThreshold: 60,
        density: 1e-3,
        restitution: 0,
        friction: 0.1,
        frictionStatic: 0.5,
        frictionAir: 0.01,
        collisionFilter: {
          category: 1,
          mask: 4294967295,
          group: 0
        },
        slop: 0.05,
        timeScale: 1,
        events: null,
        bounds: null,
        chamfer: null,
        circleRadius: 0,
        positionPrev: null,
        anglePrev: 0,
        parent: null,
        axes: null,
        area: 0,
        mass: 0,
        inverseMass: 0,
        inertia: 0,
        inverseInertia: 0,
        _original: null,
        render: {
          visible: true,
          opacity: 1,
          sprite: {
            xOffset: 0,
            yOffset: 0
          },
          fillColor: null,
          fillOpacity: null,
          lineColor: null,
          lineOpacity: null,
          lineThickness: null
        },
        gameObject: null,
        scale: {x: 1, y: 1},
        centerOfMass: {x: 0, y: 0},
        centerOffset: {x: 0, y: 0},
        gravityScale: {x: 1, y: 1},
        ignoreGravity: false,
        ignorePointer: false,
        onCollideCallback: null,
        onCollideEndCallback: null,
        onCollideActiveCallback: null,
        onCollideWith: {}
      };
      if (!options.hasOwnProperty("position") && options.hasOwnProperty("vertices")) {
        options.position = Vertices.centre(options.vertices);
      } else if (!options.hasOwnProperty("vertices")) {
        defaults.vertices = Vertices.fromPath("L 0 0 L 40 0 L 40 40 L 0 40");
      }
      var body = Common.extend(defaults, options);
      _initProperties(body, options);
      body.setOnCollideWith = function(body2, callback) {
        if (callback) {
          this.onCollideWith[body2.id] = callback;
        } else {
          delete this.onCollideWith[body2.id];
        }
        return this;
      };
      return body;
    };
    Body.nextGroup = function(isNonColliding) {
      if (isNonColliding)
        return Body._nextNonCollidingGroupId--;
      return Body._nextCollidingGroupId++;
    };
    Body.nextCategory = function() {
      Body._nextCategory = Body._nextCategory << 1;
      return Body._nextCategory;
    };
    var _initProperties = function(body, options) {
      options = options || {};
      Body.set(body, {
        bounds: body.bounds || Bounds.create(body.vertices),
        positionPrev: body.positionPrev || Vector.clone(body.position),
        anglePrev: body.anglePrev || body.angle,
        vertices: body.vertices,
        parts: body.parts || [body],
        isStatic: body.isStatic,
        isSleeping: body.isSleeping,
        parent: body.parent || body
      });
      var bounds = body.bounds;
      Vertices.rotate(body.vertices, body.angle, body.position);
      Axes.rotate(body.axes, body.angle);
      Bounds.update(bounds, body.vertices, body.velocity);
      Body.set(body, {
        axes: options.axes || body.axes,
        area: options.area || body.area,
        mass: options.mass || body.mass,
        inertia: options.inertia || body.inertia
      });
      if (body.parts.length === 1) {
        var centerOfMass = body.centerOfMass;
        var centerOffset = body.centerOffset;
        var bodyWidth = bounds.max.x - bounds.min.x;
        var bodyHeight = bounds.max.y - bounds.min.y;
        centerOfMass.x = -(bounds.min.x - body.position.x) / bodyWidth;
        centerOfMass.y = -(bounds.min.y - body.position.y) / bodyHeight;
        centerOffset.x = bodyWidth * centerOfMass.x;
        centerOffset.y = bodyHeight * centerOfMass.y;
      }
    };
    Body.set = function(body, settings, value) {
      var property;
      if (typeof settings === "string") {
        property = settings;
        settings = {};
        settings[property] = value;
      }
      for (property in settings) {
        if (!Object.prototype.hasOwnProperty.call(settings, property))
          continue;
        value = settings[property];
        switch (property) {
          case "isStatic":
            Body.setStatic(body, value);
            break;
          case "isSleeping":
            Sleeping.set(body, value);
            break;
          case "mass":
            Body.setMass(body, value);
            break;
          case "density":
            Body.setDensity(body, value);
            break;
          case "inertia":
            Body.setInertia(body, value);
            break;
          case "vertices":
            Body.setVertices(body, value);
            break;
          case "position":
            Body.setPosition(body, value);
            break;
          case "angle":
            Body.setAngle(body, value);
            break;
          case "velocity":
            Body.setVelocity(body, value);
            break;
          case "angularVelocity":
            Body.setAngularVelocity(body, value);
            break;
          case "parts":
            Body.setParts(body, value);
            break;
          case "centre":
            Body.setCentre(body, value);
            break;
          default:
            body[property] = value;
        }
      }
    };
    Body.setStatic = function(body, isStatic) {
      for (var i = 0; i < body.parts.length; i++) {
        var part = body.parts[i];
        part.isStatic = isStatic;
        if (isStatic) {
          part._original = {
            restitution: part.restitution,
            friction: part.friction,
            mass: part.mass,
            inertia: part.inertia,
            density: part.density,
            inverseMass: part.inverseMass,
            inverseInertia: part.inverseInertia
          };
          part.restitution = 0;
          part.friction = 1;
          part.mass = part.inertia = part.density = Infinity;
          part.inverseMass = part.inverseInertia = 0;
          part.positionPrev.x = part.position.x;
          part.positionPrev.y = part.position.y;
          part.anglePrev = part.angle;
          part.angularVelocity = 0;
          part.speed = 0;
          part.angularSpeed = 0;
          part.motion = 0;
        } else if (part._original) {
          part.restitution = part._original.restitution;
          part.friction = part._original.friction;
          part.mass = part._original.mass;
          part.inertia = part._original.inertia;
          part.density = part._original.density;
          part.inverseMass = part._original.inverseMass;
          part.inverseInertia = part._original.inverseInertia;
          part._original = null;
        }
      }
    };
    Body.setMass = function(body, mass) {
      var moment = body.inertia / (body.mass / 6);
      body.inertia = moment * (mass / 6);
      body.inverseInertia = 1 / body.inertia;
      body.mass = mass;
      body.inverseMass = 1 / body.mass;
      body.density = body.mass / body.area;
    };
    Body.setDensity = function(body, density) {
      Body.setMass(body, density * body.area);
      body.density = density;
    };
    Body.setInertia = function(body, inertia) {
      body.inertia = inertia;
      body.inverseInertia = 1 / body.inertia;
    };
    Body.setVertices = function(body, vertices) {
      if (vertices[0].body === body) {
        body.vertices = vertices;
      } else {
        body.vertices = Vertices.create(vertices, body);
      }
      body.axes = Axes.fromVertices(body.vertices);
      body.area = Vertices.area(body.vertices);
      Body.setMass(body, body.density * body.area);
      var centre = Vertices.centre(body.vertices);
      Vertices.translate(body.vertices, centre, -1);
      Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));
      Vertices.translate(body.vertices, body.position);
      Bounds.update(body.bounds, body.vertices, body.velocity);
    };
    Body.setParts = function(body, parts, autoHull) {
      var i;
      parts = parts.slice(0);
      body.parts.length = 0;
      body.parts.push(body);
      body.parent = body;
      for (i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (part !== body) {
          part.parent = body;
          body.parts.push(part);
        }
      }
      if (body.parts.length === 1)
        return;
      autoHull = typeof autoHull !== "undefined" ? autoHull : true;
      if (autoHull) {
        var vertices = [];
        for (i = 0; i < parts.length; i++) {
          vertices = vertices.concat(parts[i].vertices);
        }
        Vertices.clockwiseSort(vertices);
        var hull = Vertices.hull(vertices), hullCentre = Vertices.centre(hull);
        Body.setVertices(body, hull);
        Vertices.translate(body.vertices, hullCentre);
      }
      var total = Body._totalProperties(body);
      var cx = total.centre.x;
      var cy = total.centre.y;
      var bounds = body.bounds;
      var centerOfMass = body.centerOfMass;
      var centerOffset = body.centerOffset;
      Bounds.update(bounds, body.vertices, body.velocity);
      centerOfMass.x = -(bounds.min.x - cx) / (bounds.max.x - bounds.min.x);
      centerOfMass.y = -(bounds.min.y - cy) / (bounds.max.y - bounds.min.y);
      centerOffset.x = cx;
      centerOffset.y = cy;
      body.area = total.area;
      body.parent = body;
      body.position.x = cx;
      body.position.y = cy;
      body.positionPrev.x = cx;
      body.positionPrev.y = cy;
      Body.setMass(body, total.mass);
      Body.setInertia(body, total.inertia);
      Body.setPosition(body, total.centre);
    };
    Body.setCentre = function(body, centre, relative) {
      if (!relative) {
        body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);
        body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);
        body.position.x = centre.x;
        body.position.y = centre.y;
      } else {
        body.positionPrev.x += centre.x;
        body.positionPrev.y += centre.y;
        body.position.x += centre.x;
        body.position.y += centre.y;
      }
    };
    Body.setPosition = function(body, position) {
      var delta = Vector.sub(position, body.position);
      body.positionPrev.x += delta.x;
      body.positionPrev.y += delta.y;
      for (var i = 0; i < body.parts.length; i++) {
        var part = body.parts[i];
        part.position.x += delta.x;
        part.position.y += delta.y;
        Vertices.translate(part.vertices, delta);
        Bounds.update(part.bounds, part.vertices, body.velocity);
      }
    };
    Body.setAngle = function(body, angle) {
      var delta = angle - body.angle;
      body.anglePrev += delta;
      for (var i = 0; i < body.parts.length; i++) {
        var part = body.parts[i];
        part.angle += delta;
        Vertices.rotate(part.vertices, delta, body.position);
        Axes.rotate(part.axes, delta);
        Bounds.update(part.bounds, part.vertices, body.velocity);
        if (i > 0) {
          Vector.rotateAbout(part.position, delta, body.position, part.position);
        }
      }
    };
    Body.setVelocity = function(body, velocity) {
      body.positionPrev.x = body.position.x - velocity.x;
      body.positionPrev.y = body.position.y - velocity.y;
      body.velocity.x = velocity.x;
      body.velocity.y = velocity.y;
      body.speed = Vector.magnitude(body.velocity);
    };
    Body.setAngularVelocity = function(body, velocity) {
      body.anglePrev = body.angle - velocity;
      body.angularVelocity = velocity;
      body.angularSpeed = Math.abs(body.angularVelocity);
    };
    Body.translate = function(body, translation) {
      Body.setPosition(body, Vector.add(body.position, translation));
    };
    Body.rotate = function(body, rotation, point) {
      if (!point) {
        Body.setAngle(body, body.angle + rotation);
      } else {
        var cos = Math.cos(rotation), sin = Math.sin(rotation), dx = body.position.x - point.x, dy = body.position.y - point.y;
        Body.setPosition(body, {
          x: point.x + (dx * cos - dy * sin),
          y: point.y + (dx * sin + dy * cos)
        });
        Body.setAngle(body, body.angle + rotation);
      }
    };
    Body.scale = function(body, scaleX, scaleY, point) {
      var totalArea = 0, totalInertia = 0;
      point = point || body.position;
      for (var i = 0; i < body.parts.length; i++) {
        var part = body.parts[i];
        part.scale.x = scaleX;
        part.scale.y = scaleY;
        Vertices.scale(part.vertices, scaleX, scaleY, point);
        part.axes = Axes.fromVertices(part.vertices);
        part.area = Vertices.area(part.vertices);
        Body.setMass(part, body.density * part.area);
        Vertices.translate(part.vertices, {x: -part.position.x, y: -part.position.y});
        Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));
        Vertices.translate(part.vertices, {x: part.position.x, y: part.position.y});
        if (i > 0) {
          totalArea += part.area;
          totalInertia += part.inertia;
        }
        part.position.x = point.x + (part.position.x - point.x) * scaleX;
        part.position.y = point.y + (part.position.y - point.y) * scaleY;
        Bounds.update(part.bounds, part.vertices, body.velocity);
      }
      if (body.parts.length > 1) {
        body.area = totalArea;
        if (!body.isStatic) {
          Body.setMass(body, body.density * totalArea);
          Body.setInertia(body, totalInertia);
        }
      }
      if (body.circleRadius) {
        if (scaleX === scaleY) {
          body.circleRadius *= scaleX;
        } else {
          body.circleRadius = null;
        }
      }
    };
    Body.update = function(body, deltaTime, timeScale, correction) {
      var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);
      var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale, velocityPrevX = body.position.x - body.positionPrev.x, velocityPrevY = body.position.y - body.positionPrev.y;
      body.velocity.x = velocityPrevX * frictionAir * correction + body.force.x / body.mass * deltaTimeSquared;
      body.velocity.y = velocityPrevY * frictionAir * correction + body.force.y / body.mass * deltaTimeSquared;
      body.positionPrev.x = body.position.x;
      body.positionPrev.y = body.position.y;
      body.position.x += body.velocity.x;
      body.position.y += body.velocity.y;
      body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;
      body.anglePrev = body.angle;
      body.angle += body.angularVelocity;
      body.speed = Vector.magnitude(body.velocity);
      body.angularSpeed = Math.abs(body.angularVelocity);
      for (var i = 0; i < body.parts.length; i++) {
        var part = body.parts[i];
        Vertices.translate(part.vertices, body.velocity);
        if (i > 0) {
          part.position.x += body.velocity.x;
          part.position.y += body.velocity.y;
        }
        if (body.angularVelocity !== 0) {
          Vertices.rotate(part.vertices, body.angularVelocity, body.position);
          Axes.rotate(part.axes, body.angularVelocity);
          if (i > 0) {
            Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
          }
        }
        Bounds.update(part.bounds, part.vertices, body.velocity);
      }
    };
    Body.applyForce = function(body, position, force) {
      body.force.x += force.x;
      body.force.y += force.y;
      var offset = {x: position.x - body.position.x, y: position.y - body.position.y};
      body.torque += offset.x * force.y - offset.y * force.x;
    };
    Body._totalProperties = function(body) {
      var properties = {
        mass: 0,
        area: 0,
        inertia: 0,
        centre: {x: 0, y: 0}
      };
      for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {
        var part = body.parts[i], mass = part.mass !== Infinity ? part.mass : 1;
        properties.mass += mass;
        properties.area += part.area;
        properties.inertia += part.inertia;
        properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));
      }
      properties.centre = Vector.div(properties.centre, properties.mass);
      return properties;
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/components/Force.js
var require_Force = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Body = require_Body2();
  var Force = {
    applyForce: function(force) {
      this._tempVec2.set(this.body.position.x, this.body.position.y);
      Body.applyForce(this.body, this._tempVec2, force);
      return this;
    },
    applyForceFrom: function(position, force) {
      Body.applyForce(this.body, position, force);
      return this;
    },
    thrust: function(speed) {
      var angle = this.body.angle;
      this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
      Body.applyForce(this.body, {x: this.body.position.x, y: this.body.position.y}, this._tempVec2);
      return this;
    },
    thrustLeft: function(speed) {
      var angle = this.body.angle - Math.PI / 2;
      this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
      Body.applyForce(this.body, {x: this.body.position.x, y: this.body.position.y}, this._tempVec2);
      return this;
    },
    thrustRight: function(speed) {
      var angle = this.body.angle + Math.PI / 2;
      this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
      Body.applyForce(this.body, {x: this.body.position.x, y: this.body.position.y}, this._tempVec2);
      return this;
    },
    thrustBack: function(speed) {
      var angle = this.body.angle - Math.PI;
      this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));
      Body.applyForce(this.body, {x: this.body.position.x, y: this.body.position.y}, this._tempVec2);
      return this;
    }
  };
  module2.exports = Force;
});

// node_modules/phaser/src/physics/matter-js/components/Friction.js
var require_Friction2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Friction = {
    setFriction: function(value, air, fstatic) {
      this.body.friction = value;
      if (air !== void 0) {
        this.body.frictionAir = air;
      }
      if (fstatic !== void 0) {
        this.body.frictionStatic = fstatic;
      }
      return this;
    },
    setFrictionAir: function(value) {
      this.body.frictionAir = value;
      return this;
    },
    setFrictionStatic: function(value) {
      this.body.frictionStatic = value;
      return this;
    }
  };
  module2.exports = Friction;
});

// node_modules/phaser/src/physics/matter-js/components/Gravity.js
var require_Gravity2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Gravity = {
    setIgnoreGravity: function(value) {
      this.body.ignoreGravity = value;
      return this;
    }
  };
  module2.exports = Gravity;
});

// node_modules/phaser/src/physics/matter-js/components/Mass.js
var require_Mass2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Body = require_Body2();
  var Vector2 = require_Vector2();
  var Mass = {
    setMass: function(value) {
      Body.setMass(this.body, value);
      return this;
    },
    setDensity: function(value) {
      Body.setDensity(this.body, value);
      return this;
    },
    centerOfMass: {
      get: function() {
        return new Vector2(this.body.centerOfMass.x, this.body.centerOfMass.y);
      }
    }
  };
  module2.exports = Mass;
});

// node_modules/phaser/src/physics/matter-js/components/Sensor.js
var require_Sensor = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Sensor = {
    setSensor: function(value) {
      this.body.isSensor = value;
      return this;
    },
    isSensor: function() {
      return this.body.isSensor;
    }
  };
  module2.exports = Sensor;
});

// node_modules/phaser/src/physics/matter-js/poly-decomp/index.js
var require_poly_decomp = __commonJS((exports2, module2) => {
  /**
   * @author       Stefan Hedman <schteppe@gmail.com> (http://steffe.se)
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    decomp: polygonDecomp,
    quickDecomp: polygonQuickDecomp,
    isSimple: polygonIsSimple,
    removeCollinearPoints: polygonRemoveCollinearPoints,
    removeDuplicatePoints: polygonRemoveDuplicatePoints,
    makeCCW: polygonMakeCCW
  };
  function lineInt(l1, l2, precision) {
    precision = precision || 0;
    var i = [0, 0];
    var a1, b1, c1, a2, b2, c2, det;
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2 * b1;
    if (!scalar_eq(det, 0, precision)) {
      i[0] = (b2 * c1 - b1 * c2) / det;
      i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
  }
  function lineSegmentsIntersect(p1, p2, q1, q2) {
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    var da = q2[0] - q1[0];
    var db = q2[1] - q1[1];
    if (da * dy - db * dx === 0) {
      return false;
    }
    var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
    var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
    return s >= 0 && s <= 1 && t >= 0 && t <= 1;
  }
  function triangleArea(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
  }
  function isLeft(a, b, c) {
    return triangleArea(a, b, c) > 0;
  }
  function isLeftOn(a, b, c) {
    return triangleArea(a, b, c) >= 0;
  }
  function isRight(a, b, c) {
    return triangleArea(a, b, c) < 0;
  }
  function isRightOn(a, b, c) {
    return triangleArea(a, b, c) <= 0;
  }
  var tmpPoint1 = [];
  var tmpPoint2 = [];
  function collinear(a, b, c, thresholdAngle) {
    if (!thresholdAngle) {
      return triangleArea(a, b, c) === 0;
    } else {
      var ab = tmpPoint1, bc = tmpPoint2;
      ab[0] = b[0] - a[0];
      ab[1] = b[1] - a[1];
      bc[0] = c[0] - b[0];
      bc[1] = c[1] - b[1];
      var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
      return angle < thresholdAngle;
    }
  }
  function sqdist(a, b) {
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
  }
  function polygonAt(polygon, i) {
    var s = polygon.length;
    return polygon[i < 0 ? i % s + s : i % s];
  }
  function polygonClear(polygon) {
    polygon.length = 0;
  }
  function polygonAppend(polygon, poly, from, to) {
    for (var i = from; i < to; i++) {
      polygon.push(poly[i]);
    }
  }
  function polygonMakeCCW(polygon) {
    var br = 0, v = polygon;
    for (var i = 1; i < polygon.length; ++i) {
      if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) {
        br = i;
      }
    }
    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
      polygonReverse(polygon);
      return true;
    } else {
      return false;
    }
  }
  function polygonReverse(polygon) {
    var tmp = [];
    var N = polygon.length;
    for (var i = 0; i !== N; i++) {
      tmp.push(polygon.pop());
    }
    for (var i = 0; i !== N; i++) {
      polygon[i] = tmp[i];
    }
  }
  function polygonIsReflex(polygon, i) {
    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
  }
  var tmpLine1 = [];
  var tmpLine2 = [];
  function polygonCanSee(polygon, a, b) {
    var p, dist, l1 = tmpLine1, l2 = tmpLine2;
    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
      return false;
    }
    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
    for (var i = 0; i !== polygon.length; ++i) {
      if ((i + 1) % polygon.length === a || i === a) {
        continue;
      }
      if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {
        l1[0] = polygonAt(polygon, a);
        l1[1] = polygonAt(polygon, b);
        l2[0] = polygonAt(polygon, i);
        l2[1] = polygonAt(polygon, i + 1);
        p = lineInt(l1, l2);
        if (sqdist(polygonAt(polygon, a), p) < dist) {
          return false;
        }
      }
    }
    return true;
  }
  function polygonCanSee2(polygon, a, b) {
    for (var i = 0; i !== polygon.length; ++i) {
      if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {
        continue;
      }
      if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {
        return false;
      }
    }
    return true;
  }
  function polygonCopy(polygon, i, j, targetPoly) {
    var p = targetPoly || [];
    polygonClear(p);
    if (i < j) {
      for (var k = i; k <= j; k++) {
        p.push(polygon[k]);
      }
    } else {
      for (var k = 0; k <= j; k++) {
        p.push(polygon[k]);
      }
      for (var k = i; k < polygon.length; k++) {
        p.push(polygon[k]);
      }
    }
    return p;
  }
  function polygonGetCutEdges(polygon) {
    var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];
    var nDiags = Number.MAX_VALUE;
    for (var i = 0; i < polygon.length; ++i) {
      if (polygonIsReflex(polygon, i)) {
        for (var j = 0; j < polygon.length; ++j) {
          if (polygonCanSee(polygon, i, j)) {
            tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
            tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));
            for (var k = 0; k < tmp2.length; k++) {
              tmp1.push(tmp2[k]);
            }
            if (tmp1.length < nDiags) {
              min = tmp1;
              nDiags = tmp1.length;
              min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);
            }
          }
        }
      }
    }
    return min;
  }
  function polygonDecomp(polygon) {
    var edges = polygonGetCutEdges(polygon);
    if (edges.length > 0) {
      return polygonSlice(polygon, edges);
    } else {
      return [polygon];
    }
  }
  function polygonSlice(polygon, cutEdges) {
    if (cutEdges.length === 0) {
      return [polygon];
    }
    if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {
      var polys = [polygon];
      for (var i = 0; i < cutEdges.length; i++) {
        var cutEdge = cutEdges[i];
        for (var j = 0; j < polys.length; j++) {
          var poly = polys[j];
          var result = polygonSlice(poly, cutEdge);
          if (result) {
            polys.splice(j, 1);
            polys.push(result[0], result[1]);
            break;
          }
        }
      }
      return polys;
    } else {
      var cutEdge = cutEdges;
      var i = polygon.indexOf(cutEdge[0]);
      var j = polygon.indexOf(cutEdge[1]);
      if (i !== -1 && j !== -1) {
        return [
          polygonCopy(polygon, i, j),
          polygonCopy(polygon, j, i)
        ];
      } else {
        return false;
      }
    }
  }
  function polygonIsSimple(polygon) {
    var path = polygon, i;
    for (i = 0; i < path.length - 1; i++) {
      for (var j = 0; j < i - 1; j++) {
        if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
          return false;
        }
      }
    }
    for (i = 1; i < path.length - 2; i++) {
      if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
        return false;
      }
    }
    return true;
  }
  function getIntersectionPoint(p1, p2, q1, q2, delta) {
    delta = delta || 0;
    var a1 = p2[1] - p1[1];
    var b1 = p1[0] - p2[0];
    var c1 = a1 * p1[0] + b1 * p1[1];
    var a2 = q2[1] - q1[1];
    var b2 = q1[0] - q2[0];
    var c2 = a2 * q1[0] + b2 * q1[1];
    var det = a1 * b2 - a2 * b1;
    if (!scalar_eq(det, 0, delta)) {
      return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];
    } else {
      return [0, 0];
    }
  }
  function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof result !== "undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];
    var upperInt = [0, 0], lowerInt = [0, 0], p = [0, 0];
    var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0;
    var upperIndex = 0, lowerIndex = 0, closestIndex = 0;
    var lowerPoly = [], upperPoly = [];
    var poly = polygon, v = polygon;
    if (v.length < 3) {
      return result;
    }
    level++;
    if (level > maxlevel) {
      console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
      return result;
    }
    for (var i = 0; i < polygon.length; ++i) {
      if (polygonIsReflex(poly, i)) {
        reflexVertices.push(poly[i]);
        upperDist = lowerDist = Number.MAX_VALUE;
        for (var j = 0; j < polygon.length; ++j) {
          if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {
            p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1));
            if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {
              d = sqdist(poly[i], p);
              if (d < lowerDist) {
                lowerDist = d;
                lowerInt = p;
                lowerIndex = j;
              }
            }
          }
          if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
            p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
            if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
              d = sqdist(poly[i], p);
              if (d < upperDist) {
                upperDist = d;
                upperInt = p;
                upperIndex = j;
              }
            }
          }
        }
        if (lowerIndex === (upperIndex + 1) % polygon.length) {
          p[0] = (lowerInt[0] + upperInt[0]) / 2;
          p[1] = (lowerInt[1] + upperInt[1]) / 2;
          steinerPoints.push(p);
          if (i < upperIndex) {
            polygonAppend(lowerPoly, poly, i, upperIndex + 1);
            lowerPoly.push(p);
            upperPoly.push(p);
            if (lowerIndex !== 0) {
              polygonAppend(upperPoly, poly, lowerIndex, poly.length);
            }
            polygonAppend(upperPoly, poly, 0, i + 1);
          } else {
            if (i !== 0) {
              polygonAppend(lowerPoly, poly, i, poly.length);
            }
            polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
            lowerPoly.push(p);
            upperPoly.push(p);
            polygonAppend(upperPoly, poly, lowerIndex, i + 1);
          }
        } else {
          if (lowerIndex > upperIndex) {
            upperIndex += polygon.length;
          }
          closestDist = Number.MAX_VALUE;
          if (upperIndex < lowerIndex) {
            return result;
          }
          for (var j = lowerIndex; j <= upperIndex; ++j) {
            if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
              d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
              if (d < closestDist && polygonCanSee2(poly, i, j)) {
                closestDist = d;
                closestIndex = j % polygon.length;
              }
            }
          }
          if (i < closestIndex) {
            polygonAppend(lowerPoly, poly, i, closestIndex + 1);
            if (closestIndex !== 0) {
              polygonAppend(upperPoly, poly, closestIndex, v.length);
            }
            polygonAppend(upperPoly, poly, 0, i + 1);
          } else {
            if (i !== 0) {
              polygonAppend(lowerPoly, poly, i, v.length);
            }
            polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
            polygonAppend(upperPoly, poly, closestIndex, i + 1);
          }
        }
        if (lowerPoly.length < upperPoly.length) {
          polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
          polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
        } else {
          polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
          polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
        }
        return result;
      }
    }
    result.push(polygon);
    return result;
  }
  function polygonRemoveCollinearPoints(polygon, precision) {
    var num = 0;
    for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {
      if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {
        polygon.splice(i % polygon.length, 1);
        num++;
      }
    }
    return num;
  }
  function polygonRemoveDuplicatePoints(polygon, precision) {
    for (var i = polygon.length - 1; i >= 1; --i) {
      var pi = polygon[i];
      for (var j = i - 1; j >= 0; --j) {
        if (points_eq(pi, polygon[j], precision)) {
          polygon.splice(i, 1);
          continue;
        }
      }
    }
  }
  function scalar_eq(a, b, precision) {
    precision = precision || 0;
    return Math.abs(a - b) <= precision;
  }
  function points_eq(a, b, precision) {
    return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);
  }
});

// node_modules/phaser/src/physics/matter-js/lib/factory/Bodies.js
var require_Bodies = __commonJS((exports2, module2) => {
  var Bodies = {};
  module2.exports = Bodies;
  var Vertices = require_Vertices();
  var Common = require_Common();
  var Body = require_Body2();
  var Bounds = require_Bounds();
  var Vector = require_Vector();
  var decomp = require_poly_decomp();
  (function() {
    Bodies.rectangle = function(x, y, width, height, options) {
      options = options || {};
      var rectangle = {
        label: "Rectangle Body",
        position: {x, y},
        vertices: Vertices.fromPath("L 0 0 L " + width + " 0 L " + width + " " + height + " L 0 " + height)
      };
      if (options.chamfer) {
        var chamfer = options.chamfer;
        rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
        delete options.chamfer;
      }
      return Body.create(Common.extend({}, rectangle, options));
    };
    Bodies.trapezoid = function(x, y, width, height, slope, options) {
      options = options || {};
      slope *= 0.5;
      var roof = (1 - slope * 2) * width;
      var x1 = width * slope, x2 = x1 + roof, x3 = x2 + x1, verticesPath;
      if (slope < 0.5) {
        verticesPath = "L 0 0 L " + x1 + " " + -height + " L " + x2 + " " + -height + " L " + x3 + " 0";
      } else {
        verticesPath = "L 0 0 L " + x2 + " " + -height + " L " + x3 + " 0";
      }
      var trapezoid = {
        label: "Trapezoid Body",
        position: {x, y},
        vertices: Vertices.fromPath(verticesPath)
      };
      if (options.chamfer) {
        var chamfer = options.chamfer;
        trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
        delete options.chamfer;
      }
      return Body.create(Common.extend({}, trapezoid, options));
    };
    Bodies.circle = function(x, y, radius, options, maxSides) {
      options = options || {};
      var circle = {
        label: "Circle Body",
        circleRadius: radius
      };
      maxSides = maxSides || 25;
      var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));
      if (sides % 2 === 1)
        sides += 1;
      return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));
    };
    Bodies.polygon = function(x, y, sides, radius, options) {
      options = options || {};
      if (sides < 3)
        return Bodies.circle(x, y, radius, options);
      var theta = 2 * Math.PI / sides, path = "", offset = theta * 0.5;
      for (var i = 0; i < sides; i += 1) {
        var angle = offset + i * theta, xx = Math.cos(angle) * radius, yy = Math.sin(angle) * radius;
        path += "L " + xx.toFixed(3) + " " + yy.toFixed(3) + " ";
      }
      var polygon = {
        label: "Polygon Body",
        position: {x, y},
        vertices: Vertices.fromPath(path)
      };
      if (options.chamfer) {
        var chamfer = options.chamfer;
        polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
        delete options.chamfer;
      }
      return Body.create(Common.extend({}, polygon, options));
    };
    Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
      var body, parts, isConvex, vertices, i, j, k, v, z;
      options = options || {};
      parts = [];
      flagInternal = typeof flagInternal !== "undefined" ? flagInternal : false;
      removeCollinear = typeof removeCollinear !== "undefined" ? removeCollinear : 0.01;
      minimumArea = typeof minimumArea !== "undefined" ? minimumArea : 10;
      if (!decomp) {
        Common.warn("Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.");
      }
      if (!Common.isArray(vertexSets[0])) {
        vertexSets = [vertexSets];
      }
      for (v = 0; v < vertexSets.length; v += 1) {
        vertices = vertexSets[v];
        isConvex = Vertices.isConvex(vertices);
        if (isConvex || !decomp) {
          if (isConvex) {
            vertices = Vertices.clockwiseSort(vertices);
          } else {
            vertices = Vertices.hull(vertices);
          }
          parts.push({
            position: {x, y},
            vertices
          });
        } else {
          var concave = vertices.map(function(vertex) {
            return [vertex.x, vertex.y];
          });
          decomp.makeCCW(concave);
          if (removeCollinear !== false)
            decomp.removeCollinearPoints(concave, removeCollinear);
          var decomposed = decomp.quickDecomp(concave);
          for (i = 0; i < decomposed.length; i++) {
            var chunk = decomposed[i];
            var chunkVertices = chunk.map(function(vertices2) {
              return {
                x: vertices2[0],
                y: vertices2[1]
              };
            });
            if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)
              continue;
            parts.push({
              position: Vertices.centre(chunkVertices),
              vertices: chunkVertices
            });
          }
        }
      }
      for (i = 0; i < parts.length; i++) {
        parts[i] = Body.create(Common.extend(parts[i], options));
      }
      if (flagInternal) {
        Bodies.flagCoincidentParts(parts, 5);
      }
      if (parts.length > 1) {
        body = Body.create(Common.extend({parts: parts.slice(0)}, options));
        Body.setPosition(body, {x, y});
        return body;
      } else {
        return parts[0];
      }
    };
    Bodies.flagCoincidentParts = function(parts, maxDistance) {
      if (maxDistance === void 0) {
        maxDistance = 5;
      }
      for (var i = 0; i < parts.length; i++) {
        var partA = parts[i];
        for (var j = i + 1; j < parts.length; j++) {
          var partB = parts[j];
          if (Bounds.overlaps(partA.bounds, partB.bounds)) {
            var pav = partA.vertices;
            var pbv = partB.vertices;
            for (var k = 0; k < partA.vertices.length; k++) {
              for (var z = 0; z < partB.vertices.length; z++) {
                var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z]));
                var db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));
                if (da < maxDistance && db < maxDistance) {
                  pav[k].isInternal = true;
                  pbv[z].isInternal = true;
                }
              }
            }
          }
        }
      }
      return parts;
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/PhysicsEditorParser.js
var require_PhysicsEditorParser = __commonJS((exports2, module2) => {
  /**
   * @author       Joachim Grill <joachim@codeandweb.com>
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 CodeAndWeb GmbH
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Bodies = require_Bodies();
  var Body = require_Body2();
  var Common = require_Common();
  var GetFastValue = require_GetFastValue();
  var Vertices = require_Vertices();
  var PhysicsEditorParser = {
    parseBody: function(x, y, config2, options) {
      if (options === void 0) {
        options = {};
      }
      var fixtureConfigs = GetFastValue(config2, "fixtures", []);
      var fixtures = [];
      for (var fc = 0; fc < fixtureConfigs.length; fc++) {
        var fixtureParts = this.parseFixture(fixtureConfigs[fc]);
        for (var i = 0; i < fixtureParts.length; i++) {
          fixtures.push(fixtureParts[i]);
        }
      }
      var matterConfig = Common.clone(config2, true);
      Common.extend(matterConfig, options, true);
      delete matterConfig.fixtures;
      delete matterConfig.type;
      var body = Body.create(matterConfig);
      Body.setParts(body, fixtures);
      Body.setPosition(body, {x, y});
      return body;
    },
    parseFixture: function(fixtureConfig) {
      var matterConfig = Common.extend({}, false, fixtureConfig);
      delete matterConfig.circle;
      delete matterConfig.vertices;
      var fixtures;
      if (fixtureConfig.circle) {
        var x = GetFastValue(fixtureConfig.circle, "x");
        var y = GetFastValue(fixtureConfig.circle, "y");
        var r = GetFastValue(fixtureConfig.circle, "radius");
        fixtures = [Bodies.circle(x, y, r, matterConfig)];
      } else if (fixtureConfig.vertices) {
        fixtures = this.parseVertices(fixtureConfig.vertices, matterConfig);
      }
      return fixtures;
    },
    parseVertices: function(vertexSets, options) {
      if (options === void 0) {
        options = {};
      }
      var parts = [];
      for (var v = 0; v < vertexSets.length; v++) {
        Vertices.clockwiseSort(vertexSets[v]);
        parts.push(Body.create(Common.extend({
          position: Vertices.centre(vertexSets[v]),
          vertices: vertexSets[v]
        }, options)));
      }
      return Bodies.flagCoincidentParts(parts);
    }
  };
  module2.exports = PhysicsEditorParser;
});

// node_modules/phaser/src/physics/matter-js/PhysicsJSONParser.js
var require_PhysicsJSONParser = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Bodies = require_Bodies();
  var Body = require_Body2();
  var PhysicsJSONParser = {
    parseBody: function(x, y, config2, options) {
      if (options === void 0) {
        options = {};
      }
      var body;
      var vertexSets = config2.vertices;
      if (vertexSets.length === 1) {
        options.vertices = vertexSets[0];
        body = Body.create(options);
        Bodies.flagCoincidentParts(body.parts);
      } else {
        var parts = [];
        for (var i = 0; i < vertexSets.length; i++) {
          var part = Body.create({
            vertices: vertexSets[i]
          });
          parts.push(part);
        }
        Bodies.flagCoincidentParts(parts);
        options.parts = parts;
        body = Body.create(options);
      }
      body.label = config2.label;
      Body.setPosition(body, {x, y});
      return body;
    }
  };
  module2.exports = PhysicsJSONParser;
});

// node_modules/phaser/src/physics/matter-js/components/SetBody.js
var require_SetBody = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Bodies = require_Bodies();
  var Body = require_Body2();
  var FuzzyEquals = require_Equal();
  var GetFastValue = require_GetFastValue();
  var PhysicsEditorParser = require_PhysicsEditorParser();
  var PhysicsJSONParser = require_PhysicsJSONParser();
  var Vertices = require_Vertices();
  var SetBody = {
    setRectangle: function(width, height, options) {
      return this.setBody({type: "rectangle", width, height}, options);
    },
    setCircle: function(radius, options) {
      return this.setBody({type: "circle", radius}, options);
    },
    setPolygon: function(radius, sides, options) {
      return this.setBody({type: "polygon", sides, radius}, options);
    },
    setTrapezoid: function(width, height, slope, options) {
      return this.setBody({type: "trapezoid", width, height, slope}, options);
    },
    setExistingBody: function(body, addToWorld) {
      if (addToWorld === void 0) {
        addToWorld = true;
      }
      if (this.body) {
        this.world.remove(this.body, true);
      }
      this.body = body;
      for (var i = 0; i < body.parts.length; i++) {
        body.parts[i].gameObject = this;
      }
      var _this = this;
      body.destroy = function destroy() {
        _this.world.remove(_this.body, true);
        _this.body.gameObject = null;
      };
      if (addToWorld) {
        if (this.world.has(body)) {
          this.world.remove(body, true);
        }
        this.world.add(body);
      }
      if (this._originComponent) {
        var rx = body.render.sprite.xOffset;
        var ry = body.render.sprite.yOffset;
        var comx = body.centerOfMass.x;
        var comy = body.centerOfMass.y;
        if (FuzzyEquals(comx, 0.5) && FuzzyEquals(comy, 0.5)) {
          this.setOrigin(rx + 0.5, ry + 0.5);
        } else {
          var cx = body.centerOffset.x;
          var cy = body.centerOffset.y;
          this.setOrigin(rx + cx / this.displayWidth, ry + cy / this.displayHeight);
        }
      }
      return this;
    },
    setBody: function(config2, options) {
      if (!config2) {
        return this;
      }
      var body;
      if (typeof config2 === "string") {
        config2 = {type: config2};
      }
      var shapeType = GetFastValue(config2, "type", "rectangle");
      var bodyX = GetFastValue(config2, "x", this._tempVec2.x);
      var bodyY = GetFastValue(config2, "y", this._tempVec2.y);
      var bodyWidth = GetFastValue(config2, "width", this.width);
      var bodyHeight = GetFastValue(config2, "height", this.height);
      switch (shapeType) {
        case "rectangle":
          body = Bodies.rectangle(bodyX, bodyY, bodyWidth, bodyHeight, options);
          break;
        case "circle":
          var radius = GetFastValue(config2, "radius", Math.max(bodyWidth, bodyHeight) / 2);
          var maxSides = GetFastValue(config2, "maxSides", 25);
          body = Bodies.circle(bodyX, bodyY, radius, options, maxSides);
          break;
        case "trapezoid":
          var slope = GetFastValue(config2, "slope", 0.5);
          body = Bodies.trapezoid(bodyX, bodyY, bodyWidth, bodyHeight, slope, options);
          break;
        case "polygon":
          var sides = GetFastValue(config2, "sides", 5);
          var pRadius = GetFastValue(config2, "radius", Math.max(bodyWidth, bodyHeight) / 2);
          body = Bodies.polygon(bodyX, bodyY, sides, pRadius, options);
          break;
        case "fromVertices":
        case "fromVerts":
          var verts = GetFastValue(config2, "verts", null);
          if (verts) {
            if (typeof verts === "string") {
              verts = Vertices.fromPath(verts);
            }
            if (this.body && !this.body.hasOwnProperty("temp")) {
              Body.setVertices(this.body, verts);
              body = this.body;
            } else {
              var flagInternal = GetFastValue(config2, "flagInternal", false);
              var removeCollinear = GetFastValue(config2, "removeCollinear", 0.01);
              var minimumArea = GetFastValue(config2, "minimumArea", 10);
              body = Bodies.fromVertices(bodyX, bodyY, verts, options, flagInternal, removeCollinear, minimumArea);
            }
          }
          break;
        case "fromPhysicsEditor":
          body = PhysicsEditorParser.parseBody(bodyX, bodyY, config2, options);
          break;
        case "fromPhysicsTracer":
          body = PhysicsJSONParser.parseBody(bodyX, bodyY, config2, options);
          break;
      }
      if (body) {
        this.setExistingBody(body, config2.addToWorld);
      }
      return this;
    }
  };
  module2.exports = SetBody;
});

// node_modules/phaser/src/physics/matter-js/events/AFTER_ADD_EVENT.js
var require_AFTER_ADD_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "afteradd";
});

// node_modules/phaser/src/physics/matter-js/events/AFTER_REMOVE_EVENT.js
var require_AFTER_REMOVE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "afterremove";
});

// node_modules/phaser/src/physics/matter-js/events/AFTER_UPDATE_EVENT.js
var require_AFTER_UPDATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "afterupdate";
});

// node_modules/phaser/src/physics/matter-js/events/BEFORE_ADD_EVENT.js
var require_BEFORE_ADD_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "beforeadd";
});

// node_modules/phaser/src/physics/matter-js/events/BEFORE_REMOVE_EVENT.js
var require_BEFORE_REMOVE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "beforeremove";
});

// node_modules/phaser/src/physics/matter-js/events/BEFORE_UPDATE_EVENT.js
var require_BEFORE_UPDATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "beforeupdate";
});

// node_modules/phaser/src/physics/matter-js/events/COLLISION_ACTIVE_EVENT.js
var require_COLLISION_ACTIVE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "collisionactive";
});

// node_modules/phaser/src/physics/matter-js/events/COLLISION_END_EVENT.js
var require_COLLISION_END_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "collisionend";
});

// node_modules/phaser/src/physics/matter-js/events/COLLISION_START_EVENT.js
var require_COLLISION_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "collisionstart";
});

// node_modules/phaser/src/physics/matter-js/events/DRAG_END_EVENT.js
var require_DRAG_END_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "dragend";
});

// node_modules/phaser/src/physics/matter-js/events/DRAG_EVENT.js
var require_DRAG_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "drag";
});

// node_modules/phaser/src/physics/matter-js/events/DRAG_START_EVENT.js
var require_DRAG_START_EVENT2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "dragstart";
});

// node_modules/phaser/src/physics/matter-js/events/PAUSE_EVENT.js
var require_PAUSE_EVENT5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pause";
});

// node_modules/phaser/src/physics/matter-js/events/RESUME_EVENT.js
var require_RESUME_EVENT5 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "resume";
});

// node_modules/phaser/src/physics/matter-js/events/SLEEP_END_EVENT.js
var require_SLEEP_END_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "sleepend";
});

// node_modules/phaser/src/physics/matter-js/events/SLEEP_START_EVENT.js
var require_SLEEP_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "sleepstart";
});

// node_modules/phaser/src/physics/matter-js/events/index.js
var require_events20 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    AFTER_ADD: require_AFTER_ADD_EVENT(),
    AFTER_REMOVE: require_AFTER_REMOVE_EVENT(),
    AFTER_UPDATE: require_AFTER_UPDATE_EVENT(),
    BEFORE_ADD: require_BEFORE_ADD_EVENT(),
    BEFORE_REMOVE: require_BEFORE_REMOVE_EVENT(),
    BEFORE_UPDATE: require_BEFORE_UPDATE_EVENT(),
    COLLISION_ACTIVE: require_COLLISION_ACTIVE_EVENT(),
    COLLISION_END: require_COLLISION_END_EVENT(),
    COLLISION_START: require_COLLISION_START_EVENT(),
    DRAG_END: require_DRAG_END_EVENT2(),
    DRAG: require_DRAG_EVENT2(),
    DRAG_START: require_DRAG_START_EVENT2(),
    PAUSE: require_PAUSE_EVENT5(),
    RESUME: require_RESUME_EVENT5(),
    SLEEP_END: require_SLEEP_END_EVENT(),
    SLEEP_START: require_SLEEP_START_EVENT()
  };
});

// node_modules/phaser/src/physics/matter-js/components/Sleep.js
var require_Sleep = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Events = require_events20();
  var Sleeping = require_Sleeping();
  var MatterEvents = require_Events();
  var Sleep = {
    setToSleep: function() {
      Sleeping.set(this.body, true);
      return this;
    },
    setAwake: function() {
      Sleeping.set(this.body, false);
      return this;
    },
    setSleepThreshold: function(value) {
      if (value === void 0) {
        value = 60;
      }
      this.body.sleepThreshold = value;
      return this;
    },
    setSleepEvents: function(start, end) {
      this.setSleepStartEvent(start);
      this.setSleepEndEvent(end);
      return this;
    },
    setSleepStartEvent: function(value) {
      if (value) {
        var world = this.world;
        MatterEvents.on(this.body, "sleepStart", function(event) {
          world.emit(Events.SLEEP_START, event, this);
        });
      } else {
        MatterEvents.off(this.body, "sleepStart");
      }
      return this;
    },
    setSleepEndEvent: function(value) {
      if (value) {
        var world = this.world;
        MatterEvents.on(this.body, "sleepEnd", function(event) {
          world.emit(Events.SLEEP_END, event, this);
        });
      } else {
        MatterEvents.off(this.body, "sleepEnd");
      }
      return this;
    }
  };
  module2.exports = Sleep;
});

// node_modules/phaser/src/physics/matter-js/components/Static.js
var require_Static = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Body = require_Body2();
  var Static = {
    setStatic: function(value) {
      Body.setStatic(this.body, value);
      return this;
    },
    isStatic: function() {
      return this.body.isStatic;
    }
  };
  module2.exports = Static;
});

// node_modules/phaser/src/physics/matter-js/components/Transform.js
var require_Transform2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Body = require_Body2();
  var MATH_CONST = require_const4();
  var WrapAngle = require_Wrap2();
  var WrapAngleDegrees = require_WrapDegrees();
  var _FLAG = 4;
  var Transform = {
    x: {
      get: function() {
        return this.body.position.x;
      },
      set: function(value) {
        this._tempVec2.set(value, this.y);
        Body.setPosition(this.body, this._tempVec2);
      }
    },
    y: {
      get: function() {
        return this.body.position.y;
      },
      set: function(value) {
        this._tempVec2.set(this.x, value);
        Body.setPosition(this.body, this._tempVec2);
      }
    },
    scaleX: {
      get: function() {
        return this._scaleX;
      },
      set: function(value) {
        var factorX = 1 / this._scaleX;
        var factorY = 1 / this._scaleY;
        this._scaleX = value;
        if (this._scaleX === 0) {
          this.renderFlags &= ~_FLAG;
        } else {
          this.renderFlags |= _FLAG;
        }
        Body.scale(this.body, factorX, factorY);
        Body.scale(this.body, value, this._scaleY);
      }
    },
    scaleY: {
      get: function() {
        return this._scaleY;
      },
      set: function(value) {
        var factorX = 1 / this._scaleX;
        var factorY = 1 / this._scaleY;
        this._scaleY = value;
        if (this._scaleY === 0) {
          this.renderFlags &= ~_FLAG;
        } else {
          this.renderFlags |= _FLAG;
        }
        Body.scale(this.body, factorX, factorY);
        Body.scale(this.body, this._scaleX, value);
      }
    },
    angle: {
      get: function() {
        return WrapAngleDegrees(this.body.angle * MATH_CONST.RAD_TO_DEG);
      },
      set: function(value) {
        this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;
      }
    },
    rotation: {
      get: function() {
        return this.body.angle;
      },
      set: function(value) {
        this._rotation = WrapAngle(value);
        Body.setAngle(this.body, this._rotation);
      }
    },
    setPosition: function(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = x;
      }
      this._tempVec2.set(x, y);
      Body.setPosition(this.body, this._tempVec2);
      return this;
    },
    setRotation: function(radians) {
      if (radians === void 0) {
        radians = 0;
      }
      this._rotation = WrapAngle(radians);
      Body.setAngle(this.body, radians);
      return this;
    },
    setFixedRotation: function() {
      Body.setInertia(this.body, Infinity);
      return this;
    },
    setAngle: function(degrees) {
      if (degrees === void 0) {
        degrees = 0;
      }
      this.angle = degrees;
      Body.setAngle(this.body, this.rotation);
      return this;
    },
    setScale: function(x, y, point) {
      if (x === void 0) {
        x = 1;
      }
      if (y === void 0) {
        y = x;
      }
      var factorX = 1 / this._scaleX;
      var factorY = 1 / this._scaleY;
      this._scaleX = x;
      this._scaleY = y;
      Body.scale(this.body, factorX, factorY, point);
      Body.scale(this.body, x, y, point);
      return this;
    }
  };
  module2.exports = Transform;
});

// node_modules/phaser/src/physics/matter-js/components/Velocity.js
var require_Velocity2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Body = require_Body2();
  var Velocity = {
    setAngularVelocity: function(value) {
      Body.setAngularVelocity(this.body, value);
      return this;
    },
    setVelocityX: function(x) {
      this._tempVec2.set(x, this.body.velocity.y);
      Body.setVelocity(this.body, this._tempVec2);
      return this;
    },
    setVelocityY: function(y) {
      this._tempVec2.set(this.body.velocity.x, y);
      Body.setVelocity(this.body, this._tempVec2);
      return this;
    },
    setVelocity: function(x, y) {
      this._tempVec2.set(x, y);
      Body.setVelocity(this.body, this._tempVec2);
      return this;
    }
  };
  module2.exports = Velocity;
});

// node_modules/phaser/src/physics/matter-js/components/index.js
var require_components3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Bounce: require_Bounce2(),
    Collision: require_Collision(),
    Force: require_Force(),
    Friction: require_Friction2(),
    Gravity: require_Gravity2(),
    Mass: require_Mass2(),
    Sensor: require_Sensor(),
    SetBody: require_SetBody(),
    Sleep: require_Sleep(),
    Static: require_Static(),
    Transform: require_Transform2(),
    Velocity: require_Velocity2()
  };
});

// node_modules/phaser/src/physics/matter-js/lib/body/Composite.js
var require_Composite = __commonJS((exports2, module2) => {
  var Composite = {};
  module2.exports = Composite;
  var Events = require_Events();
  var Common = require_Common();
  var Bounds = require_Bounds();
  var Body = require_Body2();
  (function() {
    Composite.create = function(options) {
      return Common.extend({
        id: Common.nextId(),
        type: "composite",
        parent: null,
        isModified: false,
        bodies: [],
        constraints: [],
        composites: [],
        label: "Composite",
        plugin: {}
      }, options);
    };
    Composite.setModified = function(composite, isModified, updateParents, updateChildren) {
      Events.trigger(composite, "compositeModified", composite);
      composite.isModified = isModified;
      if (updateParents && composite.parent) {
        Composite.setModified(composite.parent, isModified, updateParents, updateChildren);
      }
      if (updateChildren) {
        for (var i = 0; i < composite.composites.length; i++) {
          var childComposite = composite.composites[i];
          Composite.setModified(childComposite, isModified, updateParents, updateChildren);
        }
      }
    };
    Composite.add = function(composite, object) {
      var objects = [].concat(object);
      Events.trigger(composite, "beforeAdd", {object});
      for (var i = 0; i < objects.length; i++) {
        var obj = objects[i];
        switch (obj.type) {
          case "body":
            if (obj.parent !== obj) {
              Common.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
              break;
            }
            Composite.addBody(composite, obj);
            break;
          case "constraint":
            Composite.addConstraint(composite, obj);
            break;
          case "composite":
            Composite.addComposite(composite, obj);
            break;
          case "mouseConstraint":
            Composite.addConstraint(composite, obj.constraint);
            break;
        }
      }
      Events.trigger(composite, "afterAdd", {object});
      return composite;
    };
    Composite.remove = function(composite, object, deep) {
      var objects = [].concat(object);
      Events.trigger(composite, "beforeRemove", {object});
      for (var i = 0; i < objects.length; i++) {
        var obj = objects[i];
        switch (obj.type) {
          case "body":
            Composite.removeBody(composite, obj, deep);
            break;
          case "constraint":
            Composite.removeConstraint(composite, obj, deep);
            break;
          case "composite":
            Composite.removeComposite(composite, obj, deep);
            break;
          case "mouseConstraint":
            Composite.removeConstraint(composite, obj.constraint);
            break;
        }
      }
      Events.trigger(composite, "afterRemove", {object});
      return composite;
    };
    Composite.addComposite = function(compositeA, compositeB) {
      compositeA.composites.push(compositeB);
      compositeB.parent = compositeA;
      Composite.setModified(compositeA, true, true, false);
      return compositeA;
    };
    Composite.removeComposite = function(compositeA, compositeB, deep) {
      var position = compositeA.composites.indexOf(compositeB);
      if (position !== -1) {
        Composite.removeCompositeAt(compositeA, position);
        Composite.setModified(compositeA, true, true, false);
      }
      if (deep) {
        for (var i = 0; i < compositeA.composites.length; i++) {
          Composite.removeComposite(compositeA.composites[i], compositeB, true);
        }
      }
      return compositeA;
    };
    Composite.removeCompositeAt = function(composite, position) {
      composite.composites.splice(position, 1);
      Composite.setModified(composite, true, true, false);
      return composite;
    };
    Composite.addBody = function(composite, body) {
      composite.bodies.push(body);
      Composite.setModified(composite, true, true, false);
      return composite;
    };
    Composite.removeBody = function(composite, body, deep) {
      var position = composite.bodies.indexOf(body);
      if (position !== -1) {
        Composite.removeBodyAt(composite, position);
        Composite.setModified(composite, true, true, false);
      }
      if (deep) {
        for (var i = 0; i < composite.composites.length; i++) {
          Composite.removeBody(composite.composites[i], body, true);
        }
      }
      return composite;
    };
    Composite.removeBodyAt = function(composite, position) {
      composite.bodies.splice(position, 1);
      Composite.setModified(composite, true, true, false);
      return composite;
    };
    Composite.addConstraint = function(composite, constraint) {
      composite.constraints.push(constraint);
      Composite.setModified(composite, true, true, false);
      return composite;
    };
    Composite.removeConstraint = function(composite, constraint, deep) {
      var position = composite.constraints.indexOf(constraint);
      if (position !== -1) {
        Composite.removeConstraintAt(composite, position);
      }
      if (deep) {
        for (var i = 0; i < composite.composites.length; i++) {
          Composite.removeConstraint(composite.composites[i], constraint, true);
        }
      }
      return composite;
    };
    Composite.removeConstraintAt = function(composite, position) {
      composite.constraints.splice(position, 1);
      Composite.setModified(composite, true, true, false);
      return composite;
    };
    Composite.clear = function(composite, keepStatic, deep) {
      if (deep) {
        for (var i = 0; i < composite.composites.length; i++) {
          Composite.clear(composite.composites[i], keepStatic, true);
        }
      }
      if (keepStatic) {
        composite.bodies = composite.bodies.filter(function(body) {
          return body.isStatic;
        });
      } else {
        composite.bodies.length = 0;
      }
      composite.constraints.length = 0;
      composite.composites.length = 0;
      Composite.setModified(composite, true, true, false);
      return composite;
    };
    Composite.allBodies = function(composite) {
      var bodies = [].concat(composite.bodies);
      for (var i = 0; i < composite.composites.length; i++)
        bodies = bodies.concat(Composite.allBodies(composite.composites[i]));
      return bodies;
    };
    Composite.allConstraints = function(composite) {
      var constraints = [].concat(composite.constraints);
      for (var i = 0; i < composite.composites.length; i++)
        constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));
      return constraints;
    };
    Composite.allComposites = function(composite) {
      var composites = [].concat(composite.composites);
      for (var i = 0; i < composite.composites.length; i++)
        composites = composites.concat(Composite.allComposites(composite.composites[i]));
      return composites;
    };
    Composite.get = function(composite, id, type) {
      var objects, object;
      switch (type) {
        case "body":
          objects = Composite.allBodies(composite);
          break;
        case "constraint":
          objects = Composite.allConstraints(composite);
          break;
        case "composite":
          objects = Composite.allComposites(composite).concat(composite);
          break;
      }
      if (!objects)
        return null;
      object = objects.filter(function(object2) {
        return object2.id.toString() === id.toString();
      });
      return object.length === 0 ? null : object[0];
    };
    Composite.move = function(compositeA, objects, compositeB) {
      Composite.remove(compositeA, objects);
      Composite.add(compositeB, objects);
      return compositeA;
    };
    Composite.rebase = function(composite) {
      var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));
      for (var i = 0; i < objects.length; i++) {
        objects[i].id = Common.nextId();
      }
      Composite.setModified(composite, true, true, false);
      return composite;
    };
    Composite.translate = function(composite, translation, recursive) {
      var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
      for (var i = 0; i < bodies.length; i++) {
        Body.translate(bodies[i], translation);
      }
      Composite.setModified(composite, true, true, false);
      return composite;
    };
    Composite.rotate = function(composite, rotation, point, recursive) {
      var cos = Math.cos(rotation), sin = Math.sin(rotation), bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;
        Body.setPosition(body, {
          x: point.x + (dx * cos - dy * sin),
          y: point.y + (dx * sin + dy * cos)
        });
        Body.rotate(body, rotation);
      }
      Composite.setModified(composite, true, true, false);
      return composite;
    };
    Composite.scale = function(composite, scaleX, scaleY, point, recursive) {
      var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;
        Body.setPosition(body, {
          x: point.x + dx * scaleX,
          y: point.y + dy * scaleY
        });
        Body.scale(body, scaleX, scaleY);
      }
      Composite.setModified(composite, true, true, false);
      return composite;
    };
    Composite.bounds = function(composite) {
      var bodies = Composite.allBodies(composite), vertices = [];
      for (var i = 0; i < bodies.length; i += 1) {
        var body = bodies[i];
        vertices.push(body.bounds.min, body.bounds.max);
      }
      return Bounds.create(vertices);
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/constraint/Constraint.js
var require_Constraint = __commonJS((exports2, module2) => {
  var Constraint = {};
  module2.exports = Constraint;
  var Vertices = require_Vertices();
  var Vector = require_Vector();
  var Sleeping = require_Sleeping();
  var Bounds = require_Bounds();
  var Axes = require_Axes();
  var Common = require_Common();
  (function() {
    Constraint._warming = 0.4;
    Constraint._torqueDampen = 1;
    Constraint._minLength = 1e-6;
    Constraint.create = function(options) {
      var constraint = options;
      if (constraint.bodyA && !constraint.pointA)
        constraint.pointA = {x: 0, y: 0};
      if (constraint.bodyB && !constraint.pointB)
        constraint.pointB = {x: 0, y: 0};
      var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA, initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB, length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));
      constraint.length = typeof constraint.length !== "undefined" ? constraint.length : length;
      constraint.id = constraint.id || Common.nextId();
      constraint.label = constraint.label || "Constraint";
      constraint.type = "constraint";
      constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);
      constraint.damping = constraint.damping || 0;
      constraint.angularStiffness = constraint.angularStiffness || 0;
      constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;
      constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;
      constraint.plugin = {};
      var render = {
        visible: true,
        type: "line",
        anchors: true,
        lineColor: null,
        lineOpacity: null,
        lineThickness: null,
        pinSize: null,
        anchorColor: null,
        anchorSize: null
      };
      if (constraint.length === 0 && constraint.stiffness > 0.1) {
        render.type = "pin";
        render.anchors = false;
      } else if (constraint.stiffness < 0.9) {
        render.type = "spring";
      }
      constraint.render = Common.extend(render, constraint.render);
      return constraint;
    };
    Constraint.preSolveAll = function(bodies) {
      for (var i = 0; i < bodies.length; i += 1) {
        var body = bodies[i], impulse = body.constraintImpulse;
        if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
          continue;
        }
        body.position.x += impulse.x;
        body.position.y += impulse.y;
        body.angle += impulse.angle;
      }
    };
    Constraint.solveAll = function(constraints, timeScale) {
      for (var i = 0; i < constraints.length; i += 1) {
        var constraint = constraints[i], fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic, fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
        if (fixedA || fixedB) {
          Constraint.solve(constraints[i], timeScale);
        }
      }
      for (i = 0; i < constraints.length; i += 1) {
        constraint = constraints[i];
        fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic;
        fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
        if (!fixedA && !fixedB) {
          Constraint.solve(constraints[i], timeScale);
        }
      }
    };
    Constraint.solve = function(constraint, timeScale) {
      var bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointA = constraint.pointA, pointB = constraint.pointB;
      if (!bodyA && !bodyB)
        return;
      if (bodyA && !bodyA.isStatic) {
        Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);
        constraint.angleA = bodyA.angle;
      }
      if (bodyB && !bodyB.isStatic) {
        Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);
        constraint.angleB = bodyB.angle;
      }
      var pointAWorld = pointA, pointBWorld = pointB;
      if (bodyA)
        pointAWorld = Vector.add(bodyA.position, pointA);
      if (bodyB)
        pointBWorld = Vector.add(bodyB.position, pointB);
      if (!pointAWorld || !pointBWorld)
        return;
      var delta = Vector.sub(pointAWorld, pointBWorld), currentLength = Vector.magnitude(delta);
      if (currentLength < Constraint._minLength) {
        currentLength = Constraint._minLength;
      }
      var difference = (currentLength - constraint.length) / currentLength, stiffness = constraint.stiffness < 1 ? constraint.stiffness * timeScale : constraint.stiffness, force = Vector.mult(delta, difference * stiffness), massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0), inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0), resistanceTotal = massTotal + inertiaTotal, torque, share, normal, normalVelocity, relativeVelocity;
      if (constraint.damping) {
        var zero = Vector.create();
        normal = Vector.div(delta, currentLength);
        relativeVelocity = Vector.sub(bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero, bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero);
        normalVelocity = Vector.dot(normal, relativeVelocity);
      }
      if (bodyA && !bodyA.isStatic) {
        share = bodyA.inverseMass / massTotal;
        bodyA.constraintImpulse.x -= force.x * share;
        bodyA.constraintImpulse.y -= force.y * share;
        bodyA.position.x -= force.x * share;
        bodyA.position.y -= force.y * share;
        if (constraint.damping) {
          bodyA.positionPrev.x -= constraint.damping * normal.x * normalVelocity * share;
          bodyA.positionPrev.y -= constraint.damping * normal.y * normalVelocity * share;
        }
        torque = Vector.cross(pointA, force) / resistanceTotal * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);
        bodyA.constraintImpulse.angle -= torque;
        bodyA.angle -= torque;
      }
      if (bodyB && !bodyB.isStatic) {
        share = bodyB.inverseMass / massTotal;
        bodyB.constraintImpulse.x += force.x * share;
        bodyB.constraintImpulse.y += force.y * share;
        bodyB.position.x += force.x * share;
        bodyB.position.y += force.y * share;
        if (constraint.damping) {
          bodyB.positionPrev.x += constraint.damping * normal.x * normalVelocity * share;
          bodyB.positionPrev.y += constraint.damping * normal.y * normalVelocity * share;
        }
        torque = Vector.cross(pointB, force) / resistanceTotal * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);
        bodyB.constraintImpulse.angle += torque;
        bodyB.angle += torque;
      }
    };
    Constraint.postSolveAll = function(bodies) {
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i], impulse = body.constraintImpulse;
        if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
          continue;
        }
        Sleeping.set(body, false);
        for (var j = 0; j < body.parts.length; j++) {
          var part = body.parts[j];
          Vertices.translate(part.vertices, impulse);
          if (j > 0) {
            part.position.x += impulse.x;
            part.position.y += impulse.y;
          }
          if (impulse.angle !== 0) {
            Vertices.rotate(part.vertices, impulse.angle, body.position);
            Axes.rotate(part.axes, impulse.angle);
            if (j > 0) {
              Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);
            }
          }
          Bounds.update(part.bounds, part.vertices, body.velocity);
        }
        impulse.angle *= Constraint._warming;
        impulse.x *= Constraint._warming;
        impulse.y *= Constraint._warming;
      }
    };
    Constraint.pointAWorld = function(constraint) {
      return {
        x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + constraint.pointA.x,
        y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + constraint.pointA.y
      };
    };
    Constraint.pointBWorld = function(constraint) {
      return {
        x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + constraint.pointB.x,
        y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + constraint.pointB.y
      };
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/factory/Composites.js
var require_Composites = __commonJS((exports2, module2) => {
  var Composites = {};
  module2.exports = Composites;
  var Composite = require_Composite();
  var Constraint = require_Constraint();
  var Common = require_Common();
  var Body = require_Body2();
  var Bodies = require_Bodies();
  (function() {
    Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
      var stack = Composite.create({label: "Stack"}), x = xx, y = yy, lastBody, i = 0;
      for (var row = 0; row < rows; row++) {
        var maxHeight = 0;
        for (var column = 0; column < columns; column++) {
          var body = callback(x, y, column, row, lastBody, i);
          if (body) {
            var bodyHeight = body.bounds.max.y - body.bounds.min.y, bodyWidth = body.bounds.max.x - body.bounds.min.x;
            if (bodyHeight > maxHeight)
              maxHeight = bodyHeight;
            Body.translate(body, {x: bodyWidth * 0.5, y: bodyHeight * 0.5});
            x = body.bounds.max.x + columnGap;
            Composite.addBody(stack, body);
            lastBody = body;
            i += 1;
          } else {
            x += columnGap;
          }
        }
        y += maxHeight + rowGap;
        x = xx;
      }
      return stack;
    };
    Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
      var bodies = composite.bodies;
      for (var i = 1; i < bodies.length; i++) {
        var bodyA = bodies[i - 1], bodyB = bodies[i], bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y, bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y, bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;
        var defaults = {
          bodyA,
          pointA: {x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA},
          bodyB,
          pointB: {x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB}
        };
        var constraint = Common.extend(defaults, options);
        Composite.addConstraint(composite, Constraint.create(constraint));
      }
      composite.label += " Chain";
      return composite;
    };
    Composites.mesh = function(composite, columns, rows, crossBrace, options) {
      var bodies = composite.bodies, row, col, bodyA, bodyB, bodyC;
      for (row = 0; row < rows; row++) {
        for (col = 1; col < columns; col++) {
          bodyA = bodies[col - 1 + row * columns];
          bodyB = bodies[col + row * columns];
          Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA, bodyB}, options)));
        }
        if (row > 0) {
          for (col = 0; col < columns; col++) {
            bodyA = bodies[col + (row - 1) * columns];
            bodyB = bodies[col + row * columns];
            Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA, bodyB}, options)));
            if (crossBrace && col > 0) {
              bodyC = bodies[col - 1 + (row - 1) * columns];
              Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA: bodyC, bodyB}, options)));
            }
            if (crossBrace && col < columns - 1) {
              bodyC = bodies[col + 1 + (row - 1) * columns];
              Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA: bodyC, bodyB}, options)));
            }
          }
        }
      }
      composite.label += " Mesh";
      return composite;
    };
    Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
      return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {
        var actualRows = Math.min(rows, Math.ceil(columns / 2)), lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;
        if (row > actualRows)
          return;
        row = actualRows - row;
        var start = row, end = columns - 1 - row;
        if (column < start || column > end)
          return;
        if (i === 1) {
          Body.translate(lastBody, {x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0});
        }
        var xOffset = lastBody ? column * lastBodyWidth : 0;
        return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);
      });
    };
    Composites.newtonsCradle = function(xx, yy, number, size, length) {
      var newtonsCradle = Composite.create({label: "Newtons Cradle"});
      for (var i = 0; i < number; i++) {
        var separation = 1.9, circle = Bodies.circle(xx + i * (size * separation), yy + length, size, {inertia: Infinity, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1}), constraint = Constraint.create({pointA: {x: xx + i * (size * separation), y: yy}, bodyB: circle});
        Composite.addBody(newtonsCradle, circle);
        Composite.addConstraint(newtonsCradle, constraint);
      }
      return newtonsCradle;
    };
    Composites.car = function(xx, yy, width, height, wheelSize) {
      var group = Body.nextGroup(true), wheelBase = 20, wheelAOffset = -width * 0.5 + wheelBase, wheelBOffset = width * 0.5 - wheelBase, wheelYOffset = 0;
      var car = Composite.create({label: "Car"}), body = Bodies.rectangle(xx, yy, width, height, {
        collisionFilter: {
          group
        },
        chamfer: {
          radius: height * 0.5
        },
        density: 2e-4
      });
      var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, {
        collisionFilter: {
          group
        },
        friction: 0.8
      });
      var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, {
        collisionFilter: {
          group
        },
        friction: 0.8
      });
      var axelA = Constraint.create({
        bodyB: body,
        pointB: {x: wheelAOffset, y: wheelYOffset},
        bodyA: wheelA,
        stiffness: 1,
        length: 0
      });
      var axelB = Constraint.create({
        bodyB: body,
        pointB: {x: wheelBOffset, y: wheelYOffset},
        bodyA: wheelB,
        stiffness: 1,
        length: 0
      });
      Composite.addBody(car, body);
      Composite.addBody(car, wheelA);
      Composite.addBody(car, wheelB);
      Composite.addConstraint(car, axelA);
      Composite.addConstraint(car, axelB);
      return car;
    };
    Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
      particleOptions = Common.extend({inertia: Infinity}, particleOptions);
      constraintOptions = Common.extend({stiffness: 0.2, render: {type: "line", anchors: false}}, constraintOptions);
      var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {
        return Bodies.circle(x, y, particleRadius, particleOptions);
      });
      Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);
      softBody.label = "Soft Body";
      return softBody;
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/geometry/Svg.js
var require_Svg = __commonJS((exports2, module2) => {
  var Svg = {};
  module2.exports = Svg;
  var Bounds = require_Bounds();
  var Common = require_Common();
  (function() {
    Svg.pathToVertices = function(path, sampleLength) {
      if (typeof window !== "undefined" && !("SVGPathSeg" in window)) {
        Common.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
      }
      var i, il, total, point, segment, segments, segmentsQueue, lastSegment, lastPoint, segmentIndex, points = [], lx, ly, length = 0, x = 0, y = 0;
      sampleLength = sampleLength || 15;
      var addPoint = function(px, py, pathSegType) {
        var isRelative = pathSegType % 2 === 1 && pathSegType > 1;
        if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {
          if (lastPoint && isRelative) {
            lx = lastPoint.x;
            ly = lastPoint.y;
          } else {
            lx = 0;
            ly = 0;
          }
          var point2 = {
            x: lx + px,
            y: ly + py
          };
          if (isRelative || !lastPoint) {
            lastPoint = point2;
          }
          points.push(point2);
          x = lx + px;
          y = ly + py;
        }
      };
      var addSegmentPoint = function(segment2) {
        var segType = segment2.pathSegTypeAsLetter.toUpperCase();
        if (segType === "Z")
          return;
        switch (segType) {
          case "M":
          case "L":
          case "T":
          case "C":
          case "S":
          case "Q":
            x = segment2.x;
            y = segment2.y;
            break;
          case "H":
            x = segment2.x;
            break;
          case "V":
            y = segment2.y;
            break;
        }
        addPoint(x, y, segment2.pathSegType);
      };
      Svg._svgPathToAbsolute(path);
      total = path.getTotalLength();
      segments = [];
      for (i = 0; i < path.pathSegList.numberOfItems; i += 1)
        segments.push(path.pathSegList.getItem(i));
      segmentsQueue = segments.concat();
      while (length < total) {
        segmentIndex = path.getPathSegAtLength(length);
        segment = segments[segmentIndex];
        if (segment != lastSegment) {
          while (segmentsQueue.length && segmentsQueue[0] != segment)
            addSegmentPoint(segmentsQueue.shift());
          lastSegment = segment;
        }
        switch (segment.pathSegTypeAsLetter.toUpperCase()) {
          case "C":
          case "T":
          case "S":
          case "Q":
          case "A":
            point = path.getPointAtLength(length);
            addPoint(point.x, point.y, 0);
            break;
        }
        length += sampleLength;
      }
      for (i = 0, il = segmentsQueue.length; i < il; ++i)
        addSegmentPoint(segmentsQueue[i]);
      return points;
    };
    Svg._svgPathToAbsolute = function(path) {
      var x0, y0, x1, y1, x2, y2, segs = path.pathSegList, x = 0, y = 0, len = segs.numberOfItems;
      for (var i = 0; i < len; ++i) {
        var seg = segs.getItem(i), segType = seg.pathSegTypeAsLetter;
        if (/[MLHVCSQTA]/.test(segType)) {
          if ("x" in seg)
            x = seg.x;
          if ("y" in seg)
            y = seg.y;
        } else {
          if ("x1" in seg)
            x1 = x + seg.x1;
          if ("x2" in seg)
            x2 = x + seg.x2;
          if ("y1" in seg)
            y1 = y + seg.y1;
          if ("y2" in seg)
            y2 = y + seg.y2;
          if ("x" in seg)
            x += seg.x;
          if ("y" in seg)
            y += seg.y;
          switch (segType) {
            case "m":
              segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);
              break;
            case "l":
              segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);
              break;
            case "h":
              segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);
              break;
            case "v":
              segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);
              break;
            case "c":
              segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
              break;
            case "s":
              segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
              break;
            case "q":
              segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
              break;
            case "t":
              segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
              break;
            case "a":
              segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);
              break;
            case "z":
            case "Z":
              x = x0;
              y = y0;
              break;
          }
        }
        if (segType == "M" || segType == "m") {
          x0 = x;
          y0 = y;
        }
      }
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/MatterGameObject.js
var require_MatterGameObject = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Components = require_components3();
  var GetFastValue = require_GetFastValue();
  var Vector2 = require_Vector2();
  function hasGetterOrSetter(def) {
    return !!def.get && typeof def.get === "function" || !!def.set && typeof def.set === "function";
  }
  var MatterGameObject = function(world, gameObject, options, addToWorld) {
    if (options === void 0) {
      options = {};
    }
    if (addToWorld === void 0) {
      addToWorld = true;
    }
    var x = gameObject.x;
    var y = gameObject.y;
    gameObject.body = {
      temp: true,
      position: {
        x,
        y
      }
    };
    var mixins = [
      Components.Bounce,
      Components.Collision,
      Components.Force,
      Components.Friction,
      Components.Gravity,
      Components.Mass,
      Components.Sensor,
      Components.SetBody,
      Components.Sleep,
      Components.Static,
      Components.Transform,
      Components.Velocity
    ];
    mixins.forEach(function(mixin) {
      for (var key in mixin) {
        if (hasGetterOrSetter(mixin[key])) {
          Object.defineProperty(gameObject, key, {
            get: mixin[key].get,
            set: mixin[key].set
          });
        } else {
          Object.defineProperty(gameObject, key, {value: mixin[key]});
        }
      }
    });
    gameObject.world = world;
    gameObject._tempVec2 = new Vector2(x, y);
    if (options.hasOwnProperty("type") && options.type === "body") {
      gameObject.setExistingBody(options, addToWorld);
    } else {
      var shape = GetFastValue(options, "shape", null);
      if (!shape) {
        shape = "rectangle";
      }
      options.addToWorld = addToWorld;
      gameObject.setBody(shape, options);
    }
    return gameObject;
  };
  module2.exports = MatterGameObject;
});

// node_modules/phaser/src/physics/matter-js/MatterImage.js
var require_MatterImage = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components3();
  var GameObject = require_GameObject();
  var GetFastValue = require_GetFastValue();
  var Image2 = require_Image2();
  var Pipeline = require_Pipeline();
  var Vector2 = require_Vector2();
  var MatterImage = new Class({
    Extends: Image2,
    Mixins: [
      Components.Bounce,
      Components.Collision,
      Components.Force,
      Components.Friction,
      Components.Gravity,
      Components.Mass,
      Components.Sensor,
      Components.SetBody,
      Components.Sleep,
      Components.Static,
      Components.Transform,
      Components.Velocity,
      Pipeline
    ],
    initialize: function MatterImage2(world, x, y, texture, frame, options) {
      GameObject.call(this, world.scene, "Image");
      this._crop = this.resetCropObject();
      this.setTexture(texture, frame);
      this.setSizeToFrame();
      this.setOrigin();
      this.world = world;
      this._tempVec2 = new Vector2(x, y);
      var shape = GetFastValue(options, "shape", null);
      if (shape) {
        this.setBody(shape, options);
      } else {
        this.setRectangle(this.width, this.height, options);
      }
      this.setPosition(x, y);
      this.initPipeline();
    }
  });
  module2.exports = MatterImage;
});

// node_modules/phaser/src/physics/matter-js/MatterSprite.js
var require_MatterSprite = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AnimationState = require_AnimationState();
  var Class = require_Class();
  var Components = require_components3();
  var GameObject = require_GameObject();
  var GetFastValue = require_GetFastValue();
  var Pipeline = require_Pipeline();
  var Sprite = require_Sprite();
  var Vector2 = require_Vector2();
  var MatterSprite = new Class({
    Extends: Sprite,
    Mixins: [
      Components.Bounce,
      Components.Collision,
      Components.Force,
      Components.Friction,
      Components.Gravity,
      Components.Mass,
      Components.Sensor,
      Components.SetBody,
      Components.Sleep,
      Components.Static,
      Components.Transform,
      Components.Velocity,
      Pipeline
    ],
    initialize: function MatterSprite2(world, x, y, texture, frame, options) {
      GameObject.call(this, world.scene, "Sprite");
      this._crop = this.resetCropObject();
      this.anims = new AnimationState(this);
      this.setTexture(texture, frame);
      this.setSizeToFrame();
      this.setOrigin();
      this.world = world;
      this._tempVec2 = new Vector2(x, y);
      var shape = GetFastValue(options, "shape", null);
      if (shape) {
        this.setBody(shape, options);
      } else {
        this.setRectangle(this.width, this.height, options);
      }
      this.setPosition(x, y);
      this.initPipeline();
    }
  });
  module2.exports = MatterSprite;
});

// node_modules/phaser/src/physics/matter-js/MatterTileBody.js
var require_MatterTileBody = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Bodies = require_Bodies();
  var Body = require_Body2();
  var Class = require_Class();
  var Components = require_components3();
  var EventEmitter = require_eventemitter3();
  var GetFastValue = require_GetFastValue();
  var HasValue = require_HasValue();
  var Vertices = require_Vertices();
  var MatterTileBody = new Class({
    Extends: EventEmitter,
    Mixins: [
      Components.Bounce,
      Components.Collision,
      Components.Friction,
      Components.Gravity,
      Components.Mass,
      Components.Sensor,
      Components.Sleep,
      Components.Static
    ],
    initialize: function MatterTileBody2(world, tile, options) {
      EventEmitter.call(this);
      this.tile = tile;
      this.world = world;
      if (tile.physics.matterBody) {
        tile.physics.matterBody.destroy();
      }
      tile.physics.matterBody = this;
      var body = GetFastValue(options, "body", null);
      var addToWorld = GetFastValue(options, "addToWorld", true);
      if (!body) {
        var collisionGroup = tile.getCollisionGroup();
        var collisionObjects = GetFastValue(collisionGroup, "objects", []);
        if (collisionObjects.length > 0) {
          this.setFromTileCollision(options);
        } else {
          this.setFromTileRectangle(options);
        }
      } else {
        this.setBody(body, addToWorld);
      }
    },
    setFromTileRectangle: function(options) {
      if (options === void 0) {
        options = {};
      }
      if (!HasValue(options, "isStatic")) {
        options.isStatic = true;
      }
      if (!HasValue(options, "addToWorld")) {
        options.addToWorld = true;
      }
      var bounds = this.tile.getBounds();
      var cx = bounds.x + bounds.width / 2;
      var cy = bounds.y + bounds.height / 2;
      var body = Bodies.rectangle(cx, cy, bounds.width, bounds.height, options);
      this.setBody(body, options.addToWorld);
      return this;
    },
    setFromTileCollision: function(options) {
      if (options === void 0) {
        options = {};
      }
      if (!HasValue(options, "isStatic")) {
        options.isStatic = true;
      }
      if (!HasValue(options, "addToWorld")) {
        options.addToWorld = true;
      }
      var sx = this.tile.tilemapLayer.scaleX;
      var sy = this.tile.tilemapLayer.scaleY;
      var tileX = this.tile.getLeft();
      var tileY = this.tile.getTop();
      var collisionGroup = this.tile.getCollisionGroup();
      var collisionObjects = GetFastValue(collisionGroup, "objects", []);
      var parts = [];
      for (var i = 0; i < collisionObjects.length; i++) {
        var object = collisionObjects[i];
        var ox = tileX + object.x * sx;
        var oy = tileY + object.y * sy;
        var ow = object.width * sx;
        var oh = object.height * sy;
        var body = null;
        if (object.rectangle) {
          body = Bodies.rectangle(ox + ow / 2, oy + oh / 2, ow, oh, options);
        } else if (object.ellipse) {
          body = Bodies.circle(ox + ow / 2, oy + oh / 2, ow / 2, options);
        } else if (object.polygon || object.polyline) {
          var originalPoints = object.polygon ? object.polygon : object.polyline;
          var points = originalPoints.map(function(p) {
            return {x: p.x * sx, y: p.y * sy};
          });
          var vertices = Vertices.create(points);
          var center = Vertices.centre(vertices);
          ox += center.x;
          oy += center.y;
          body = Bodies.fromVertices(ox, oy, vertices, options);
        }
        if (body) {
          parts.push(body);
        }
      }
      if (parts.length === 1) {
        this.setBody(parts[0], options.addToWorld);
      } else if (parts.length > 1) {
        options.parts = parts;
        this.setBody(Body.create(options), options.addToWorld);
      }
      return this;
    },
    setBody: function(body, addToWorld) {
      if (addToWorld === void 0) {
        addToWorld = true;
      }
      if (this.body) {
        this.removeBody();
      }
      this.body = body;
      this.body.gameObject = this;
      if (addToWorld) {
        this.world.add(this.body);
      }
      return this;
    },
    removeBody: function() {
      if (this.body) {
        this.world.remove(this.body);
        this.body.gameObject = void 0;
        this.body = void 0;
      }
      return this;
    },
    destroy: function() {
      this.removeBody();
      this.tile.physics.matterBody = void 0;
      this.removeAllListeners();
    }
  });
  module2.exports = MatterTileBody;
});

// node_modules/phaser/src/physics/matter-js/lib/collision/SAT.js
var require_SAT = __commonJS((exports2, module2) => {
  var SAT = {};
  module2.exports = SAT;
  var Vertices = require_Vertices();
  var Vector = require_Vector();
  (function() {
    SAT.collides = function(bodyA, bodyB, previousCollision) {
      var overlapAB, overlapBA, minOverlap, collision, canReusePrevCol = false;
      if (previousCollision) {
        var parentA = bodyA.parent, parentB = bodyB.parent, motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;
        canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;
        collision = previousCollision;
      } else {
        collision = {collided: false, bodyA, bodyB};
      }
      if (previousCollision && canReusePrevCol) {
        var axisBodyA = collision.axisBody, axisBodyB = axisBodyA === bodyA ? bodyB : bodyA, axes = [axisBodyA.axes[previousCollision.axisNumber]];
        minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);
        collision.reused = true;
        if (minOverlap.overlap <= 0) {
          collision.collided = false;
          return collision;
        }
      } else {
        overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);
        if (overlapAB.overlap <= 0) {
          collision.collided = false;
          return collision;
        }
        overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);
        if (overlapBA.overlap <= 0) {
          collision.collided = false;
          return collision;
        }
        if (overlapAB.overlap < overlapBA.overlap) {
          minOverlap = overlapAB;
          collision.axisBody = bodyA;
        } else {
          minOverlap = overlapBA;
          collision.axisBody = bodyB;
        }
        collision.axisNumber = minOverlap.axisNumber;
      }
      collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;
      collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;
      collision.collided = true;
      collision.depth = minOverlap.overlap;
      collision.parentA = collision.bodyA.parent;
      collision.parentB = collision.bodyB.parent;
      bodyA = collision.bodyA;
      bodyB = collision.bodyB;
      if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {
        collision.normal = {
          x: minOverlap.axis.x,
          y: minOverlap.axis.y
        };
      } else {
        collision.normal = {
          x: -minOverlap.axis.x,
          y: -minOverlap.axis.y
        };
      }
      collision.tangent = Vector.perp(collision.normal);
      collision.penetration = collision.penetration || {};
      collision.penetration.x = collision.normal.x * collision.depth;
      collision.penetration.y = collision.normal.y * collision.depth;
      var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal), supports = [];
      if (Vertices.contains(bodyA.vertices, verticesB[0]))
        supports.push(verticesB[0]);
      if (Vertices.contains(bodyA.vertices, verticesB[1]))
        supports.push(verticesB[1]);
      if (supports.length < 2) {
        var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));
        if (Vertices.contains(bodyB.vertices, verticesA[0]))
          supports.push(verticesA[0]);
        if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))
          supports.push(verticesA[1]);
      }
      if (supports.length < 1)
        supports = [verticesB[0]];
      collision.supports = supports;
      return collision;
    };
    SAT._overlapAxes = function(verticesA, verticesB, axes) {
      var projectionA = Vector._temp[0], projectionB = Vector._temp[1], result = {overlap: Number.MAX_VALUE}, overlap, axis;
      for (var i = 0; i < axes.length; i++) {
        axis = axes[i];
        SAT._projectToAxis(projectionA, verticesA, axis);
        SAT._projectToAxis(projectionB, verticesB, axis);
        overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);
        if (overlap <= 0) {
          result.overlap = overlap;
          return result;
        }
        if (overlap < result.overlap) {
          result.overlap = overlap;
          result.axis = axis;
          result.axisNumber = i;
        }
      }
      return result;
    };
    SAT._projectToAxis = function(projection, vertices, axis) {
      var min = Vector.dot(vertices[0], axis), max = min;
      for (var i = 1; i < vertices.length; i += 1) {
        var dot = Vector.dot(vertices[i], axis);
        if (dot > max) {
          max = dot;
        } else if (dot < min) {
          min = dot;
        }
      }
      projection.min = min;
      projection.max = max;
    };
    SAT._findSupports = function(bodyA, bodyB, normal) {
      var nearestDistance = Number.MAX_VALUE, vertexToBody = Vector._temp[0], vertices = bodyB.vertices, bodyAPosition = bodyA.position, distance, vertex, vertexA, vertexB;
      for (var i = 0; i < vertices.length; i++) {
        vertex = vertices[i];
        vertexToBody.x = vertex.x - bodyAPosition.x;
        vertexToBody.y = vertex.y - bodyAPosition.y;
        distance = -Vector.dot(normal, vertexToBody);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          vertexA = vertex;
        }
      }
      var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;
      vertex = vertices[prevIndex];
      vertexToBody.x = vertex.x - bodyAPosition.x;
      vertexToBody.y = vertex.y - bodyAPosition.y;
      nearestDistance = -Vector.dot(normal, vertexToBody);
      vertexB = vertex;
      var nextIndex = (vertexA.index + 1) % vertices.length;
      vertex = vertices[nextIndex];
      vertexToBody.x = vertex.x - bodyAPosition.x;
      vertexToBody.y = vertex.y - bodyAPosition.y;
      distance = -Vector.dot(normal, vertexToBody);
      if (distance < nearestDistance) {
        vertexB = vertex;
      }
      return [vertexA, vertexB];
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/collision/Pair.js
var require_Pair = __commonJS((exports2, module2) => {
  var Pair = {};
  module2.exports = Pair;
  (function() {
    Pair.create = function(collision, timestamp) {
      var bodyA = collision.bodyA, bodyB = collision.bodyB;
      var pair = {
        id: Pair.id(bodyA, bodyB),
        bodyA,
        bodyB,
        activeContacts: [],
        separation: 0,
        isActive: true,
        confirmedActive: true,
        isSensor: bodyA.isSensor || bodyB.isSensor,
        timeCreated: timestamp,
        timeUpdated: timestamp,
        collision: null,
        inverseMass: 0,
        friction: 0,
        frictionStatic: 0,
        restitution: 0,
        slop: 0
      };
      Pair.update(pair, collision, timestamp);
      return pair;
    };
    Pair.update = function(pair, collision, timestamp) {
      pair.collision = collision;
      if (collision.collided) {
        var supports = collision.supports, activeContacts = pair.activeContacts, parentA = collision.parentA, parentB = collision.parentB;
        pair.inverseMass = parentA.inverseMass + parentB.inverseMass;
        pair.friction = Math.min(parentA.friction, parentB.friction);
        pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);
        pair.restitution = Math.max(parentA.restitution, parentB.restitution);
        pair.slop = Math.max(parentA.slop, parentB.slop);
        for (var i = 0; i < supports.length; i++) {
          activeContacts[i] = supports[i].contact;
        }
        var supportCount = supports.length;
        if (supportCount < activeContacts.length) {
          activeContacts.length = supportCount;
        }
        pair.separation = collision.depth;
        Pair.setActive(pair, true, timestamp);
      } else {
        if (pair.isActive === true)
          Pair.setActive(pair, false, timestamp);
      }
    };
    Pair.setActive = function(pair, isActive, timestamp) {
      if (isActive) {
        pair.isActive = true;
        pair.timeUpdated = timestamp;
      } else {
        pair.isActive = false;
        pair.activeContacts.length = 0;
      }
    };
    Pair.id = function(bodyA, bodyB) {
      if (bodyA.id < bodyB.id) {
        return "A" + bodyA.id + "B" + bodyB.id;
      } else {
        return "A" + bodyB.id + "B" + bodyA.id;
      }
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/collision/Detector.js
var require_Detector = __commonJS((exports2, module2) => {
  var Detector = {};
  module2.exports = Detector;
  var SAT = require_SAT();
  var Pair = require_Pair();
  var Bounds = require_Bounds();
  (function() {
    Detector.collisions = function(broadphasePairs, engine) {
      var collisions = [], pairsTable = engine.pairs.table;
      var metrics = engine.metrics;
      for (var i = 0; i < broadphasePairs.length; i++) {
        var bodyA = broadphasePairs[i][0], bodyB = broadphasePairs[i][1];
        if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))
          continue;
        if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))
          continue;
        metrics.midphaseTests += 1;
        if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {
          for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {
            var partA = bodyA.parts[j];
            for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {
              var partB = bodyB.parts[k];
              if (partA === bodyA && partB === bodyB || Bounds.overlaps(partA.bounds, partB.bounds)) {
                var pairId = Pair.id(partA, partB), pair = pairsTable[pairId], previousCollision;
                if (pair && pair.isActive) {
                  previousCollision = pair.collision;
                } else {
                  previousCollision = null;
                }
                var collision = SAT.collides(partA, partB, previousCollision);
                metrics.narrowphaseTests += 1;
                if (collision.reused)
                  metrics.narrowReuseCount += 1;
                if (collision.collided) {
                  collisions.push(collision);
                  metrics.narrowDetections += 1;
                }
              }
            }
          }
        }
      }
      return collisions;
    };
    Detector.canCollide = function(filterA, filterB) {
      if (filterA.group === filterB.group && filterA.group !== 0)
        return filterA.group > 0;
      return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/PointerConstraint.js
var require_PointerConstraint = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Bounds = require_Bounds();
  var Class = require_Class();
  var Composite = require_Composite();
  var Constraint = require_Constraint();
  var Detector = require_Detector();
  var Events = require_events20();
  var InputEvents = require_events13();
  var Merge = require_Merge();
  var Sleeping = require_Sleeping();
  var Vector2 = require_Vector2();
  var Vertices = require_Vertices();
  var PointerConstraint = new Class({
    initialize: function PointerConstraint2(scene, world, options) {
      if (options === void 0) {
        options = {};
      }
      var defaults = {
        label: "Pointer Constraint",
        pointA: {x: 0, y: 0},
        pointB: {x: 0, y: 0},
        length: 0.01,
        stiffness: 0.1,
        angularStiffness: 1,
        collisionFilter: {
          category: 1,
          mask: 4294967295,
          group: 0
        }
      };
      this.scene = scene;
      this.world = world;
      this.camera = null;
      this.pointer = null;
      this.active = true;
      this.position = new Vector2();
      this.body = null;
      this.part = null;
      this.constraint = Constraint.create(Merge(options, defaults));
      this.world.on(Events.BEFORE_UPDATE, this.update, this);
      scene.sys.input.on(InputEvents.POINTER_DOWN, this.onDown, this);
      scene.sys.input.on(InputEvents.POINTER_UP, this.onUp, this);
    },
    onDown: function(pointer) {
      if (!this.pointer) {
        this.pointer = pointer;
        this.camera = pointer.camera;
      }
    },
    onUp: function(pointer) {
      if (pointer === this.pointer) {
        this.pointer = null;
      }
    },
    getBody: function(pointer) {
      var pos = this.position;
      var constraint = this.constraint;
      this.camera.getWorldPoint(pointer.x, pointer.y, pos);
      var bodies = Composite.allBodies(this.world.localWorld);
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        if (!body.ignorePointer && Bounds.contains(body.bounds, pos) && Detector.canCollide(body.collisionFilter, constraint.collisionFilter)) {
          if (this.hitTestBody(body, pos)) {
            this.world.emit(Events.DRAG_START, body, this.part, this);
            return true;
          }
        }
      }
      return false;
    },
    hitTestBody: function(body, position) {
      var constraint = this.constraint;
      var partsLength = body.parts.length;
      var start = partsLength > 1 ? 1 : 0;
      for (var i = start; i < partsLength; i++) {
        var part = body.parts[i];
        if (Vertices.contains(part.vertices, position)) {
          constraint.pointA = position;
          constraint.pointB = {x: position.x - body.position.x, y: position.y - body.position.y};
          constraint.bodyB = body;
          constraint.angleB = body.angle;
          Sleeping.set(body, false);
          this.part = part;
          this.body = body;
          return true;
        }
      }
      return false;
    },
    update: function() {
      var pointer = this.pointer;
      var body = this.body;
      if (!this.active || !pointer) {
        if (body) {
          this.stopDrag();
        }
        return;
      }
      if (!pointer.isDown && body) {
        this.stopDrag();
        return;
      } else if (pointer.isDown) {
        if (!body && !this.getBody(pointer)) {
          return;
        }
        body = this.body;
        var pos = this.position;
        var constraint = this.constraint;
        this.camera.getWorldPoint(pointer.x, pointer.y, pos);
        constraint.pointA.x = pos.x;
        constraint.pointA.y = pos.y;
        Sleeping.set(body, false);
        this.world.emit(Events.DRAG, body, this);
      }
    },
    stopDrag: function() {
      var body = this.body;
      var constraint = this.constraint;
      constraint.bodyB = null;
      constraint.pointB = null;
      this.pointer = null;
      this.body = null;
      this.part = null;
      if (body) {
        this.world.emit(Events.DRAG_END, body, this);
      }
    },
    destroy: function() {
      this.world.removeConstraint(this.constraint);
      this.pointer = null;
      this.constraint = null;
      this.body = null;
      this.part = null;
      this.world.off(Events.BEFORE_UPDATE, this.update);
      this.scene.sys.input.off(InputEvents.POINTER_DOWN, this.onDown, this);
      this.scene.sys.input.off(InputEvents.POINTER_UP, this.onUp, this);
    }
  });
  module2.exports = PointerConstraint;
});

// node_modules/phaser/src/physics/matter-js/Factory.js
var require_Factory2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Bodies = require_Bodies();
  var Class = require_Class();
  var Composites = require_Composites();
  var Constraint = require_Constraint();
  var Svg = require_Svg();
  var MatterGameObject = require_MatterGameObject();
  var MatterImage = require_MatterImage();
  var MatterSprite = require_MatterSprite();
  var MatterTileBody = require_MatterTileBody();
  var PhysicsEditorParser = require_PhysicsEditorParser();
  var PhysicsJSONParser = require_PhysicsJSONParser();
  var PointerConstraint = require_PointerConstraint();
  var Vertices = require_Vertices();
  var Factory = new Class({
    initialize: function Factory2(world) {
      this.world = world;
      this.scene = world.scene;
      this.sys = world.scene.sys;
    },
    rectangle: function(x, y, width, height, options) {
      var body = Bodies.rectangle(x, y, width, height, options);
      this.world.add(body);
      return body;
    },
    trapezoid: function(x, y, width, height, slope, options) {
      var body = Bodies.trapezoid(x, y, width, height, slope, options);
      this.world.add(body);
      return body;
    },
    circle: function(x, y, radius, options, maxSides) {
      var body = Bodies.circle(x, y, radius, options, maxSides);
      this.world.add(body);
      return body;
    },
    polygon: function(x, y, sides, radius, options) {
      var body = Bodies.polygon(x, y, sides, radius, options);
      this.world.add(body);
      return body;
    },
    fromVertices: function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
      if (typeof vertexSets === "string") {
        vertexSets = Vertices.fromPath(vertexSets);
      }
      var body = Bodies.fromVertices(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea);
      this.world.add(body);
      return body;
    },
    fromPhysicsEditor: function(x, y, config2, options, addToWorld) {
      if (addToWorld === void 0) {
        addToWorld = true;
      }
      var body = PhysicsEditorParser.parseBody(x, y, config2, options);
      if (addToWorld && !this.world.has(body)) {
        this.world.add(body);
      }
      return body;
    },
    fromSVG: function(x, y, xml, scale, options, addToWorld) {
      if (scale === void 0) {
        scale = 1;
      }
      if (options === void 0) {
        options = {};
      }
      if (addToWorld === void 0) {
        addToWorld = true;
      }
      var path = xml.getElementsByTagName("path");
      var vertexSets = [];
      for (var i = 0; i < path.length; i++) {
        var points = Svg.pathToVertices(path[i], 30);
        if (scale !== 1) {
          Vertices.scale(points, scale, scale);
        }
        vertexSets.push(points);
      }
      var body = Bodies.fromVertices(x, y, vertexSets, options);
      if (addToWorld) {
        this.world.add(body);
      }
      return body;
    },
    fromJSON: function(x, y, config2, options, addToWorld) {
      if (options === void 0) {
        options = {};
      }
      if (addToWorld === void 0) {
        addToWorld = true;
      }
      var body = PhysicsJSONParser.parseBody(x, y, config2, options);
      if (body && addToWorld) {
        this.world.add(body);
      }
      return body;
    },
    imageStack: function(key, frame, x, y, columns, rows, columnGap, rowGap, options) {
      if (columnGap === void 0) {
        columnGap = 0;
      }
      if (rowGap === void 0) {
        rowGap = 0;
      }
      if (options === void 0) {
        options = {};
      }
      var world = this.world;
      var displayList = this.sys.displayList;
      options.addToWorld = false;
      var stack = Composites.stack(x, y, columns, rows, columnGap, rowGap, function(x2, y2) {
        var image = new MatterImage(world, x2, y2, key, frame, options);
        displayList.add(image);
        return image.body;
      });
      world.add(stack);
      return stack;
    },
    stack: function(x, y, columns, rows, columnGap, rowGap, callback) {
      var stack = Composites.stack(x, y, columns, rows, columnGap, rowGap, callback);
      this.world.add(stack);
      return stack;
    },
    pyramid: function(x, y, columns, rows, columnGap, rowGap, callback) {
      var stack = Composites.pyramid(x, y, columns, rows, columnGap, rowGap, callback);
      this.world.add(stack);
      return stack;
    },
    chain: function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
      return Composites.chain(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options);
    },
    mesh: function(composite, columns, rows, crossBrace, options) {
      return Composites.mesh(composite, columns, rows, crossBrace, options);
    },
    newtonsCradle: function(x, y, number, size, length) {
      var composite = Composites.newtonsCradle(x, y, number, size, length);
      this.world.add(composite);
      return composite;
    },
    car: function(x, y, width, height, wheelSize) {
      var composite = Composites.car(x, y, width, height, wheelSize);
      this.world.add(composite);
      return composite;
    },
    softBody: function(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
      var composite = Composites.softBody(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions);
      this.world.add(composite);
      return composite;
    },
    joint: function(bodyA, bodyB, length, stiffness, options) {
      return this.constraint(bodyA, bodyB, length, stiffness, options);
    },
    spring: function(bodyA, bodyB, length, stiffness, options) {
      return this.constraint(bodyA, bodyB, length, stiffness, options);
    },
    constraint: function(bodyA, bodyB, length, stiffness, options) {
      if (stiffness === void 0) {
        stiffness = 1;
      }
      if (options === void 0) {
        options = {};
      }
      options.bodyA = bodyA.type === "body" ? bodyA : bodyA.body;
      options.bodyB = bodyB.type === "body" ? bodyB : bodyB.body;
      if (!isNaN(length)) {
        options.length = length;
      }
      options.stiffness = stiffness;
      var constraint = Constraint.create(options);
      this.world.add(constraint);
      return constraint;
    },
    worldConstraint: function(body, length, stiffness, options) {
      if (stiffness === void 0) {
        stiffness = 1;
      }
      if (options === void 0) {
        options = {};
      }
      options.bodyB = body.type === "body" ? body : body.body;
      if (!isNaN(length)) {
        options.length = length;
      }
      options.stiffness = stiffness;
      var constraint = Constraint.create(options);
      this.world.add(constraint);
      return constraint;
    },
    mouseSpring: function(options) {
      return this.pointerConstraint(options);
    },
    pointerConstraint: function(options) {
      if (options === void 0) {
        options = {};
      }
      if (!options.hasOwnProperty("render")) {
        options.render = {visible: false};
      }
      var pointerConstraint = new PointerConstraint(this.scene, this.world, options);
      this.world.add(pointerConstraint.constraint);
      return pointerConstraint;
    },
    image: function(x, y, key, frame, options) {
      var image = new MatterImage(this.world, x, y, key, frame, options);
      this.sys.displayList.add(image);
      return image;
    },
    tileBody: function(tile, options) {
      return new MatterTileBody(this.world, tile, options);
    },
    sprite: function(x, y, key, frame, options) {
      var sprite = new MatterSprite(this.world, x, y, key, frame, options);
      this.sys.displayList.add(sprite);
      this.sys.updateList.add(sprite);
      return sprite;
    },
    gameObject: function(gameObject, options, addToWorld) {
      return MatterGameObject(this.world, gameObject, options, addToWorld);
    },
    destroy: function() {
      this.world = null;
      this.scene = null;
      this.sys = null;
    }
  });
  module2.exports = Factory;
});

// node_modules/phaser/src/physics/matter-js/lib/core/Plugin.js
var require_Plugin = __commonJS((exports2, module2) => {
  var Plugin = {};
  module2.exports = Plugin;
  var Common = require_Common();
  (function() {
    Plugin._registry = {};
    Plugin.register = function(plugin) {
      if (!Plugin.isPlugin(plugin)) {
        Common.warn("Plugin.register:", Plugin.toString(plugin), "does not implement all required fields.");
      }
      if (plugin.name in Plugin._registry) {
        var registered = Plugin._registry[plugin.name], pluginVersion = Plugin.versionParse(plugin.version).number, registeredVersion = Plugin.versionParse(registered.version).number;
        if (pluginVersion > registeredVersion) {
          Common.warn("Plugin.register:", Plugin.toString(registered), "was upgraded to", Plugin.toString(plugin));
          Plugin._registry[plugin.name] = plugin;
        } else if (pluginVersion < registeredVersion) {
          Common.warn("Plugin.register:", Plugin.toString(registered), "can not be downgraded to", Plugin.toString(plugin));
        } else if (plugin !== registered) {
          Common.warn("Plugin.register:", Plugin.toString(plugin), "is already registered to different plugin object");
        }
      } else {
        Plugin._registry[plugin.name] = plugin;
      }
      return plugin;
    };
    Plugin.resolve = function(dependency) {
      return Plugin._registry[Plugin.dependencyParse(dependency).name];
    };
    Plugin.toString = function(plugin) {
      return typeof plugin === "string" ? plugin : (plugin.name || "anonymous") + "@" + (plugin.version || plugin.range || "0.0.0");
    };
    Plugin.isPlugin = function(obj) {
      return obj && obj.name && obj.version && obj.install;
    };
    Plugin.isUsed = function(module3, name) {
      return module3.used.indexOf(name) > -1;
    };
    Plugin.isFor = function(plugin, module3) {
      var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
      return !plugin.for || module3.name === parsed.name && Plugin.versionSatisfies(module3.version, parsed.range);
    };
    Plugin.use = function(module3, plugins) {
      module3.uses = (module3.uses || []).concat(plugins || []);
      if (module3.uses.length === 0) {
        Common.warn("Plugin.use:", Plugin.toString(module3), "does not specify any dependencies to install.");
        return;
      }
      var dependencies = Plugin.dependencies(module3), sortedDependencies = Common.topologicalSort(dependencies), status = [];
      for (var i = 0; i < sortedDependencies.length; i += 1) {
        if (sortedDependencies[i] === module3.name) {
          continue;
        }
        var plugin = Plugin.resolve(sortedDependencies[i]);
        if (!plugin) {
          status.push("\u274C " + sortedDependencies[i]);
          continue;
        }
        if (Plugin.isUsed(module3, plugin.name)) {
          continue;
        }
        if (!Plugin.isFor(plugin, module3)) {
          Common.warn("Plugin.use:", Plugin.toString(plugin), "is for", plugin.for, "but installed on", Plugin.toString(module3) + ".");
          plugin._warned = true;
        }
        if (plugin.install) {
          plugin.install(module3);
        } else {
          Common.warn("Plugin.use:", Plugin.toString(plugin), "does not specify an install function.");
          plugin._warned = true;
        }
        if (plugin._warned) {
          status.push("\u{1F536} " + Plugin.toString(plugin));
          delete plugin._warned;
        } else {
          status.push("\u2705 " + Plugin.toString(plugin));
        }
        module3.used.push(plugin.name);
      }
      if (status.length > 0 && !plugin.silent) {
        Common.info(status.join("  "));
      }
    };
    Plugin.dependencies = function(module3, tracked) {
      var parsedBase = Plugin.dependencyParse(module3), name = parsedBase.name;
      tracked = tracked || {};
      if (name in tracked) {
        return;
      }
      module3 = Plugin.resolve(module3) || module3;
      tracked[name] = Common.map(module3.uses || [], function(dependency) {
        if (Plugin.isPlugin(dependency)) {
          Plugin.register(dependency);
        }
        var parsed = Plugin.dependencyParse(dependency), resolved = Plugin.resolve(dependency);
        if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {
          Common.warn("Plugin.dependencies:", Plugin.toString(resolved), "does not satisfy", Plugin.toString(parsed), "used by", Plugin.toString(parsedBase) + ".");
          resolved._warned = true;
          module3._warned = true;
        } else if (!resolved) {
          Common.warn("Plugin.dependencies:", Plugin.toString(dependency), "used by", Plugin.toString(parsedBase), "could not be resolved.");
          module3._warned = true;
        }
        return parsed.name;
      });
      for (var i = 0; i < tracked[name].length; i += 1) {
        Plugin.dependencies(tracked[name][i], tracked);
      }
      return tracked;
    };
    Plugin.dependencyParse = function(dependency) {
      if (Common.isString(dependency)) {
        var pattern = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/;
        if (!pattern.test(dependency)) {
          Common.warn("Plugin.dependencyParse:", dependency, "is not a valid dependency string.");
        }
        return {
          name: dependency.split("@")[0],
          range: dependency.split("@")[1] || "*"
        };
      }
      return {
        name: dependency.name,
        range: dependency.range || dependency.version
      };
    };
    Plugin.versionParse = function(range) {
      var pattern = /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/;
      if (!pattern.test(range)) {
        Common.warn("Plugin.versionParse:", range, "is not a valid version or range.");
      }
      var identifiers = range.split("-");
      range = identifiers[0];
      var isRange = isNaN(Number(range[0])), version = isRange ? range.substr(1) : range, parts = Common.map(version.split("."), function(part) {
        return Number(part);
      });
      return {
        isRange,
        version,
        range,
        operator: isRange ? range[0] : "",
        parts,
        prerelease: identifiers[1],
        number: parts[0] * 1e8 + parts[1] * 1e4 + parts[2]
      };
    };
    Plugin.versionSatisfies = function(version, range) {
      range = range || "*";
      var rangeParsed = Plugin.versionParse(range), rangeParts = rangeParsed.parts, versionParsed = Plugin.versionParse(version), versionParts = versionParsed.parts;
      if (rangeParsed.isRange) {
        if (rangeParsed.operator === "*" || version === "*") {
          return true;
        }
        if (rangeParsed.operator === "~") {
          return versionParts[0] === rangeParts[0] && versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
        }
        if (rangeParsed.operator === "^") {
          if (rangeParts[0] > 0) {
            return versionParts[0] === rangeParts[0] && versionParsed.number >= rangeParsed.number;
          }
          if (rangeParts[1] > 0) {
            return versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
          }
          return versionParts[2] === rangeParts[2];
        }
      }
      return version === range || version === "*";
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/core/Matter.js
var require_Matter = __commonJS((exports2, module2) => {
  var Matter = {};
  module2.exports = Matter;
  var Plugin = require_Plugin();
  var Common = require_Common();
  (function() {
    Matter.name = "matter-js";
    Matter.version = "0.14.2";
    Matter.uses = [];
    Matter.used = [];
    Matter.use = function() {
      Plugin.use(Matter, Array.prototype.slice.call(arguments));
    };
    Matter.before = function(path, func) {
      path = path.replace(/^Matter./, "");
      return Common.chainPathBefore(Matter, path, func);
    };
    Matter.after = function(path, func) {
      path = path.replace(/^Matter./, "");
      return Common.chainPathAfter(Matter, path, func);
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/body/World.js
var require_World2 = __commonJS((exports2, module2) => {
  var World = {};
  module2.exports = World;
  var Composite = require_Composite();
  var Constraint = require_Constraint();
  var Common = require_Common();
  (function() {
    World.create = function(options) {
      var composite = Composite.create();
      var defaults = {
        label: "World",
        gravity: {
          x: 0,
          y: 1,
          scale: 1e-3
        },
        bounds: {
          min: {x: -Infinity, y: -Infinity},
          max: {x: Infinity, y: Infinity}
        }
      };
      return Common.extend(composite, defaults, options);
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/collision/Grid.js
var require_Grid2 = __commonJS((exports2, module2) => {
  var Grid = {};
  module2.exports = Grid;
  var Pair = require_Pair();
  var Detector = require_Detector();
  var Common = require_Common();
  (function() {
    Grid.create = function(options) {
      var defaults = {
        controller: Grid,
        detector: Detector.collisions,
        buckets: {},
        pairs: {},
        pairsList: [],
        bucketWidth: 48,
        bucketHeight: 48
      };
      return Common.extend(defaults, options);
    };
    Grid.update = function(grid, bodies, engine, forceUpdate) {
      var i, col, row, world = engine.world, buckets = grid.buckets, bucket, bucketId, gridChanged = false;
      var metrics = engine.metrics;
      metrics.broadphaseTests = 0;
      for (i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        if (body.isSleeping && !forceUpdate)
          continue;
        if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)
          continue;
        var newRegion = Grid._getRegion(grid, body);
        if (!body.region || newRegion.id !== body.region.id || forceUpdate) {
          metrics.broadphaseTests += 1;
          if (!body.region || forceUpdate)
            body.region = newRegion;
          var union = Grid._regionUnion(newRegion, body.region);
          for (col = union.startCol; col <= union.endCol; col++) {
            for (row = union.startRow; row <= union.endRow; row++) {
              bucketId = Grid._getBucketId(col, row);
              bucket = buckets[bucketId];
              var isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow;
              var isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow;
              if (!isInsideNewRegion && isInsideOldRegion) {
                if (isInsideOldRegion) {
                  if (bucket)
                    Grid._bucketRemoveBody(grid, bucket, body);
                }
              }
              if (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) {
                if (!bucket)
                  bucket = Grid._createBucket(buckets, bucketId);
                Grid._bucketAddBody(grid, bucket, body);
              }
            }
          }
          body.region = newRegion;
          gridChanged = true;
        }
      }
      if (gridChanged)
        grid.pairsList = Grid._createActivePairsList(grid);
    };
    Grid.clear = function(grid) {
      grid.buckets = {};
      grid.pairs = {};
      grid.pairsList = [];
    };
    Grid._regionUnion = function(regionA, regionB) {
      var startCol = Math.min(regionA.startCol, regionB.startCol), endCol = Math.max(regionA.endCol, regionB.endCol), startRow = Math.min(regionA.startRow, regionB.startRow), endRow = Math.max(regionA.endRow, regionB.endRow);
      return Grid._createRegion(startCol, endCol, startRow, endRow);
    };
    Grid._getRegion = function(grid, body) {
      var bounds = body.bounds, startCol = Math.floor(bounds.min.x / grid.bucketWidth), endCol = Math.floor(bounds.max.x / grid.bucketWidth), startRow = Math.floor(bounds.min.y / grid.bucketHeight), endRow = Math.floor(bounds.max.y / grid.bucketHeight);
      return Grid._createRegion(startCol, endCol, startRow, endRow);
    };
    Grid._createRegion = function(startCol, endCol, startRow, endRow) {
      return {
        id: startCol + "," + endCol + "," + startRow + "," + endRow,
        startCol,
        endCol,
        startRow,
        endRow
      };
    };
    Grid._getBucketId = function(column, row) {
      return "C" + column + "R" + row;
    };
    Grid._createBucket = function(buckets, bucketId) {
      var bucket = buckets[bucketId] = [];
      return bucket;
    };
    Grid._bucketAddBody = function(grid, bucket, body) {
      for (var i = 0; i < bucket.length; i++) {
        var bodyB = bucket[i];
        if (body.id === bodyB.id || body.isStatic && bodyB.isStatic)
          continue;
        var pairId = Pair.id(body, bodyB), pair = grid.pairs[pairId];
        if (pair) {
          pair[2] += 1;
        } else {
          grid.pairs[pairId] = [body, bodyB, 1];
        }
      }
      bucket.push(body);
    };
    Grid._bucketRemoveBody = function(grid, bucket, body) {
      bucket.splice(bucket.indexOf(body), 1);
      for (var i = 0; i < bucket.length; i++) {
        var bodyB = bucket[i], pairId = Pair.id(body, bodyB), pair = grid.pairs[pairId];
        if (pair)
          pair[2] -= 1;
      }
    };
    Grid._createActivePairsList = function(grid) {
      var pairKeys, pair, pairs = [];
      pairKeys = Common.keys(grid.pairs);
      for (var k = 0; k < pairKeys.length; k++) {
        pair = grid.pairs[pairKeys[k]];
        if (pair[2] > 0) {
          pairs.push(pair);
        } else {
          delete grid.pairs[pairKeys[k]];
        }
      }
      return pairs;
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/collision/Pairs.js
var require_Pairs = __commonJS((exports2, module2) => {
  var Pairs = {};
  module2.exports = Pairs;
  var Pair = require_Pair();
  var Common = require_Common();
  (function() {
    Pairs._pairMaxIdleLife = 1e3;
    Pairs.create = function(options) {
      return Common.extend({
        table: {},
        list: [],
        collisionStart: [],
        collisionActive: [],
        collisionEnd: []
      }, options);
    };
    Pairs.update = function(pairs, collisions, timestamp) {
      var pairsList = pairs.list, pairsTable = pairs.table, collisionStart = pairs.collisionStart, collisionEnd = pairs.collisionEnd, collisionActive = pairs.collisionActive, collision, pairId, pair, i;
      collisionStart.length = 0;
      collisionEnd.length = 0;
      collisionActive.length = 0;
      for (i = 0; i < pairsList.length; i++) {
        pairsList[i].confirmedActive = false;
      }
      for (i = 0; i < collisions.length; i++) {
        collision = collisions[i];
        if (collision.collided) {
          pairId = Pair.id(collision.bodyA, collision.bodyB);
          pair = pairsTable[pairId];
          if (pair) {
            if (pair.isActive) {
              collisionActive.push(pair);
            } else {
              collisionStart.push(pair);
            }
            Pair.update(pair, collision, timestamp);
            pair.confirmedActive = true;
          } else {
            pair = Pair.create(collision, timestamp);
            pairsTable[pairId] = pair;
            collisionStart.push(pair);
            pairsList.push(pair);
          }
        }
      }
      for (i = 0; i < pairsList.length; i++) {
        pair = pairsList[i];
        if (pair.isActive && !pair.confirmedActive) {
          Pair.setActive(pair, false, timestamp);
          collisionEnd.push(pair);
        }
      }
    };
    Pairs.removeOld = function(pairs, timestamp) {
      var pairsList = pairs.list, pairsTable = pairs.table, indexesToRemove = [], pair, collision, pairIndex, i;
      for (i = 0; i < pairsList.length; i++) {
        pair = pairsList[i];
        collision = pair.collision;
        if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {
          pair.timeUpdated = timestamp;
          continue;
        }
        if (timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife) {
          indexesToRemove.push(i);
        }
      }
      for (i = 0; i < indexesToRemove.length; i++) {
        pairIndex = indexesToRemove[i] - i;
        pair = pairsList[pairIndex];
        delete pairsTable[pair.id];
        pairsList.splice(pairIndex, 1);
      }
    };
    Pairs.clear = function(pairs) {
      pairs.table = {};
      pairs.list.length = 0;
      pairs.collisionStart.length = 0;
      pairs.collisionActive.length = 0;
      pairs.collisionEnd.length = 0;
      return pairs;
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/collision/Query.js
var require_Query = __commonJS((exports2, module2) => {
  var Query = {};
  module2.exports = Query;
  var Vector = require_Vector();
  var SAT = require_SAT();
  var Bounds = require_Bounds();
  var Bodies = require_Bodies();
  var Vertices = require_Vertices();
  (function() {
    Query.collides = function(body, bodies) {
      var collisions = [];
      for (var i = 0; i < bodies.length; i++) {
        var bodyA = bodies[i];
        if (body === bodyA) {
          continue;
        }
        if (Bounds.overlaps(bodyA.bounds, body.bounds)) {
          for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {
            var part = bodyA.parts[j];
            if (Bounds.overlaps(part.bounds, body.bounds)) {
              var collision = SAT.collides(part, body);
              if (collision.collided) {
                collisions.push(collision);
                break;
              }
            }
          }
        }
      }
      return collisions;
    };
    Query.ray = function(bodies, startPoint, endPoint, rayWidth) {
      rayWidth = rayWidth || 1e-100;
      var rayAngle = Vector.angle(startPoint, endPoint), rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)), rayX = (endPoint.x + startPoint.x) * 0.5, rayY = (endPoint.y + startPoint.y) * 0.5, ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, {angle: rayAngle}), collisions = Query.collides(ray, bodies);
      for (var i = 0; i < collisions.length; i += 1) {
        var collision = collisions[i];
        collision.body = collision.bodyB = collision.bodyA;
      }
      return collisions;
    };
    Query.region = function(bodies, bounds, outside) {
      var result = [];
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i], overlaps = Bounds.overlaps(body.bounds, bounds);
        if (overlaps && !outside || !overlaps && outside)
          result.push(body);
      }
      return result;
    };
    Query.point = function(bodies, point) {
      var result = [];
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        if (Bounds.contains(body.bounds, point)) {
          for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {
            var part = body.parts[j];
            if (Bounds.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {
              result.push(body);
              break;
            }
          }
        }
      }
      return result;
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/collision/Resolver.js
var require_Resolver = __commonJS((exports2, module2) => {
  var Resolver = {};
  module2.exports = Resolver;
  var Vertices = require_Vertices();
  var Vector = require_Vector();
  var Common = require_Common();
  var Bounds = require_Bounds();
  (function() {
    Resolver._restingThresh = 4;
    Resolver._restingThreshTangent = 6;
    Resolver._positionDampen = 0.9;
    Resolver._positionWarming = 0.8;
    Resolver._frictionNormalMultiplier = 5;
    Resolver.preSolvePosition = function(pairs) {
      var i, pair, activeCount;
      for (i = 0; i < pairs.length; i++) {
        pair = pairs[i];
        if (!pair.isActive)
          continue;
        activeCount = pair.activeContacts.length;
        pair.collision.parentA.totalContacts += activeCount;
        pair.collision.parentB.totalContacts += activeCount;
      }
    };
    Resolver.solvePosition = function(pairs, bodies, timeScale) {
      var i, normalX, normalY, pair, collision, bodyA, bodyB, normal, separation, penetration, positionImpulseA, positionImpulseB, contactShare, bodyBtoAX, bodyBtoAY, positionImpulse, impulseCoefficient = timeScale * Resolver._positionDampen;
      for (i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        body.previousPositionImpulse.x = body.positionImpulse.x;
        body.previousPositionImpulse.y = body.positionImpulse.y;
      }
      for (i = 0; i < pairs.length; i++) {
        pair = pairs[i];
        if (!pair.isActive || pair.isSensor)
          continue;
        collision = pair.collision;
        bodyA = collision.parentA;
        bodyB = collision.parentB;
        normal = collision.normal;
        positionImpulseA = bodyA.previousPositionImpulse;
        positionImpulseB = bodyB.previousPositionImpulse;
        penetration = collision.penetration;
        bodyBtoAX = positionImpulseB.x - positionImpulseA.x + penetration.x;
        bodyBtoAY = positionImpulseB.y - positionImpulseA.y + penetration.y;
        normalX = normal.x;
        normalY = normal.y;
        separation = normalX * bodyBtoAX + normalY * bodyBtoAY;
        pair.separation = separation;
        positionImpulse = (separation - pair.slop) * impulseCoefficient;
        if (bodyA.isStatic || bodyB.isStatic)
          positionImpulse *= 2;
        if (!(bodyA.isStatic || bodyA.isSleeping)) {
          contactShare = positionImpulse / bodyA.totalContacts;
          bodyA.positionImpulse.x += normalX * contactShare;
          bodyA.positionImpulse.y += normalY * contactShare;
        }
        if (!(bodyB.isStatic || bodyB.isSleeping)) {
          contactShare = positionImpulse / bodyB.totalContacts;
          bodyB.positionImpulse.x -= normalX * contactShare;
          bodyB.positionImpulse.y -= normalY * contactShare;
        }
      }
    };
    Resolver.postSolvePosition = function(bodies) {
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        body.totalContacts = 0;
        if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {
          for (var j = 0; j < body.parts.length; j++) {
            var part = body.parts[j];
            Vertices.translate(part.vertices, body.positionImpulse);
            Bounds.update(part.bounds, part.vertices, body.velocity);
            part.position.x += body.positionImpulse.x;
            part.position.y += body.positionImpulse.y;
          }
          body.positionPrev.x += body.positionImpulse.x;
          body.positionPrev.y += body.positionImpulse.y;
          if (Vector.dot(body.positionImpulse, body.velocity) < 0) {
            body.positionImpulse.x = 0;
            body.positionImpulse.y = 0;
          } else {
            body.positionImpulse.x *= Resolver._positionWarming;
            body.positionImpulse.y *= Resolver._positionWarming;
          }
        }
      }
    };
    Resolver.preSolveVelocity = function(pairs) {
      var i, j, pair, contacts, collision, bodyA, bodyB, normal, tangent, contact, contactVertex, normalImpulse, tangentImpulse, offset, impulse = Vector._temp[0], tempA = Vector._temp[1];
      for (i = 0; i < pairs.length; i++) {
        pair = pairs[i];
        if (!pair.isActive || pair.isSensor)
          continue;
        contacts = pair.activeContacts;
        collision = pair.collision;
        bodyA = collision.parentA;
        bodyB = collision.parentB;
        normal = collision.normal;
        tangent = collision.tangent;
        for (j = 0; j < contacts.length; j++) {
          contact = contacts[j];
          contactVertex = contact.vertex;
          normalImpulse = contact.normalImpulse;
          tangentImpulse = contact.tangentImpulse;
          if (normalImpulse !== 0 || tangentImpulse !== 0) {
            impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;
            impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse;
            if (!(bodyA.isStatic || bodyA.isSleeping)) {
              offset = Vector.sub(contactVertex, bodyA.position, tempA);
              bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
              bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
              bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;
            }
            if (!(bodyB.isStatic || bodyB.isSleeping)) {
              offset = Vector.sub(contactVertex, bodyB.position, tempA);
              bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
              bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
              bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;
            }
          }
        }
      }
    };
    Resolver.solveVelocity = function(pairs, timeScale) {
      var timeScaleSquared = timeScale * timeScale, impulse = Vector._temp[0], tempA = Vector._temp[1], tempB = Vector._temp[2], tempC = Vector._temp[3], tempD = Vector._temp[4], tempE = Vector._temp[5];
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        if (!pair.isActive || pair.isSensor)
          continue;
        var collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, normal = collision.normal, tangent = collision.tangent, contacts = pair.activeContacts, contactShare = 1 / contacts.length;
        bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
        bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
        bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
        bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
        bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
        bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;
        for (var j = 0; j < contacts.length; j++) {
          var contact = contacts[j], contactVertex = contact.vertex, offsetA = Vector.sub(contactVertex, bodyA.position, tempA), offsetB = Vector.sub(contactVertex, bodyB.position, tempB), velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC), velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE), normalVelocity = Vector.dot(normal, relativeVelocity);
          var tangentVelocity = Vector.dot(tangent, relativeVelocity), tangentSpeed = Math.abs(tangentVelocity), tangentVelocityDirection = Common.sign(tangentVelocity);
          var normalImpulse = (1 + pair.restitution) * normalVelocity, normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;
          var tangentImpulse = tangentVelocity, maxFriction = Infinity;
          if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {
            maxFriction = tangentSpeed;
            tangentImpulse = Common.clamp(pair.friction * tangentVelocityDirection * timeScaleSquared, -maxFriction, maxFriction);
          }
          var oAcN = Vector.cross(offsetA, normal), oBcN = Vector.cross(offsetB, normal), share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);
          normalImpulse *= share;
          tangentImpulse *= share;
          if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {
            contact.normalImpulse = 0;
          } else {
            var contactNormalImpulse = contact.normalImpulse;
            contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);
            normalImpulse = contact.normalImpulse - contactNormalImpulse;
          }
          if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {
            contact.tangentImpulse = 0;
          } else {
            var contactTangentImpulse = contact.tangentImpulse;
            contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);
            tangentImpulse = contact.tangentImpulse - contactTangentImpulse;
          }
          impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;
          impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse;
          if (!(bodyA.isStatic || bodyA.isSleeping)) {
            bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
            bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
            bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;
          }
          if (!(bodyB.isStatic || bodyB.isSleeping)) {
            bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
            bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
            bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;
          }
        }
      }
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/core/Metrics.js
var require_Metrics = __commonJS((exports2, module2) => {
  var Metrics = {};
  module2.exports = Metrics;
  var Composite = require_Composite();
  var Common = require_Common();
  (function() {
    Metrics.create = function(options) {
      var defaults = {
        extended: false,
        narrowDetections: 0,
        narrowphaseTests: 0,
        narrowReuse: 0,
        narrowReuseCount: 0,
        midphaseTests: 0,
        broadphaseTests: 0,
        narrowEff: 1e-4,
        midEff: 1e-4,
        broadEff: 1e-4,
        collisions: 0,
        buckets: 0,
        bodies: 0,
        pairs: 0
      };
      return Common.extend(defaults, false, options);
    };
    Metrics.reset = function(metrics) {
      if (metrics.extended) {
        metrics.narrowDetections = 0;
        metrics.narrowphaseTests = 0;
        metrics.narrowReuse = 0;
        metrics.narrowReuseCount = 0;
        metrics.midphaseTests = 0;
        metrics.broadphaseTests = 0;
        metrics.narrowEff = 0;
        metrics.midEff = 0;
        metrics.broadEff = 0;
        metrics.collisions = 0;
        metrics.buckets = 0;
        metrics.pairs = 0;
        metrics.bodies = 0;
      }
    };
    Metrics.update = function(metrics, engine) {
      if (metrics.extended) {
        var world = engine.world, bodies = Composite.allBodies(world);
        metrics.collisions = metrics.narrowDetections;
        metrics.pairs = engine.pairs.list.length;
        metrics.bodies = bodies.length;
        metrics.midEff = (metrics.narrowDetections / (metrics.midphaseTests || 1)).toFixed(2);
        metrics.narrowEff = (metrics.narrowDetections / (metrics.narrowphaseTests || 1)).toFixed(2);
        metrics.broadEff = (1 - metrics.broadphaseTests / (bodies.length || 1)).toFixed(2);
        metrics.narrowReuse = (metrics.narrowReuseCount / (metrics.narrowphaseTests || 1)).toFixed(2);
      }
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/lib/core/Engine.js
var require_Engine = __commonJS((exports2, module2) => {
  var Engine = {};
  module2.exports = Engine;
  var World = require_World2();
  var Sleeping = require_Sleeping();
  var Resolver = require_Resolver();
  var Pairs = require_Pairs();
  var Metrics = require_Metrics();
  var Grid = require_Grid2();
  var Events = require_Events();
  var Composite = require_Composite();
  var Constraint = require_Constraint();
  var Common = require_Common();
  var Body = require_Body2();
  (function() {
    Engine.create = function(element, options) {
      options = Common.isElement(element) ? options : element;
      element = Common.isElement(element) ? element : null;
      options = options || {};
      if (element || options.render) {
        Common.warn("Engine.create: engine.render is deprecated (see docs)");
      }
      var defaults = {
        positionIterations: 6,
        velocityIterations: 4,
        constraintIterations: 2,
        enableSleeping: false,
        events: [],
        plugin: {},
        timing: {
          timestamp: 0,
          timeScale: 1
        },
        broadphase: {
          controller: Grid
        }
      };
      var engine = Common.extend(defaults, options);
      engine.world = options.world || World.create(engine.world);
      engine.pairs = Pairs.create();
      engine.broadphase = engine.broadphase.controller.create(engine.broadphase);
      engine.metrics = engine.metrics || {extended: false};
      engine.metrics = Metrics.create(engine.metrics);
      return engine;
    };
    Engine.update = function(engine, delta, correction) {
      delta = delta || 1e3 / 60;
      correction = correction || 1;
      var world = engine.world, timing = engine.timing, broadphase = engine.broadphase, broadphasePairs = [], i;
      timing.timestamp += delta * timing.timeScale;
      var event = {
        timestamp: timing.timestamp
      };
      Events.trigger(engine, "beforeUpdate", event);
      var allBodies = Composite.allBodies(world), allConstraints = Composite.allConstraints(world);
      Metrics.reset(engine.metrics);
      if (engine.enableSleeping)
        Sleeping.update(allBodies, timing.timeScale);
      Engine._bodiesApplyGravity(allBodies, world.gravity);
      Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);
      Constraint.preSolveAll(allBodies);
      for (i = 0; i < engine.constraintIterations; i++) {
        Constraint.solveAll(allConstraints, timing.timeScale);
      }
      Constraint.postSolveAll(allBodies);
      if (broadphase.controller) {
        if (world.isModified)
          broadphase.controller.clear(broadphase);
        broadphase.controller.update(broadphase, allBodies, engine, world.isModified);
        broadphasePairs = broadphase.pairsList;
      } else {
        broadphasePairs = allBodies;
      }
      if (world.isModified) {
        Composite.setModified(world, false, false, true);
      }
      var collisions = broadphase.detector(broadphasePairs, engine);
      var pairs = engine.pairs, timestamp = timing.timestamp;
      Pairs.update(pairs, collisions, timestamp);
      Pairs.removeOld(pairs, timestamp);
      if (engine.enableSleeping)
        Sleeping.afterCollisions(pairs.list, timing.timeScale);
      if (pairs.collisionStart.length > 0)
        Events.trigger(engine, "collisionStart", {pairs: pairs.collisionStart});
      Resolver.preSolvePosition(pairs.list);
      for (i = 0; i < engine.positionIterations; i++) {
        Resolver.solvePosition(pairs.list, allBodies, timing.timeScale);
      }
      Resolver.postSolvePosition(allBodies);
      Constraint.preSolveAll(allBodies);
      for (i = 0; i < engine.constraintIterations; i++) {
        Constraint.solveAll(allConstraints, timing.timeScale);
      }
      Constraint.postSolveAll(allBodies);
      Resolver.preSolveVelocity(pairs.list);
      for (i = 0; i < engine.velocityIterations; i++) {
        Resolver.solveVelocity(pairs.list, timing.timeScale);
      }
      if (pairs.collisionActive.length > 0)
        Events.trigger(engine, "collisionActive", {pairs: pairs.collisionActive});
      if (pairs.collisionEnd.length > 0)
        Events.trigger(engine, "collisionEnd", {pairs: pairs.collisionEnd});
      Metrics.update(engine.metrics, engine);
      Engine._bodiesClearForces(allBodies);
      Events.trigger(engine, "afterUpdate", event);
      return engine;
    };
    Engine.merge = function(engineA, engineB) {
      Common.extend(engineA, engineB);
      if (engineB.world) {
        engineA.world = engineB.world;
        Engine.clear(engineA);
        var bodies = Composite.allBodies(engineA.world);
        for (var i = 0; i < bodies.length; i++) {
          var body = bodies[i];
          Sleeping.set(body, false);
          body.id = Common.nextId();
        }
      }
    };
    Engine.clear = function(engine) {
      var world = engine.world;
      Pairs.clear(engine.pairs);
      var broadphase = engine.broadphase;
      if (broadphase.controller) {
        var bodies = Composite.allBodies(world);
        broadphase.controller.clear(broadphase);
        broadphase.controller.update(broadphase, bodies, engine, true);
      }
    };
    Engine._bodiesClearForces = function(bodies) {
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        body.force.x = 0;
        body.force.y = 0;
        body.torque = 0;
      }
    };
    Engine._bodiesApplyGravity = function(bodies, gravity) {
      var gravityScale = typeof gravity.scale !== "undefined" ? gravity.scale : 1e-3;
      if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {
        return;
      }
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        if (body.ignoreGravity || body.isStatic || body.isSleeping)
          continue;
        body.force.x += body.mass * gravity.x * gravityScale * body.gravityScale.x;
        body.force.y += body.mass * gravity.y * gravityScale * body.gravityScale.y;
      }
    };
    Engine._bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        if (body.isStatic || body.isSleeping)
          continue;
        Body.update(body, deltaTime, timeScale, correction);
      }
    };
  })();
});

// node_modules/phaser/src/physics/matter-js/CustomMain.js
var require_CustomMain = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Matter = require_Matter();
  Matter.Body = require_Body2();
  Matter.Composite = require_Composite();
  Matter.World = require_World2();
  Matter.Detector = require_Detector();
  Matter.Grid = require_Grid2();
  Matter.Pairs = require_Pairs();
  Matter.Pair = require_Pair();
  Matter.Query = require_Query();
  Matter.Resolver = require_Resolver();
  Matter.SAT = require_SAT();
  Matter.Constraint = require_Constraint();
  Matter.Common = require_Common();
  Matter.Engine = require_Engine();
  Matter.Events = require_Events();
  Matter.Sleeping = require_Sleeping();
  Matter.Plugin = require_Plugin();
  Matter.Bodies = require_Bodies();
  Matter.Composites = require_Composites();
  Matter.Axes = require_Axes();
  Matter.Bounds = require_Bounds();
  Matter.Svg = require_Svg();
  Matter.Vector = require_Vector();
  Matter.Vertices = require_Vertices();
  Matter.World.add = Matter.Composite.add;
  Matter.World.remove = Matter.Composite.remove;
  Matter.World.addComposite = Matter.Composite.addComposite;
  Matter.World.addBody = Matter.Composite.addBody;
  Matter.World.addConstraint = Matter.Composite.addConstraint;
  Matter.World.clear = Matter.Composite.clear;
  module2.exports = Matter;
});

// node_modules/phaser/src/physics/matter-js/lib/plugins/MatterAttractors.js
var require_MatterAttractors = __commonJS((exports2, module2) => {
  var Matter = require_CustomMain();
  var MatterAttractors = {
    name: "matter-attractors",
    version: "0.1.7",
    for: "matter-js@^0.14.2",
    silent: true,
    install: function(base) {
      base.after("Body.create", function() {
        MatterAttractors.Body.init(this);
      });
      base.before("Engine.update", function(engine) {
        MatterAttractors.Engine.update(engine);
      });
    },
    Body: {
      init: function(body) {
        body.plugin.attractors = body.plugin.attractors || [];
      }
    },
    Engine: {
      update: function(engine) {
        var bodies = Matter.Composite.allBodies(engine.world);
        for (var i = 0; i < bodies.length; i++) {
          var bodyA = bodies[i];
          var attractors = bodyA.plugin.attractors;
          if (attractors && attractors.length > 0) {
            for (var j = 0; j < bodies.length; j++) {
              var bodyB = bodies[j];
              if (i !== j) {
                for (var k = 0; k < attractors.length; k++) {
                  var attractor = attractors[k];
                  var forceVector = attractor;
                  if (Matter.Common.isFunction(attractor)) {
                    forceVector = attractor(bodyA, bodyB);
                  }
                  if (forceVector) {
                    Matter.Body.applyForce(bodyB, bodyB.position, forceVector);
                  }
                }
              }
            }
          }
        }
      }
    },
    Attractors: {
      gravityConstant: 1e-3,
      gravity: function(bodyA, bodyB) {
        var bToA = Matter.Vector.sub(bodyB.position, bodyA.position);
        var distanceSq = Matter.Vector.magnitudeSquared(bToA) || 1e-4;
        var normal = Matter.Vector.normalise(bToA);
        var magnitude = -MatterAttractors.Attractors.gravityConstant * (bodyA.mass * bodyB.mass / distanceSq);
        var force = Matter.Vector.mult(normal, magnitude);
        Matter.Body.applyForce(bodyA, bodyA.position, Matter.Vector.neg(force));
        Matter.Body.applyForce(bodyB, bodyB.position, force);
      }
    }
  };
  module2.exports = MatterAttractors;
});

// node_modules/phaser/src/physics/matter-js/lib/plugins/MatterCollisionEvents.js
var require_MatterCollisionEvents = __commonJS((exports2, module2) => {
  /**
   * @author       @dxu https://github.com/dxu/matter-collision-events
   * @author       Richard Davey <rich@photonstorm.com>
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var MatterCollisionEvents = {
    name: "matter-collision-events",
    version: "0.1.6",
    for: "matter-js@^0.14.2",
    silent: true,
    install: function(matter) {
      matter.after("Engine.create", function() {
        matter.Events.on(this, "collisionStart", function(event) {
          event.pairs.map(function(pair) {
            var bodyA = pair.bodyA;
            var bodyB = pair.bodyB;
            if (bodyA.gameObject) {
              bodyA.gameObject.emit("collide", bodyA, bodyB, pair);
            }
            if (bodyB.gameObject) {
              bodyB.gameObject.emit("collide", bodyB, bodyA, pair);
            }
            matter.Events.trigger(bodyA, "onCollide", {pair});
            matter.Events.trigger(bodyB, "onCollide", {pair});
            if (bodyA.onCollideCallback) {
              bodyA.onCollideCallback(pair);
            }
            if (bodyB.onCollideCallback) {
              bodyB.onCollideCallback(pair);
            }
            if (bodyA.onCollideWith[bodyB.id]) {
              bodyA.onCollideWith[bodyB.id](bodyB, pair);
            }
            if (bodyB.onCollideWith[bodyA.id]) {
              bodyB.onCollideWith[bodyA.id](bodyA, pair);
            }
          });
        });
        matter.Events.on(this, "collisionActive", function(event) {
          event.pairs.map(function(pair) {
            var bodyA = pair.bodyA;
            var bodyB = pair.bodyB;
            if (bodyA.gameObject) {
              bodyA.gameObject.emit("collideActive", bodyA, bodyB, pair);
            }
            if (bodyB.gameObject) {
              bodyB.gameObject.emit("collideActive", bodyB, bodyA, pair);
            }
            matter.Events.trigger(bodyA, "onCollideActive", {pair});
            matter.Events.trigger(bodyB, "onCollideActive", {pair});
            if (bodyA.onCollideActiveCallback) {
              bodyA.onCollideActiveCallback(pair);
            }
            if (bodyB.onCollideActiveCallback) {
              bodyB.onCollideActiveCallback(pair);
            }
          });
        });
        matter.Events.on(this, "collisionEnd", function(event) {
          event.pairs.map(function(pair) {
            var bodyA = pair.bodyA;
            var bodyB = pair.bodyB;
            if (bodyA.gameObject) {
              bodyA.gameObject.emit("collideEnd", bodyA, bodyB, pair);
            }
            if (bodyB.gameObject) {
              bodyB.gameObject.emit("collideEnd", bodyB, bodyA, pair);
            }
            matter.Events.trigger(bodyA, "onCollideEnd", {pair});
            matter.Events.trigger(bodyB, "onCollideEnd", {pair});
            if (bodyA.onCollideEndCallback) {
              bodyA.onCollideEndCallback(pair);
            }
            if (bodyB.onCollideEndCallback) {
              bodyB.onCollideEndCallback(pair);
            }
          });
        });
      });
    }
  };
  module2.exports = MatterCollisionEvents;
});

// node_modules/phaser/src/physics/matter-js/lib/plugins/MatterWrap.js
var require_MatterWrap = __commonJS((exports2, module2) => {
  var Matter = require_CustomMain();
  var MatterWrap = {
    name: "matter-wrap",
    version: "0.1.4",
    for: "matter-js@^0.14.2",
    silent: true,
    install: function(base) {
      base.after("Engine.update", function() {
        MatterWrap.Engine.update(this);
      });
    },
    Engine: {
      update: function(engine) {
        var world = engine.world, bodies = Matter.Composite.allBodies(world), composites = Matter.Composite.allComposites(world);
        for (var i = 0; i < bodies.length; i += 1) {
          var body = bodies[i];
          if (body.plugin.wrap) {
            MatterWrap.Body.wrap(body, body.plugin.wrap);
          }
        }
        for (i = 0; i < composites.length; i += 1) {
          var composite = composites[i];
          if (composite.plugin.wrap) {
            MatterWrap.Composite.wrap(composite, composite.plugin.wrap);
          }
        }
      }
    },
    Bounds: {
      wrap: function(objectBounds, bounds) {
        var x = null, y = null;
        if (typeof bounds.min.x !== "undefined" && typeof bounds.max.x !== "undefined") {
          if (objectBounds.min.x > bounds.max.x) {
            x = bounds.min.x - objectBounds.max.x;
          } else if (objectBounds.max.x < bounds.min.x) {
            x = bounds.max.x - objectBounds.min.x;
          }
        }
        if (typeof bounds.min.y !== "undefined" && typeof bounds.max.y !== "undefined") {
          if (objectBounds.min.y > bounds.max.y) {
            y = bounds.min.y - objectBounds.max.y;
          } else if (objectBounds.max.y < bounds.min.y) {
            y = bounds.max.y - objectBounds.min.y;
          }
        }
        if (x !== null || y !== null) {
          return {
            x: x || 0,
            y: y || 0
          };
        }
      }
    },
    Body: {
      wrap: function(body, bounds) {
        var translation = MatterWrap.Bounds.wrap(body.bounds, bounds);
        if (translation) {
          Matter.Body.translate(body, translation);
        }
        return translation;
      }
    },
    Composite: {
      bounds: function(composite) {
        var bodies = Matter.Composite.allBodies(composite), vertices = [];
        for (var i = 0; i < bodies.length; i += 1) {
          var body = bodies[i];
          vertices.push(body.bounds.min, body.bounds.max);
        }
        return Matter.Bounds.create(vertices);
      },
      wrap: function(composite, bounds) {
        var translation = MatterWrap.Bounds.wrap(MatterWrap.Composite.bounds(composite), bounds);
        if (translation) {
          Matter.Composite.translate(composite, translation);
        }
        return translation;
      }
    }
  };
  module2.exports = MatterWrap;
});

// node_modules/phaser/src/physics/matter-js/World.js
var require_World3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Bodies = require_Bodies();
  var Body = require_Body2();
  var Class = require_Class();
  var Common = require_Common();
  var Composite = require_Composite();
  var Engine = require_Engine();
  var EventEmitter = require_eventemitter3();
  var Events = require_events20();
  var GetFastValue = require_GetFastValue();
  var GetValue = require_GetValue();
  var MatterBody = require_Body2();
  var MatterEvents = require_Events();
  var MatterTileBody = require_MatterTileBody();
  var MatterWorld = require_World2();
  var Vector = require_Vector();
  var World = new Class({
    Extends: EventEmitter,
    initialize: function World2(scene, config2) {
      EventEmitter.call(this);
      this.scene = scene;
      this.engine = Engine.create(config2);
      this.localWorld = this.engine.world;
      var gravity = GetValue(config2, "gravity", null);
      if (gravity) {
        this.setGravity(gravity.x, gravity.y, gravity.scale);
      } else if (gravity === false) {
        this.setGravity(0, 0, 0);
      }
      this.walls = {left: null, right: null, top: null, bottom: null};
      this.enabled = GetValue(config2, "enabled", true);
      this.correction = GetValue(config2, "correction", 1);
      this.getDelta = GetValue(config2, "getDelta", this.update60Hz);
      var runnerConfig = GetFastValue(config2, "runner", {});
      var hasFPS = GetFastValue(runnerConfig, "fps", false);
      var fps = GetFastValue(runnerConfig, "fps", 60);
      var delta = GetFastValue(runnerConfig, "delta", 1e3 / fps);
      var deltaMin = GetFastValue(runnerConfig, "deltaMin", 1e3 / fps);
      var deltaMax = GetFastValue(runnerConfig, "deltaMax", 1e3 / (fps * 0.5));
      if (!hasFPS) {
        fps = 1e3 / delta;
      }
      this.runner = {
        fps,
        correction: GetFastValue(runnerConfig, "correction", 1),
        deltaSampleSize: GetFastValue(runnerConfig, "deltaSampleSize", 60),
        counterTimestamp: 0,
        frameCounter: 0,
        deltaHistory: [],
        timePrev: null,
        timeScalePrev: 1,
        frameRequestId: null,
        isFixed: GetFastValue(runnerConfig, "isFixed", false),
        delta,
        deltaMin,
        deltaMax
      };
      this.autoUpdate = GetValue(config2, "autoUpdate", true);
      var debugConfig = GetValue(config2, "debug", false);
      this.drawDebug = typeof debugConfig === "object" ? true : debugConfig;
      this.debugGraphic;
      this.debugConfig = {
        showAxes: GetFastValue(debugConfig, "showAxes", false),
        showAngleIndicator: GetFastValue(debugConfig, "showAngleIndicator", false),
        angleColor: GetFastValue(debugConfig, "angleColor", 15208787),
        showBroadphase: GetFastValue(debugConfig, "showBroadphase", false),
        broadphaseColor: GetFastValue(debugConfig, "broadphaseColor", 16757760),
        showBounds: GetFastValue(debugConfig, "showBounds", false),
        boundsColor: GetFastValue(debugConfig, "boundsColor", 16777215),
        showVelocity: GetFastValue(debugConfig, "showVelocity", false),
        velocityColor: GetFastValue(debugConfig, "velocityColor", 44783),
        showCollisions: GetFastValue(debugConfig, "showCollisions", false),
        collisionColor: GetFastValue(debugConfig, "collisionColor", 16094476),
        showSeparations: GetFastValue(debugConfig, "showSeparations", false),
        separationColor: GetFastValue(debugConfig, "separationColor", 16753920),
        showBody: GetFastValue(debugConfig, "showBody", true),
        showStaticBody: GetFastValue(debugConfig, "showStaticBody", true),
        showInternalEdges: GetFastValue(debugConfig, "showInternalEdges", false),
        renderFill: GetFastValue(debugConfig, "renderFill", false),
        renderLine: GetFastValue(debugConfig, "renderLine", true),
        fillColor: GetFastValue(debugConfig, "fillColor", 1075465),
        fillOpacity: GetFastValue(debugConfig, "fillOpacity", 1),
        lineColor: GetFastValue(debugConfig, "lineColor", 2678297),
        lineOpacity: GetFastValue(debugConfig, "lineOpacity", 1),
        lineThickness: GetFastValue(debugConfig, "lineThickness", 1),
        staticFillColor: GetFastValue(debugConfig, "staticFillColor", 857979),
        staticLineColor: GetFastValue(debugConfig, "staticLineColor", 1255396),
        showSleeping: GetFastValue(debugConfig, "showSleeping", false),
        staticBodySleepOpacity: GetFastValue(debugConfig, "staticBodySleepOpacity", 0.7),
        sleepFillColor: GetFastValue(debugConfig, "sleepFillColor", 4605510),
        sleepLineColor: GetFastValue(debugConfig, "sleepLineColor", 10066585),
        showSensors: GetFastValue(debugConfig, "showSensors", true),
        sensorFillColor: GetFastValue(debugConfig, "sensorFillColor", 857979),
        sensorLineColor: GetFastValue(debugConfig, "sensorLineColor", 1255396),
        showPositions: GetFastValue(debugConfig, "showPositions", true),
        positionSize: GetFastValue(debugConfig, "positionSize", 4),
        positionColor: GetFastValue(debugConfig, "positionColor", 14697178),
        showJoint: GetFastValue(debugConfig, "showJoint", true),
        jointColor: GetFastValue(debugConfig, "jointColor", 14737474),
        jointLineOpacity: GetFastValue(debugConfig, "jointLineOpacity", 1),
        jointLineThickness: GetFastValue(debugConfig, "jointLineThickness", 2),
        pinSize: GetFastValue(debugConfig, "pinSize", 4),
        pinColor: GetFastValue(debugConfig, "pinColor", 4382944),
        springColor: GetFastValue(debugConfig, "springColor", 14697184),
        anchorColor: GetFastValue(debugConfig, "anchorColor", 15724527),
        anchorSize: GetFastValue(debugConfig, "anchorSize", 4),
        showConvexHulls: GetFastValue(debugConfig, "showConvexHulls", false),
        hullColor: GetFastValue(debugConfig, "hullColor", 14091216)
      };
      if (this.drawDebug) {
        this.createDebugGraphic();
      }
      this.setEventsProxy();
      if (GetFastValue(config2, "setBounds", false)) {
        var boundsConfig = config2["setBounds"];
        if (typeof boundsConfig === "boolean") {
          this.setBounds();
        } else {
          var x = GetFastValue(boundsConfig, "x", 0);
          var y = GetFastValue(boundsConfig, "y", 0);
          var width = GetFastValue(boundsConfig, "width", scene.sys.scale.width);
          var height = GetFastValue(boundsConfig, "height", scene.sys.scale.height);
          var thickness = GetFastValue(boundsConfig, "thickness", 64);
          var left = GetFastValue(boundsConfig, "left", true);
          var right = GetFastValue(boundsConfig, "right", true);
          var top = GetFastValue(boundsConfig, "top", true);
          var bottom = GetFastValue(boundsConfig, "bottom", true);
          this.setBounds(x, y, width, height, thickness, left, right, top, bottom);
        }
      }
    },
    setCompositeRenderStyle: function(composite) {
      var bodies = composite.bodies;
      var constraints = composite.constraints;
      var composites = composite.composites;
      var i;
      var obj;
      var render;
      for (i = 0; i < bodies.length; i++) {
        obj = bodies[i];
        render = obj.render;
        this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);
      }
      for (i = 0; i < constraints.length; i++) {
        obj = constraints[i];
        render = obj.render;
        this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);
      }
      for (i = 0; i < composites.length; i++) {
        obj = composites[i];
        this.setCompositeRenderStyle(obj);
      }
      return this;
    },
    setBodyRenderStyle: function(body, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {
      var render = body.render;
      var config2 = this.debugConfig;
      if (!render) {
        return this;
      }
      if (lineColor === void 0 || lineColor === null) {
        lineColor = body.isStatic ? config2.staticLineColor : config2.lineColor;
      }
      if (lineOpacity === void 0 || lineOpacity === null) {
        lineOpacity = config2.lineOpacity;
      }
      if (lineThickness === void 0 || lineThickness === null) {
        lineThickness = config2.lineThickness;
      }
      if (fillColor === void 0 || fillColor === null) {
        fillColor = body.isStatic ? config2.staticFillColor : config2.fillColor;
      }
      if (fillOpacity === void 0 || fillOpacity === null) {
        fillOpacity = config2.fillOpacity;
      }
      if (lineColor !== false) {
        render.lineColor = lineColor;
      }
      if (lineOpacity !== false) {
        render.lineOpacity = lineOpacity;
      }
      if (lineThickness !== false) {
        render.lineThickness = lineThickness;
      }
      if (fillColor !== false) {
        render.fillColor = fillColor;
      }
      if (fillOpacity !== false) {
        render.fillOpacity = fillOpacity;
      }
      return this;
    },
    setConstraintRenderStyle: function(constraint, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {
      var render = constraint.render;
      var config2 = this.debugConfig;
      if (!render) {
        return this;
      }
      if (lineColor === void 0 || lineColor === null) {
        var type = render.type;
        if (type === "line") {
          lineColor = config2.jointColor;
        } else if (type === "pin") {
          lineColor = config2.pinColor;
        } else if (type === "spring") {
          lineColor = config2.springColor;
        }
      }
      if (lineOpacity === void 0 || lineOpacity === null) {
        lineOpacity = config2.jointLineOpacity;
      }
      if (lineThickness === void 0 || lineThickness === null) {
        lineThickness = config2.jointLineThickness;
      }
      if (pinSize === void 0 || pinSize === null) {
        pinSize = config2.pinSize;
      }
      if (anchorColor === void 0 || anchorColor === null) {
        anchorColor = config2.anchorColor;
      }
      if (anchorSize === void 0 || anchorSize === null) {
        anchorSize = config2.anchorSize;
      }
      if (lineColor !== false) {
        render.lineColor = lineColor;
      }
      if (lineOpacity !== false) {
        render.lineOpacity = lineOpacity;
      }
      if (lineThickness !== false) {
        render.lineThickness = lineThickness;
      }
      if (pinSize !== false) {
        render.pinSize = pinSize;
      }
      if (anchorColor !== false) {
        render.anchorColor = anchorColor;
      }
      if (anchorSize !== false) {
        render.anchorSize = anchorSize;
      }
      return this;
    },
    setEventsProxy: function() {
      var _this = this;
      var engine = this.engine;
      var world = this.localWorld;
      if (this.drawDebug) {
        MatterEvents.on(world, "compositeModified", function(composite) {
          _this.setCompositeRenderStyle(composite);
        });
        MatterEvents.on(world, "beforeAdd", function(event) {
          var objects = [].concat(event.object);
          for (var i = 0; i < objects.length; i++) {
            var obj = objects[i];
            var render = obj.render;
            if (obj.type === "body") {
              _this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);
            } else if (obj.type === "composite") {
              _this.setCompositeRenderStyle(obj);
            } else if (obj.type === "constraint") {
              _this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);
            }
          }
        });
      }
      MatterEvents.on(world, "beforeAdd", function(event) {
        _this.emit(Events.BEFORE_ADD, event);
      });
      MatterEvents.on(world, "afterAdd", function(event) {
        _this.emit(Events.AFTER_ADD, event);
      });
      MatterEvents.on(world, "beforeRemove", function(event) {
        _this.emit(Events.BEFORE_REMOVE, event);
      });
      MatterEvents.on(world, "afterRemove", function(event) {
        _this.emit(Events.AFTER_REMOVE, event);
      });
      MatterEvents.on(engine, "beforeUpdate", function(event) {
        _this.emit(Events.BEFORE_UPDATE, event);
      });
      MatterEvents.on(engine, "afterUpdate", function(event) {
        _this.emit(Events.AFTER_UPDATE, event);
      });
      MatterEvents.on(engine, "collisionStart", function(event) {
        var pairs = event.pairs;
        var bodyA;
        var bodyB;
        if (pairs.length > 0) {
          bodyA = pairs[0].bodyA;
          bodyB = pairs[0].bodyB;
        }
        _this.emit(Events.COLLISION_START, event, bodyA, bodyB);
      });
      MatterEvents.on(engine, "collisionActive", function(event) {
        var pairs = event.pairs;
        var bodyA;
        var bodyB;
        if (pairs.length > 0) {
          bodyA = pairs[0].bodyA;
          bodyB = pairs[0].bodyB;
        }
        _this.emit(Events.COLLISION_ACTIVE, event, bodyA, bodyB);
      });
      MatterEvents.on(engine, "collisionEnd", function(event) {
        var pairs = event.pairs;
        var bodyA;
        var bodyB;
        if (pairs.length > 0) {
          bodyA = pairs[0].bodyA;
          bodyB = pairs[0].bodyB;
        }
        _this.emit(Events.COLLISION_END, event, bodyA, bodyB);
      });
    },
    setBounds: function(x, y, width, height, thickness, left, right, top, bottom) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = this.scene.sys.scale.width;
      }
      if (height === void 0) {
        height = this.scene.sys.scale.height;
      }
      if (thickness === void 0) {
        thickness = 64;
      }
      if (left === void 0) {
        left = true;
      }
      if (right === void 0) {
        right = true;
      }
      if (top === void 0) {
        top = true;
      }
      if (bottom === void 0) {
        bottom = true;
      }
      this.updateWall(left, "left", x - thickness, y - thickness, thickness, height + thickness * 2);
      this.updateWall(right, "right", x + width, y - thickness, thickness, height + thickness * 2);
      this.updateWall(top, "top", x, y - thickness, width, thickness);
      this.updateWall(bottom, "bottom", x, y + height, width, thickness);
      return this;
    },
    updateWall: function(add, position, x, y, width, height) {
      var wall = this.walls[position];
      if (add) {
        if (wall) {
          MatterWorld.remove(this.localWorld, wall);
        }
        x += width / 2;
        y += height / 2;
        this.walls[position] = this.create(x, y, width, height, {isStatic: true, friction: 0, frictionStatic: 0});
      } else {
        if (wall) {
          MatterWorld.remove(this.localWorld, wall);
        }
        this.walls[position] = null;
      }
    },
    createDebugGraphic: function() {
      var graphic = this.scene.sys.add.graphics({x: 0, y: 0});
      graphic.setDepth(Number.MAX_VALUE);
      this.debugGraphic = graphic;
      this.drawDebug = true;
      return graphic;
    },
    disableGravity: function() {
      this.localWorld.gravity.x = 0;
      this.localWorld.gravity.y = 0;
      this.localWorld.gravity.scale = 0;
      return this;
    },
    setGravity: function(x, y, scale) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 1;
      }
      this.localWorld.gravity.x = x;
      this.localWorld.gravity.y = y;
      if (scale !== void 0) {
        this.localWorld.gravity.scale = scale;
      }
      return this;
    },
    create: function(x, y, width, height, options) {
      var body = Bodies.rectangle(x, y, width, height, options);
      MatterWorld.add(this.localWorld, body);
      return body;
    },
    add: function(object) {
      MatterWorld.add(this.localWorld, object);
      return this;
    },
    remove: function(object, deep) {
      if (!Array.isArray(object)) {
        object = [object];
      }
      for (var i = 0; i < object.length; i++) {
        var entity = object[i];
        var body = entity.body ? entity.body : entity;
        Composite.remove(this.localWorld, body, deep);
      }
      return this;
    },
    removeConstraint: function(constraint, deep) {
      Composite.remove(this.localWorld, constraint, deep);
      return this;
    },
    convertTilemapLayer: function(tilemapLayer, options) {
      var layerData = tilemapLayer.layer;
      var tiles = tilemapLayer.getTilesWithin(0, 0, layerData.width, layerData.height, {isColliding: true});
      this.convertTiles(tiles, options);
      return this;
    },
    convertTiles: function(tiles, options) {
      if (tiles.length === 0) {
        return this;
      }
      for (var i = 0; i < tiles.length; i++) {
        new MatterTileBody(this, tiles[i], options);
      }
      return this;
    },
    nextGroup: function(isNonColliding) {
      return MatterBody.nextGroup(isNonColliding);
    },
    nextCategory: function() {
      return MatterBody.nextCategory();
    },
    pause: function() {
      this.enabled = false;
      this.emit(Events.PAUSE);
      return this;
    },
    resume: function() {
      this.enabled = true;
      this.emit(Events.RESUME);
      return this;
    },
    update: function(time, delta) {
      if (!this.enabled || !this.autoUpdate) {
        return;
      }
      var engine = this.engine;
      var runner = this.runner;
      var timing = engine.timing;
      var correction = this.correction;
      if (runner.isFixed) {
        delta = this.getDelta(time, delta);
      } else {
        delta = time - runner.timePrev || runner.delta;
        runner.timePrev = time;
        runner.deltaHistory.push(delta);
        runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
        delta = Math.min.apply(null, runner.deltaHistory);
        delta = delta < runner.deltaMin ? runner.deltaMin : delta;
        delta = delta > runner.deltaMax ? runner.deltaMax : delta;
        correction = delta / runner.delta;
        runner.delta = delta;
      }
      if (runner.timeScalePrev !== 0) {
        correction *= timing.timeScale / runner.timeScalePrev;
      }
      if (timing.timeScale === 0) {
        correction = 0;
      }
      runner.timeScalePrev = timing.timeScale;
      runner.correction = correction;
      runner.frameCounter += 1;
      if (time - runner.counterTimestamp >= 1e3) {
        runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1e3);
        runner.counterTimestamp = time;
        runner.frameCounter = 0;
      }
      Engine.update(engine, delta, correction);
    },
    step: function(delta, correction) {
      Engine.update(this.engine, delta, correction);
    },
    update60Hz: function() {
      return 1e3 / 60;
    },
    update30Hz: function() {
      return 1e3 / 30;
    },
    has: function(body) {
      var src = body.hasOwnProperty("body") ? body.body : body;
      return Composite.get(this.localWorld, src.id, src.type) !== null;
    },
    getAllBodies: function() {
      return Composite.allBodies(this.localWorld);
    },
    getAllConstraints: function() {
      return Composite.allConstraints(this.localWorld);
    },
    getAllComposites: function() {
      return Composite.allComposites(this.localWorld);
    },
    postUpdate: function() {
      if (!this.drawDebug) {
        return;
      }
      var config2 = this.debugConfig;
      var engine = this.engine;
      var graphics = this.debugGraphic;
      var bodies = Composite.allBodies(this.localWorld);
      this.debugGraphic.clear();
      if (config2.showBroadphase && engine.broadphase.controller) {
        this.renderGrid(engine.broadphase, graphics, config2.broadphaseColor, 0.5);
      }
      if (config2.showBounds) {
        this.renderBodyBounds(bodies, graphics, config2.boundsColor, 0.5);
      }
      if (config2.showBody || config2.showStaticBody) {
        this.renderBodies(bodies);
      }
      if (config2.showJoint) {
        this.renderJoints();
      }
      if (config2.showAxes || config2.showAngleIndicator) {
        this.renderBodyAxes(bodies, graphics, config2.showAxes, config2.angleColor, 0.5);
      }
      if (config2.showVelocity) {
        this.renderBodyVelocity(bodies, graphics, config2.velocityColor, 1, 2);
      }
      if (config2.showSeparations) {
        this.renderSeparations(engine.pairs.list, graphics, config2.separationColor);
      }
      if (config2.showCollisions) {
        this.renderCollisions(engine.pairs.list, graphics, config2.collisionColor);
      }
    },
    renderGrid: function(grid, graphics, lineColor, lineOpacity) {
      graphics.lineStyle(1, lineColor, lineOpacity);
      var bucketKeys = Common.keys(grid.buckets);
      for (var i = 0; i < bucketKeys.length; i++) {
        var bucketId = bucketKeys[i];
        if (grid.buckets[bucketId].length < 2) {
          continue;
        }
        var region = bucketId.split(/C|R/);
        graphics.strokeRect(parseInt(region[1], 10) * grid.bucketWidth, parseInt(region[2], 10) * grid.bucketHeight, grid.bucketWidth, grid.bucketHeight);
      }
      return this;
    },
    renderSeparations: function(pairs, graphics, lineColor) {
      graphics.lineStyle(1, lineColor, 1);
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        if (!pair.isActive) {
          continue;
        }
        var collision = pair.collision;
        var bodyA = collision.bodyA;
        var bodyB = collision.bodyB;
        var posA = bodyA.position;
        var posB = bodyB.position;
        var penetration = collision.penetration;
        var k = !bodyA.isStatic && !bodyB.isStatic ? 4 : 1;
        if (bodyB.isStatic) {
          k = 0;
        }
        graphics.lineBetween(posB.x, posB.y, posB.x - penetration.x * k, posB.y - penetration.y * k);
        k = !bodyA.isStatic && !bodyB.isStatic ? 4 : 1;
        if (bodyA.isStatic) {
          k = 0;
        }
        graphics.lineBetween(posA.x, posA.y, posA.x - penetration.x * k, posA.y - penetration.y * k);
      }
      return this;
    },
    renderCollisions: function(pairs, graphics, lineColor) {
      graphics.lineStyle(1, lineColor, 0.5);
      graphics.fillStyle(lineColor, 1);
      var i;
      var pair;
      for (i = 0; i < pairs.length; i++) {
        pair = pairs[i];
        if (!pair.isActive) {
          continue;
        }
        for (var j = 0; j < pair.activeContacts.length; j++) {
          var contact = pair.activeContacts[j];
          var vertex = contact.vertex;
          graphics.fillRect(vertex.x - 2, vertex.y - 2, 5, 5);
        }
      }
      for (i = 0; i < pairs.length; i++) {
        pair = pairs[i];
        if (!pair.isActive) {
          continue;
        }
        var collision = pair.collision;
        var contacts = pair.activeContacts;
        if (contacts.length > 0) {
          var normalPosX = contacts[0].vertex.x;
          var normalPosY = contacts[0].vertex.y;
          if (contacts.length === 2) {
            normalPosX = (contacts[0].vertex.x + contacts[1].vertex.x) / 2;
            normalPosY = (contacts[0].vertex.y + contacts[1].vertex.y) / 2;
          }
          if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic) {
            graphics.lineBetween(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8, normalPosX, normalPosY);
          } else {
            graphics.lineBetween(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8, normalPosX, normalPosY);
          }
        }
      }
      return this;
    },
    renderBodyBounds: function(bodies, graphics, lineColor, lineOpacity) {
      graphics.lineStyle(1, lineColor, lineOpacity);
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        if (!body.render.visible) {
          continue;
        }
        var bounds = body.bounds;
        if (bounds) {
          graphics.strokeRect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);
        } else {
          var parts = body.parts;
          for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
            var part = parts[j];
            graphics.strokeRect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
          }
        }
      }
      return this;
    },
    renderBodyAxes: function(bodies, graphics, showAxes, lineColor, lineOpacity) {
      graphics.lineStyle(1, lineColor, lineOpacity);
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        var parts = body.parts;
        if (!body.render.visible) {
          continue;
        }
        var part;
        var j;
        var k;
        if (showAxes) {
          for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
            part = parts[j];
            for (k = 0; k < part.axes.length; k++) {
              var axis = part.axes[k];
              graphics.lineBetween(part.position.x, part.position.y, part.position.x + axis.x * 20, part.position.y + axis.y * 20);
            }
          }
        } else {
          for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
            part = parts[j];
            for (k = 0; k < part.axes.length; k++) {
              graphics.lineBetween(part.position.x, part.position.y, (part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);
            }
          }
        }
      }
      return this;
    },
    renderBodyVelocity: function(bodies, graphics, lineColor, lineOpacity, lineThickness) {
      graphics.lineStyle(lineThickness, lineColor, lineOpacity);
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        if (!body.render.visible) {
          continue;
        }
        graphics.lineBetween(body.position.x, body.position.y, body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);
      }
      return this;
    },
    renderBodies: function(bodies) {
      var graphics = this.debugGraphic;
      var config2 = this.debugConfig;
      var showBody = config2.showBody;
      var showStaticBody = config2.showStaticBody;
      var showSleeping = config2.showSleeping;
      var showInternalEdges = config2.showInternalEdges;
      var showConvexHulls = config2.showConvexHulls;
      var renderFill = config2.renderFill;
      var renderLine = config2.renderLine;
      var staticBodySleepOpacity = config2.staticBodySleepOpacity;
      var sleepFillColor = config2.sleepFillColor;
      var sleepLineColor = config2.sleepLineColor;
      var hullColor = config2.hullColor;
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        if (!body.render.visible) {
          continue;
        }
        if (!showStaticBody && body.isStatic || !showBody && !body.isStatic) {
          continue;
        }
        var lineColor = body.render.lineColor;
        var lineOpacity = body.render.lineOpacity;
        var lineThickness = body.render.lineThickness;
        var fillColor = body.render.fillColor;
        var fillOpacity = body.render.fillOpacity;
        if (showSleeping && body.isSleeping) {
          if (body.isStatic) {
            lineOpacity *= staticBodySleepOpacity;
            fillOpacity *= staticBodySleepOpacity;
          } else {
            lineColor = sleepLineColor;
            fillColor = sleepFillColor;
          }
        }
        if (!renderFill) {
          fillColor = null;
        }
        if (!renderLine) {
          lineColor = null;
        }
        this.renderBody(body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity);
        var partsLength = body.parts.length;
        if (showConvexHulls && partsLength > 1) {
          this.renderConvexHull(body, graphics, hullColor, lineThickness);
        }
      }
    },
    renderBody: function(body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {
      if (lineColor === void 0) {
        lineColor = null;
      }
      if (lineOpacity === void 0) {
        lineOpacity = null;
      }
      if (lineThickness === void 0) {
        lineThickness = 1;
      }
      if (fillColor === void 0) {
        fillColor = null;
      }
      if (fillOpacity === void 0) {
        fillOpacity = null;
      }
      var config2 = this.debugConfig;
      var sensorFillColor = config2.sensorFillColor;
      var sensorLineColor = config2.sensorLineColor;
      var parts = body.parts;
      var partsLength = parts.length;
      for (var k = partsLength > 1 ? 1 : 0; k < partsLength; k++) {
        var part = parts[k];
        var render = part.render;
        var opacity = render.opacity;
        if (!render.visible || opacity === 0 || part.isSensor && !config2.showSensors) {
          continue;
        }
        var circleRadius = part.circleRadius;
        graphics.beginPath();
        if (part.isSensor) {
          if (fillColor !== null) {
            graphics.fillStyle(sensorFillColor, fillOpacity * opacity);
          }
          if (lineColor !== null) {
            graphics.lineStyle(lineThickness, sensorLineColor, lineOpacity * opacity);
          }
        } else {
          if (fillColor !== null) {
            graphics.fillStyle(fillColor, fillOpacity * opacity);
          }
          if (lineColor !== null) {
            graphics.lineStyle(lineThickness, lineColor, lineOpacity * opacity);
          }
        }
        if (circleRadius) {
          graphics.arc(part.position.x, part.position.y, circleRadius, 0, 2 * Math.PI);
        } else {
          var vertices = part.vertices;
          var vertLength = vertices.length;
          graphics.moveTo(vertices[0].x, vertices[0].y);
          for (var j = 1; j < vertLength; j++) {
            var vert = vertices[j];
            if (!vertices[j - 1].isInternal || showInternalEdges) {
              graphics.lineTo(vert.x, vert.y);
            } else {
              graphics.moveTo(vert.x, vert.y);
            }
            if (j < vertLength && vert.isInternal && !showInternalEdges) {
              var nextIndex = (j + 1) % vertLength;
              graphics.moveTo(vertices[nextIndex].x, vertices[nextIndex].y);
            }
          }
          graphics.closePath();
        }
        if (fillColor !== null) {
          graphics.fillPath();
        }
        if (lineColor !== null) {
          graphics.strokePath();
        }
      }
      if (config2.showPositions && !body.isStatic) {
        var px = body.position.x;
        var py = body.position.y;
        var hs = Math.ceil(config2.positionSize / 2);
        graphics.fillStyle(config2.positionColor, 1);
        graphics.fillRect(px - hs, py - hs, config2.positionSize, config2.positionSize);
      }
      return this;
    },
    renderConvexHull: function(body, graphics, hullColor, lineThickness) {
      if (lineThickness === void 0) {
        lineThickness = 1;
      }
      var parts = body.parts;
      var partsLength = parts.length;
      if (partsLength > 1) {
        var verts = body.vertices;
        graphics.lineStyle(lineThickness, hullColor);
        graphics.beginPath();
        graphics.moveTo(verts[0].x, verts[0].y);
        for (var v = 1; v < verts.length; v++) {
          graphics.lineTo(verts[v].x, verts[v].y);
        }
        graphics.lineTo(verts[0].x, verts[0].y);
        graphics.strokePath();
      }
      return this;
    },
    renderJoints: function() {
      var graphics = this.debugGraphic;
      var constraints = Composite.allConstraints(this.localWorld);
      for (var i = 0; i < constraints.length; i++) {
        var config2 = constraints[i].render;
        var lineColor = config2.lineColor;
        var lineOpacity = config2.lineOpacity;
        var lineThickness = config2.lineThickness;
        var pinSize = config2.pinSize;
        var anchorColor = config2.anchorColor;
        var anchorSize = config2.anchorSize;
        this.renderConstraint(constraints[i], graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize);
      }
    },
    renderConstraint: function(constraint, graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {
      var render = constraint.render;
      if (!render.visible || !constraint.pointA || !constraint.pointB) {
        return this;
      }
      graphics.lineStyle(lineThickness, lineColor, lineOpacity);
      var bodyA = constraint.bodyA;
      var bodyB = constraint.bodyB;
      var start;
      var end;
      if (bodyA) {
        start = Vector.add(bodyA.position, constraint.pointA);
      } else {
        start = constraint.pointA;
      }
      if (render.type === "pin") {
        graphics.strokeCircle(start.x, start.y, pinSize);
      } else {
        if (bodyB) {
          end = Vector.add(bodyB.position, constraint.pointB);
        } else {
          end = constraint.pointB;
        }
        graphics.beginPath();
        graphics.moveTo(start.x, start.y);
        if (render.type === "spring") {
          var delta = Vector.sub(end, start);
          var normal = Vector.perp(Vector.normalise(delta));
          var coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20));
          var offset;
          for (var j = 1; j < coils; j += 1) {
            offset = j % 2 === 0 ? 1 : -1;
            graphics.lineTo(start.x + delta.x * (j / coils) + normal.x * offset * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);
          }
        }
        graphics.lineTo(end.x, end.y);
      }
      graphics.strokePath();
      if (render.anchors && anchorSize > 0) {
        graphics.fillStyle(anchorColor);
        graphics.fillCircle(start.x, start.y, anchorSize);
        graphics.fillCircle(end.x, end.y, anchorSize);
      }
      return this;
    },
    resetCollisionIDs: function() {
      Body._nextCollidingGroupId = 1;
      Body._nextNonCollidingGroupId = -1;
      Body._nextCategory = 1;
      return this;
    },
    shutdown: function() {
      MatterEvents.off(this.engine);
      this.removeAllListeners();
      MatterWorld.clear(this.localWorld, false);
      Engine.clear(this.engine);
      if (this.drawDebug) {
        this.debugGraphic.destroy();
      }
    },
    destroy: function() {
      this.shutdown();
    }
  });
  module2.exports = World;
});

// node_modules/phaser/src/physics/matter-js/MatterPhysics.js
var require_MatterPhysics = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ALIGN_CONST = require_const2();
  var Axes = require_Axes();
  var Bodies = require_Bodies();
  var Body = require_Body2();
  var BodyBounds = require_BodyBounds();
  var Bounds = require_Bounds();
  var Class = require_Class();
  var Composite = require_Composite();
  var Composites = require_Composites();
  var Constraint = require_Constraint();
  var Detector = require_Detector();
  var DistanceBetween = require_DistanceBetween();
  var Factory = require_Factory2();
  var GetFastValue = require_GetFastValue();
  var GetValue = require_GetValue();
  var Grid = require_Grid2();
  var MatterAttractors = require_MatterAttractors();
  var MatterCollisionEvents = require_MatterCollisionEvents();
  var MatterLib = require_Matter();
  var MatterWrap = require_MatterWrap();
  var Merge = require_Merge();
  var Pair = require_Pair();
  var Pairs = require_Pairs();
  var Plugin = require_Plugin();
  var PluginCache = require_PluginCache();
  var Query = require_Query();
  var Resolver = require_Resolver();
  var SAT = require_SAT();
  var SceneEvents = require_events5();
  var Svg = require_Svg();
  var Vector = require_Vector();
  var Vertices = require_Vertices();
  var World = require_World3();
  var MatterPhysics = new Class({
    initialize: function MatterPhysics2(scene) {
      this.scene = scene;
      this.systems = scene.sys;
      this.config = this.getConfig();
      this.world;
      this.add;
      this.bodyBounds;
      this.body = Body;
      this.composite = Composite;
      this.detector = Detector;
      this.grid = Grid;
      this.pair = Pair;
      this.pairs = Pairs;
      this.query = Query;
      this.resolver = Resolver;
      this.sat = SAT;
      this.constraint = Constraint;
      this.bodies = Bodies;
      this.composites = Composites;
      this.axes = Axes;
      this.bounds = Bounds;
      this.svg = Svg;
      this.vector = Vector;
      this.vertices = Vertices;
      this.verts = Vertices;
      this._tempVec2 = Vector.create();
      if (GetValue(this.config, "plugins.collisionevents", true)) {
        this.enableCollisionEventsPlugin();
      }
      if (GetValue(this.config, "plugins.attractors", false)) {
        this.enableAttractorPlugin();
      }
      if (GetValue(this.config, "plugins.wrap", false)) {
        this.enableWrapPlugin();
      }
      Resolver._restingThresh = GetValue(this.config, "restingThresh", 4);
      Resolver._restingThreshTangent = GetValue(this.config, "restingThreshTangent", 6);
      Resolver._positionDampen = GetValue(this.config, "positionDampen", 0.9);
      Resolver._positionWarming = GetValue(this.config, "positionWarming", 0.8);
      Resolver._frictionNormalMultiplier = GetValue(this.config, "frictionNormalMultiplier", 5);
      scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
      scene.sys.events.on(SceneEvents.START, this.start, this);
    },
    boot: function() {
      this.world = new World(this.scene, this.config);
      this.add = new Factory(this.world);
      this.bodyBounds = new BodyBounds();
      this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
    },
    start: function() {
      if (!this.world) {
        this.world = new World(this.scene, this.config);
        this.add = new Factory(this.world);
      }
      var eventEmitter = this.systems.events;
      eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);
      eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
      eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    getConfig: function() {
      var gameConfig = this.systems.game.config.physics;
      var sceneConfig = this.systems.settings.physics;
      var config2 = Merge(GetFastValue(sceneConfig, "matter", {}), GetFastValue(gameConfig, "matter", {}));
      return config2;
    },
    enableAttractorPlugin: function() {
      Plugin.register(MatterAttractors);
      Plugin.use(MatterLib, MatterAttractors);
      return this;
    },
    enableWrapPlugin: function() {
      Plugin.register(MatterWrap);
      Plugin.use(MatterLib, MatterWrap);
      return this;
    },
    enableCollisionEventsPlugin: function() {
      Plugin.register(MatterCollisionEvents);
      Plugin.use(MatterLib, MatterCollisionEvents);
      return this;
    },
    pause: function() {
      return this.world.pause();
    },
    resume: function() {
      return this.world.resume();
    },
    set60Hz: function() {
      this.world.getDelta = this.world.update60Hz;
      this.world.autoUpdate = true;
      return this;
    },
    set30Hz: function() {
      this.world.getDelta = this.world.update30Hz;
      this.world.autoUpdate = true;
      return this;
    },
    step: function(delta, correction) {
      this.world.step(delta, correction);
    },
    containsPoint: function(body, x, y) {
      body = this.getMatterBodies(body);
      var position = Vector.create(x, y);
      var result = Query.point(body, position);
      return result.length > 0 ? true : false;
    },
    intersectPoint: function(x, y, bodies) {
      bodies = this.getMatterBodies(bodies);
      var position = Vector.create(x, y);
      var output = [];
      var result = Query.point(bodies, position);
      result.forEach(function(body) {
        if (output.indexOf(body) === -1) {
          output.push(body);
        }
      });
      return output;
    },
    intersectRect: function(x, y, width, height, outside, bodies) {
      if (outside === void 0) {
        outside = false;
      }
      bodies = this.getMatterBodies(bodies);
      var bounds = {
        min: {x, y},
        max: {x: x + width, y: y + height}
      };
      var output = [];
      var result = Query.region(bodies, bounds, outside);
      result.forEach(function(body) {
        if (output.indexOf(body) === -1) {
          output.push(body);
        }
      });
      return output;
    },
    intersectRay: function(x1, y1, x2, y2, rayWidth, bodies) {
      if (rayWidth === void 0) {
        rayWidth = 1;
      }
      bodies = this.getMatterBodies(bodies);
      var result = [];
      var collisions = Query.ray(bodies, Vector.create(x1, y1), Vector.create(x2, y2), rayWidth);
      for (var i = 0; i < collisions.length; i++) {
        result.push(collisions[i].body);
      }
      return result;
    },
    intersectBody: function(body, bodies) {
      bodies = this.getMatterBodies(bodies);
      var result = [];
      var collisions = Query.collides(body, bodies);
      for (var i = 0; i < collisions.length; i++) {
        var pair = collisions[i];
        if (pair.bodyA === body) {
          result.push(pair.bodyB);
        } else {
          result.push(pair.bodyA);
        }
      }
      return result;
    },
    overlap: function(target, bodies, overlapCallback, processCallback, callbackContext) {
      if (overlapCallback === void 0) {
        overlapCallback = null;
      }
      if (processCallback === void 0) {
        processCallback = null;
      }
      if (callbackContext === void 0) {
        callbackContext = overlapCallback;
      }
      if (!Array.isArray(target)) {
        target = [target];
      }
      target = this.getMatterBodies(target);
      bodies = this.getMatterBodies(bodies);
      var match = false;
      for (var i = 0; i < target.length; i++) {
        var entry = target[i];
        var collisions = Query.collides(entry, bodies);
        for (var c = 0; c < collisions.length; c++) {
          var info = collisions[c];
          var bodyB = info.bodyA.id === entry.id ? info.bodyB : info.bodyA;
          if (!processCallback || processCallback.call(callbackContext, entry, bodyB, info)) {
            match = true;
            if (overlapCallback) {
              overlapCallback.call(callbackContext, entry, bodyB, info);
            } else if (!processCallback) {
              return true;
            }
          }
        }
      }
      return match;
    },
    setCollisionCategory: function(bodies, value) {
      bodies = this.getMatterBodies(bodies);
      bodies.forEach(function(body) {
        body.collisionFilter.category = value;
      });
      return this;
    },
    setCollisionGroup: function(bodies, value) {
      bodies = this.getMatterBodies(bodies);
      bodies.forEach(function(body) {
        body.collisionFilter.group = value;
      });
      return this;
    },
    setCollidesWith: function(bodies, categories) {
      bodies = this.getMatterBodies(bodies);
      var flags = 0;
      if (!Array.isArray(categories)) {
        flags = categories;
      } else {
        for (var i = 0; i < categories.length; i++) {
          flags |= categories[i];
        }
      }
      bodies.forEach(function(body) {
        body.collisionFilter.mask = flags;
      });
      return this;
    },
    getMatterBodies: function(bodies) {
      if (!bodies) {
        return this.world.getAllBodies();
      }
      if (!Array.isArray(bodies)) {
        bodies = [bodies];
      }
      var output = [];
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i].hasOwnProperty("body") ? bodies[i].body : bodies[i];
        output.push(body);
      }
      return output;
    },
    setVelocity: function(bodies, x, y) {
      bodies = this.getMatterBodies(bodies);
      var vec2 = this._tempVec2;
      vec2.x = x;
      vec2.y = y;
      bodies.forEach(function(body) {
        Body.setVelocity(body, vec2);
      });
      return this;
    },
    setVelocityX: function(bodies, x) {
      bodies = this.getMatterBodies(bodies);
      var vec2 = this._tempVec2;
      vec2.x = x;
      bodies.forEach(function(body) {
        vec2.y = body.velocity.y;
        Body.setVelocity(body, vec2);
      });
      return this;
    },
    setVelocityY: function(bodies, y) {
      bodies = this.getMatterBodies(bodies);
      var vec2 = this._tempVec2;
      vec2.y = y;
      bodies.forEach(function(body) {
        vec2.x = body.velocity.x;
        Body.setVelocity(body, vec2);
      });
      return this;
    },
    setAngularVelocity: function(bodies, value) {
      bodies = this.getMatterBodies(bodies);
      bodies.forEach(function(body) {
        Body.setAngularVelocity(body, value);
      });
      return this;
    },
    applyForce: function(bodies, force) {
      bodies = this.getMatterBodies(bodies);
      var vec2 = this._tempVec2;
      bodies.forEach(function(body) {
        vec2.x = body.position.x;
        vec2.y = body.position.y;
        Body.applyForce(body, vec2, force);
      });
      return this;
    },
    applyForceFromPosition: function(bodies, position, speed, angle) {
      bodies = this.getMatterBodies(bodies);
      var vec2 = this._tempVec2;
      bodies.forEach(function(body) {
        if (angle === void 0) {
          angle = body.angle;
        }
        vec2.x = speed * Math.cos(angle);
        vec2.y = speed * Math.sin(angle);
        Body.applyForce(body, position, vec2);
      });
      return this;
    },
    applyForceFromAngle: function(bodies, speed, angle) {
      bodies = this.getMatterBodies(bodies);
      var vec2 = this._tempVec2;
      bodies.forEach(function(body) {
        if (angle === void 0) {
          angle = body.angle;
        }
        vec2.x = speed * Math.cos(angle);
        vec2.y = speed * Math.sin(angle);
        Body.applyForce(body, {x: body.position.x, y: body.position.y}, vec2);
      });
      return this;
    },
    getConstraintLength: function(constraint) {
      var aX = constraint.pointA.x;
      var aY = constraint.pointA.y;
      var bX = constraint.pointB.x;
      var bY = constraint.pointB.y;
      if (constraint.bodyA) {
        aX += constraint.bodyA.position.x;
        aY += constraint.bodyA.position.y;
      }
      if (constraint.bodyB) {
        bX += constraint.bodyB.position.x;
        bY += constraint.bodyB.position.y;
      }
      return DistanceBetween(aX, aY, bX, bY);
    },
    alignBody: function(body, x, y, align) {
      body = body.hasOwnProperty("body") ? body.body : body;
      var pos;
      switch (align) {
        case ALIGN_CONST.TOP_LEFT:
        case ALIGN_CONST.LEFT_TOP:
          pos = this.bodyBounds.getTopLeft(body, x, y);
          break;
        case ALIGN_CONST.TOP_CENTER:
          pos = this.bodyBounds.getTopCenter(body, x, y);
          break;
        case ALIGN_CONST.TOP_RIGHT:
        case ALIGN_CONST.RIGHT_TOP:
          pos = this.bodyBounds.getTopRight(body, x, y);
          break;
        case ALIGN_CONST.LEFT_CENTER:
          pos = this.bodyBounds.getLeftCenter(body, x, y);
          break;
        case ALIGN_CONST.CENTER:
          pos = this.bodyBounds.getCenter(body, x, y);
          break;
        case ALIGN_CONST.RIGHT_CENTER:
          pos = this.bodyBounds.getRightCenter(body, x, y);
          break;
        case ALIGN_CONST.LEFT_BOTTOM:
        case ALIGN_CONST.BOTTOM_LEFT:
          pos = this.bodyBounds.getBottomLeft(body, x, y);
          break;
        case ALIGN_CONST.BOTTOM_CENTER:
          pos = this.bodyBounds.getBottomCenter(body, x, y);
          break;
        case ALIGN_CONST.BOTTOM_RIGHT:
        case ALIGN_CONST.RIGHT_BOTTOM:
          pos = this.bodyBounds.getBottomRight(body, x, y);
          break;
      }
      if (pos) {
        Body.setPosition(body, pos);
      }
      return this;
    },
    shutdown: function() {
      var eventEmitter = this.systems.events;
      if (this.world) {
        eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);
        eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);
      }
      eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
      if (this.add) {
        this.add.destroy();
      }
      if (this.world) {
        this.world.destroy();
      }
      this.add = null;
      this.world = null;
    },
    destroy: function() {
      this.shutdown();
      this.scene.sys.events.off(SceneEvents.START, this.start, this);
      this.scene = null;
      this.systems = null;
    }
  });
  PluginCache.register("MatterPhysics", MatterPhysics, "matterPhysics");
  module2.exports = MatterPhysics;
});

// node_modules/phaser/src/physics/matter-js/index.js
var require_matter_js = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    BodyBounds: require_BodyBounds(),
    Components: require_components3(),
    Events: require_events20(),
    Factory: require_Factory2(),
    MatterGameObject: require_MatterGameObject(),
    Image: require_MatterImage(),
    Matter: require_CustomMain(),
    MatterPhysics: require_MatterPhysics(),
    PolyDecomp: require_poly_decomp(),
    Sprite: require_MatterSprite(),
    TileBody: require_MatterTileBody(),
    PhysicsEditorParser: require_PhysicsEditorParser(),
    PhysicsJSONParser: require_PhysicsJSONParser(),
    PointerConstraint: require_PointerConstraint(),
    World: require_World3()
  };
});

// node_modules/phaser/src/physics/index.js
var require_physics = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Arcade: require_arcade(),
    Matter: require_matter_js()
  };
});

// node_modules/phaser/src/plugins/BasePlugin.js
var require_BasePlugin = __commonJS((exports2, module2) => {
  /**
  * @author       Richard Davey <rich@photonstorm.com>
  * @copyright    2020 Photon Storm Ltd.
  * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
  */
  var Class = require_Class();
  var BasePlugin = new Class({
    initialize: function BasePlugin2(pluginManager) {
      this.pluginManager = pluginManager;
      this.game = pluginManager.game;
    },
    init: function() {
    },
    start: function() {
    },
    stop: function() {
    },
    destroy: function() {
      this.pluginManager = null;
      this.game = null;
      this.scene = null;
      this.systems = null;
    }
  });
  module2.exports = BasePlugin;
});

// node_modules/phaser/src/plugins/ScenePlugin.js
var require_ScenePlugin = __commonJS((exports2, module2) => {
  /**
  * @author       Richard Davey <rich@photonstorm.com>
  * @copyright    2020 Photon Storm Ltd.
  * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
  */
  var BasePlugin = require_BasePlugin();
  var Class = require_Class();
  var SceneEvents = require_events5();
  var ScenePlugin = new Class({
    Extends: BasePlugin,
    initialize: function ScenePlugin2(scene, pluginManager, pluginKey) {
      BasePlugin.call(this, pluginManager);
      this.scene = scene;
      this.systems = scene.sys;
      this.pluginKey = pluginKey;
      scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
    },
    boot: function() {
    },
    destroy: function() {
      this.pluginManager = null;
      this.game = null;
      this.scene = null;
      this.systems = null;
    }
  });
  module2.exports = ScenePlugin;
});

// node_modules/phaser/src/plugins/index.js
var require_plugins = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    BasePlugin: require_BasePlugin(),
    DefaultPlugins: require_DefaultPlugins(),
    PluginCache: require_PluginCache(),
    PluginManager: require_PluginManager(),
    ScenePlugin: require_ScenePlugin()
  };
});

// node_modules/phaser/src/renderer/canvas/index.js
var require_canvas2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    CanvasRenderer: require_CanvasRenderer(),
    GetBlendModes: require_GetBlendModes(),
    SetTransform: require_SetTransform()
  };
});

// node_modules/phaser/src/renderer/snapshot/index.js
var require_snapshot = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Canvas: require_CanvasSnapshot(),
    WebGL: require_WebGLSnapshot()
  };
});

// node_modules/phaser/src/renderer/webgl/shaders/PostFX-frag.js
var require_PostFX_frag = __commonJS((exports2, module2) => {
  module2.exports = [
    "#define SHADER_NAME PHASER_POSTFX_FS",
    "",
    "precision mediump float;",
    "",
    "uniform sampler2D uMainSampler;",
    "",
    "varying vec2 outTexCoord;",
    "",
    "void main ()",
    "{",
    "    gl_FragColor = texture2D(uMainSampler, outTexCoord);",
    "}",
    ""
  ].join("\n");
});

// node_modules/phaser/src/renderer/webgl/pipelines/PostFXPipeline.js
var require_PostFXPipeline = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var ColorMatrix = require_ColorMatrix();
  var GetFastValue = require_GetFastValue();
  var ShaderSourceFS = require_PostFX_frag();
  var ShaderSourceVS = require_Quad_vert();
  var WebGLPipeline = require_WebGLPipeline();
  var PostFXPipeline = new Class({
    Extends: WebGLPipeline,
    initialize: function PostFXPipeline2(config2) {
      config2.renderTarget = GetFastValue(config2, "renderTarget", 1);
      config2.fragShader = GetFastValue(config2, "fragShader", ShaderSourceFS);
      config2.vertShader = GetFastValue(config2, "vertShader", ShaderSourceVS);
      config2.attributes = GetFastValue(config2, "attributes", [
        {
          name: "inPosition",
          size: 2
        },
        {
          name: "inTexCoord",
          size: 2
        }
      ]);
      config2.batchSize = 1;
      config2.vertices = [
        -1,
        -1,
        0,
        0,
        -1,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        -1,
        1,
        0
      ];
      WebGLPipeline.call(this, config2);
      this.isPostFX = true;
      this.gameObject;
      this.colorMatrix = new ColorMatrix();
      this.fullFrame1;
      this.fullFrame2;
      this.halfFrame1;
      this.halfFrame2;
      if (this.renderer.isBooted) {
        this.manager = this.renderer.pipelines;
        this.boot();
      }
    },
    boot: function() {
      WebGLPipeline.prototype.boot.call(this);
      var utility = this.manager.UTILITY_PIPELINE;
      this.fullFrame1 = utility.fullFrame1;
      this.fullFrame2 = utility.fullFrame2;
      this.halfFrame1 = utility.halfFrame1;
      this.halfFrame2 = utility.halfFrame2;
      this.set1i("uMainSampler", 0);
    },
    onDraw: function(renderTarget) {
      this.bindAndDraw(renderTarget);
    },
    copyFrame: function(source, target, brightness, clear, clearAlpha) {
      this.manager.copyFrame(source, target, brightness, clear, clearAlpha);
    },
    copyToGame: function(source) {
      this.manager.copyToGame(source);
    },
    drawFrame: function(source, target, clearAlpha) {
      this.manager.drawFrame(source, target, clearAlpha, this.colorMatrix);
    },
    blendFrames: function(source1, source2, target, strength, clearAlpha) {
      this.manager.blendFrames(source1, source2, target, strength, clearAlpha);
    },
    blendFramesAdditive: function(source1, source2, target, strength, clearAlpha) {
      this.manager.blendFramesAdditive(source1, source2, target, strength, clearAlpha);
    },
    clearFrame: function(target, clearAlpha) {
      this.manager.clearFrame(target, clearAlpha);
    },
    blitFrame: function(source, target, brightness, clear, clearAlpha, eraseMode) {
      this.manager.blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);
    },
    copyFrameRect: function(source, target, x, y, width, height, clear, clearAlpha) {
      this.manager.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);
    },
    bindAndDraw: function(source, target, clear, clearAlpha, currentShader) {
      if (clear === void 0) {
        clear = true;
      }
      if (clearAlpha === void 0) {
        clearAlpha = true;
      }
      var gl = this.gl;
      var renderer = this.renderer;
      this.bind(currentShader);
      this.set1i("uMainSampler", 0);
      if (target) {
        gl.viewport(0, 0, target.width, target.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);
        if (clear) {
          if (clearAlpha) {
            gl.clearColor(0, 0, 0, 0);
          } else {
            gl.clearColor(0, 0, 0, 1);
          }
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
      } else {
        renderer.popFramebuffer(false, false, false);
        if (!renderer.currentFramebuffer) {
          gl.viewport(0, 0, renderer.width, renderer.height);
        }
      }
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, source.texture);
      gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      if (!target) {
        renderer.resetTextures();
      } else {
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
    }
  });
  module2.exports = PostFXPipeline;
});

// node_modules/phaser/src/renderer/webgl/pipelines/index.js
var require_pipelines = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const6();
  var Extend = require_Extend();
  var Pipelines = {
    BitmapMaskPipeline: require_BitmapMaskPipeline(),
    Events: require_events11(),
    GraphicsPipeline: require_GraphicsPipeline(),
    LightPipeline: require_LightPipeline(),
    MultiPipeline: require_MultiPipeline(),
    PointLightPipeline: require_PointLightPipeline(),
    PostFXPipeline: require_PostFXPipeline(),
    RopePipeline: require_RopePipeline(),
    SinglePipeline: require_SinglePipeline(),
    UtilityPipeline: require_UtilityPipeline()
  };
  Pipelines = Extend(false, Pipelines, CONST);
  module2.exports = Pipelines;
});

// node_modules/phaser/src/renderer/webgl/index.js
var require_webgl = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var WEBGL_CONST = require_const7();
  var Extend = require_Extend();
  var WebGL = {
    PipelineManager: require_PipelineManager(),
    Pipelines: require_pipelines(),
    RenderTarget: require_RenderTarget(),
    Utils: require_Utils(),
    WebGLPipeline: require_WebGLPipeline(),
    WebGLRenderer: require_WebGLRenderer(),
    WebGLShader: require_WebGLShader()
  };
  WebGL = Extend(false, WebGL, WEBGL_CONST);
  module2.exports = WebGL;
});

// node_modules/phaser/src/renderer/index.js
var require_renderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Canvas: require_canvas2(),
    Events: require_events2(),
    Snapshot: require_snapshot(),
    WebGL: require_webgl()
  };
});

// node_modules/phaser/src/scale/index.js
var require_scale = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Extend = require_Extend();
  var CONST = require_const8();
  var Scale = {
    Center: require_CENTER_CONST(),
    Events: require_events9(),
    Orientation: require_ORIENTATION_CONST(),
    ScaleManager: require_ScaleManager(),
    ScaleModes: require_SCALE_MODE_CONST(),
    Zoom: require_ZOOM_CONST()
  };
  Scale = Extend(false, Scale, CONST.CENTER);
  Scale = Extend(false, Scale, CONST.ORIENTATION);
  Scale = Extend(false, Scale, CONST.SCALE_MODE);
  Scale = Extend(false, Scale, CONST.ZOOM);
  module2.exports = Scale;
});

// node_modules/phaser/src/scene/ScenePlugin.js
var require_ScenePlugin2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clamp = require_Clamp();
  var Class = require_Class();
  var Events = require_events5();
  var GetFastValue = require_GetFastValue();
  var PluginCache = require_PluginCache();
  var ScenePlugin = new Class({
    initialize: function ScenePlugin2(scene) {
      this.scene = scene;
      this.systems = scene.sys;
      this.settings = scene.sys.settings;
      this.key = scene.sys.settings.key;
      this.manager = scene.sys.game.scene;
      this.transitionProgress = 0;
      this._elapsed = 0;
      this._target = null;
      this._duration = 0;
      this._onUpdate;
      this._onUpdateScope;
      this._willSleep = false;
      this._willRemove = false;
      scene.sys.events.once(Events.BOOT, this.boot, this);
      scene.sys.events.on(Events.START, this.pluginStart, this);
    },
    boot: function() {
      this.systems.events.once(Events.DESTROY, this.destroy, this);
    },
    pluginStart: function() {
      this._target = null;
      this.systems.events.once(Events.SHUTDOWN, this.shutdown, this);
    },
    start: function(key, data) {
      if (key === void 0) {
        key = this.key;
      }
      this.manager.queueOp("stop", this.key);
      this.manager.queueOp("start", key, data);
      return this;
    },
    restart: function(data) {
      var key = this.key;
      this.manager.queueOp("stop", key);
      this.manager.queueOp("start", key, data);
      return this;
    },
    transition: function(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      var key = GetFastValue(config2, "target", false);
      var target = this.manager.getScene(key);
      if (!key || !this.checkValidTransition(target)) {
        return false;
      }
      var duration = GetFastValue(config2, "duration", 1e3);
      this._elapsed = 0;
      this._target = target;
      this._duration = duration;
      this._willSleep = GetFastValue(config2, "sleep", false);
      this._willRemove = GetFastValue(config2, "remove", false);
      var callback = GetFastValue(config2, "onUpdate", null);
      if (callback) {
        this._onUpdate = callback;
        this._onUpdateScope = GetFastValue(config2, "onUpdateScope", this.scene);
      }
      var allowInput = GetFastValue(config2, "allowInput", false);
      this.settings.transitionAllowInput = allowInput;
      var targetSettings = target.sys.settings;
      targetSettings.isTransition = true;
      targetSettings.transitionFrom = this.scene;
      targetSettings.transitionDuration = duration;
      targetSettings.transitionAllowInput = allowInput;
      if (GetFastValue(config2, "moveAbove", false)) {
        this.manager.moveAbove(this.key, key);
      } else if (GetFastValue(config2, "moveBelow", false)) {
        this.manager.moveBelow(this.key, key);
      }
      if (target.sys.isSleeping()) {
        target.sys.wake(GetFastValue(config2, "data"));
      } else {
        this.manager.start(key, GetFastValue(config2, "data"));
      }
      this.systems.events.emit(Events.TRANSITION_OUT, target, duration);
      this.systems.events.on(Events.UPDATE, this.step, this);
      return true;
    },
    checkValidTransition: function(target) {
      if (!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning()) {
        return false;
      }
      return true;
    },
    step: function(time, delta) {
      this._elapsed += delta;
      this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1);
      if (this._onUpdate) {
        this._onUpdate.call(this._onUpdateScope, this.transitionProgress);
      }
      if (this._elapsed >= this._duration) {
        this.transitionComplete();
      }
    },
    transitionComplete: function() {
      var targetSys = this._target.sys;
      var targetSettings = this._target.sys.settings;
      this.systems.events.off(Events.UPDATE, this.step, this);
      targetSys.events.emit(Events.TRANSITION_COMPLETE, this.scene);
      targetSettings.isTransition = false;
      targetSettings.transitionFrom = null;
      this._duration = 0;
      this._target = null;
      this._onUpdate = null;
      this._onUpdateScope = null;
      if (this._willRemove) {
        this.manager.remove(this.key);
      } else if (this._willSleep) {
        this.systems.sleep();
      } else {
        this.manager.stop(this.key);
      }
    },
    add: function(key, sceneConfig, autoStart, data) {
      return this.manager.add(key, sceneConfig, autoStart, data);
    },
    launch: function(key, data) {
      if (key && key !== this.key) {
        this.manager.queueOp("start", key, data);
      }
      return this;
    },
    run: function(key, data) {
      if (key && key !== this.key) {
        this.manager.queueOp("run", key, data);
      }
      return this;
    },
    pause: function(key, data) {
      if (key === void 0) {
        key = this.key;
      }
      this.manager.queueOp("pause", key, data);
      return this;
    },
    resume: function(key, data) {
      if (key === void 0) {
        key = this.key;
      }
      this.manager.queueOp("resume", key, data);
      return this;
    },
    sleep: function(key, data) {
      if (key === void 0) {
        key = this.key;
      }
      this.manager.queueOp("sleep", key, data);
      return this;
    },
    wake: function(key, data) {
      if (key === void 0) {
        key = this.key;
      }
      this.manager.queueOp("wake", key, data);
      return this;
    },
    switch: function(key) {
      if (key !== this.key) {
        this.manager.queueOp("switch", this.key, key);
      }
      return this;
    },
    stop: function(key, data) {
      if (key === void 0) {
        key = this.key;
      }
      this.manager.queueOp("stop", key, data);
      return this;
    },
    setActive: function(value, key, data) {
      if (key === void 0) {
        key = this.key;
      }
      var scene = this.manager.getScene(key);
      if (scene) {
        scene.sys.setActive(value, data);
      }
      return this;
    },
    setVisible: function(value, key) {
      if (key === void 0) {
        key = this.key;
      }
      var scene = this.manager.getScene(key);
      if (scene) {
        scene.sys.setVisible(value);
      }
      return this;
    },
    isSleeping: function(key) {
      if (key === void 0) {
        key = this.key;
      }
      return this.manager.isSleeping(key);
    },
    isActive: function(key) {
      if (key === void 0) {
        key = this.key;
      }
      return this.manager.isActive(key);
    },
    isPaused: function(key) {
      if (key === void 0) {
        key = this.key;
      }
      return this.manager.isPaused(key);
    },
    isVisible: function(key) {
      if (key === void 0) {
        key = this.key;
      }
      return this.manager.isVisible(key);
    },
    swapPosition: function(keyA, keyB) {
      if (keyB === void 0) {
        keyB = this.key;
      }
      if (keyA !== keyB) {
        this.manager.swapPosition(keyA, keyB);
      }
      return this;
    },
    moveAbove: function(keyA, keyB) {
      if (keyB === void 0) {
        keyB = this.key;
      }
      if (keyA !== keyB) {
        this.manager.moveAbove(keyA, keyB);
      }
      return this;
    },
    moveBelow: function(keyA, keyB) {
      if (keyB === void 0) {
        keyB = this.key;
      }
      if (keyA !== keyB) {
        this.manager.moveBelow(keyA, keyB);
      }
      return this;
    },
    remove: function(key) {
      if (key === void 0) {
        key = this.key;
      }
      this.manager.remove(key);
      return this;
    },
    moveUp: function(key) {
      if (key === void 0) {
        key = this.key;
      }
      this.manager.moveUp(key);
      return this;
    },
    moveDown: function(key) {
      if (key === void 0) {
        key = this.key;
      }
      this.manager.moveDown(key);
      return this;
    },
    bringToTop: function(key) {
      if (key === void 0) {
        key = this.key;
      }
      this.manager.bringToTop(key);
      return this;
    },
    sendToBack: function(key) {
      if (key === void 0) {
        key = this.key;
      }
      this.manager.sendToBack(key);
      return this;
    },
    get: function(key) {
      return this.manager.getScene(key);
    },
    getIndex: function(key) {
      if (key === void 0) {
        key = this.key;
      }
      return this.manager.getIndex(key);
    },
    shutdown: function() {
      var eventEmitter = this.systems.events;
      eventEmitter.off(Events.SHUTDOWN, this.shutdown, this);
      eventEmitter.off(Events.POST_UPDATE, this.step, this);
      eventEmitter.off(Events.TRANSITION_OUT);
    },
    destroy: function() {
      this.shutdown();
      this.scene.sys.events.off(Events.START, this.start, this);
      this.scene = null;
      this.systems = null;
      this.settings = null;
      this.manager = null;
    }
  });
  PluginCache.register("ScenePlugin", ScenePlugin, "scenePlugin");
  module2.exports = ScenePlugin;
});

// node_modules/phaser/src/scene/index.js
var require_scene = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const10();
  var Extend = require_Extend();
  var Scene = {
    Events: require_events5(),
    GetPhysicsPlugins: require_GetPhysicsPlugins(),
    GetScenePlugins: require_GetScenePlugins(),
    SceneManager: require_SceneManager(),
    ScenePlugin: require_ScenePlugin2(),
    Settings: require_Settings(),
    Systems: require_Systems()
  };
  Scene = Extend(false, Scene, CONST);
  module2.exports = Scene;
});

// node_modules/phaser/src/structs/index.js
var require_structs = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Events: require_events16(),
    List: require_List(),
    Map: require_Map(),
    ProcessQueue: require_ProcessQueue(),
    RTree: require_RTree(),
    Set: require_Set(),
    Size: require_Size2()
  };
});

// node_modules/phaser/src/textures/const.js
var require_const14 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = {
    LINEAR: 0,
    NEAREST: 1
  };
  module2.exports = CONST;
});

// node_modules/phaser/src/textures/index.js
var require_textures = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Extend = require_Extend();
  var FilterMode = require_const14();
  var Textures = {
    CanvasTexture: require_CanvasTexture(),
    Events: require_events10(),
    FilterMode,
    Frame: require_Frame(),
    Parsers: require_parsers(),
    Texture: require_Texture2(),
    TextureManager: require_TextureManager(),
    TextureSource: require_TextureSource()
  };
  Textures = Extend(false, Textures, FilterMode);
  module2.exports = Textures;
});

// node_modules/phaser/src/tilemaps/const/ORIENTATION_CONST.js
var require_ORIENTATION_CONST2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ORTHOGONAL: 0,
    ISOMETRIC: 1,
    STAGGERED: 2,
    HEXAGONAL: 3
  };
});

// node_modules/phaser/src/tilemaps/const/index.js
var require_const15 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = {
    ORIENTATION: require_ORIENTATION_CONST2()
  };
  module2.exports = CONST;
});

// node_modules/phaser/src/tilemaps/components/IsInLayerBounds.js
var require_IsInLayerBounds = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var IsInLayerBounds = function(tileX, tileY, layer) {
    return tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height;
  };
  module2.exports = IsInLayerBounds;
});

// node_modules/phaser/src/tilemaps/components/GetTileAt.js
var require_GetTileAt = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var IsInLayerBounds = require_IsInLayerBounds();
  var GetTileAt = function(tileX, tileY, nonNull, layer) {
    if (nonNull === void 0) {
      nonNull = false;
    }
    if (IsInLayerBounds(tileX, tileY, layer)) {
      var tile = layer.data[tileY][tileX] || null;
      if (!tile) {
        return null;
      } else if (tile.index === -1) {
        return nonNull ? tile : null;
      } else {
        return tile;
      }
    } else {
      return null;
    }
  };
  module2.exports = GetTileAt;
});

// node_modules/phaser/src/tilemaps/components/CalculateFacesAt.js
var require_CalculateFacesAt = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTileAt = require_GetTileAt();
  var CalculateFacesAt = function(tileX, tileY, layer) {
    var tile = GetTileAt(tileX, tileY, true, layer);
    var above = GetTileAt(tileX, tileY - 1, true, layer);
    var below = GetTileAt(tileX, tileY + 1, true, layer);
    var left = GetTileAt(tileX - 1, tileY, true, layer);
    var right = GetTileAt(tileX + 1, tileY, true, layer);
    var tileCollides = tile && tile.collides;
    if (tileCollides) {
      tile.faceTop = true;
      tile.faceBottom = true;
      tile.faceLeft = true;
      tile.faceRight = true;
    }
    if (above && above.collides) {
      if (tileCollides) {
        tile.faceTop = false;
      }
      above.faceBottom = !tileCollides;
    }
    if (below && below.collides) {
      if (tileCollides) {
        tile.faceBottom = false;
      }
      below.faceTop = !tileCollides;
    }
    if (left && left.collides) {
      if (tileCollides) {
        tile.faceLeft = false;
      }
      left.faceRight = !tileCollides;
    }
    if (right && right.collides) {
      if (tileCollides) {
        tile.faceRight = false;
      }
      right.faceLeft = !tileCollides;
    }
    if (tile && !tile.collides) {
      tile.resetFaces();
    }
    return tile;
  };
  module2.exports = CalculateFacesAt;
});

// node_modules/phaser/src/tilemaps/components/CalculateFacesWithin.js
var require_CalculateFacesWithin = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTileAt = require_GetTileAt();
  var GetTilesWithin = require_GetTilesWithin();
  var CalculateFacesWithin = function(tileX, tileY, width, height, layer) {
    var above = null;
    var below = null;
    var left = null;
    var right = null;
    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
    for (var i = 0; i < tiles.length; i++) {
      var tile = tiles[i];
      if (tile) {
        if (tile.collides) {
          above = GetTileAt(tile.x, tile.y - 1, true, layer);
          below = GetTileAt(tile.x, tile.y + 1, true, layer);
          left = GetTileAt(tile.x - 1, tile.y, true, layer);
          right = GetTileAt(tile.x + 1, tile.y, true, layer);
          tile.faceTop = above && above.collides ? false : true;
          tile.faceBottom = below && below.collides ? false : true;
          tile.faceLeft = left && left.collides ? false : true;
          tile.faceRight = right && right.collides ? false : true;
        } else {
          tile.resetFaces();
        }
      }
    }
  };
  module2.exports = CalculateFacesWithin;
});

// node_modules/phaser/src/tilemaps/components/CheckIsoBounds.js
var require_CheckIsoBounds = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector2 = require_Vector2();
  var point = new Vector2();
  var CheckIsoBounds = function(tileX, tileY, layer, camera) {
    var tilemapLayer = layer.tilemapLayer;
    var cullPaddingX = tilemapLayer.cullPaddingX;
    var cullPaddingY = tilemapLayer.cullPaddingY;
    var pos = tilemapLayer.tilemap.tileToWorldXY(tileX, tileY, point, camera, tilemapLayer);
    return pos.x > camera.worldView.x + tilemapLayer.scaleX * layer.tileWidth * (-cullPaddingX - 0.5) && pos.x < camera.worldView.right + tilemapLayer.scaleX * layer.tileWidth * (cullPaddingX - 0.5) && pos.y > camera.worldView.y + tilemapLayer.scaleY * layer.tileHeight * (-cullPaddingY - 1) && pos.y < camera.worldView.bottom + tilemapLayer.scaleY * layer.tileHeight * (cullPaddingY - 0.5);
  };
  module2.exports = CheckIsoBounds;
});

// node_modules/phaser/src/tilemaps/components/Copy.js
var require_Copy = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var CalculateFacesWithin = require_CalculateFacesWithin();
  var Copy = function(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {
    if (recalculateFaces === void 0) {
      recalculateFaces = true;
    }
    if (srcTileX < 0) {
      srcTileX = 0;
    }
    if (srcTileY < 0) {
      srcTileY = 0;
    }
    var srcTiles = GetTilesWithin(srcTileX, srcTileY, width, height, null, layer);
    var offsetX = destTileX - srcTileX;
    var offsetY = destTileY - srcTileY;
    for (var i = 0; i < srcTiles.length; i++) {
      var tileX = srcTiles[i].x + offsetX;
      var tileY = srcTiles[i].y + offsetY;
      if (tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height) {
        if (layer.data[tileY][tileX]) {
          layer.data[tileY][tileX].copy(srcTiles[i]);
        }
      }
    }
    if (recalculateFaces) {
      CalculateFacesWithin(destTileX - 1, destTileY - 1, width + 2, height + 2, layer);
    }
  };
  module2.exports = Copy;
});

// node_modules/phaser/src/tilemaps/components/ReplaceByIndex.js
var require_ReplaceByIndex = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var ReplaceByIndex = function(findIndex, newIndex, tileX, tileY, width, height, layer) {
    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
    for (var i = 0; i < tiles.length; i++) {
      if (tiles[i] && tiles[i].index === findIndex) {
        tiles[i].index = newIndex;
      }
    }
  };
  module2.exports = ReplaceByIndex;
});

// node_modules/phaser/src/tilemaps/components/CreateFromTiles.js
var require_CreateFromTiles = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var ReplaceByIndex = require_ReplaceByIndex();
  var CreateFromTiles = function(indexes, replacements, spriteConfig, scene, camera, layer) {
    if (!spriteConfig) {
      spriteConfig = {};
    }
    if (!Array.isArray(indexes)) {
      indexes = [indexes];
    }
    var tilemapLayer = layer.tilemapLayer;
    if (!scene) {
      scene = tilemapLayer.scene;
    }
    if (!camera) {
      camera = scene.cameras.main;
    }
    var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);
    var sprites = [];
    var i;
    for (i = 0; i < tiles.length; i++) {
      var tile = tiles[i];
      if (indexes.indexOf(tile.index) !== -1) {
        var point = tilemapLayer.tileToWorldXY(tile.x, tile.y, void 0, camera, layer);
        spriteConfig.x = point.x;
        spriteConfig.y = point.y;
        sprites.push(scene.make.sprite(spriteConfig));
      }
    }
    if (typeof replacements === "number") {
      for (i = 0; i < indexes.length; i++) {
        ReplaceByIndex(indexes[i], replacements, 0, 0, layer.width, layer.height, layer);
      }
    } else if (Array.isArray(replacements)) {
      for (i = 0; i < indexes.length; i++) {
        ReplaceByIndex(indexes[i], replacements[i], 0, 0, layer.width, layer.height, layer);
      }
    }
    return sprites;
  };
  module2.exports = CreateFromTiles;
});

// node_modules/phaser/src/tilemaps/components/CullBounds.js
var require_CullBounds = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Rectangle = require_Rectangle();
  var SnapCeil = require_SnapCeil();
  var SnapFloor = require_SnapFloor();
  var bounds = new Rectangle();
  var CullBounds = function(layer, camera) {
    var tilemap = layer.tilemapLayer.tilemap;
    var tilemapLayer = layer.tilemapLayer;
    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;
    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;
    return bounds.setTo(boundsLeft, boundsTop, boundsRight - boundsLeft, boundsBottom - boundsTop);
  };
  module2.exports = CullBounds;
});

// node_modules/phaser/src/tilemaps/components/RunCull.js
var require_RunCull = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RunCull = function(layer, bounds, renderOrder, outputArray) {
    var mapData = layer.data;
    var mapWidth = layer.width;
    var mapHeight = layer.height;
    var tilemapLayer = layer.tilemapLayer;
    var drawLeft = Math.max(0, bounds.left);
    var drawRight = Math.min(mapWidth, bounds.right);
    var drawTop = Math.max(0, bounds.top);
    var drawBottom = Math.min(mapHeight, bounds.bottom);
    var x;
    var y;
    var tile;
    if (renderOrder === 0) {
      for (y = drawTop; y < drawBottom; y++) {
        for (x = drawLeft; mapData[y] && x < drawRight; x++) {
          tile = mapData[y][x];
          if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
            continue;
          }
          outputArray.push(tile);
        }
      }
    } else if (renderOrder === 1) {
      for (y = drawTop; y < drawBottom; y++) {
        for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
          tile = mapData[y][x];
          if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
            continue;
          }
          outputArray.push(tile);
        }
      }
    } else if (renderOrder === 2) {
      for (y = drawBottom; y >= drawTop; y--) {
        for (x = drawLeft; mapData[y] && x < drawRight; x++) {
          tile = mapData[y][x];
          if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
            continue;
          }
          outputArray.push(tile);
        }
      }
    } else if (renderOrder === 3) {
      for (y = drawBottom; y >= drawTop; y--) {
        for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
          tile = mapData[y][x];
          if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
            continue;
          }
          outputArray.push(tile);
        }
      }
    }
    tilemapLayer.tilesDrawn = outputArray.length;
    tilemapLayer.tilesTotal = mapWidth * mapHeight;
    return outputArray;
  };
  module2.exports = RunCull;
});

// node_modules/phaser/src/tilemaps/components/CullTiles.js
var require_CullTiles = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CullBounds = require_CullBounds();
  var RunCull = require_RunCull();
  var CullTiles = function(layer, camera, outputArray, renderOrder) {
    if (outputArray === void 0) {
      outputArray = [];
    }
    if (renderOrder === void 0) {
      renderOrder = 0;
    }
    outputArray.length = 0;
    var tilemapLayer = layer.tilemapLayer;
    var bounds = CullBounds(layer, camera);
    if (tilemapLayer.skipCull || tilemapLayer.scrollFactorX !== 1 || tilemapLayer.scrollFactorY !== 1) {
      bounds.left = 0;
      bounds.right = layer.width;
      bounds.top = 0;
      bounds.bottom = layer.height;
    }
    RunCull(layer, bounds, renderOrder, outputArray);
    return outputArray;
  };
  module2.exports = CullTiles;
});

// node_modules/phaser/src/tilemaps/components/SetTileCollision.js
var require_SetTileCollision = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetTileCollision = function(tile, collides) {
    if (collides) {
      tile.setCollision(true, true, true, true, false);
    } else {
      tile.resetCollision(false);
    }
  };
  module2.exports = SetTileCollision;
});

// node_modules/phaser/src/tilemaps/components/Fill.js
var require_Fill = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var CalculateFacesWithin = require_CalculateFacesWithin();
  var SetTileCollision = require_SetTileCollision();
  var Fill = function(index, tileX, tileY, width, height, recalculateFaces, layer) {
    var doesIndexCollide = layer.collideIndexes.indexOf(index) !== -1;
    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
    for (var i = 0; i < tiles.length; i++) {
      tiles[i].index = index;
      SetTileCollision(tiles[i], doesIndexCollide);
    }
    if (recalculateFaces) {
      CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
    }
  };
  module2.exports = Fill;
});

// node_modules/phaser/src/tilemaps/components/FilterTiles.js
var require_FilterTiles = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var FilterTiles = function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
    return tiles.filter(callback, context);
  };
  module2.exports = FilterTiles;
});

// node_modules/phaser/src/tilemaps/components/FindByIndex.js
var require_FindByIndex = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FindByIndex = function(findIndex, skip, reverse, layer) {
    if (skip === void 0) {
      skip = 0;
    }
    if (reverse === void 0) {
      reverse = false;
    }
    var count = 0;
    var tx;
    var ty;
    var tile;
    if (reverse) {
      for (ty = layer.height - 1; ty >= 0; ty--) {
        for (tx = layer.width - 1; tx >= 0; tx--) {
          tile = layer.data[ty][tx];
          if (tile && tile.index === findIndex) {
            if (count === skip) {
              return tile;
            } else {
              count += 1;
            }
          }
        }
      }
    } else {
      for (ty = 0; ty < layer.height; ty++) {
        for (tx = 0; tx < layer.width; tx++) {
          tile = layer.data[ty][tx];
          if (tile && tile.index === findIndex) {
            if (count === skip) {
              return tile;
            } else {
              count += 1;
            }
          }
        }
      }
    }
    return null;
  };
  module2.exports = FindByIndex;
});

// node_modules/phaser/src/tilemaps/components/FindTile.js
var require_FindTile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var FindTile = function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
    return tiles.find(callback, context) || null;
  };
  module2.exports = FindTile;
});

// node_modules/phaser/src/tilemaps/components/ForEachTile.js
var require_ForEachTile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var ForEachTile = function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
    tiles.forEach(callback, context);
  };
  module2.exports = ForEachTile;
});

// node_modules/phaser/src/tilemaps/components/HexagonalCullBounds.js
var require_HexagonalCullBounds = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SnapCeil = require_SnapCeil();
  var SnapFloor = require_SnapFloor();
  var HexagonalCullBounds = function(layer, camera) {
    var tilemap = layer.tilemapLayer.tilemap;
    var tilemapLayer = layer.tilemapLayer;
    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
    var len = layer.hexSideLength;
    var rowH = (tileH - len) / 2 + len;
    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, rowH, 0, true) - tilemapLayer.cullPaddingY;
    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, rowH, 0, true) + tilemapLayer.cullPaddingY;
    return {
      left: boundsLeft,
      right: boundsRight,
      top: boundsTop,
      bottom: boundsBottom
    };
  };
  module2.exports = HexagonalCullBounds;
});

// node_modules/phaser/src/tilemaps/components/HexagonalCullTiles.js
var require_HexagonalCullTiles = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CullBounds = require_HexagonalCullBounds();
  var RunCull = require_RunCull();
  var HexagonalCullTiles = function(layer, camera, outputArray, renderOrder) {
    if (outputArray === void 0) {
      outputArray = [];
    }
    if (renderOrder === void 0) {
      renderOrder = 0;
    }
    outputArray.length = 0;
    var tilemapLayer = layer.tilemapLayer;
    if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1) {
      var bounds = CullBounds(layer, camera);
      RunCull(layer, bounds, renderOrder, outputArray);
    }
    return outputArray;
  };
  module2.exports = HexagonalCullTiles;
});

// node_modules/phaser/src/tilemaps/components/IsometricCullTiles.js
var require_IsometricCullTiles = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CheckIsoBounds = require_CheckIsoBounds();
  var IsometricCullTiles = function(layer, camera, outputArray, renderOrder) {
    if (outputArray === void 0) {
      outputArray = [];
    }
    if (renderOrder === void 0) {
      renderOrder = 0;
    }
    outputArray.length = 0;
    var tilemapLayer = layer.tilemapLayer;
    var mapData = layer.data;
    var mapWidth = layer.width;
    var mapHeight = layer.height;
    var drawLeft = 0;
    var drawRight = mapWidth;
    var drawTop = 0;
    var drawBottom = mapHeight;
    if (!tilemapLayer.skipCull) {
      var x;
      var y;
      var tile;
      if (renderOrder === 0) {
        for (y = drawTop; y < drawBottom; y++) {
          for (x = drawLeft; mapData[y] && x < drawRight; x++) {
            if (CheckIsoBounds(x, y, layer, camera)) {
              tile = mapData[y][x];
              if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                continue;
              }
              outputArray.push(tile);
            }
          }
        }
      } else if (renderOrder === 1) {
        for (y = drawTop; y < drawBottom; y++) {
          for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
            if (CheckIsoBounds(x, y, layer, camera)) {
              tile = mapData[y][x];
              if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                continue;
              }
              outputArray.push(tile);
            }
          }
        }
      } else if (renderOrder === 2) {
        for (y = drawBottom; y >= drawTop; y--) {
          for (x = drawLeft; mapData[y] && x < drawRight; x++) {
            if (CheckIsoBounds(x, y, layer, camera)) {
              tile = mapData[y][x];
              if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                continue;
              }
              outputArray.push(tile);
            }
          }
        }
      } else if (renderOrder === 3) {
        for (y = drawBottom; y >= drawTop; y--) {
          for (x = drawRight; mapData[y] && x >= drawLeft; x--) {
            if (CheckIsoBounds(x, y, layer, camera)) {
              tile = mapData[y][x];
              if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {
                continue;
              }
              outputArray.push(tile);
            }
          }
        }
      }
    }
    tilemapLayer.tilesDrawn = outputArray.length;
    tilemapLayer.tilesTotal = mapWidth * mapHeight;
    return outputArray;
  };
  module2.exports = IsometricCullTiles;
});

// node_modules/phaser/src/tilemaps/components/StaggeredCullBounds.js
var require_StaggeredCullBounds = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SnapCeil = require_SnapCeil();
  var SnapFloor = require_SnapFloor();
  var StaggeredCullBounds = function(layer, camera) {
    var tilemap = layer.tilemapLayer.tilemap;
    var tilemapLayer = layer.tilemapLayer;
    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);
    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);
    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;
    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;
    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH / 2, 0, true) - tilemapLayer.cullPaddingY;
    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH / 2, 0, true) + tilemapLayer.cullPaddingY;
    return {
      left: boundsLeft,
      right: boundsRight,
      top: boundsTop,
      bottom: boundsBottom
    };
  };
  module2.exports = StaggeredCullBounds;
});

// node_modules/phaser/src/tilemaps/components/StaggeredCullTiles.js
var require_StaggeredCullTiles = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CullBounds = require_StaggeredCullBounds();
  var RunCull = require_RunCull();
  var StaggeredCullTiles = function(layer, camera, outputArray, renderOrder) {
    if (outputArray === void 0) {
      outputArray = [];
    }
    if (renderOrder === void 0) {
      renderOrder = 0;
    }
    outputArray.length = 0;
    var tilemapLayer = layer.tilemapLayer;
    if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1) {
      var bounds = CullBounds(layer, camera);
      RunCull(layer, bounds, renderOrder, outputArray);
    }
    return outputArray;
  };
  module2.exports = StaggeredCullTiles;
});

// node_modules/phaser/src/tilemaps/components/GetCullTilesFunction.js
var require_GetCullTilesFunction = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_ORIENTATION_CONST2();
  var CullTiles = require_CullTiles();
  var HexagonalCullTiles = require_HexagonalCullTiles();
  var IsometricCullTiles = require_IsometricCullTiles();
  var NOOP = require_NOOP();
  var StaggeredCullTiles = require_StaggeredCullTiles();
  var GetCullTilesFunction = function(orientation) {
    if (orientation === CONST.ORTHOGONAL) {
      return CullTiles;
    } else if (orientation === CONST.HEXAGONAL) {
      return HexagonalCullTiles;
    } else if (orientation === CONST.STAGGERED) {
      return StaggeredCullTiles;
    } else if (orientation === CONST.ISOMETRIC) {
      return IsometricCullTiles;
    } else {
      return NOOP;
    }
  };
  module2.exports = GetCullTilesFunction;
});

// node_modules/phaser/src/tilemaps/components/GetTileAtWorldXY.js
var require_GetTileAtWorldXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTileAt = require_GetTileAt();
  var Vector2 = require_Vector2();
  var point = new Vector2();
  var GetTileAtWorldXY = function(worldX, worldY, nonNull, camera, layer) {
    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);
    return GetTileAt(point.x, point.y, nonNull, layer);
  };
  module2.exports = GetTileAtWorldXY;
});

// node_modules/phaser/src/tilemaps/components/GetTilesWithinShape.js
var require_GetTilesWithinShape = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Geom = require_geom();
  var GetTilesWithin = require_GetTilesWithin();
  var Intersects = require_intersects();
  var NOOP = require_NOOP();
  var Vector2 = require_Vector2();
  var TriangleToRectangle = function(triangle, rect) {
    return Intersects.RectangleToTriangle(rect, triangle);
  };
  var point = new Vector2();
  var pointStart = new Vector2();
  var pointEnd = new Vector2();
  var GetTilesWithinShape = function(shape, filteringOptions, camera, layer) {
    if (shape === void 0) {
      return [];
    }
    var intersectTest = NOOP;
    if (shape instanceof Geom.Circle) {
      intersectTest = Intersects.CircleToRectangle;
    } else if (shape instanceof Geom.Rectangle) {
      intersectTest = Intersects.RectangleToRectangle;
    } else if (shape instanceof Geom.Triangle) {
      intersectTest = TriangleToRectangle;
    } else if (shape instanceof Geom.Line) {
      intersectTest = Intersects.LineToRectangle;
    }
    layer.tilemapLayer.worldToTileXY(shape.left, shape.top, true, pointStart, camera);
    var xStart = pointStart.x;
    var yStart = pointStart.y;
    layer.tilemapLayer.worldToTileXY(shape.right, shape.bottom, true, pointEnd, camera);
    var xEnd = Math.ceil(pointEnd.x);
    var yEnd = Math.ceil(pointEnd.y);
    var width = Math.max(xEnd - xStart, 1);
    var height = Math.max(yEnd - yStart, 1);
    var tiles = GetTilesWithin(xStart, yStart, width, height, filteringOptions, layer);
    var tileWidth = layer.tileWidth;
    var tileHeight = layer.tileHeight;
    if (layer.tilemapLayer) {
      tileWidth *= layer.tilemapLayer.scaleX;
      tileHeight *= layer.tilemapLayer.scaleY;
    }
    var results = [];
    var tileRect = new Geom.Rectangle(0, 0, tileWidth, tileHeight);
    for (var i = 0; i < tiles.length; i++) {
      var tile = tiles[i];
      layer.tilemapLayer.tileToWorldXY(tile.x, tile.y, point, camera);
      tileRect.x = point.x;
      tileRect.y = point.y;
      if (intersectTest(shape, tileRect)) {
        results.push(tile);
      }
    }
    return results;
  };
  module2.exports = GetTilesWithinShape;
});

// node_modules/phaser/src/tilemaps/components/TileToWorldX.js
var require_TileToWorldX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TileToWorldX = function(tileX, camera, layer) {
    var tileWidth = layer.baseTileWidth;
    var tilemapLayer = layer.tilemapLayer;
    var layerWorldX = 0;
    if (tilemapLayer) {
      if (!camera) {
        camera = tilemapLayer.scene.cameras.main;
      }
      layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
      tileWidth *= tilemapLayer.scaleX;
    }
    return layerWorldX + tileX * tileWidth;
  };
  module2.exports = TileToWorldX;
});

// node_modules/phaser/src/tilemaps/components/GetTileToWorldXFunction.js
var require_GetTileToWorldXFunction = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_ORIENTATION_CONST2();
  var NOOP = require_NOOP();
  var TileToWorldX = require_TileToWorldX();
  var GetTileToWorldXFunction = function(orientation) {
    if (orientation === CONST.ORTHOGONAL) {
      return TileToWorldX;
    } else {
      return NOOP;
    }
  };
  module2.exports = GetTileToWorldXFunction;
});

// node_modules/phaser/src/tilemaps/components/HexagonalTileToWorldXY.js
var require_HexagonalTileToWorldXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector2 = require_Vector2();
  var HexagonalTileToWorldXY = function(tileX, tileY, point, camera, layer) {
    if (!point) {
      point = new Vector2();
    }
    var tileWidth = layer.baseTileWidth;
    var tileHeight = layer.baseTileHeight;
    var tilemapLayer = layer.tilemapLayer;
    var layerWorldX = 0;
    var layerWorldY = 0;
    if (tilemapLayer) {
      if (!camera) {
        camera = tilemapLayer.scene.cameras.main;
      }
      layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
      tileWidth *= tilemapLayer.scaleX;
      layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
      tileHeight *= tilemapLayer.scaleY;
    }
    var len = layer.hexSideLength;
    var rowHeight = (tileHeight - len) / 2 + len;
    var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);
    var y = layerWorldY + tileY * rowHeight;
    return point.set(x, y);
  };
  module2.exports = HexagonalTileToWorldXY;
});

// node_modules/phaser/src/tilemaps/components/IsometricTileToWorldXY.js
var require_IsometricTileToWorldXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector2 = require_Vector2();
  var IsometricTileToWorldXY = function(tileX, tileY, point, camera, layer) {
    if (!point) {
      point = new Vector2();
    }
    var tileWidth = layer.baseTileWidth;
    var tileHeight = layer.baseTileHeight;
    var tilemapLayer = layer.tilemapLayer;
    var layerWorldX = 0;
    var layerWorldY = 0;
    if (tilemapLayer) {
      if (!camera) {
        camera = tilemapLayer.scene.cameras.main;
      }
      layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
      tileWidth *= tilemapLayer.scaleX;
      layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
      tileHeight *= tilemapLayer.scaleY;
    }
    var x = layerWorldX + (tileX - tileY) * (tileWidth / 2);
    var y = layerWorldY + (tileX + tileY) * (tileHeight / 2);
    return point.set(x, y);
  };
  module2.exports = IsometricTileToWorldXY;
});

// node_modules/phaser/src/tilemaps/components/StaggeredTileToWorldXY.js
var require_StaggeredTileToWorldXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector2 = require_Vector2();
  var StaggeredTileToWorldXY = function(tileX, tileY, point, camera, layer) {
    if (!point) {
      point = new Vector2();
    }
    var tileWidth = layer.baseTileWidth;
    var tileHeight = layer.baseTileHeight;
    var tilemapLayer = layer.tilemapLayer;
    var layerWorldX = 0;
    var layerWorldY = 0;
    if (tilemapLayer) {
      if (!camera) {
        camera = tilemapLayer.scene.cameras.main;
      }
      layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);
      tileWidth *= tilemapLayer.scaleX;
      layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
      tileHeight *= tilemapLayer.scaleY;
    }
    var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);
    var y = layerWorldY + tileY * (tileHeight / 2);
    return point.set(x, y);
  };
  module2.exports = StaggeredTileToWorldXY;
});

// node_modules/phaser/src/tilemaps/components/TileToWorldY.js
var require_TileToWorldY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TileToWorldY = function(tileY, camera, layer) {
    var tileHeight = layer.baseTileHeight;
    var tilemapLayer = layer.tilemapLayer;
    var layerWorldY = 0;
    if (tilemapLayer) {
      if (!camera) {
        camera = tilemapLayer.scene.cameras.main;
      }
      layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
      tileHeight *= tilemapLayer.scaleY;
    }
    return layerWorldY + tileY * tileHeight;
  };
  module2.exports = TileToWorldY;
});

// node_modules/phaser/src/tilemaps/components/TileToWorldXY.js
var require_TileToWorldXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TileToWorldX = require_TileToWorldX();
  var TileToWorldY = require_TileToWorldY();
  var Vector2 = require_Vector2();
  var TileToWorldXY = function(tileX, tileY, point, camera, layer) {
    if (!point) {
      point = new Vector2(0, 0);
    }
    point.x = TileToWorldX(tileX, camera, layer);
    point.y = TileToWorldY(tileY, camera, layer);
    return point;
  };
  module2.exports = TileToWorldXY;
});

// node_modules/phaser/src/tilemaps/components/GetTileToWorldXYFunction.js
var require_GetTileToWorldXYFunction = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_ORIENTATION_CONST2();
  var HexagonalTileToWorldXY = require_HexagonalTileToWorldXY();
  var IsometricTileToWorldXY = require_IsometricTileToWorldXY();
  var NOOP = require_NOOP();
  var StaggeredTileToWorldXY = require_StaggeredTileToWorldXY();
  var TileToWorldXY = require_TileToWorldXY();
  var GetTileToWorldXYFunction = function(orientation) {
    if (orientation === CONST.ORTHOGONAL) {
      return TileToWorldXY;
    } else if (orientation === CONST.ISOMETRIC) {
      return IsometricTileToWorldXY;
    } else if (orientation === CONST.HEXAGONAL) {
      return HexagonalTileToWorldXY;
    } else if (orientation === CONST.STAGGERED) {
      return StaggeredTileToWorldXY;
    } else {
      return NOOP;
    }
  };
  module2.exports = GetTileToWorldXYFunction;
});

// node_modules/phaser/src/tilemaps/components/HexagonalTileToWorldY.js
var require_HexagonalTileToWorldY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var HexagonalTileToWorldY = function(tileY, camera, layer) {
    var tileHeight = layer.baseTileHeight;
    var tilemapLayer = layer.tilemapLayer;
    var layerWorldY = 0;
    if (tilemapLayer) {
      if (camera === void 0) {
        camera = tilemapLayer.scene.cameras.main;
      }
      layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
      tileHeight *= tilemapLayer.scaleY;
    }
    var len = tilemapLayer.tilemap.hexSideLength;
    var rowHeight = (tileHeight - len) / 2 + len;
    return layerWorldY + tileY * rowHeight;
  };
  module2.exports = HexagonalTileToWorldY;
});

// node_modules/phaser/src/tilemaps/components/StaggeredTileToWorldY.js
var require_StaggeredTileToWorldY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var StaggeredTileToWorldY = function(tileY, camera, layer) {
    var tileHeight = layer.baseTileHeight;
    var tilemapLayer = layer.tilemapLayer;
    var layerWorldY = 0;
    if (tilemapLayer) {
      if (camera === void 0) {
        camera = tilemapLayer.scene.cameras.main;
      }
      layerWorldY = tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY);
      tileHeight *= tilemapLayer.scaleY;
    }
    return layerWorldY + tileY * (tileHeight / 2);
  };
  module2.exports = StaggeredTileToWorldY;
});

// node_modules/phaser/src/tilemaps/components/GetTileToWorldYFunction.js
var require_GetTileToWorldYFunction = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_ORIENTATION_CONST2();
  var HexagonalTileToWorldY = require_HexagonalTileToWorldY();
  var NOOP = require_NOOP();
  var StaggeredTileToWorldY = require_StaggeredTileToWorldY();
  var TileToWorldY = require_TileToWorldY();
  var GetTileToWorldYFunction = function(orientation) {
    if (orientation === CONST.ORTHOGONAL) {
      return TileToWorldY;
    } else if (orientation === CONST.HEXAGONAL) {
      return HexagonalTileToWorldY;
    } else if (orientation === CONST.STAGGERED) {
      return StaggeredTileToWorldY;
    } else {
      return NOOP;
    }
  };
  module2.exports = GetTileToWorldYFunction;
});

// node_modules/phaser/src/tilemaps/components/WorldToTileX.js
var require_WorldToTileX = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var WorldToTileX = function(worldX, snapToFloor, camera, layer) {
    if (snapToFloor === void 0) {
      snapToFloor = true;
    }
    var tileWidth = layer.baseTileWidth;
    var tilemapLayer = layer.tilemapLayer;
    if (tilemapLayer) {
      if (!camera) {
        camera = tilemapLayer.scene.cameras.main;
      }
      worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
      tileWidth *= tilemapLayer.scaleX;
    }
    return snapToFloor ? Math.floor(worldX / tileWidth) : worldX / tileWidth;
  };
  module2.exports = WorldToTileX;
});

// node_modules/phaser/src/tilemaps/components/GetWorldToTileXFunction.js
var require_GetWorldToTileXFunction = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_ORIENTATION_CONST2();
  var NOOP = require_NOOP();
  var WorldToTileX = require_WorldToTileX();
  var GetWorldToTileXFunction = function(orientation) {
    if (orientation === CONST.ORTHOGONAL) {
      return WorldToTileX;
    } else {
      return NOOP;
    }
  };
  module2.exports = GetWorldToTileXFunction;
});

// node_modules/phaser/src/tilemaps/components/HexagonalWorldToTileXY.js
var require_HexagonalWorldToTileXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector2 = require_Vector2();
  var HexagonalWorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
    if (!point) {
      point = new Vector2();
    }
    var tileWidth = layer.baseTileWidth;
    var tileHeight = layer.baseTileHeight;
    var tilemapLayer = layer.tilemapLayer;
    if (tilemapLayer) {
      if (!camera) {
        camera = tilemapLayer.scene.cameras.main;
      }
      worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
      tileHeight *= tilemapLayer.scaleY;
      worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
      tileWidth *= tilemapLayer.scaleX;
    }
    var len = layer.hexSideLength;
    var rowHeight = (tileHeight - len) / 2 + len;
    var y = snapToFloor ? Math.floor(worldY / rowHeight) : worldY / rowHeight;
    var x = snapToFloor ? Math.floor((worldX - y % 2 * 0.5 * tileWidth) / tileWidth) : (worldX - y % 2 * 0.5 * tileWidth) / tileWidth;
    return point.set(x, y);
  };
  module2.exports = HexagonalWorldToTileXY;
});

// node_modules/phaser/src/tilemaps/components/IsometricWorldToTileXY.js
var require_IsometricWorldToTileXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector2 = require_Vector2();
  var IsometricWorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
    if (!point) {
      point = new Vector2();
    }
    var tileWidth = layer.baseTileWidth;
    var tileHeight = layer.baseTileHeight;
    var tilemapLayer = layer.tilemapLayer;
    if (tilemapLayer) {
      if (!camera) {
        camera = tilemapLayer.scene.cameras.main;
      }
      worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
      tileHeight *= tilemapLayer.scaleY;
      worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
      tileWidth *= tilemapLayer.scaleX;
    }
    var x = snapToFloor ? Math.floor((worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2) : (worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2;
    var y = snapToFloor ? Math.floor((worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2) : (worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2;
    return point.set(x, y);
  };
  module2.exports = IsometricWorldToTileXY;
});

// node_modules/phaser/src/tilemaps/components/StaggeredWorldToTileXY.js
var require_StaggeredWorldToTileXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Vector2 = require_Vector2();
  var StaggeredWorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
    if (!point) {
      point = new Vector2();
    }
    var tileWidth = layer.baseTileWidth;
    var tileHeight = layer.baseTileHeight;
    var tilemapLayer = layer.tilemapLayer;
    if (tilemapLayer) {
      if (!camera) {
        camera = tilemapLayer.scene.cameras.main;
      }
      worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
      tileHeight *= tilemapLayer.scaleY;
      worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));
      tileWidth *= tilemapLayer.scaleX;
    }
    var y = snapToFloor ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);
    var x = snapToFloor ? Math.floor((worldX + y % 2 * 0.5 * tileWidth) / tileWidth) : (worldX + y % 2 * 0.5 * tileWidth) / tileWidth;
    return point.set(x, y);
  };
  module2.exports = StaggeredWorldToTileXY;
});

// node_modules/phaser/src/tilemaps/components/WorldToTileY.js
var require_WorldToTileY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var WorldToTileY = function(worldY, snapToFloor, camera, layer) {
    if (snapToFloor === void 0) {
      snapToFloor = true;
    }
    var tileHeight = layer.baseTileHeight;
    var tilemapLayer = layer.tilemapLayer;
    if (tilemapLayer) {
      if (!camera) {
        camera = tilemapLayer.scene.cameras.main;
      }
      worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
      tileHeight *= tilemapLayer.scaleY;
    }
    return snapToFloor ? Math.floor(worldY / tileHeight) : worldY / tileHeight;
  };
  module2.exports = WorldToTileY;
});

// node_modules/phaser/src/tilemaps/components/WorldToTileXY.js
var require_WorldToTileXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var WorldToTileX = require_WorldToTileX();
  var WorldToTileY = require_WorldToTileY();
  var Vector2 = require_Vector2();
  var WorldToTileXY = function(worldX, worldY, snapToFloor, point, camera, layer) {
    if (snapToFloor === void 0) {
      snapToFloor = true;
    }
    if (!point) {
      point = new Vector2(0, 0);
    }
    point.x = WorldToTileX(worldX, snapToFloor, camera, layer);
    point.y = WorldToTileY(worldY, snapToFloor, camera, layer);
    return point;
  };
  module2.exports = WorldToTileXY;
});

// node_modules/phaser/src/tilemaps/components/GetWorldToTileXYFunction.js
var require_GetWorldToTileXYFunction = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_ORIENTATION_CONST2();
  var HexagonalWorldToTileXY = require_HexagonalWorldToTileXY();
  var IsometricWorldToTileXY = require_IsometricWorldToTileXY();
  var NOOP = require_NOOP();
  var StaggeredWorldToTileXY = require_StaggeredWorldToTileXY();
  var WorldToTileXY = require_WorldToTileXY();
  var GetWorldToTileXYFunction = function(orientation) {
    if (orientation === CONST.ORTHOGONAL) {
      return WorldToTileXY;
    } else if (orientation === CONST.ISOMETRIC) {
      return IsometricWorldToTileXY;
    } else if (orientation === CONST.HEXAGONAL) {
      return HexagonalWorldToTileXY;
    } else if (orientation === CONST.STAGGERED) {
      return StaggeredWorldToTileXY;
    } else {
      return NOOP;
    }
  };
  module2.exports = GetWorldToTileXYFunction;
});

// node_modules/phaser/src/tilemaps/components/HexagonalWorldToTileY.js
var require_HexagonalWorldToTileY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var HexagonalWorldToTileY = function(worldY, snapToFloor, camera, layer) {
    var tileHeight = layer.baseTileHeight;
    var tilemapLayer = layer.tilemapLayer;
    if (tilemapLayer) {
      if (!camera) {
        camera = tilemapLayer.scene.cameras.main;
      }
      worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
      tileHeight *= tilemapLayer.scaleY;
    }
    var len = layer.hexSideLength;
    var rowHeight = (tileHeight - len) / 2 + len;
    return snapToFloor ? Math.floor(worldY / rowHeight) : worldY / rowHeight;
  };
  module2.exports = HexagonalWorldToTileY;
});

// node_modules/phaser/src/tilemaps/components/StaggeredWorldToTileY.js
var require_StaggeredWorldToTileY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var StaggeredWorldToTileY = function(worldY, snapToFloor, camera, layer) {
    var tileHeight = layer.baseTileHeight;
    var tilemapLayer = layer.tilemapLayer;
    if (tilemapLayer) {
      if (!camera) {
        camera = tilemapLayer.scene.cameras.main;
      }
      worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));
      tileHeight *= tilemapLayer.scaleY;
    }
    return snapToFloor ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);
  };
  module2.exports = StaggeredWorldToTileY;
});

// node_modules/phaser/src/tilemaps/components/GetWorldToTileYFunction.js
var require_GetWorldToTileYFunction = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_ORIENTATION_CONST2();
  var HexagonalWorldToTileY = require_HexagonalWorldToTileY();
  var NOOP = require_NOOP();
  var StaggeredWorldToTileY = require_StaggeredWorldToTileY();
  var WorldToTileY = require_WorldToTileY();
  var GetWorldToTileYFunction = function(orientation) {
    if (orientation === CONST.ORTHOGONAL) {
      return WorldToTileY;
    } else if (orientation === CONST.HEXAGONAL) {
      return HexagonalWorldToTileY;
    } else if (orientation === CONST.STAGGERED) {
      return StaggeredWorldToTileY;
    } else {
      return NOOP;
    }
  };
  module2.exports = GetWorldToTileYFunction;
});

// node_modules/phaser/src/tilemaps/components/HasTileAt.js
var require_HasTileAt = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var IsInLayerBounds = require_IsInLayerBounds();
  var HasTileAt = function(tileX, tileY, layer) {
    if (IsInLayerBounds(tileX, tileY, layer)) {
      var tile = layer.data[tileY][tileX];
      return tile !== null && tile.index > -1;
    } else {
      return false;
    }
  };
  module2.exports = HasTileAt;
});

// node_modules/phaser/src/tilemaps/components/HasTileAtWorldXY.js
var require_HasTileAtWorldXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var HasTileAt = require_HasTileAt();
  var Vector2 = require_Vector2();
  var point = new Vector2();
  var HasTileAtWorldXY = function(worldX, worldY, camera, layer) {
    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);
    var tileX = point.x;
    var tileY = point.y;
    return HasTileAt(tileX, tileY, layer);
  };
  module2.exports = HasTileAtWorldXY;
});

// node_modules/phaser/src/tilemaps/Tile.js
var require_Tile = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_ORIENTATION_CONST2();
  var Class = require_Class();
  var Components = require_components();
  var Rectangle = require_rectangle();
  var Tile = new Class({
    Mixins: [
      Components.Alpha,
      Components.Flip,
      Components.Visible
    ],
    initialize: function Tile2(layer, index, x, y, width, height, baseWidth, baseHeight) {
      this.layer = layer;
      this.index = index;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.right;
      this.bottom;
      this.baseWidth = baseWidth !== void 0 ? baseWidth : width;
      this.baseHeight = baseHeight !== void 0 ? baseHeight : height;
      this.pixelX = 0;
      this.pixelY = 0;
      this.updatePixelXY();
      this.properties = {};
      this.rotation = 0;
      this.collideLeft = false;
      this.collideRight = false;
      this.collideUp = false;
      this.collideDown = false;
      this.faceLeft = false;
      this.faceRight = false;
      this.faceTop = false;
      this.faceBottom = false;
      this.collisionCallback = void 0;
      this.collisionCallbackContext = this;
      this.tint = 16777215;
      this.physics = {};
    },
    containsPoint: function(x, y) {
      return !(x < this.pixelX || y < this.pixelY || x > this.right || y > this.bottom);
    },
    copy: function(tile) {
      this.index = tile.index;
      this.alpha = tile.alpha;
      this.properties = tile.properties;
      this.visible = tile.visible;
      this.setFlip(tile.flipX, tile.flipY);
      this.tint = tile.tint;
      this.rotation = tile.rotation;
      this.collideUp = tile.collideUp;
      this.collideDown = tile.collideDown;
      this.collideLeft = tile.collideLeft;
      this.collideRight = tile.collideRight;
      this.collisionCallback = tile.collisionCallback;
      this.collisionCallbackContext = tile.collisionCallbackContext;
      return this;
    },
    getCollisionGroup: function() {
      return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;
    },
    getTileData: function() {
      return this.tileset ? this.tileset.getTileData(this.index) : null;
    },
    getLeft: function(camera) {
      var tilemapLayer = this.tilemapLayer;
      return tilemapLayer ? tilemapLayer.tileToWorldX(this.x, camera) : this.x * this.baseWidth;
    },
    getRight: function(camera) {
      var tilemapLayer = this.tilemapLayer;
      return tilemapLayer ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;
    },
    getTop: function(camera) {
      var tilemapLayer = this.tilemapLayer;
      return tilemapLayer ? tilemapLayer.tileToWorldY(this.y, camera) - (this.height - this.baseHeight) * tilemapLayer.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight);
    },
    getBottom: function(camera) {
      var tilemapLayer = this.tilemapLayer;
      return tilemapLayer ? this.getTop(camera) + this.height * tilemapLayer.scaleY : this.getTop(camera) + this.height;
    },
    getBounds: function(camera, output) {
      if (output === void 0) {
        output = new Rectangle();
      }
      output.x = this.getLeft();
      output.y = this.getTop();
      output.width = this.getRight() - output.x;
      output.height = this.getBottom() - output.y;
      return output;
    },
    getCenterX: function(camera) {
      return (this.getLeft(camera) + this.getRight(camera)) / 2;
    },
    getCenterY: function(camera) {
      return (this.getTop(camera) + this.getBottom(camera)) / 2;
    },
    intersects: function(x, y, right, bottom) {
      return !(right <= this.pixelX || bottom <= this.pixelY || x >= this.right || y >= this.bottom);
    },
    isInteresting: function(collides, faces) {
      if (collides && faces) {
        return this.canCollide || this.hasInterestingFace;
      } else if (collides) {
        return this.collides;
      } else if (faces) {
        return this.hasInterestingFace;
      }
      return false;
    },
    resetCollision: function(recalculateFaces) {
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      this.collideLeft = false;
      this.collideRight = false;
      this.collideUp = false;
      this.collideDown = false;
      this.faceTop = false;
      this.faceBottom = false;
      this.faceLeft = false;
      this.faceRight = false;
      if (recalculateFaces) {
        var tilemapLayer = this.tilemapLayer;
        if (tilemapLayer) {
          this.tilemapLayer.calculateFacesAt(this.x, this.y);
        }
      }
      return this;
    },
    resetFaces: function() {
      this.faceTop = false;
      this.faceBottom = false;
      this.faceLeft = false;
      this.faceRight = false;
      return this;
    },
    setCollision: function(left, right, up, down, recalculateFaces) {
      if (right === void 0) {
        right = left;
      }
      if (up === void 0) {
        up = left;
      }
      if (down === void 0) {
        down = left;
      }
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      this.collideLeft = left;
      this.collideRight = right;
      this.collideUp = up;
      this.collideDown = down;
      this.faceLeft = left;
      this.faceRight = right;
      this.faceTop = up;
      this.faceBottom = down;
      if (recalculateFaces) {
        var tilemapLayer = this.tilemapLayer;
        if (tilemapLayer) {
          this.tilemapLayer.calculateFacesAt(this.x, this.y);
        }
      }
      return this;
    },
    setCollisionCallback: function(callback, context) {
      if (callback === null) {
        this.collisionCallback = void 0;
        this.collisionCallbackContext = void 0;
      } else {
        this.collisionCallback = callback;
        this.collisionCallbackContext = context;
      }
      return this;
    },
    setSize: function(tileWidth, tileHeight, baseWidth, baseHeight) {
      if (tileWidth !== void 0) {
        this.width = tileWidth;
      }
      if (tileHeight !== void 0) {
        this.height = tileHeight;
      }
      if (baseWidth !== void 0) {
        this.baseWidth = baseWidth;
      }
      if (baseHeight !== void 0) {
        this.baseHeight = baseHeight;
      }
      this.updatePixelXY();
      return this;
    },
    updatePixelXY: function() {
      var orientation = this.layer.orientation;
      if (orientation === CONST.ORTHOGONAL) {
        this.pixelX = this.x * this.baseWidth;
        this.pixelY = this.y * this.baseHeight;
      } else if (orientation === CONST.ISOMETRIC) {
        this.pixelX = (this.x - this.y) * this.baseWidth * 0.5;
        this.pixelY = (this.x + this.y) * this.baseHeight * 0.5;
      } else if (orientation === CONST.STAGGERED) {
        this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
        this.pixelY = this.y * (this.baseHeight / 2);
      } else if (orientation === CONST.HEXAGONAL) {
        var len = this.layer.hexSideLength;
        var rowHeight = (this.baseHeight - len) / 2 + len;
        this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
        this.pixelY = this.y * rowHeight;
      }
      this.right = this.pixelX + this.baseWidth;
      this.bottom = this.pixelY + this.baseHeight;
      return this;
    },
    destroy: function() {
      this.collisionCallback = void 0;
      this.collisionCallbackContext = void 0;
      this.properties = void 0;
    },
    canCollide: {
      get: function() {
        return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback !== void 0;
      }
    },
    collides: {
      get: function() {
        return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
      }
    },
    hasInterestingFace: {
      get: function() {
        return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight;
      }
    },
    tileset: {
      get: function() {
        var tilemapLayer = this.layer.tilemapLayer;
        if (tilemapLayer) {
          var tileset = tilemapLayer.gidMap[this.index];
          if (tileset) {
            return tileset;
          }
        }
        return null;
      }
    },
    tilemapLayer: {
      get: function() {
        return this.layer.tilemapLayer;
      }
    },
    tilemap: {
      get: function() {
        var tilemapLayer = this.tilemapLayer;
        return tilemapLayer ? tilemapLayer.tilemap : null;
      }
    }
  });
  module2.exports = Tile;
});

// node_modules/phaser/src/tilemaps/components/PutTileAt.js
var require_PutTileAt = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Tile = require_Tile();
  var IsInLayerBounds = require_IsInLayerBounds();
  var CalculateFacesAt = require_CalculateFacesAt();
  var SetTileCollision = require_SetTileCollision();
  var PutTileAt = function(tile, tileX, tileY, recalculateFaces, layer) {
    if (recalculateFaces === void 0) {
      recalculateFaces = true;
    }
    if (!IsInLayerBounds(tileX, tileY, layer)) {
      return null;
    }
    var oldTile = layer.data[tileY][tileX];
    var oldTileCollides = oldTile && oldTile.collides;
    if (tile instanceof Tile) {
      if (layer.data[tileY][tileX] === null) {
        layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, layer.tileWidth, layer.tileHeight);
      }
      layer.data[tileY][tileX].copy(tile);
    } else {
      var index = tile;
      if (layer.data[tileY][tileX] === null) {
        layer.data[tileY][tileX] = new Tile(layer, index, tileX, tileY, layer.tileWidth, layer.tileHeight);
      } else {
        layer.data[tileY][tileX].index = index;
      }
    }
    var newTile = layer.data[tileY][tileX];
    var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;
    SetTileCollision(newTile, collides);
    if (recalculateFaces && oldTileCollides !== newTile.collides) {
      CalculateFacesAt(tileX, tileY, layer);
    }
    return newTile;
  };
  module2.exports = PutTileAt;
});

// node_modules/phaser/src/tilemaps/components/PutTileAtWorldXY.js
var require_PutTileAtWorldXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var PutTileAt = require_PutTileAt();
  var Vector2 = require_Vector2();
  var point = new Vector2();
  var PutTileAtWorldXY = function(tile, worldX, worldY, recalculateFaces, camera, layer) {
    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);
    return PutTileAt(tile, point.x, point.y, recalculateFaces, layer);
  };
  module2.exports = PutTileAtWorldXY;
});

// node_modules/phaser/src/tilemaps/components/PutTilesAt.js
var require_PutTilesAt = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CalculateFacesWithin = require_CalculateFacesWithin();
  var PutTileAt = require_PutTileAt();
  var PutTilesAt = function(tilesArray, tileX, tileY, recalculateFaces, layer) {
    if (recalculateFaces === void 0) {
      recalculateFaces = true;
    }
    if (!Array.isArray(tilesArray)) {
      return null;
    }
    if (!Array.isArray(tilesArray[0])) {
      tilesArray = [tilesArray];
    }
    var height = tilesArray.length;
    var width = tilesArray[0].length;
    for (var ty = 0; ty < height; ty++) {
      for (var tx = 0; tx < width; tx++) {
        var tile = tilesArray[ty][tx];
        PutTileAt(tile, tileX + tx, tileY + ty, false, layer);
      }
    }
    if (recalculateFaces) {
      CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);
    }
  };
  module2.exports = PutTilesAt;
});

// node_modules/phaser/src/tilemaps/components/Randomize.js
var require_Randomize = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var GetRandom = require_GetRandom();
  var Randomize = function(tileX, tileY, width, height, indexes, layer) {
    var i;
    var tiles = GetTilesWithin(tileX, tileY, width, height, {}, layer);
    if (!indexes) {
      indexes = [];
      for (i = 0; i < tiles.length; i++) {
        if (indexes.indexOf(tiles[i].index) === -1) {
          indexes.push(tiles[i].index);
        }
      }
    }
    for (i = 0; i < tiles.length; i++) {
      tiles[i].index = GetRandom(indexes);
    }
  };
  module2.exports = Randomize;
});

// node_modules/phaser/src/tilemaps/components/RemoveTileAt.js
var require_RemoveTileAt = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Tile = require_Tile();
  var IsInLayerBounds = require_IsInLayerBounds();
  var CalculateFacesAt = require_CalculateFacesAt();
  var RemoveTileAt = function(tileX, tileY, replaceWithNull, recalculateFaces, layer) {
    if (replaceWithNull === void 0) {
      replaceWithNull = true;
    }
    if (recalculateFaces === void 0) {
      recalculateFaces = true;
    }
    if (!IsInLayerBounds(tileX, tileY, layer)) {
      return null;
    }
    var tile = layer.data[tileY][tileX];
    if (!tile) {
      return null;
    } else {
      layer.data[tileY][tileX] = replaceWithNull ? null : new Tile(layer, -1, tileX, tileY, layer.tileWidth, layer.tileHeight);
    }
    if (recalculateFaces && tile && tile.collides) {
      CalculateFacesAt(tileX, tileY, layer);
    }
    return tile;
  };
  module2.exports = RemoveTileAt;
});

// node_modules/phaser/src/tilemaps/components/RemoveTileAtWorldXY.js
var require_RemoveTileAtWorldXY = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RemoveTileAt = require_RemoveTileAt();
  var Vector2 = require_Vector2();
  var point = new Vector2();
  var RemoveTileAtWorldXY = function(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {
    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);
    return RemoveTileAt(point.x, point.y, replaceWithNull, recalculateFaces, layer);
  };
  module2.exports = RemoveTileAtWorldXY;
});

// node_modules/phaser/src/tilemaps/components/RenderDebug.js
var require_RenderDebug = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var Color = require_color();
  var defaultTileColor = new Color(105, 210, 231, 150);
  var defaultCollidingTileColor = new Color(243, 134, 48, 200);
  var defaultFaceColor = new Color(40, 39, 37, 150);
  var RenderDebug = function(graphics, styleConfig, layer) {
    if (styleConfig === void 0) {
      styleConfig = {};
    }
    var tileColor = styleConfig.tileColor !== void 0 ? styleConfig.tileColor : defaultTileColor;
    var collidingTileColor = styleConfig.collidingTileColor !== void 0 ? styleConfig.collidingTileColor : defaultCollidingTileColor;
    var faceColor = styleConfig.faceColor !== void 0 ? styleConfig.faceColor : defaultFaceColor;
    var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);
    graphics.translateCanvas(layer.tilemapLayer.x, layer.tilemapLayer.y);
    graphics.scaleCanvas(layer.tilemapLayer.scaleX, layer.tilemapLayer.scaleY);
    for (var i = 0; i < tiles.length; i++) {
      var tile = tiles[i];
      var tw = tile.width;
      var th = tile.height;
      var x = tile.pixelX;
      var y = tile.pixelY;
      var color = tile.collides ? collidingTileColor : tileColor;
      if (color !== null) {
        graphics.fillStyle(color.color, color.alpha / 255);
        graphics.fillRect(x, y, tw, th);
      }
      x += 1;
      y += 1;
      tw -= 2;
      th -= 2;
      if (faceColor !== null) {
        graphics.lineStyle(1, faceColor.color, faceColor.alpha / 255);
        if (tile.faceTop) {
          graphics.lineBetween(x, y, x + tw, y);
        }
        if (tile.faceRight) {
          graphics.lineBetween(x + tw, y, x + tw, y + th);
        }
        if (tile.faceBottom) {
          graphics.lineBetween(x, y + th, x + tw, y + th);
        }
        if (tile.faceLeft) {
          graphics.lineBetween(x, y, x, y + th);
        }
      }
    }
  };
  module2.exports = RenderDebug;
});

// node_modules/phaser/src/tilemaps/components/SetLayerCollisionIndex.js
var require_SetLayerCollisionIndex = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetLayerCollisionIndex = function(tileIndex, collides, layer) {
    var loc = layer.collideIndexes.indexOf(tileIndex);
    if (collides && loc === -1) {
      layer.collideIndexes.push(tileIndex);
    } else if (!collides && loc !== -1) {
      layer.collideIndexes.splice(loc, 1);
    }
  };
  module2.exports = SetLayerCollisionIndex;
});

// node_modules/phaser/src/tilemaps/components/SetCollision.js
var require_SetCollision = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetTileCollision = require_SetTileCollision();
  var CalculateFacesWithin = require_CalculateFacesWithin();
  var SetLayerCollisionIndex = require_SetLayerCollisionIndex();
  var SetCollision = function(indexes, collides, recalculateFaces, layer, updateLayer) {
    if (collides === void 0) {
      collides = true;
    }
    if (recalculateFaces === void 0) {
      recalculateFaces = true;
    }
    if (updateLayer === void 0) {
      updateLayer = true;
    }
    if (!Array.isArray(indexes)) {
      indexes = [indexes];
    }
    for (var i = 0; i < indexes.length; i++) {
      SetLayerCollisionIndex(indexes[i], collides, layer);
    }
    if (updateLayer) {
      for (var ty = 0; ty < layer.height; ty++) {
        for (var tx = 0; tx < layer.width; tx++) {
          var tile = layer.data[ty][tx];
          if (tile && indexes.indexOf(tile.index) !== -1) {
            SetTileCollision(tile, collides);
          }
        }
      }
    }
    if (recalculateFaces) {
      CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
    }
  };
  module2.exports = SetCollision;
});

// node_modules/phaser/src/tilemaps/components/SetCollisionBetween.js
var require_SetCollisionBetween = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetTileCollision = require_SetTileCollision();
  var CalculateFacesWithin = require_CalculateFacesWithin();
  var SetLayerCollisionIndex = require_SetLayerCollisionIndex();
  var SetCollisionBetween = function(start, stop, collides, recalculateFaces, layer, updateLayer) {
    if (collides === void 0) {
      collides = true;
    }
    if (recalculateFaces === void 0) {
      recalculateFaces = true;
    }
    if (updateLayer === void 0) {
      updateLayer = true;
    }
    if (start > stop) {
      return;
    }
    for (var index = start; index <= stop; index++) {
      SetLayerCollisionIndex(index, collides, layer);
    }
    if (updateLayer) {
      for (var ty = 0; ty < layer.height; ty++) {
        for (var tx = 0; tx < layer.width; tx++) {
          var tile = layer.data[ty][tx];
          if (tile) {
            if (tile.index >= start && tile.index <= stop) {
              SetTileCollision(tile, collides);
            }
          }
        }
      }
    }
    if (recalculateFaces) {
      CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
    }
  };
  module2.exports = SetCollisionBetween;
});

// node_modules/phaser/src/tilemaps/components/SetCollisionByExclusion.js
var require_SetCollisionByExclusion = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetTileCollision = require_SetTileCollision();
  var CalculateFacesWithin = require_CalculateFacesWithin();
  var SetLayerCollisionIndex = require_SetLayerCollisionIndex();
  var SetCollisionByExclusion = function(indexes, collides, recalculateFaces, layer) {
    if (collides === void 0) {
      collides = true;
    }
    if (recalculateFaces === void 0) {
      recalculateFaces = true;
    }
    if (!Array.isArray(indexes)) {
      indexes = [indexes];
    }
    for (var ty = 0; ty < layer.height; ty++) {
      for (var tx = 0; tx < layer.width; tx++) {
        var tile = layer.data[ty][tx];
        if (tile && indexes.indexOf(tile.index) === -1) {
          SetTileCollision(tile, collides);
          SetLayerCollisionIndex(tile.index, collides, layer);
        }
      }
    }
    if (recalculateFaces) {
      CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
    }
  };
  module2.exports = SetCollisionByExclusion;
});

// node_modules/phaser/src/tilemaps/components/SetCollisionByProperty.js
var require_SetCollisionByProperty = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetTileCollision = require_SetTileCollision();
  var CalculateFacesWithin = require_CalculateFacesWithin();
  var HasValue = require_HasValue();
  var SetCollisionByProperty = function(properties, collides, recalculateFaces, layer) {
    if (collides === void 0) {
      collides = true;
    }
    if (recalculateFaces === void 0) {
      recalculateFaces = true;
    }
    for (var ty = 0; ty < layer.height; ty++) {
      for (var tx = 0; tx < layer.width; tx++) {
        var tile = layer.data[ty][tx];
        if (!tile) {
          continue;
        }
        for (var property in properties) {
          if (!HasValue(tile.properties, property)) {
            continue;
          }
          var values = properties[property];
          if (!Array.isArray(values)) {
            values = [values];
          }
          for (var i = 0; i < values.length; i++) {
            if (tile.properties[property] === values[i]) {
              SetTileCollision(tile, collides);
            }
          }
        }
      }
    }
    if (recalculateFaces) {
      CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
    }
  };
  module2.exports = SetCollisionByProperty;
});

// node_modules/phaser/src/tilemaps/components/SetCollisionFromCollisionGroup.js
var require_SetCollisionFromCollisionGroup = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetTileCollision = require_SetTileCollision();
  var CalculateFacesWithin = require_CalculateFacesWithin();
  var SetCollisionFromCollisionGroup = function(collides, recalculateFaces, layer) {
    if (collides === void 0) {
      collides = true;
    }
    if (recalculateFaces === void 0) {
      recalculateFaces = true;
    }
    for (var ty = 0; ty < layer.height; ty++) {
      for (var tx = 0; tx < layer.width; tx++) {
        var tile = layer.data[ty][tx];
        if (!tile) {
          continue;
        }
        var collisionGroup = tile.getCollisionGroup();
        if (collisionGroup && collisionGroup.objects && collisionGroup.objects.length > 0) {
          SetTileCollision(tile, collides);
        }
      }
    }
    if (recalculateFaces) {
      CalculateFacesWithin(0, 0, layer.width, layer.height, layer);
    }
  };
  module2.exports = SetCollisionFromCollisionGroup;
});

// node_modules/phaser/src/tilemaps/components/SetTileIndexCallback.js
var require_SetTileIndexCallback = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var SetTileIndexCallback = function(indexes, callback, callbackContext, layer) {
    if (typeof indexes === "number") {
      layer.callbacks[indexes] = callback !== null ? {callback, callbackContext} : void 0;
    } else {
      for (var i = 0, len = indexes.length; i < len; i++) {
        layer.callbacks[indexes[i]] = callback !== null ? {callback, callbackContext} : void 0;
      }
    }
  };
  module2.exports = SetTileIndexCallback;
});

// node_modules/phaser/src/tilemaps/components/SetTileLocationCallback.js
var require_SetTileLocationCallback = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var SetTileLocationCallback = function(tileX, tileY, width, height, callback, callbackContext, layer) {
    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
    for (var i = 0; i < tiles.length; i++) {
      tiles[i].setCollisionCallback(callback, callbackContext);
    }
  };
  module2.exports = SetTileLocationCallback;
});

// node_modules/phaser/src/tilemaps/components/Shuffle.js
var require_Shuffle3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var ShuffleArray = require_Shuffle();
  var Shuffle = function(tileX, tileY, width, height, layer) {
    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
    var indexes = tiles.map(function(tile) {
      return tile.index;
    });
    ShuffleArray(indexes);
    for (var i = 0; i < tiles.length; i++) {
      tiles[i].index = indexes[i];
    }
  };
  module2.exports = Shuffle;
});

// node_modules/phaser/src/tilemaps/components/SwapByIndex.js
var require_SwapByIndex = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var SwapByIndex = function(indexA, indexB, tileX, tileY, width, height, layer) {
    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
    for (var i = 0; i < tiles.length; i++) {
      if (tiles[i]) {
        if (tiles[i].index === indexA) {
          tiles[i].index = indexB;
        } else if (tiles[i].index === indexB) {
          tiles[i].index = indexA;
        }
      }
    }
  };
  module2.exports = SwapByIndex;
});

// node_modules/phaser/src/tilemaps/components/WeightedRandomize.js
var require_WeightedRandomize = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetTilesWithin = require_GetTilesWithin();
  var WeightedRandomize = function(tileX, tileY, width, height, weightedIndexes, layer) {
    if (!weightedIndexes) {
      return;
    }
    var i;
    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);
    var weightTotal = 0;
    for (i = 0; i < weightedIndexes.length; i++) {
      weightTotal += weightedIndexes[i].weight;
    }
    if (weightTotal <= 0) {
      return;
    }
    for (i = 0; i < tiles.length; i++) {
      var rand = Math.random() * weightTotal;
      var sum = 0;
      var randomIndex = -1;
      for (var j = 0; j < weightedIndexes.length; j++) {
        sum += weightedIndexes[j].weight;
        if (rand <= sum) {
          var chosen = weightedIndexes[j].index;
          randomIndex = Array.isArray(chosen) ? chosen[Math.floor(Math.random() * chosen.length)] : chosen;
          break;
        }
      }
      tiles[i].index = randomIndex;
    }
  };
  module2.exports = WeightedRandomize;
});

// node_modules/phaser/src/tilemaps/components/index.js
var require_components4 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    CalculateFacesAt: require_CalculateFacesAt(),
    CalculateFacesWithin: require_CalculateFacesWithin(),
    CheckIsoBounds: require_CheckIsoBounds(),
    Copy: require_Copy(),
    CreateFromTiles: require_CreateFromTiles(),
    CullBounds: require_CullBounds(),
    CullTiles: require_CullTiles(),
    Fill: require_Fill(),
    FilterTiles: require_FilterTiles(),
    FindByIndex: require_FindByIndex(),
    FindTile: require_FindTile(),
    ForEachTile: require_ForEachTile(),
    GetCullTilesFunction: require_GetCullTilesFunction(),
    GetTileAt: require_GetTileAt(),
    GetTileAtWorldXY: require_GetTileAtWorldXY(),
    GetTilesWithin: require_GetTilesWithin(),
    GetTilesWithinShape: require_GetTilesWithinShape(),
    GetTilesWithinWorldXY: require_GetTilesWithinWorldXY(),
    GetTileToWorldXFunction: require_GetTileToWorldXFunction(),
    GetTileToWorldXYFunction: require_GetTileToWorldXYFunction(),
    GetTileToWorldYFunction: require_GetTileToWorldYFunction(),
    GetWorldToTileXFunction: require_GetWorldToTileXFunction(),
    GetWorldToTileXYFunction: require_GetWorldToTileXYFunction(),
    GetWorldToTileYFunction: require_GetWorldToTileYFunction(),
    HasTileAt: require_HasTileAt(),
    HasTileAtWorldXY: require_HasTileAtWorldXY(),
    HexagonalCullBounds: require_HexagonalCullBounds(),
    HexagonalCullTiles: require_HexagonalCullTiles(),
    HexagonalTileToWorldXY: require_HexagonalTileToWorldXY(),
    HexagonalTileToWorldY: require_HexagonalTileToWorldY(),
    HexagonalWorldToTileXY: require_HexagonalWorldToTileXY(),
    HexagonalWorldToTileY: require_HexagonalWorldToTileY(),
    IsInLayerBounds: require_IsInLayerBounds(),
    IsometricCullTiles: require_IsometricCullTiles(),
    IsometricTileToWorldXY: require_IsometricTileToWorldXY(),
    IsometricWorldToTileXY: require_IsometricWorldToTileXY(),
    PutTileAt: require_PutTileAt(),
    PutTileAtWorldXY: require_PutTileAtWorldXY(),
    PutTilesAt: require_PutTilesAt(),
    Randomize: require_Randomize(),
    RemoveTileAt: require_RemoveTileAt(),
    RemoveTileAtWorldXY: require_RemoveTileAtWorldXY(),
    RenderDebug: require_RenderDebug(),
    ReplaceByIndex: require_ReplaceByIndex(),
    RunCull: require_RunCull(),
    SetCollision: require_SetCollision(),
    SetCollisionBetween: require_SetCollisionBetween(),
    SetCollisionByExclusion: require_SetCollisionByExclusion(),
    SetCollisionByProperty: require_SetCollisionByProperty(),
    SetCollisionFromCollisionGroup: require_SetCollisionFromCollisionGroup(),
    SetLayerCollisionIndex: require_SetLayerCollisionIndex(),
    SetTileCollision: require_SetTileCollision(),
    SetTileIndexCallback: require_SetTileIndexCallback(),
    SetTileLocationCallback: require_SetTileLocationCallback(),
    Shuffle: require_Shuffle3(),
    StaggeredCullBounds: require_StaggeredCullBounds(),
    StaggeredCullTiles: require_StaggeredCullTiles(),
    StaggeredTileToWorldXY: require_StaggeredTileToWorldXY(),
    StaggeredTileToWorldY: require_StaggeredTileToWorldY(),
    StaggeredWorldToTileXY: require_StaggeredWorldToTileXY(),
    StaggeredWorldToTileY: require_StaggeredWorldToTileY(),
    SwapByIndex: require_SwapByIndex(),
    TileToWorldX: require_TileToWorldX(),
    TileToWorldXY: require_TileToWorldXY(),
    TileToWorldY: require_TileToWorldY(),
    WeightedRandomize: require_WeightedRandomize(),
    WorldToTileX: require_WorldToTileX(),
    WorldToTileXY: require_WorldToTileXY(),
    WorldToTileY: require_WorldToTileY()
  };
});

// node_modules/phaser/src/tilemaps/parsers/FromOrientationString.js
var require_FromOrientationString = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_ORIENTATION_CONST2();
  var FromOrientationString = function(orientation) {
    orientation = orientation.toLowerCase();
    if (orientation === "isometric") {
      return CONST.ISOMETRIC;
    } else if (orientation === "staggered") {
      return CONST.STAGGERED;
    } else if (orientation === "hexagonal") {
      return CONST.HEXAGONAL;
    } else {
      return CONST.ORTHOGONAL;
    }
  };
  module2.exports = FromOrientationString;
});

// node_modules/phaser/src/tilemaps/mapdata/LayerData.js
var require_LayerData = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_ORIENTATION_CONST2();
  var GetFastValue = require_GetFastValue();
  var LayerData = new Class({
    initialize: function LayerData2(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      this.name = GetFastValue(config2, "name", "layer");
      this.x = GetFastValue(config2, "x", 0);
      this.y = GetFastValue(config2, "y", 0);
      this.width = GetFastValue(config2, "width", 0);
      this.height = GetFastValue(config2, "height", 0);
      this.tileWidth = GetFastValue(config2, "tileWidth", 0);
      this.tileHeight = GetFastValue(config2, "tileHeight", 0);
      this.baseTileWidth = GetFastValue(config2, "baseTileWidth", this.tileWidth);
      this.baseTileHeight = GetFastValue(config2, "baseTileHeight", this.tileHeight);
      this.orientation = GetFastValue(config2, "orientation", CONST.ORTHOGONAL);
      this.widthInPixels = GetFastValue(config2, "widthInPixels", this.width * this.baseTileWidth);
      this.heightInPixels = GetFastValue(config2, "heightInPixels", this.height * this.baseTileHeight);
      this.alpha = GetFastValue(config2, "alpha", 1);
      this.visible = GetFastValue(config2, "visible", true);
      this.properties = GetFastValue(config2, "properties", []);
      this.indexes = GetFastValue(config2, "indexes", []);
      this.collideIndexes = GetFastValue(config2, "collideIndexes", []);
      this.callbacks = GetFastValue(config2, "callbacks", []);
      this.bodies = GetFastValue(config2, "bodies", []);
      this.data = GetFastValue(config2, "data", []);
      this.tilemapLayer = GetFastValue(config2, "tilemapLayer", null);
      this.hexSideLength = GetFastValue(config2, "hexSideLength", 0);
    }
  });
  module2.exports = LayerData;
});

// node_modules/phaser/src/tilemaps/mapdata/MapData.js
var require_MapData = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var CONST = require_ORIENTATION_CONST2();
  var GetFastValue = require_GetFastValue();
  var MapData = new Class({
    initialize: function MapData2(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      this.name = GetFastValue(config2, "name", "map");
      this.width = GetFastValue(config2, "width", 0);
      this.height = GetFastValue(config2, "height", 0);
      this.infinite = GetFastValue(config2, "infinite", false);
      this.tileWidth = GetFastValue(config2, "tileWidth", 0);
      this.tileHeight = GetFastValue(config2, "tileHeight", 0);
      this.widthInPixels = GetFastValue(config2, "widthInPixels", this.width * this.tileWidth);
      this.heightInPixels = GetFastValue(config2, "heightInPixels", this.height * this.tileHeight);
      this.format = GetFastValue(config2, "format", null);
      this.orientation = GetFastValue(config2, "orientation", CONST.ORTHOGONAL);
      this.renderOrder = GetFastValue(config2, "renderOrder", "right-down");
      this.version = GetFastValue(config2, "version", "1");
      this.properties = GetFastValue(config2, "properties", {});
      this.layers = GetFastValue(config2, "layers", []);
      this.images = GetFastValue(config2, "images", []);
      this.objects = GetFastValue(config2, "objects", {});
      this.collision = GetFastValue(config2, "collision", {});
      this.tilesets = GetFastValue(config2, "tilesets", []);
      this.imageCollections = GetFastValue(config2, "imageCollections", []);
      this.tiles = GetFastValue(config2, "tiles", []);
      this.hexSideLength = GetFastValue(config2, "hexSideLength", 0);
    }
  });
  module2.exports = MapData;
});

// node_modules/phaser/src/tilemaps/parsers/Parse2DArray.js
var require_Parse2DArray = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Formats = require_Formats();
  var LayerData = require_LayerData();
  var MapData = require_MapData();
  var Tile = require_Tile();
  var Parse2DArray = function(name, data, tileWidth, tileHeight, insertNull) {
    var layerData = new LayerData({
      tileWidth,
      tileHeight
    });
    var mapData = new MapData({
      name,
      tileWidth,
      tileHeight,
      format: Formats.ARRAY_2D,
      layers: [layerData]
    });
    var tiles = [];
    var height = data.length;
    var width = 0;
    for (var y = 0; y < data.length; y++) {
      tiles[y] = [];
      var row = data[y];
      for (var x = 0; x < row.length; x++) {
        var tileIndex = parseInt(row[x], 10);
        if (isNaN(tileIndex) || tileIndex === -1) {
          tiles[y][x] = insertNull ? null : new Tile(layerData, -1, x, y, tileWidth, tileHeight);
        } else {
          tiles[y][x] = new Tile(layerData, tileIndex, x, y, tileWidth, tileHeight);
        }
      }
      if (width === 0) {
        width = row.length;
      }
    }
    mapData.width = layerData.width = width;
    mapData.height = layerData.height = height;
    mapData.widthInPixels = layerData.widthInPixels = width * tileWidth;
    mapData.heightInPixels = layerData.heightInPixels = height * tileHeight;
    layerData.data = tiles;
    return mapData;
  };
  module2.exports = Parse2DArray;
});

// node_modules/phaser/src/tilemaps/parsers/ParseCSV.js
var require_ParseCSV = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Formats = require_Formats();
  var Parse2DArray = require_Parse2DArray();
  var ParseCSV = function(name, data, tileWidth, tileHeight, insertNull) {
    var array2D = data.trim().split("\n").map(function(row) {
      return row.split(",");
    });
    var map = Parse2DArray(name, array2D, tileWidth, tileHeight, insertNull);
    map.format = Formats.CSV;
    return map;
  };
  module2.exports = ParseCSV;
});

// node_modules/phaser/src/tilemaps/parsers/tiled/AssignTileProperties.js
var require_AssignTileProperties = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Extend = require_Extend();
  var AssignTileProperties = function(mapData) {
    var layerData;
    var tile;
    var sid;
    var set;
    var row;
    for (var i = 0; i < mapData.layers.length; i++) {
      layerData = mapData.layers[i];
      set = null;
      for (var j = 0; j < layerData.data.length; j++) {
        row = layerData.data[j];
        for (var k = 0; k < row.length; k++) {
          tile = row[k];
          if (tile === null || tile.index < 0) {
            continue;
          }
          sid = mapData.tiles[tile.index][2];
          set = mapData.tilesets[sid];
          tile.width = set.tileWidth;
          tile.height = set.tileHeight;
          if (set.tileProperties && set.tileProperties[tile.index - set.firstgid]) {
            tile.properties = Extend(tile.properties, set.tileProperties[tile.index - set.firstgid]);
          }
        }
      }
    }
  };
  module2.exports = AssignTileProperties;
});

// node_modules/phaser/src/tilemaps/Tileset.js
var require_Tileset = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Tileset = new Class({
    initialize: function Tileset2(name, firstgid, tileWidth, tileHeight, tileMargin, tileSpacing, tileProperties, tileData) {
      if (tileWidth === void 0 || tileWidth <= 0) {
        tileWidth = 32;
      }
      if (tileHeight === void 0 || tileHeight <= 0) {
        tileHeight = 32;
      }
      if (tileMargin === void 0) {
        tileMargin = 0;
      }
      if (tileSpacing === void 0) {
        tileSpacing = 0;
      }
      if (tileProperties === void 0) {
        tileProperties = {};
      }
      if (tileData === void 0) {
        tileData = {};
      }
      this.name = name;
      this.firstgid = firstgid;
      this.tileWidth = tileWidth;
      this.tileHeight = tileHeight;
      this.tileMargin = tileMargin;
      this.tileSpacing = tileSpacing;
      this.tileProperties = tileProperties;
      this.tileData = tileData;
      this.image = null;
      this.glTexture = null;
      this.rows = 0;
      this.columns = 0;
      this.total = 0;
      this.texCoordinates = [];
    },
    getTileProperties: function(tileIndex) {
      if (!this.containsTileIndex(tileIndex)) {
        return null;
      }
      return this.tileProperties[tileIndex - this.firstgid];
    },
    getTileData: function(tileIndex) {
      if (!this.containsTileIndex(tileIndex)) {
        return null;
      }
      return this.tileData[tileIndex - this.firstgid];
    },
    getTileCollisionGroup: function(tileIndex) {
      var data = this.getTileData(tileIndex);
      return data && data.objectgroup ? data.objectgroup : null;
    },
    containsTileIndex: function(tileIndex) {
      return tileIndex >= this.firstgid && tileIndex < this.firstgid + this.total;
    },
    getTileTextureCoordinates: function(tileIndex) {
      if (!this.containsTileIndex(tileIndex)) {
        return null;
      }
      return this.texCoordinates[tileIndex - this.firstgid];
    },
    setImage: function(texture) {
      this.image = texture;
      this.glTexture = texture.get().source.glTexture;
      this.updateTileData(this.image.source[0].width, this.image.source[0].height);
      return this;
    },
    setTileSize: function(tileWidth, tileHeight) {
      if (tileWidth !== void 0) {
        this.tileWidth = tileWidth;
      }
      if (tileHeight !== void 0) {
        this.tileHeight = tileHeight;
      }
      if (this.image) {
        this.updateTileData(this.image.source[0].width, this.image.source[0].height);
      }
      return this;
    },
    setSpacing: function(margin, spacing) {
      if (margin !== void 0) {
        this.tileMargin = margin;
      }
      if (spacing !== void 0) {
        this.tileSpacing = spacing;
      }
      if (this.image) {
        this.updateTileData(this.image.source[0].width, this.image.source[0].height);
      }
      return this;
    },
    updateTileData: function(imageWidth, imageHeight) {
      var rowCount = (imageHeight - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing);
      var colCount = (imageWidth - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
      if (rowCount % 1 !== 0 || colCount % 1 !== 0) {
        console.warn("Image tile area not tile size multiple in: " + this.name);
      }
      rowCount = Math.floor(rowCount);
      colCount = Math.floor(colCount);
      this.rows = rowCount;
      this.columns = colCount;
      this.total = rowCount * colCount;
      this.texCoordinates.length = 0;
      var tx = this.tileMargin;
      var ty = this.tileMargin;
      for (var y = 0; y < this.rows; y++) {
        for (var x = 0; x < this.columns; x++) {
          this.texCoordinates.push({x: tx, y: ty});
          tx += this.tileWidth + this.tileSpacing;
        }
        tx = this.tileMargin;
        ty += this.tileHeight + this.tileSpacing;
      }
      return this;
    }
  });
  module2.exports = Tileset;
});

// node_modules/phaser/src/tilemaps/parsers/tiled/BuildTilesetIndex.js
var require_BuildTilesetIndex = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Tileset = require_Tileset();
  var BuildTilesetIndex = function(mapData) {
    var i;
    var set;
    var tiles = [];
    for (i = 0; i < mapData.imageCollections.length; i++) {
      var collection = mapData.imageCollections[i];
      var images = collection.images;
      for (var j = 0; j < images.length; j++) {
        var image = images[j];
        set = new Tileset(image.image, image.gid, collection.imageWidth, collection.imageHeight, 0, 0);
        set.updateTileData(collection.imageWidth, collection.imageHeight);
        mapData.tilesets.push(set);
      }
    }
    for (i = 0; i < mapData.tilesets.length; i++) {
      set = mapData.tilesets[i];
      var x = set.tileMargin;
      var y = set.tileMargin;
      var count = 0;
      var countX = 0;
      var countY = 0;
      for (var t = set.firstgid; t < set.firstgid + set.total; t++) {
        tiles[t] = [x, y, i];
        x += set.tileWidth + set.tileSpacing;
        count++;
        if (count === set.total) {
          break;
        }
        countX++;
        if (countX === set.columns) {
          x = set.tileMargin;
          y += set.tileHeight + set.tileSpacing;
          countX = 0;
          countY++;
          if (countY === set.rows) {
            break;
          }
        }
      }
    }
    return tiles;
  };
  module2.exports = BuildTilesetIndex;
});

// node_modules/phaser/src/tilemaps/parsers/tiled/CreateGroupLayer.js
var require_CreateGroupLayer = __commonJS((exports2, module2) => {
  /**
   * @author       Seth Berrier <berriers@uwstout.edu>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetFastValue = require_GetFastValue();
  var CreateGroupLayer = function(json, groupl, parentstate) {
    if (!groupl) {
      return {
        i: 0,
        layers: json.layers,
        name: "",
        opacity: 1,
        visible: true,
        x: 0,
        y: 0
      };
    }
    var layerX = groupl.x + GetFastValue(groupl, "startx", 0) * json.tilewidth + GetFastValue(groupl, "offsetx", 0);
    var layerY = groupl.y + GetFastValue(groupl, "starty", 0) * json.tileheight + GetFastValue(groupl, "offsety", 0);
    return {
      i: 0,
      layers: groupl.layers,
      name: parentstate.name + groupl.name + "/",
      opacity: parentstate.opacity * groupl.opacity,
      visible: parentstate.visible && groupl.visible,
      x: parentstate.x + layerX,
      y: parentstate.y + layerY
    };
  };
  module2.exports = CreateGroupLayer;
});

// node_modules/phaser/src/tilemaps/parsers/tiled/ParseImageLayers.js
var require_ParseImageLayers = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetFastValue = require_GetFastValue();
  var CreateGroupLayer = require_CreateGroupLayer();
  var ParseImageLayers = function(json) {
    var images = [];
    var groupStack = [];
    var curGroupState = CreateGroupLayer(json);
    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
      if (curGroupState.i >= curGroupState.layers.length) {
        if (groupStack.length < 1) {
          console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
          break;
        }
        curGroupState = groupStack.pop();
        continue;
      }
      var curi = curGroupState.layers[curGroupState.i];
      curGroupState.i++;
      if (curi.type !== "imagelayer") {
        if (curi.type === "group") {
          var nextGroupState = CreateGroupLayer(json, curi, curGroupState);
          groupStack.push(curGroupState);
          curGroupState = nextGroupState;
        }
        continue;
      }
      var layerOffsetX = GetFastValue(curi, "offsetx", 0) + GetFastValue(curi, "startx", 0);
      var layerOffsetY = GetFastValue(curi, "offsety", 0) + GetFastValue(curi, "starty", 0);
      images.push({
        name: curGroupState.name + curi.name,
        image: curi.image,
        x: curGroupState.x + layerOffsetX + curi.x,
        y: curGroupState.y + layerOffsetY + curi.y,
        alpha: curGroupState.opacity * curi.opacity,
        visible: curGroupState.visible && curi.visible,
        properties: GetFastValue(curi, "properties", {})
      });
    }
    return images;
  };
  module2.exports = ParseImageLayers;
});

// node_modules/phaser/src/utils/object/Pick.js
var require_Pick = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var HasValue = require_HasValue();
  var Pick = function(object, keys) {
    var obj = {};
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (HasValue(object, key)) {
        obj[key] = object[key];
      }
    }
    return obj;
  };
  module2.exports = Pick;
});

// node_modules/phaser/src/tilemaps/parsers/tiled/ParseGID.js
var require_ParseGID = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var FLIPPED_HORIZONTAL = 2147483648;
  var FLIPPED_VERTICAL = 1073741824;
  var FLIPPED_ANTI_DIAGONAL = 536870912;
  var ParseGID = function(gid) {
    var flippedHorizontal = Boolean(gid & FLIPPED_HORIZONTAL);
    var flippedVertical = Boolean(gid & FLIPPED_VERTICAL);
    var flippedAntiDiagonal = Boolean(gid & FLIPPED_ANTI_DIAGONAL);
    gid = gid & ~(FLIPPED_HORIZONTAL | FLIPPED_VERTICAL | FLIPPED_ANTI_DIAGONAL);
    var rotation = 0;
    var flipped = false;
    if (flippedHorizontal && flippedVertical && flippedAntiDiagonal) {
      rotation = Math.PI / 2;
      flipped = true;
    } else if (flippedHorizontal && flippedVertical && !flippedAntiDiagonal) {
      rotation = Math.PI;
      flipped = false;
    } else if (flippedHorizontal && !flippedVertical && flippedAntiDiagonal) {
      rotation = Math.PI / 2;
      flipped = false;
    } else if (flippedHorizontal && !flippedVertical && !flippedAntiDiagonal) {
      rotation = 0;
      flipped = true;
    } else if (!flippedHorizontal && flippedVertical && flippedAntiDiagonal) {
      rotation = 3 * Math.PI / 2;
      flipped = false;
    } else if (!flippedHorizontal && flippedVertical && !flippedAntiDiagonal) {
      rotation = Math.PI;
      flipped = true;
    } else if (!flippedHorizontal && !flippedVertical && flippedAntiDiagonal) {
      rotation = 3 * Math.PI / 2;
      flipped = true;
    } else if (!flippedHorizontal && !flippedVertical && !flippedAntiDiagonal) {
      rotation = 0;
      flipped = false;
    }
    return {
      gid,
      flippedHorizontal,
      flippedVertical,
      flippedAntiDiagonal,
      rotation,
      flipped
    };
  };
  module2.exports = ParseGID;
});

// node_modules/phaser/src/tilemaps/parsers/tiled/ParseObject.js
var require_ParseObject = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Pick = require_Pick();
  var ParseGID = require_ParseGID();
  var copyPoints = function(p) {
    return {x: p.x, y: p.y};
  };
  var commonObjectProps = ["id", "name", "type", "rotation", "properties", "visible", "x", "y", "width", "height"];
  var ParseObject = function(tiledObject, offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    var parsedObject = Pick(tiledObject, commonObjectProps);
    parsedObject.x += offsetX;
    parsedObject.y += offsetY;
    if (tiledObject.gid) {
      var gidInfo = ParseGID(tiledObject.gid);
      parsedObject.gid = gidInfo.gid;
      parsedObject.flippedHorizontal = gidInfo.flippedHorizontal;
      parsedObject.flippedVertical = gidInfo.flippedVertical;
      parsedObject.flippedAntiDiagonal = gidInfo.flippedAntiDiagonal;
    } else if (tiledObject.polyline) {
      parsedObject.polyline = tiledObject.polyline.map(copyPoints);
    } else if (tiledObject.polygon) {
      parsedObject.polygon = tiledObject.polygon.map(copyPoints);
    } else if (tiledObject.ellipse) {
      parsedObject.ellipse = tiledObject.ellipse;
    } else if (tiledObject.text) {
      parsedObject.text = tiledObject.text;
    } else if (tiledObject.point) {
      parsedObject.point = true;
    } else {
      parsedObject.rectangle = true;
    }
    return parsedObject;
  };
  module2.exports = ParseObject;
});

// node_modules/phaser/src/tilemaps/mapdata/ObjectLayer.js
var require_ObjectLayer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetFastValue = require_GetFastValue();
  var ObjectLayer = new Class({
    initialize: function ObjectLayer2(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      this.name = GetFastValue(config2, "name", "object layer");
      this.opacity = GetFastValue(config2, "opacity", 1);
      this.properties = GetFastValue(config2, "properties", {});
      this.propertyTypes = GetFastValue(config2, "propertytypes", {});
      this.type = GetFastValue(config2, "type", "objectgroup");
      this.visible = GetFastValue(config2, "visible", true);
      this.objects = GetFastValue(config2, "objects", []);
    }
  });
  module2.exports = ObjectLayer;
});

// node_modules/phaser/src/tilemaps/parsers/tiled/ParseObjectLayers.js
var require_ParseObjectLayers = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetFastValue = require_GetFastValue();
  var ParseObject = require_ParseObject();
  var ObjectLayer = require_ObjectLayer();
  var CreateGroupLayer = require_CreateGroupLayer();
  var ParseObjectLayers = function(json) {
    var objectLayers = [];
    var groupStack = [];
    var curGroupState = CreateGroupLayer(json);
    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
      if (curGroupState.i >= curGroupState.layers.length) {
        if (groupStack.length < 1) {
          console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
          break;
        }
        curGroupState = groupStack.pop();
        continue;
      }
      var curo = curGroupState.layers[curGroupState.i];
      curGroupState.i++;
      curo.opacity *= curGroupState.opacity;
      curo.visible = curGroupState.visible && curo.visible;
      if (curo.type !== "objectgroup") {
        if (curo.type === "group") {
          var nextGroupState = CreateGroupLayer(json, curo, curGroupState);
          groupStack.push(curGroupState);
          curGroupState = nextGroupState;
        }
        continue;
      }
      curo.name = curGroupState.name + curo.name;
      var offsetX = curGroupState.x + GetFastValue(curo, "startx", 0) + GetFastValue(curo, "offsetx", 0);
      var offsetY = curGroupState.y + GetFastValue(curo, "starty", 0) + GetFastValue(curo, "offsety", 0);
      var objects = [];
      for (var j = 0; j < curo.objects.length; j++) {
        var parsedObject = ParseObject(curo.objects[j], offsetX, offsetY);
        objects.push(parsedObject);
      }
      var objectLayer = new ObjectLayer(curo);
      objectLayer.objects = objects;
      objectLayers.push(objectLayer);
    }
    return objectLayers;
  };
  module2.exports = ParseObjectLayers;
});

// node_modules/phaser/src/tilemaps/parsers/tiled/Base64Decode.js
var require_Base64Decode = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Base64Decode = function(data) {
    var binaryString = window.atob(data);
    var len = binaryString.length;
    var bytes = new Array(len / 4);
    for (var i = 0; i < len; i += 4) {
      bytes[i / 4] = (binaryString.charCodeAt(i) | binaryString.charCodeAt(i + 1) << 8 | binaryString.charCodeAt(i + 2) << 16 | binaryString.charCodeAt(i + 3) << 24) >>> 0;
    }
    return bytes;
  };
  module2.exports = Base64Decode;
});

// node_modules/phaser/src/tilemaps/parsers/tiled/ParseTileLayers.js
var require_ParseTileLayers = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Base64Decode = require_Base64Decode();
  var CONST = require_ORIENTATION_CONST2();
  var CreateGroupLayer = require_CreateGroupLayer();
  var FromOrientationString = require_FromOrientationString();
  var GetFastValue = require_GetFastValue();
  var LayerData = require_LayerData();
  var ParseGID = require_ParseGID();
  var Tile = require_Tile();
  var ParseTileLayers = function(json, insertNull) {
    var infiniteMap = GetFastValue(json, "infinite", false);
    var tileLayers = [];
    var groupStack = [];
    var curGroupState = CreateGroupLayer(json);
    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {
      if (curGroupState.i >= curGroupState.layers.length) {
        if (groupStack.length < 1) {
          console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
          break;
        }
        curGroupState = groupStack.pop();
        continue;
      }
      var curl = curGroupState.layers[curGroupState.i];
      curGroupState.i++;
      if (curl.type !== "tilelayer") {
        if (curl.type === "group") {
          var nextGroupState = CreateGroupLayer(json, curl, curGroupState);
          groupStack.push(curGroupState);
          curGroupState = nextGroupState;
        }
        continue;
      }
      if (curl.compression) {
        console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + curl.name + "'");
        continue;
      } else if (curl.encoding && curl.encoding === "base64") {
        if (curl.chunks) {
          for (var i = 0; i < curl.chunks.length; i++) {
            curl.chunks[i].data = Base64Decode(curl.chunks[i].data);
          }
        }
        if (curl.data) {
          curl.data = Base64Decode(curl.data);
        }
        delete curl.encoding;
      }
      var layerData;
      var gidInfo;
      var tile;
      var blankTile;
      var output = [];
      var x = 0;
      if (infiniteMap) {
        var layerOffsetX = GetFastValue(curl, "startx", 0) + curl.x;
        var layerOffsetY = GetFastValue(curl, "starty", 0) + curl.y;
        layerData = new LayerData({
          name: curGroupState.name + curl.name,
          x: curGroupState.x + GetFastValue(curl, "offsetx", 0) + layerOffsetX * json.tilewidth,
          y: curGroupState.y + GetFastValue(curl, "offsety", 0) + layerOffsetY * json.tileheight,
          width: curl.width,
          height: curl.height,
          tileWidth: json.tilewidth,
          tileHeight: json.tileheight,
          alpha: curGroupState.opacity * curl.opacity,
          visible: curGroupState.visible && curl.visible,
          properties: GetFastValue(curl, "properties", []),
          orientation: FromOrientationString(json.orientation)
        });
        if (layerData.orientation === CONST.HEXAGONAL) {
          layerData.hexSideLength = json.hexsidelength;
        }
        for (var c = 0; c < curl.height; c++) {
          output.push([null]);
          for (var j = 0; j < curl.width; j++) {
            output[c][j] = null;
          }
        }
        for (c = 0, len = curl.chunks.length; c < len; c++) {
          var chunk = curl.chunks[c];
          var offsetX = chunk.x - layerOffsetX;
          var offsetY = chunk.y - layerOffsetY;
          var y = 0;
          for (var t = 0, len2 = chunk.data.length; t < len2; t++) {
            var newOffsetX = x + offsetX;
            var newOffsetY = y + offsetY;
            gidInfo = ParseGID(chunk.data[t]);
            if (gidInfo.gid > 0) {
              tile = new Tile(layerData, gidInfo.gid, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);
              tile.rotation = gidInfo.rotation;
              tile.flipX = gidInfo.flipped;
              output[newOffsetY][newOffsetX] = tile;
            } else {
              blankTile = insertNull ? null : new Tile(layerData, -1, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);
              output[newOffsetY][newOffsetX] = blankTile;
            }
            x++;
            if (x === chunk.width) {
              y++;
              x = 0;
            }
          }
        }
      } else {
        layerData = new LayerData({
          name: curGroupState.name + curl.name,
          x: curGroupState.x + GetFastValue(curl, "offsetx", 0) + curl.x,
          y: curGroupState.y + GetFastValue(curl, "offsety", 0) + curl.y,
          width: curl.width,
          height: curl.height,
          tileWidth: json.tilewidth,
          tileHeight: json.tileheight,
          alpha: curGroupState.opacity * curl.opacity,
          visible: curGroupState.visible && curl.visible,
          properties: GetFastValue(curl, "properties", []),
          orientation: FromOrientationString(json.orientation)
        });
        if (layerData.orientation === CONST.HEXAGONAL) {
          layerData.hexSideLength = json.hexsidelength;
        }
        var row = [];
        for (var k = 0, len = curl.data.length; k < len; k++) {
          gidInfo = ParseGID(curl.data[k]);
          if (gidInfo.gid > 0) {
            tile = new Tile(layerData, gidInfo.gid, x, output.length, json.tilewidth, json.tileheight);
            tile.rotation = gidInfo.rotation;
            tile.flipX = gidInfo.flipped;
            row.push(tile);
          } else {
            blankTile = insertNull ? null : new Tile(layerData, -1, x, output.length, json.tilewidth, json.tileheight);
            row.push(blankTile);
          }
          x++;
          if (x === curl.width) {
            output.push(row);
            x = 0;
            row = [];
          }
        }
      }
      layerData.data = output;
      tileLayers.push(layerData);
    }
    return tileLayers;
  };
  module2.exports = ParseTileLayers;
});

// node_modules/phaser/src/tilemaps/ImageCollection.js
var require_ImageCollection = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var ImageCollection = new Class({
    initialize: function ImageCollection2(name, firstgid, width, height, margin, spacing, properties) {
      if (width === void 0 || width <= 0) {
        width = 32;
      }
      if (height === void 0 || height <= 0) {
        height = 32;
      }
      if (margin === void 0) {
        margin = 0;
      }
      if (spacing === void 0) {
        spacing = 0;
      }
      this.name = name;
      this.firstgid = firstgid | 0;
      this.imageWidth = width | 0;
      this.imageHeight = height | 0;
      this.imageMargin = margin | 0;
      this.imageSpacing = spacing | 0;
      this.properties = properties || {};
      this.images = [];
      this.total = 0;
    },
    containsImageIndex: function(imageIndex) {
      return imageIndex >= this.firstgid && imageIndex < this.firstgid + this.total;
    },
    addImage: function(gid, image) {
      this.images.push({gid, image});
      this.total++;
      return this;
    }
  });
  module2.exports = ImageCollection;
});

// node_modules/phaser/src/tilemaps/parsers/tiled/ParseWangsets.js
var require_ParseWangsets = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ParseWangsets = function(wangsets, datas) {
    for (var w = 0; w < wangsets.length; w++) {
      var wangset = wangsets[w];
      var identifier = w;
      if (wangset.name && wangset.name !== "") {
        identifier = wangset.name;
      }
      if (Array.isArray(wangset.wangtiles) && wangset.wangtiles.length > 0) {
        var edgeColors = {};
        var cornerColors = {};
        var c;
        var color;
        var colorIndex;
        if (Array.isArray(wangset.edgecolors)) {
          for (c = 0; c < wangset.edgecolors.length; c++) {
            colorIndex = 1 + c;
            color = wangset.edgecolors[c];
            if (color.name !== "") {
              edgeColors[colorIndex] = color.name;
            }
          }
        }
        if (Array.isArray(wangset.cornercolors)) {
          for (c = 0; c < wangset.cornercolors.length; c++) {
            colorIndex = 1 + c;
            color = wangset.cornercolors[c];
            if (color.name !== "") {
              cornerColors[colorIndex] = color.name;
            }
          }
        }
        if (Array.isArray(wangset.colors)) {
          for (c = 0; c < wangset.colors.length; c++) {
            color = wangset.colors[c];
            colorIndex = 1 + c;
            if (color.name !== "") {
              edgeColors[colorIndex] = cornerColors[colorIndex] = color.name;
            }
          }
        }
        var idLayout = [
          edgeColors,
          cornerColors,
          edgeColors,
          cornerColors,
          edgeColors,
          cornerColors,
          edgeColors,
          cornerColors
        ];
        for (var t = 0; t < wangset.wangtiles.length; t++) {
          var wangtile = wangset.wangtiles[t];
          var obj = datas[wangtile.tileid] || (datas[wangtile.tileid] = {});
          obj = obj.wangid || (obj.wangid = {});
          var wangid = [];
          for (var i = 0; i < Math.min(idLayout.length, wangtile.wangid.length); i++) {
            color = wangtile.wangid[i];
            if (color === 0) {
              wangid.push(void 0);
              continue;
            }
            var renamed = idLayout[i][color];
            if (renamed !== void 0) {
              wangid.push(renamed);
              continue;
            }
            wangid.push(color);
          }
          obj[identifier] = wangid;
        }
      }
    }
  };
  module2.exports = ParseWangsets;
});

// node_modules/phaser/src/tilemaps/parsers/tiled/ParseTilesets.js
var require_ParseTilesets = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Tileset = require_Tileset();
  var ImageCollection = require_ImageCollection();
  var ParseObject = require_ParseObject();
  var ParseWangsets = require_ParseWangsets();
  var ParseTilesets = function(json) {
    var tilesets = [];
    var imageCollections = [];
    var lastSet = null;
    var stringID;
    for (var i = 0; i < json.tilesets.length; i++) {
      var set = json.tilesets[i];
      if (set.source) {
        console.warn("External tilesets unsupported. Use Embed Tileset and re-export");
      } else if (set.image) {
        var newSet = new Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing);
        if (json.version > 1) {
          var datas = void 0;
          var props = void 0;
          if (Array.isArray(set.tiles)) {
            datas = datas || {};
            props = props || {};
            for (var t = 0; t < set.tiles.length; t++) {
              var tile = set.tiles[t];
              if (tile.properties) {
                var newPropData = {};
                tile.properties.forEach(function(propData) {
                  newPropData[propData["name"]] = propData["value"];
                });
                props[tile.id] = newPropData;
              }
              if (tile.objectgroup) {
                (datas[tile.id] || (datas[tile.id] = {})).objectgroup = tile.objectgroup;
                if (tile.objectgroup.objects) {
                  var parsedObjects2 = tile.objectgroup.objects.map(function(obj) {
                    return ParseObject(obj);
                  });
                  datas[tile.id].objectgroup.objects = parsedObjects2;
                }
              }
              if (tile.animation) {
                (datas[tile.id] || (datas[tile.id] = {})).animation = tile.animation;
              }
              if (tile.type) {
                (datas[tile.id] || (datas[tile.id] = {})).type = tile.type;
              }
            }
          }
          if (Array.isArray(set.wangsets)) {
            datas = datas || {};
            props = props || {};
            ParseWangsets(set.wangsets, datas);
          }
          if (datas) {
            newSet.tileData = datas;
            newSet.tileProperties = props;
          }
        } else {
          if (set.tileproperties) {
            newSet.tileProperties = set.tileproperties;
          }
          if (set.tiles) {
            newSet.tileData = set.tiles;
            for (stringID in newSet.tileData) {
              var objectGroup = newSet.tileData[stringID].objectgroup;
              if (objectGroup && objectGroup.objects) {
                var parsedObjects1 = objectGroup.objects.map(function(obj) {
                  return ParseObject(obj);
                });
                newSet.tileData[stringID].objectgroup.objects = parsedObjects1;
              }
            }
          }
        }
        newSet.updateTileData(set.imagewidth, set.imageheight);
        tilesets.push(newSet);
      } else {
        var newCollection = new ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);
        var maxId = 0;
        for (t = 0; t < set.tiles.length; t++) {
          tile = set.tiles[t];
          var image = tile.image;
          var tileId = parseInt(tile.id, 10);
          var gid = set.firstgid + tileId;
          newCollection.addImage(gid, image);
          maxId = Math.max(tileId, maxId);
        }
        newCollection.maxId = maxId;
        imageCollections.push(newCollection);
      }
      if (lastSet) {
        lastSet.lastgid = set.firstgid - 1;
      }
      lastSet = set;
    }
    return {tilesets, imageCollections};
  };
  module2.exports = ParseTilesets;
});

// node_modules/phaser/src/tilemaps/parsers/tiled/ParseJSONTiled.js
var require_ParseJSONTiled = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var AssignTileProperties = require_AssignTileProperties();
  var BuildTilesetIndex = require_BuildTilesetIndex();
  var CONST = require_ORIENTATION_CONST2();
  var Formats = require_Formats();
  var FromOrientationString = require_FromOrientationString();
  var MapData = require_MapData();
  var ParseImageLayers = require_ParseImageLayers();
  var ParseObjectLayers = require_ParseObjectLayers();
  var ParseTileLayers = require_ParseTileLayers();
  var ParseTilesets = require_ParseTilesets();
  var ParseJSONTiled = function(name, json, insertNull) {
    var mapData = new MapData({
      width: json.width,
      height: json.height,
      name,
      tileWidth: json.tilewidth,
      tileHeight: json.tileheight,
      orientation: FromOrientationString(json.orientation),
      format: Formats.TILED_JSON,
      version: json.version,
      properties: json.properties,
      renderOrder: json.renderorder,
      infinite: json.infinite
    });
    if (mapData.orientation === CONST.HEXAGONAL) {
      mapData.hexSideLength = json.hexsidelength;
    }
    mapData.layers = ParseTileLayers(json, insertNull);
    mapData.images = ParseImageLayers(json);
    var sets = ParseTilesets(json);
    mapData.tilesets = sets.tilesets;
    mapData.imageCollections = sets.imageCollections;
    mapData.objects = ParseObjectLayers(json);
    mapData.tiles = BuildTilesetIndex(mapData);
    AssignTileProperties(mapData);
    return mapData;
  };
  module2.exports = ParseJSONTiled;
});

// node_modules/phaser/src/tilemaps/parsers/impact/ParseTileLayers.js
var require_ParseTileLayers2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var LayerData = require_LayerData();
  var Tile = require_Tile();
  var ParseTileLayers = function(json, insertNull) {
    var tileLayers = [];
    for (var i = 0; i < json.layer.length; i++) {
      var layer = json.layer[i];
      var layerData = new LayerData({
        name: layer.name,
        width: layer.width,
        height: layer.height,
        tileWidth: layer.tilesize,
        tileHeight: layer.tilesize,
        visible: layer.visible === 1
      });
      var row = [];
      var tileGrid = [];
      for (var y = 0; y < layer.data.length; y++) {
        for (var x = 0; x < layer.data[y].length; x++) {
          var index = layer.data[y][x] - 1;
          var tile;
          if (index > -1) {
            tile = new Tile(layerData, index, x, y, layer.tilesize, layer.tilesize);
          } else {
            tile = insertNull ? null : new Tile(layerData, -1, x, y, layer.tilesize, layer.tilesize);
          }
          row.push(tile);
        }
        tileGrid.push(row);
        row = [];
      }
      layerData.data = tileGrid;
      tileLayers.push(layerData);
    }
    return tileLayers;
  };
  module2.exports = ParseTileLayers;
});

// node_modules/phaser/src/tilemaps/parsers/impact/ParseTilesets.js
var require_ParseTilesets2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Tileset = require_Tileset();
  var ParseTilesets = function(json) {
    var tilesets = [];
    var tilesetsNames = [];
    for (var i = 0; i < json.layer.length; i++) {
      var layer = json.layer[i];
      var tilesetName = layer.tilesetName;
      if (tilesetName !== "" && tilesetsNames.indexOf(tilesetName) === -1) {
        tilesetsNames.push(tilesetName);
        tilesets.push(new Tileset(tilesetName, 0, layer.tilesize, layer.tilesize, 0, 0));
      }
    }
    return tilesets;
  };
  module2.exports = ParseTilesets;
});

// node_modules/phaser/src/tilemaps/parsers/impact/ParseWeltmeister.js
var require_ParseWeltmeister = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Formats = require_Formats();
  var MapData = require_MapData();
  var ParseTileLayers = require_ParseTileLayers2();
  var ParseTilesets = require_ParseTilesets2();
  var ParseWeltmeister = function(name, json, insertNull) {
    if (json.layer.length === 0) {
      console.warn("No layers found in the Weltmeister map: " + name);
      return null;
    }
    var width = 0;
    var height = 0;
    for (var i = 0; i < json.layer.length; i++) {
      if (json.layer[i].width > width) {
        width = json.layer[i].width;
      }
      if (json.layer[i].height > height) {
        height = json.layer[i].height;
      }
    }
    var mapData = new MapData({
      width,
      height,
      name,
      tileWidth: json.layer[0].tilesize,
      tileHeight: json.layer[0].tilesize,
      format: Formats.WELTMEISTER
    });
    mapData.layers = ParseTileLayers(json, insertNull);
    mapData.tilesets = ParseTilesets(json);
    return mapData;
  };
  module2.exports = ParseWeltmeister;
});

// node_modules/phaser/src/tilemaps/parsers/Parse.js
var require_Parse = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Formats = require_Formats();
  var Parse2DArray = require_Parse2DArray();
  var ParseCSV = require_ParseCSV();
  var ParseJSONTiled = require_ParseJSONTiled();
  var ParseWeltmeister = require_ParseWeltmeister();
  var Parse = function(name, mapFormat, data, tileWidth, tileHeight, insertNull) {
    var newMap;
    switch (mapFormat) {
      case Formats.ARRAY_2D:
        newMap = Parse2DArray(name, data, tileWidth, tileHeight, insertNull);
        break;
      case Formats.CSV:
        newMap = ParseCSV(name, data, tileWidth, tileHeight, insertNull);
        break;
      case Formats.TILED_JSON:
        newMap = ParseJSONTiled(name, data, insertNull);
        break;
      case Formats.WELTMEISTER:
        newMap = ParseWeltmeister(name, data, insertNull);
        break;
      default:
        console.warn("Unrecognized tilemap data format: " + mapFormat);
        newMap = null;
    }
    return newMap;
  };
  module2.exports = Parse;
});

// node_modules/phaser/src/tilemaps/parsers/impact/index.js
var require_impact = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ParseTileLayers: require_ParseTileLayers2(),
    ParseTilesets: require_ParseTilesets2(),
    ParseWeltmeister: require_ParseWeltmeister()
  };
});

// node_modules/phaser/src/tilemaps/parsers/tiled/index.js
var require_tiled = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    AssignTileProperties: require_AssignTileProperties(),
    Base64Decode: require_Base64Decode(),
    BuildTilesetIndex: require_BuildTilesetIndex(),
    CreateGroupLayer: require_CreateGroupLayer(),
    ParseGID: require_ParseGID(),
    ParseImageLayers: require_ParseImageLayers(),
    ParseJSONTiled: require_ParseJSONTiled(),
    ParseObject: require_ParseObject(),
    ParseObjectLayers: require_ParseObjectLayers(),
    ParseTileLayers: require_ParseTileLayers(),
    ParseTilesets: require_ParseTilesets()
  };
});

// node_modules/phaser/src/tilemaps/parsers/index.js
var require_parsers2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    FromOrientationString: require_FromOrientationString(),
    Parse: require_Parse(),
    Parse2DArray: require_Parse2DArray(),
    ParseCSV: require_ParseCSV(),
    Impact: require_impact(),
    Tiled: require_tiled()
  };
});

// node_modules/phaser/src/tilemaps/TilemapLayerWebGLRenderer.js
var require_TilemapLayerWebGLRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Utils = require_Utils();
  var TilemapLayerWebGLRenderer = function(renderer, src, camera) {
    var renderTiles = src.cull(camera);
    var tileCount = renderTiles.length;
    var alpha = camera.alpha * src.alpha;
    if (tileCount === 0 || alpha <= 0) {
      return;
    }
    var gidMap = src.gidMap;
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var getTint = Utils.getTintAppendFloatAlpha;
    var scrollFactorX = src.scrollFactorX;
    var scrollFactorY = src.scrollFactorY;
    var x = src.x;
    var y = src.y;
    var sx = src.scaleX;
    var sy = src.scaleY;
    renderer.pipelines.preBatch(src);
    for (var i = 0; i < tileCount; i++) {
      var tile = renderTiles[i];
      var tileset = gidMap[tile.index];
      if (!tileset) {
        continue;
      }
      var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);
      if (tileTexCoords === null) {
        continue;
      }
      var texture = tileset.glTexture;
      var textureUnit = pipeline.setTexture2D(texture, src);
      var frameWidth = tileset.tileWidth;
      var frameHeight = tileset.tileHeight;
      var frameX = tileTexCoords.x;
      var frameY = tileTexCoords.y;
      var tw = tileset.tileWidth * 0.5;
      var th = tileset.tileHeight * 0.5;
      var tint = getTint(tile.tint, alpha * tile.alpha);
      pipeline.batchTexture(src, texture, texture.width, texture.height, x + (tw + tile.pixelX) * sx, y + (th + tile.pixelY) * sy, tile.width, tile.height, sx, sy, tile.rotation, tile.flipX, tile.flipY, scrollFactorX, scrollFactorY, tw, th, frameX, frameY, frameWidth, frameHeight, tint, tint, tint, tint, false, 0, 0, camera, null, true, textureUnit);
    }
    renderer.pipelines.postBatch(src);
  };
  module2.exports = TilemapLayerWebGLRenderer;
});

// node_modules/phaser/src/tilemaps/TilemapLayerCanvasRenderer.js
var require_TilemapLayerCanvasRenderer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TransformMatrix = require_TransformMatrix();
  var tempMatrix1 = new TransformMatrix();
  var tempMatrix2 = new TransformMatrix();
  var tempMatrix3 = new TransformMatrix();
  var TilemapLayerCanvasRenderer = function(renderer, src, camera, parentMatrix) {
    var renderTiles = src.cull(camera);
    var tileCount = renderTiles.length;
    var alpha = camera.alpha * src.alpha;
    if (tileCount === 0 || alpha <= 0) {
      return;
    }
    var camMatrix = tempMatrix1;
    var layerMatrix = tempMatrix2;
    var calcMatrix = tempMatrix3;
    layerMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);
    camMatrix.copyFrom(camera.matrix);
    var ctx = renderer.currentContext;
    var gidMap = src.gidMap;
    ctx.save();
    if (parentMatrix) {
      camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);
      layerMatrix.e = src.x;
      layerMatrix.f = src.y;
      camMatrix.multiply(layerMatrix, calcMatrix);
      calcMatrix.copyToContext(ctx);
    } else {
      layerMatrix.e -= camera.scrollX * src.scrollFactorX;
      layerMatrix.f -= camera.scrollY * src.scrollFactorY;
      layerMatrix.copyToContext(ctx);
    }
    if (!renderer.antialias || src.scaleX > 1 || src.scaleY > 1) {
      ctx.imageSmoothingEnabled = false;
    }
    for (var i = 0; i < tileCount; i++) {
      var tile = renderTiles[i];
      var tileset = gidMap[tile.index];
      if (!tileset) {
        continue;
      }
      var image = tileset.image.getSourceImage();
      var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);
      if (tileTexCoords === null) {
        continue;
      }
      var tileWidth = tileset.tileWidth;
      var tileHeight = tileset.tileHeight;
      var halfWidth = tileWidth * 0.5;
      var halfHeight = tileHeight * 0.5;
      ctx.save();
      ctx.translate(tile.pixelX + halfWidth, tile.pixelY + halfHeight);
      if (tile.rotation !== 0) {
        ctx.rotate(tile.rotation);
      }
      if (tile.flipX || tile.flipY) {
        ctx.scale(tile.flipX ? -1 : 1, tile.flipY ? -1 : 1);
      }
      ctx.globalAlpha = alpha * tile.alpha;
      ctx.drawImage(image, tileTexCoords.x, tileTexCoords.y, tileWidth, tileHeight, -halfWidth, -halfHeight, tileWidth, tileHeight);
      ctx.restore();
    }
    ctx.restore();
  };
  module2.exports = TilemapLayerCanvasRenderer;
});

// node_modules/phaser/src/tilemaps/TilemapLayerRender.js
var require_TilemapLayerRender = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var renderWebGL = require_NOOP();
  var renderCanvas = require_NOOP();
  if (typeof WEBGL_RENDERER) {
    renderWebGL = require_TilemapLayerWebGLRenderer();
  }
  if (typeof CANVAS_RENDERER) {
    renderCanvas = require_TilemapLayerCanvasRenderer();
  }
  module2.exports = {
    renderWebGL,
    renderCanvas
  };
});

// node_modules/phaser/src/tilemaps/TilemapLayer.js
var require_TilemapLayer = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var Components = require_components();
  var GameObject = require_GameObject();
  var TilemapComponents = require_components4();
  var TilemapLayerRender = require_TilemapLayerRender();
  var TilemapLayer = new Class({
    Extends: GameObject,
    Mixins: [
      Components.Alpha,
      Components.BlendMode,
      Components.ComputedSize,
      Components.Depth,
      Components.Flip,
      Components.GetBounds,
      Components.Origin,
      Components.Pipeline,
      Components.Transform,
      Components.Visible,
      Components.ScrollFactor,
      TilemapLayerRender
    ],
    initialize: function TilemapLayer2(scene, tilemap, layerIndex, tileset, x, y) {
      GameObject.call(this, scene, "TilemapLayer");
      this.isTilemap = true;
      this.tilemap = tilemap;
      this.layerIndex = layerIndex;
      this.layer = tilemap.layers[layerIndex];
      this.layer.tilemapLayer = this;
      this.tileset = [];
      this.tilesDrawn = 0;
      this.tilesTotal = this.layer.width * this.layer.height;
      this.culledTiles = [];
      this.skipCull = false;
      this.cullPaddingX = 1;
      this.cullPaddingY = 1;
      this.cullCallback = TilemapComponents.GetCullTilesFunction(this.layer.orientation);
      this._renderOrder = 0;
      this.gidMap = [];
      this.setTilesets(tileset);
      this.setAlpha(this.layer.alpha);
      this.setPosition(x, y);
      this.setOrigin();
      this.setSize(tilemap.tileWidth * this.layer.width, tilemap.tileHeight * this.layer.height);
      this.initPipeline();
    },
    setTilesets: function(tilesets) {
      var gidMap = [];
      var setList = [];
      var map = this.tilemap;
      if (!Array.isArray(tilesets)) {
        tilesets = [tilesets];
      }
      for (var i = 0; i < tilesets.length; i++) {
        var tileset = tilesets[i];
        if (typeof tileset === "string") {
          tileset = map.getTileset(tileset);
        }
        if (tileset) {
          setList.push(tileset);
          var s = tileset.firstgid;
          for (var t = 0; t < tileset.total; t++) {
            gidMap[s + t] = tileset;
          }
        }
      }
      this.gidMap = gidMap;
      this.tileset = setList;
    },
    setRenderOrder: function(renderOrder) {
      var orders = ["right-down", "left-down", "right-up", "left-up"];
      if (typeof renderOrder === "string") {
        renderOrder = orders.indexOf(renderOrder);
      }
      if (renderOrder >= 0 && renderOrder < 4) {
        this._renderOrder = renderOrder;
      }
      return this;
    },
    calculateFacesAt: function(tileX, tileY) {
      TilemapComponents.CalculateFacesAt(tileX, tileY, this.layer);
      return this;
    },
    calculateFacesWithin: function(tileX, tileY, width, height) {
      TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, this.layer);
      return this;
    },
    createFromTiles: function(indexes, replacements, spriteConfig, scene, camera) {
      return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, this.layer);
    },
    cull: function(camera) {
      return this.cullCallback(this.layer, camera, this.culledTiles, this._renderOrder);
    },
    copy: function(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces) {
      TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, this.layer);
      return this;
    },
    fill: function(index, tileX, tileY, width, height, recalculateFaces) {
      TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, this.layer);
      return this;
    },
    filterTiles: function(callback, context, tileX, tileY, width, height, filteringOptions) {
      return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
    },
    findByIndex: function(findIndex, skip, reverse) {
      return TilemapComponents.FindByIndex(findIndex, skip, reverse, this.layer);
    },
    findTile: function(callback, context, tileX, tileY, width, height, filteringOptions) {
      return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
    },
    forEachTile: function(callback, context, tileX, tileY, width, height, filteringOptions) {
      TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);
      return this;
    },
    getTileAt: function(tileX, tileY, nonNull) {
      return TilemapComponents.GetTileAt(tileX, tileY, nonNull, this.layer);
    },
    getTileAtWorldXY: function(worldX, worldY, nonNull, camera) {
      return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, this.layer);
    },
    getTilesWithin: function(tileX, tileY, width, height, filteringOptions) {
      return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, this.layer);
    },
    getTilesWithinShape: function(shape, filteringOptions, camera) {
      return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, this.layer);
    },
    getTilesWithinWorldXY: function(worldX, worldY, width, height, filteringOptions, camera) {
      return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, this.layer);
    },
    hasTileAt: function(tileX, tileY) {
      return TilemapComponents.HasTileAt(tileX, tileY, this.layer);
    },
    hasTileAtWorldXY: function(worldX, worldY, camera) {
      return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, this.layer);
    },
    putTileAt: function(tile, tileX, tileY, recalculateFaces) {
      return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, this.layer);
    },
    putTileAtWorldXY: function(tile, worldX, worldY, recalculateFaces, camera) {
      return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, this.layer);
    },
    putTilesAt: function(tilesArray, tileX, tileY, recalculateFaces) {
      TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, this.layer);
      return this;
    },
    randomize: function(tileX, tileY, width, height, indexes) {
      TilemapComponents.Randomize(tileX, tileY, width, height, indexes, this.layer);
      return this;
    },
    removeTileAt: function(tileX, tileY, replaceWithNull, recalculateFaces) {
      return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, this.layer);
    },
    removeTileAtWorldXY: function(worldX, worldY, replaceWithNull, recalculateFaces, camera) {
      return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, this.layer);
    },
    renderDebug: function(graphics, styleConfig) {
      TilemapComponents.RenderDebug(graphics, styleConfig, this.layer);
      return this;
    },
    replaceByIndex: function(findIndex, newIndex, tileX, tileY, width, height) {
      TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, this.layer);
      return this;
    },
    setSkipCull: function(value) {
      if (value === void 0) {
        value = true;
      }
      this.skipCull = value;
      return this;
    },
    setCullPadding: function(paddingX, paddingY) {
      if (paddingX === void 0) {
        paddingX = 1;
      }
      if (paddingY === void 0) {
        paddingY = 1;
      }
      this.cullPaddingX = paddingX;
      this.cullPaddingY = paddingY;
      return this;
    },
    setCollision: function(indexes, collides, recalculateFaces, updateLayer) {
      TilemapComponents.SetCollision(indexes, collides, recalculateFaces, this.layer, updateLayer);
      return this;
    },
    setCollisionBetween: function(start, stop, collides, recalculateFaces) {
      TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, this.layer);
      return this;
    },
    setCollisionByProperty: function(properties, collides, recalculateFaces) {
      TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, this.layer);
      return this;
    },
    setCollisionByExclusion: function(indexes, collides, recalculateFaces) {
      TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, this.layer);
      return this;
    },
    setCollisionFromCollisionGroup: function(collides, recalculateFaces) {
      TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, this.layer);
      return this;
    },
    setTileIndexCallback: function(indexes, callback, callbackContext) {
      TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, this.layer);
      return this;
    },
    setTileLocationCallback: function(tileX, tileY, width, height, callback, callbackContext) {
      TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, this.layer);
      return this;
    },
    shuffle: function(tileX, tileY, width, height) {
      TilemapComponents.Shuffle(tileX, tileY, width, height, this.layer);
      return this;
    },
    swapByIndex: function(indexA, indexB, tileX, tileY, width, height) {
      TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, this.layer);
      return this;
    },
    tileToWorldX: function(tileX, camera) {
      return this.tilemap.tileToWorldX(tileX, camera, this);
    },
    tileToWorldY: function(tileY, camera) {
      return this.tilemap.tileToWorldY(tileY, camera, this);
    },
    tileToWorldXY: function(tileX, tileY, point, camera) {
      return this.tilemap.tileToWorldXY(tileX, tileY, point, camera, this);
    },
    weightedRandomize: function(weightedIndexes, tileX, tileY, width, height) {
      TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, this.layer);
      return this;
    },
    worldToTileX: function(worldX, snapToFloor, camera) {
      return this.tilemap.worldToTileX(worldX, snapToFloor, camera, this);
    },
    worldToTileY: function(worldY, snapToFloor, camera) {
      return this.tilemap.worldToTileY(worldY, snapToFloor, camera, this);
    },
    worldToTileXY: function(worldX, worldY, snapToFloor, point, camera) {
      return this.tilemap.worldToTileXY(worldX, worldY, snapToFloor, point, camera, this);
    },
    destroy: function(removeFromTilemap) {
      if (removeFromTilemap === void 0) {
        removeFromTilemap = true;
      }
      if (!this.tilemap) {
        return;
      }
      if (this.layer.tilemapLayer === this) {
        this.layer.tilemapLayer = void 0;
      }
      if (removeFromTilemap) {
        this.tilemap.removeLayer(this);
      }
      this.tilemap = void 0;
      this.layer = void 0;
      this.culledTiles.length = 0;
      this.cullCallback = null;
      this.gidMap = [];
      this.tileset = [];
      GameObject.prototype.destroy.call(this);
    }
  });
  module2.exports = TilemapLayer;
});

// node_modules/phaser/src/tilemaps/Tilemap.js
var require_Tilemap = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var DegToRad = require_DegToRad();
  var Formats = require_Formats();
  var GetFastValue = require_GetFastValue();
  var LayerData = require_LayerData();
  var ORIENTATION = require_ORIENTATION_CONST2();
  var Rotate = require_Rotate2();
  var SpliceOne = require_SpliceOne();
  var Sprite = require_Sprite();
  var Tile = require_Tile();
  var TilemapComponents = require_components4();
  var TilemapLayer = require_TilemapLayer();
  var Tileset = require_Tileset();
  var Tilemap = new Class({
    initialize: function Tilemap2(scene, mapData) {
      this.scene = scene;
      this.tileWidth = mapData.tileWidth;
      this.tileHeight = mapData.tileHeight;
      this.width = mapData.width;
      this.height = mapData.height;
      this.orientation = mapData.orientation;
      this.renderOrder = mapData.renderOrder;
      this.format = mapData.format;
      this.version = mapData.version;
      this.properties = mapData.properties;
      this.widthInPixels = mapData.widthInPixels;
      this.heightInPixels = mapData.heightInPixels;
      this.imageCollections = mapData.imageCollections;
      this.images = mapData.images;
      this.layers = mapData.layers;
      this.tilesets = mapData.tilesets;
      this.objects = mapData.objects;
      this.currentLayerIndex = 0;
      this.hexSideLength = mapData.hexSideLength;
      var orientation = this.orientation;
      this._convert = {
        WorldToTileXY: TilemapComponents.GetWorldToTileXYFunction(orientation),
        WorldToTileX: TilemapComponents.GetWorldToTileXFunction(orientation),
        WorldToTileY: TilemapComponents.GetWorldToTileYFunction(orientation),
        TileToWorldXY: TilemapComponents.GetTileToWorldXYFunction(orientation),
        TileToWorldX: TilemapComponents.GetTileToWorldXFunction(orientation),
        TileToWorldY: TilemapComponents.GetTileToWorldYFunction(orientation)
      };
    },
    createBlankDynamicLayer: function(name, tileset, x, y, width, height, tileWidth, tileHeight) {
      console.warn("createBlankDynamicLayer is deprecated. Use createBlankLayer");
      return this.createBlankLayer(name, tileset, x, y, width, height, tileWidth, tileHeight);
    },
    createDynamicLayer: function(layerID, tileset, x, y) {
      console.warn("createDynamicLayer is deprecated. Use createLayer");
      return this.createLayer(layerID, tileset, x, y);
    },
    createStaticLayer: function(layerID, tileset, x, y) {
      console.warn("createStaticLayer is deprecated. Use createLayer");
      return this.createLayer(layerID, tileset, x, y);
    },
    setRenderOrder: function(renderOrder) {
      var orders = ["right-down", "left-down", "right-up", "left-up"];
      if (typeof renderOrder === "number") {
        renderOrder = orders[renderOrder];
      }
      if (orders.indexOf(renderOrder) > -1) {
        this.renderOrder = renderOrder;
      }
      return this;
    },
    addTilesetImage: function(tilesetName, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {
      if (tilesetName === void 0) {
        return null;
      }
      if (key === void 0 || key === null) {
        key = tilesetName;
      }
      if (!this.scene.sys.textures.exists(key)) {
        console.warn("Invalid Tileset Image: " + key);
        return null;
      }
      var texture = this.scene.sys.textures.get(key);
      var index = this.getTilesetIndex(tilesetName);
      if (index === null && this.format === Formats.TILED_JSON) {
        console.warn("No data found for Tileset: " + tilesetName);
        return null;
      }
      var tileset = this.tilesets[index];
      if (tileset) {
        tileset.setTileSize(tileWidth, tileHeight);
        tileset.setSpacing(tileMargin, tileSpacing);
        tileset.setImage(texture);
        return tileset;
      }
      if (tileWidth === void 0) {
        tileWidth = this.tileWidth;
      }
      if (tileHeight === void 0) {
        tileHeight = this.tileHeight;
      }
      if (tileMargin === void 0) {
        tileMargin = 0;
      }
      if (tileSpacing === void 0) {
        tileSpacing = 0;
      }
      if (gid === void 0) {
        gid = 0;
      }
      tileset = new Tileset(tilesetName, gid, tileWidth, tileHeight, tileMargin, tileSpacing);
      tileset.setImage(texture);
      this.tilesets.push(tileset);
      return tileset;
    },
    copy: function(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {
      layer = this.getLayer(layer);
      if (layer !== null) {
        TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer);
        return this;
      } else {
        return null;
      }
    },
    createBlankLayer: function(name, tileset, x, y, width, height, tileWidth, tileHeight) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = this.width;
      }
      if (height === void 0) {
        height = this.height;
      }
      if (tileWidth === void 0) {
        tileWidth = this.tileWidth;
      }
      if (tileHeight === void 0) {
        tileHeight = this.tileHeight;
      }
      var index = this.getLayerIndex(name);
      if (index !== null) {
        console.warn("Invalid Tilemap Layer ID: " + name);
        return null;
      }
      var layerData = new LayerData({
        name,
        tileWidth,
        tileHeight,
        width,
        height,
        orientation: this.orientation
      });
      var row;
      for (var tileY = 0; tileY < height; tileY++) {
        row = [];
        for (var tileX = 0; tileX < width; tileX++) {
          row.push(new Tile(layerData, -1, tileX, tileY, tileWidth, tileHeight, this.tileWidth, this.tileHeight));
        }
        layerData.data.push(row);
      }
      this.layers.push(layerData);
      this.currentLayerIndex = this.layers.length - 1;
      var layer = new TilemapLayer(this.scene, this, this.currentLayerIndex, tileset, x, y);
      layer.setRenderOrder(this.renderOrder);
      this.scene.sys.displayList.add(layer);
      return layer;
    },
    createLayer: function(layerID, tileset, x, y) {
      var index = this.getLayerIndex(layerID);
      if (index === null) {
        console.warn("Invalid Tilemap Layer ID: " + layerID);
        if (typeof layerID === "string") {
          console.warn("Valid tilelayer names:\n	" + this.getTileLayerNames().join(",\n	"));
        }
        return null;
      }
      var layerData = this.layers[index];
      if (layerData.tilemapLayer) {
        console.warn("Tilemap Layer ID already exists:" + layerID);
        return null;
      }
      this.currentLayerIndex = index;
      if (x === void 0) {
        x = layerData.x;
      }
      if (y === void 0) {
        y = layerData.y;
      }
      var layer = new TilemapLayer(this.scene, this, index, tileset, x, y);
      layer.setRenderOrder(this.renderOrder);
      this.scene.sys.displayList.add(layer);
      return layer;
    },
    createFromObjects: function(objectLayerName, config2) {
      var results = [];
      var objectLayer = this.getObjectLayer(objectLayerName);
      if (!objectLayer) {
        console.warn("createFromObjects: Invalid objectLayerName given: " + objectLayerName);
        return results;
      }
      if (!Array.isArray(config2)) {
        config2 = [config2];
      }
      var objects = objectLayer.objects;
      for (var c = 0; c < config2.length; c++) {
        var singleConfig = config2[c];
        var id = GetFastValue(singleConfig, "id", null);
        var gid = GetFastValue(singleConfig, "gid", null);
        var name = GetFastValue(singleConfig, "name", null);
        var obj;
        var toConvert = [];
        for (var s = 0; s < objects.length; s++) {
          obj = objects[s];
          if (id === null && gid === null && name === null || id !== null && obj.id === id || gid !== null && obj.gid === gid || name !== null && obj.name === name) {
            toConvert.push(obj);
          }
        }
        var classType = GetFastValue(singleConfig, "classType", Sprite);
        var scene = GetFastValue(singleConfig, "scene", this.scene);
        var container = GetFastValue(singleConfig, "container", null);
        var texture = GetFastValue(singleConfig, "key", null);
        var frame = GetFastValue(singleConfig, "frame", null);
        for (var i = 0; i < toConvert.length; i++) {
          obj = toConvert[i];
          var sprite = new classType(scene);
          sprite.setName(obj.name);
          sprite.setPosition(obj.x, obj.y);
          sprite.setTexture(texture, frame);
          if (obj.width) {
            sprite.displayWidth = obj.width;
          }
          if (obj.height) {
            sprite.displayHeight = obj.height;
          }
          var offset = {
            x: sprite.originX * obj.width,
            y: (sprite.originY - 1) * obj.height
          };
          if (obj.rotation) {
            var angle = DegToRad(obj.rotation);
            Rotate(offset, angle);
            sprite.rotation = angle;
          }
          sprite.x += offset.x;
          sprite.y += offset.y;
          if (obj.flippedHorizontal !== void 0 || obj.flippedVertical !== void 0) {
            sprite.setFlip(obj.flippedHorizontal, obj.flippedVertical);
          }
          if (!obj.visible) {
            sprite.visible = false;
          }
          if (Array.isArray(obj.properties)) {
            obj.properties.forEach(function(propData) {
              var key2 = propData["name"];
              if (sprite[key2] !== void 0) {
                sprite[key2] = propData["value"];
              } else {
                sprite.setData(key2, propData["value"]);
              }
            });
          } else {
            for (var key in obj.properties) {
              if (sprite[key] !== void 0) {
                sprite[key] = obj.properties[key];
              } else {
                sprite.setData(key, obj.properties[key]);
              }
            }
          }
          if (container) {
            container.add(sprite);
          } else {
            scene.add.existing(sprite);
          }
          results.push(sprite);
        }
      }
      return results;
    },
    createFromTiles: function(indexes, replacements, spriteConfig, scene, camera, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, layer);
    },
    fill: function(index, tileX, tileY, width, height, recalculateFaces, layer) {
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, layer);
      return this;
    },
    filterObjects: function(objectLayer, callback, context) {
      if (typeof objectLayer === "string") {
        var name = objectLayer;
        objectLayer = this.getObjectLayer(objectLayer);
        if (!objectLayer) {
          console.warn("No object layer found with the name: " + name);
          return null;
        }
      }
      return objectLayer.objects.filter(callback, context);
    },
    filterTiles: function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer);
    },
    findByIndex: function(findIndex, skip, reverse, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.FindByIndex(findIndex, skip, reverse, layer);
    },
    findObject: function(objectLayer, callback, context) {
      if (typeof objectLayer === "string") {
        var name = objectLayer;
        objectLayer = this.getObjectLayer(objectLayer);
        if (!objectLayer) {
          console.warn("No object layer found with the name: " + name);
          return null;
        }
      }
      return objectLayer.objects.find(callback, context) || null;
    },
    findTile: function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);
    },
    forEachTile: function(callback, context, tileX, tileY, width, height, filteringOptions, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);
      return this;
    },
    getImageIndex: function(name) {
      return this.getIndex(this.images, name);
    },
    getImageLayerNames: function() {
      if (!this.images || !Array.isArray(this.images)) {
        return [];
      }
      return this.images.map(function(image) {
        return image.name;
      });
    },
    getIndex: function(location, name) {
      for (var i = 0; i < location.length; i++) {
        if (location[i].name === name) {
          return i;
        }
      }
      return null;
    },
    getLayer: function(layer) {
      var index = this.getLayerIndex(layer);
      return index !== null ? this.layers[index] : null;
    },
    getObjectLayer: function(name) {
      var index = this.getIndex(this.objects, name);
      return index !== null ? this.objects[index] : null;
    },
    getObjectLayerNames: function() {
      if (!this.objects || !Array.isArray(this.objects)) {
        return [];
      }
      return this.objects.map(function(object) {
        return object.name;
      });
    },
    getLayerIndex: function(layer) {
      if (layer === void 0) {
        return this.currentLayerIndex;
      } else if (typeof layer === "string") {
        return this.getLayerIndexByName(layer);
      } else if (typeof layer === "number" && layer < this.layers.length) {
        return layer;
      } else if (layer instanceof TilemapLayer) {
        return layer.layerIndex;
      } else {
        return null;
      }
    },
    getLayerIndexByName: function(name) {
      return this.getIndex(this.layers, name);
    },
    getTileAt: function(tileX, tileY, nonNull, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.GetTileAt(tileX, tileY, nonNull, layer);
    },
    getTileAtWorldXY: function(worldX, worldY, nonNull, camera, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, layer);
    },
    getTileLayerNames: function() {
      if (!this.layers || !Array.isArray(this.layers)) {
        return [];
      }
      return this.layers.map(function(layer) {
        return layer.name;
      });
    },
    getTilesWithin: function(tileX, tileY, width, height, filteringOptions, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);
    },
    getTilesWithinShape: function(shape, filteringOptions, camera, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, layer);
    },
    getTilesWithinWorldXY: function(worldX, worldY, width, height, filteringOptions, camera, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer);
    },
    getTileset: function(name) {
      var index = this.getIndex(this.tilesets, name);
      return index !== null ? this.tilesets[index] : null;
    },
    getTilesetIndex: function(name) {
      return this.getIndex(this.tilesets, name);
    },
    hasTileAt: function(tileX, tileY, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.HasTileAt(tileX, tileY, layer);
    },
    hasTileAtWorldXY: function(worldX, worldY, camera, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, layer);
    },
    layer: {
      get: function() {
        return this.layers[this.currentLayerIndex];
      },
      set: function(layer) {
        this.setLayer(layer);
      }
    },
    putTileAt: function(tile, tileX, tileY, recalculateFaces, layer) {
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, layer);
    },
    putTileAtWorldXY: function(tile, worldX, worldY, recalculateFaces, camera, layer) {
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer);
    },
    putTilesAt: function(tilesArray, tileX, tileY, recalculateFaces, layer) {
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer);
      return this;
    },
    randomize: function(tileX, tileY, width, height, indexes, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.Randomize(tileX, tileY, width, height, indexes, layer);
      return this;
    },
    calculateFacesAt: function(tileX, tileY, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.CalculateFacesAt(tileX, tileY, layer);
      return this;
    },
    calculateFacesWithin: function(tileX, tileY, width, height, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, layer);
      return this;
    },
    removeLayer: function(layer) {
      var index = this.getLayerIndex(layer);
      if (index !== null) {
        SpliceOne(this.layers, index);
        for (var i = index; i < this.layers.length; i++) {
          if (this.layers[i].tilemapLayer) {
            this.layers[i].tilemapLayer.layerIndex--;
          }
        }
        if (this.currentLayerIndex === index) {
          this.currentLayerIndex = 0;
        }
        return this;
      } else {
        return null;
      }
    },
    destroyLayer: function(layer) {
      var index = this.getLayerIndex(layer);
      if (index !== null) {
        layer = this.layers[index];
        layer.destroy();
        SpliceOne(this.layers, index);
        if (this.currentLayerIndex === index) {
          this.currentLayerIndex = 0;
        }
        return this;
      } else {
        return null;
      }
    },
    removeAllLayers: function() {
      var layers = this.layers;
      for (var i = 0; i < layers.length; i++) {
        if (layers[i].tilemapLayer) {
          layers[i].tilemapLayer.destroy(false);
        }
      }
      layers.length = 0;
      this.currentLayerIndex = 0;
      return this;
    },
    removeTile: function(tiles, replaceIndex, recalculateFaces) {
      if (replaceIndex === void 0) {
        replaceIndex = -1;
      }
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      var removed = [];
      if (!Array.isArray(tiles)) {
        tiles = [tiles];
      }
      for (var i = 0; i < tiles.length; i++) {
        var tile = tiles[i];
        removed.push(this.removeTileAt(tile.x, tile.y, true, recalculateFaces, tile.tilemapLayer));
        if (replaceIndex > -1) {
          this.putTileAt(replaceIndex, tile.x, tile.y, recalculateFaces, tile.tilemapLayer);
        }
      }
      return removed;
    },
    removeTileAt: function(tileX, tileY, replaceWithNull, recalculateFaces, layer) {
      if (replaceWithNull === void 0) {
        replaceWithNull = true;
      }
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer);
    },
    removeTileAtWorldXY: function(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {
      if (replaceWithNull === void 0) {
        replaceWithNull = true;
      }
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer);
    },
    renderDebug: function(graphics, styleConfig, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      if (this.orientation === ORIENTATION.ORTHOGONAL) {
        TilemapComponents.RenderDebug(graphics, styleConfig, layer);
      }
      return this;
    },
    renderDebugFull: function(graphics, styleConfig) {
      var layers = this.layers;
      for (var i = 0; i < layers.length; i++) {
        TilemapComponents.RenderDebug(graphics, styleConfig, layers[i]);
      }
      return this;
    },
    replaceByIndex: function(findIndex, newIndex, tileX, tileY, width, height, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer);
      return this;
    },
    setCollision: function(indexes, collides, recalculateFaces, layer, updateLayer) {
      if (collides === void 0) {
        collides = true;
      }
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      if (updateLayer === void 0) {
        updateLayer = true;
      }
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.SetCollision(indexes, collides, recalculateFaces, layer, updateLayer);
      return this;
    },
    setCollisionBetween: function(start, stop, collides, recalculateFaces, layer) {
      if (collides === void 0) {
        collides = true;
      }
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, layer);
      return this;
    },
    setCollisionByProperty: function(properties, collides, recalculateFaces, layer) {
      if (collides === void 0) {
        collides = true;
      }
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, layer);
      return this;
    },
    setCollisionByExclusion: function(indexes, collides, recalculateFaces, layer) {
      if (collides === void 0) {
        collides = true;
      }
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, layer);
      return this;
    },
    setCollisionFromCollisionGroup: function(collides, recalculateFaces, layer) {
      if (collides === void 0) {
        collides = true;
      }
      if (recalculateFaces === void 0) {
        recalculateFaces = true;
      }
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, layer);
      return this;
    },
    setTileIndexCallback: function(indexes, callback, callbackContext, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, layer);
      return this;
    },
    setTileLocationCallback: function(tileX, tileY, width, height, callback, callbackContext, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer);
      return this;
    },
    setLayer: function(layer) {
      var index = this.getLayerIndex(layer);
      if (index !== null) {
        this.currentLayerIndex = index;
      }
      return this;
    },
    setBaseTileSize: function(tileWidth, tileHeight) {
      this.tileWidth = tileWidth;
      this.tileHeight = tileHeight;
      this.widthInPixels = this.width * tileWidth;
      this.heightInPixels = this.height * tileHeight;
      for (var i = 0; i < this.layers.length; i++) {
        this.layers[i].baseTileWidth = tileWidth;
        this.layers[i].baseTileHeight = tileHeight;
        var mapData = this.layers[i].data;
        var mapWidth = this.layers[i].width;
        var mapHeight = this.layers[i].height;
        for (var row = 0; row < mapHeight; row++) {
          for (var col = 0; col < mapWidth; col++) {
            var tile = mapData[row][col];
            if (tile !== null) {
              tile.setSize(void 0, void 0, tileWidth, tileHeight);
            }
          }
        }
      }
      return this;
    },
    setLayerTileSize: function(tileWidth, tileHeight, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return this;
      }
      layer.tileWidth = tileWidth;
      layer.tileHeight = tileHeight;
      var mapData = layer.data;
      var mapWidth = layer.width;
      var mapHeight = layer.height;
      for (var row = 0; row < mapHeight; row++) {
        for (var col = 0; col < mapWidth; col++) {
          var tile = mapData[row][col];
          if (tile !== null) {
            tile.setSize(tileWidth, tileHeight);
          }
        }
      }
      return this;
    },
    shuffle: function(tileX, tileY, width, height, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.Shuffle(tileX, tileY, width, height, layer);
      return this;
    },
    swapByIndex: function(indexA, indexB, tileX, tileY, width, height, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, layer);
      return this;
    },
    tileToWorldX: function(tileX, camera, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return this._convert.TileToWorldX(tileX, camera, layer);
    },
    tileToWorldY: function(tileX, camera, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return this._convert.TileToWorldY(tileX, camera, layer);
    },
    tileToWorldXY: function(tileX, tileY, vec2, camera, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return this._convert.TileToWorldXY(tileX, tileY, vec2, camera, layer);
    },
    weightedRandomize: function(weightedIndexes, tileX, tileY, width, height, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer);
      return this;
    },
    worldToTileX: function(worldX, snapToFloor, camera, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return this._convert.WorldToTileX(worldX, snapToFloor, camera, layer);
    },
    worldToTileY: function(worldY, snapToFloor, camera, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return this._convert.WorldToTileY(worldY, snapToFloor, camera, layer);
    },
    worldToTileXY: function(worldX, worldY, snapToFloor, vec2, camera, layer) {
      layer = this.getLayer(layer);
      if (layer === null) {
        return null;
      }
      return this._convert.WorldToTileXY(worldX, worldY, snapToFloor, vec2, camera, layer);
    },
    destroy: function() {
      this.removeAllLayers();
      this.tilesets.length = 0;
      this.objects.length = 0;
      this.scene = null;
    }
  });
  module2.exports = Tilemap;
});

// node_modules/phaser/src/tilemaps/ParseToTilemap.js
var require_ParseToTilemap = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Formats = require_Formats();
  var MapData = require_MapData();
  var Parse = require_Parse();
  var Tilemap = require_Tilemap();
  var ParseToTilemap = function(scene, key, tileWidth, tileHeight, width, height, data, insertNull) {
    if (tileWidth === void 0) {
      tileWidth = 32;
    }
    if (tileHeight === void 0) {
      tileHeight = 32;
    }
    if (width === void 0) {
      width = 10;
    }
    if (height === void 0) {
      height = 10;
    }
    if (insertNull === void 0) {
      insertNull = false;
    }
    var mapData = null;
    if (Array.isArray(data)) {
      var name = key !== void 0 ? key : "map";
      mapData = Parse(name, Formats.ARRAY_2D, data, tileWidth, tileHeight, insertNull);
    } else if (key !== void 0) {
      var tilemapData = scene.cache.tilemap.get(key);
      if (!tilemapData) {
        console.warn("No map data found for key " + key);
      } else {
        mapData = Parse(key, tilemapData.format, tilemapData.data, tileWidth, tileHeight, insertNull);
      }
    }
    if (mapData === null) {
      mapData = new MapData({
        tileWidth,
        tileHeight,
        width,
        height
      });
    }
    return new Tilemap(scene, mapData);
  };
  module2.exports = ParseToTilemap;
});

// node_modules/phaser/src/tilemaps/TilemapCreator.js
var require_TilemapCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectCreator = require_GameObjectCreator();
  var ParseToTilemap = require_ParseToTilemap();
  GameObjectCreator.register("tilemap", function(config2) {
    var c = config2 !== void 0 ? config2 : {};
    return ParseToTilemap(this.scene, c.key, c.tileWidth, c.tileHeight, c.width, c.height, c.data, c.insertNull);
  });
});

// node_modules/phaser/src/tilemaps/TilemapFactory.js
var require_TilemapFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GameObjectFactory = require_GameObjectFactory();
  var ParseToTilemap = require_ParseToTilemap();
  GameObjectFactory.register("tilemap", function(key, tileWidth, tileHeight, width, height, data, insertNull) {
    if (key === null) {
      key = void 0;
    }
    if (tileWidth === null) {
      tileWidth = void 0;
    }
    if (tileHeight === null) {
      tileHeight = void 0;
    }
    if (width === null) {
      width = void 0;
    }
    if (height === null) {
      height = void 0;
    }
    return ParseToTilemap(this.scene, key, tileWidth, tileHeight, width, height, data, insertNull);
  });
});

// node_modules/phaser/src/tilemaps/index.js
var require_tilemaps = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Extend = require_Extend();
  var CONST = require_const15();
  var Tilemaps = {
    Components: require_components4(),
    Parsers: require_parsers2(),
    Formats: require_Formats(),
    ImageCollection: require_ImageCollection(),
    ParseToTilemap: require_ParseToTilemap(),
    Tile: require_Tile(),
    Tilemap: require_Tilemap(),
    TilemapCreator: require_TilemapCreator(),
    TilemapFactory: require_TilemapFactory(),
    Tileset: require_Tileset(),
    TilemapLayer: require_TilemapLayer(),
    Orientation: require_ORIENTATION_CONST2(),
    LayerData: require_LayerData(),
    MapData: require_MapData(),
    ObjectLayer: require_ObjectLayer()
  };
  Tilemaps = Extend(false, Tilemaps, CONST.ORIENTATION);
  module2.exports = Tilemaps;
});

// node_modules/phaser/src/time/TimerEvent.js
var require_TimerEvent = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var GetFastValue = require_GetFastValue();
  var TimerEvent = new Class({
    initialize: function TimerEvent2(config2) {
      this.delay = 0;
      this.repeat = 0;
      this.repeatCount = 0;
      this.loop = false;
      this.callback;
      this.callbackScope;
      this.args;
      this.timeScale = 1;
      this.startAt = 0;
      this.elapsed = 0;
      this.paused = false;
      this.hasDispatched = false;
      this.reset(config2);
    },
    reset: function(config2) {
      this.delay = GetFastValue(config2, "delay", 0);
      this.repeat = GetFastValue(config2, "repeat", 0);
      this.loop = GetFastValue(config2, "loop", false);
      this.callback = GetFastValue(config2, "callback", void 0);
      this.callbackScope = GetFastValue(config2, "callbackScope", this.callback);
      this.args = GetFastValue(config2, "args", []);
      this.timeScale = GetFastValue(config2, "timeScale", 1);
      this.startAt = GetFastValue(config2, "startAt", 0);
      this.paused = GetFastValue(config2, "paused", false);
      this.elapsed = this.startAt;
      this.hasDispatched = false;
      this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat;
      return this;
    },
    getProgress: function() {
      return this.elapsed / this.delay;
    },
    getOverallProgress: function() {
      if (this.repeat > 0) {
        var totalDuration = this.delay + this.delay * this.repeat;
        var totalElapsed = this.elapsed + this.delay * (this.repeat - this.repeatCount);
        return totalElapsed / totalDuration;
      } else {
        return this.getProgress();
      }
    },
    getRepeatCount: function() {
      return this.repeatCount;
    },
    getElapsed: function() {
      return this.elapsed;
    },
    getElapsedSeconds: function() {
      return this.elapsed * 1e-3;
    },
    getRemaining: function() {
      return this.delay - this.elapsed;
    },
    getRemainingSeconds: function() {
      return this.getRemaining() * 1e-3;
    },
    getOverallRemaining: function() {
      return this.delay * (1 + this.repeatCount) - this.elapsed;
    },
    getOverallRemainingSeconds: function() {
      return this.getOverallRemaining() * 1e-3;
    },
    remove: function(dispatchCallback) {
      if (dispatchCallback === void 0) {
        dispatchCallback = false;
      }
      this.elapsed = this.delay;
      this.hasDispatched = !dispatchCallback;
      this.repeatCount = 0;
    },
    destroy: function() {
      this.callback = void 0;
      this.callbackScope = void 0;
      this.args = [];
    }
  });
  module2.exports = TimerEvent;
});

// node_modules/phaser/src/time/Clock.js
var require_Clock = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var PluginCache = require_PluginCache();
  var SceneEvents = require_events5();
  var TimerEvent = require_TimerEvent();
  var Remove = require_Remove();
  var Clock = new Class({
    initialize: function Clock2(scene) {
      this.scene = scene;
      this.systems = scene.sys;
      this.now = 0;
      this.timeScale = 1;
      this.paused = false;
      this._active = [];
      this._pendingInsertion = [];
      this._pendingRemoval = [];
      scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
      scene.sys.events.on(SceneEvents.START, this.start, this);
    },
    boot: function() {
      this.now = this.systems.game.loop.time;
      this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
    },
    start: function() {
      var eventEmitter = this.systems.events;
      eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
      eventEmitter.on(SceneEvents.UPDATE, this.update, this);
      eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    addEvent: function(config2) {
      var event;
      if (config2 instanceof TimerEvent) {
        event = config2;
        this.removeEvent(event);
        event.elapsed = event.startAt;
        event.hasDispatched = false;
        event.repeatCount = event.repeat === -1 || event.loop ? 999999999999 : event.repeat;
      } else {
        event = new TimerEvent(config2);
      }
      this._pendingInsertion.push(event);
      return event;
    },
    delayedCall: function(delay, callback, args, callbackScope) {
      return this.addEvent({delay, callback, args, callbackScope});
    },
    clearPendingEvents: function() {
      this._pendingInsertion = [];
      return this;
    },
    removeEvent: function(events) {
      if (!Array.isArray(events)) {
        events = [events];
      }
      for (var i = 0; i < events.length; i++) {
        var event = events[i];
        Remove(this._pendingRemoval, event);
        Remove(this._pendingInsertion, event);
        Remove(this._active, event);
      }
      return this;
    },
    removeAllEvents: function() {
      this._pendingRemoval = this._pendingRemoval.concat(this._active);
      return this;
    },
    preUpdate: function() {
      var toRemove = this._pendingRemoval.length;
      var toInsert = this._pendingInsertion.length;
      if (toRemove === 0 && toInsert === 0) {
        return;
      }
      var i;
      var event;
      for (i = 0; i < toRemove; i++) {
        event = this._pendingRemoval[i];
        var index = this._active.indexOf(event);
        if (index > -1) {
          this._active.splice(index, 1);
        }
        event.destroy();
      }
      for (i = 0; i < toInsert; i++) {
        event = this._pendingInsertion[i];
        this._active.push(event);
      }
      this._pendingRemoval.length = 0;
      this._pendingInsertion.length = 0;
    },
    update: function(time, delta) {
      this.now = time;
      if (this.paused) {
        return;
      }
      delta *= this.timeScale;
      for (var i = 0; i < this._active.length; i++) {
        var event = this._active[i];
        if (event.paused) {
          continue;
        }
        event.elapsed += delta * event.timeScale;
        if (event.elapsed >= event.delay) {
          var remainder = event.elapsed - event.delay;
          event.elapsed = event.delay;
          if (!event.hasDispatched && event.callback) {
            event.hasDispatched = true;
            event.callback.apply(event.callbackScope, event.args);
          }
          if (event.repeatCount > 0) {
            event.repeatCount--;
            event.elapsed = remainder;
            event.hasDispatched = false;
          } else {
            this._pendingRemoval.push(event);
          }
        }
      }
    },
    shutdown: function() {
      var i;
      for (i = 0; i < this._pendingInsertion.length; i++) {
        this._pendingInsertion[i].destroy();
      }
      for (i = 0; i < this._active.length; i++) {
        this._active[i].destroy();
      }
      for (i = 0; i < this._pendingRemoval.length; i++) {
        this._pendingRemoval[i].destroy();
      }
      this._active.length = 0;
      this._pendingRemoval.length = 0;
      this._pendingInsertion.length = 0;
      var eventEmitter = this.systems.events;
      eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
      eventEmitter.off(SceneEvents.UPDATE, this.update, this);
      eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    destroy: function() {
      this.shutdown();
      this.scene.sys.events.off(SceneEvents.START, this.start, this);
      this.scene = null;
      this.systems = null;
    }
  });
  PluginCache.register("Clock", Clock, "time");
  module2.exports = Clock;
});

// node_modules/phaser/src/time/index.js
var require_time = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Clock: require_Clock(),
    TimerEvent: require_TimerEvent()
  };
});

// node_modules/phaser/src/tweens/builders/GetNewValue.js
var require_GetNewValue = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetNewValue = function(source, key, defaultValue) {
    var valueCallback;
    if (source.hasOwnProperty(key)) {
      var t = typeof source[key];
      if (t === "function") {
        valueCallback = function(target, targetKey, value, targetIndex, totalTargets, tween) {
          return source[key](target, targetKey, value, targetIndex, totalTargets, tween);
        };
      } else {
        valueCallback = function() {
          return source[key];
        };
      }
    } else if (typeof defaultValue === "function") {
      valueCallback = defaultValue;
    } else {
      valueCallback = function() {
        return defaultValue;
      };
    }
    return valueCallback;
  };
  module2.exports = GetNewValue;
});

// node_modules/phaser/src/tweens/tween/ReservedProps.js
var require_ReservedProps = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = [
    "callbackScope",
    "completeDelay",
    "delay",
    "duration",
    "ease",
    "easeParams",
    "flipX",
    "flipY",
    "hold",
    "loop",
    "loopDelay",
    "offset",
    "onActive",
    "onActiveParams",
    "onActiveScope",
    "onComplete",
    "onCompleteParams",
    "onCompleteScope",
    "onLoop",
    "onLoopParams",
    "onLoopScope",
    "onRepeat",
    "onRepeatParams",
    "onRepeatScope",
    "onStart",
    "onStartParams",
    "onStartScope",
    "onStop",
    "onStopParams",
    "onStopScope",
    "onUpdate",
    "onUpdateParams",
    "onUpdateScope",
    "onYoyo",
    "onYoyoParams",
    "onYoyoScope",
    "paused",
    "props",
    "repeat",
    "repeatDelay",
    "targets",
    "useFrames",
    "yoyo"
  ];
});

// node_modules/phaser/src/tweens/builders/GetProps.js
var require_GetProps = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RESERVED = require_ReservedProps();
  var GetProps = function(config2) {
    var key;
    var keys = [];
    if (config2.hasOwnProperty("props")) {
      for (key in config2.props) {
        if (key.substr(0, 1) !== "_") {
          keys.push({key, value: config2.props[key]});
        }
      }
    } else {
      for (key in config2) {
        if (RESERVED.indexOf(key) === -1 && key.substr(0, 1) !== "_") {
          keys.push({key, value: config2[key]});
        }
      }
    }
    return keys;
  };
  module2.exports = GetProps;
});

// node_modules/phaser/src/tweens/builders/GetTargets.js
var require_GetTargets = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetValue = require_GetValue();
  var GetTargets = function(config2) {
    var targets = GetValue(config2, "targets", null);
    if (targets === null) {
      return targets;
    }
    if (typeof targets === "function") {
      targets = targets.call();
    }
    if (!Array.isArray(targets)) {
      targets = [targets];
    }
    return targets;
  };
  module2.exports = GetTargets;
});

// node_modules/phaser/src/tweens/builders/GetTweens.js
var require_GetTweens = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetValue = require_GetValue();
  var GetTweens = function(config2) {
    var tweens = GetValue(config2, "tweens", null);
    if (tweens === null) {
      return [];
    } else if (typeof tweens === "function") {
      tweens = tweens.call();
    }
    if (!Array.isArray(tweens)) {
      tweens = [tweens];
    }
    return tweens;
  };
  module2.exports = GetTweens;
});

// node_modules/phaser/src/tweens/builders/GetValueOp.js
var require_GetValueOp = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  function hasGetActive(def) {
    return !!def.getActive && typeof def.getActive === "function";
  }
  function hasGetStart(def) {
    return !!def.getStart && typeof def.getStart === "function";
  }
  function hasGetEnd(def) {
    return !!def.getEnd && typeof def.getEnd === "function";
  }
  function hasGetters(def) {
    return hasGetStart(def) || hasGetEnd(def) || hasGetActive(def);
  }
  var GetValueOp = function(key, propertyValue) {
    var callbacks;
    var getEnd = function(target, key2, value) {
      return value;
    };
    var getStart = function(target, key2, value) {
      return value;
    };
    var getActive = null;
    var t = typeof propertyValue;
    if (t === "number") {
      getEnd = function() {
        return propertyValue;
      };
    } else if (t === "string") {
      var op = propertyValue[0];
      var num = parseFloat(propertyValue.substr(2));
      switch (op) {
        case "+":
          getEnd = function(target, key2, value) {
            return value + num;
          };
          break;
        case "-":
          getEnd = function(target, key2, value) {
            return value - num;
          };
          break;
        case "*":
          getEnd = function(target, key2, value) {
            return value * num;
          };
          break;
        case "/":
          getEnd = function(target, key2, value) {
            return value / num;
          };
          break;
        default:
          getEnd = function() {
            return parseFloat(propertyValue);
          };
      }
    } else if (t === "function") {
      getEnd = propertyValue;
    } else if (t === "object") {
      if (hasGetters(propertyValue)) {
        if (hasGetActive(propertyValue)) {
          getActive = propertyValue.getActive;
        }
        if (hasGetEnd(propertyValue)) {
          getEnd = propertyValue.getEnd;
        }
        if (hasGetStart(propertyValue)) {
          getStart = propertyValue.getStart;
        }
      } else if (propertyValue.hasOwnProperty("value")) {
        callbacks = GetValueOp(key, propertyValue.value);
      } else {
        var hasTo = propertyValue.hasOwnProperty("to");
        var hasFrom = propertyValue.hasOwnProperty("from");
        var hasStart = propertyValue.hasOwnProperty("start");
        if (hasTo && (hasFrom || hasStart)) {
          callbacks = GetValueOp(key, propertyValue.to);
          if (hasStart) {
            var startCallbacks = GetValueOp(key, propertyValue.start);
            callbacks.getActive = startCallbacks.getEnd;
          }
          if (hasFrom) {
            var fromCallbacks = GetValueOp(key, propertyValue.from);
            callbacks.getStart = fromCallbacks.getEnd;
          }
        }
      }
    }
    if (!callbacks) {
      callbacks = {
        getActive,
        getEnd,
        getStart
      };
    }
    return callbacks;
  };
  module2.exports = GetValueOp;
});

// node_modules/phaser/src/tweens/tween/Defaults.js
var require_Defaults = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TWEEN_DEFAULTS = {
    targets: null,
    delay: 0,
    duration: 1e3,
    ease: "Power0",
    easeParams: null,
    hold: 0,
    repeat: 0,
    repeatDelay: 0,
    yoyo: false,
    flipX: false,
    flipY: false
  };
  module2.exports = TWEEN_DEFAULTS;
});

// node_modules/phaser/src/tweens/events/TIMELINE_COMPLETE_EVENT.js
var require_TIMELINE_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "complete";
});

// node_modules/phaser/src/tweens/events/TIMELINE_LOOP_EVENT.js
var require_TIMELINE_LOOP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "loop";
});

// node_modules/phaser/src/tweens/events/TIMELINE_PAUSE_EVENT.js
var require_TIMELINE_PAUSE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "pause";
});

// node_modules/phaser/src/tweens/events/TIMELINE_RESUME_EVENT.js
var require_TIMELINE_RESUME_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "resume";
});

// node_modules/phaser/src/tweens/events/TIMELINE_START_EVENT.js
var require_TIMELINE_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "start";
});

// node_modules/phaser/src/tweens/events/TIMELINE_UPDATE_EVENT.js
var require_TIMELINE_UPDATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "update";
});

// node_modules/phaser/src/tweens/events/TWEEN_ACTIVE_EVENT.js
var require_TWEEN_ACTIVE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "active";
});

// node_modules/phaser/src/tweens/events/TWEEN_COMPLETE_EVENT.js
var require_TWEEN_COMPLETE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "complete";
});

// node_modules/phaser/src/tweens/events/TWEEN_LOOP_EVENT.js
var require_TWEEN_LOOP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "loop";
});

// node_modules/phaser/src/tweens/events/TWEEN_REPEAT_EVENT.js
var require_TWEEN_REPEAT_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "repeat";
});

// node_modules/phaser/src/tweens/events/TWEEN_START_EVENT.js
var require_TWEEN_START_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "start";
});

// node_modules/phaser/src/tweens/events/TWEEN_STOP_EVENT.js
var require_TWEEN_STOP_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       samme
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "stop";
});

// node_modules/phaser/src/tweens/events/TWEEN_UPDATE_EVENT.js
var require_TWEEN_UPDATE_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "update";
});

// node_modules/phaser/src/tweens/events/TWEEN_YOYO_EVENT.js
var require_TWEEN_YOYO_EVENT = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = "yoyo";
});

// node_modules/phaser/src/tweens/events/index.js
var require_events21 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    TIMELINE_COMPLETE: require_TIMELINE_COMPLETE_EVENT(),
    TIMELINE_LOOP: require_TIMELINE_LOOP_EVENT(),
    TIMELINE_PAUSE: require_TIMELINE_PAUSE_EVENT(),
    TIMELINE_RESUME: require_TIMELINE_RESUME_EVENT(),
    TIMELINE_START: require_TIMELINE_START_EVENT(),
    TIMELINE_UPDATE: require_TIMELINE_UPDATE_EVENT(),
    TWEEN_ACTIVE: require_TWEEN_ACTIVE_EVENT(),
    TWEEN_COMPLETE: require_TWEEN_COMPLETE_EVENT(),
    TWEEN_LOOP: require_TWEEN_LOOP_EVENT(),
    TWEEN_REPEAT: require_TWEEN_REPEAT_EVENT(),
    TWEEN_START: require_TWEEN_START_EVENT(),
    TWEEN_STOP: require_TWEEN_STOP_EVENT(),
    TWEEN_UPDATE: require_TWEEN_UPDATE_EVENT(),
    TWEEN_YOYO: require_TWEEN_YOYO_EVENT()
  };
});

// node_modules/phaser/src/tweens/tween/Tween.js
var require_Tween = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var EventEmitter = require_eventemitter3();
  var Events = require_events21();
  var GameObjectCreator = require_GameObjectCreator();
  var GameObjectFactory = require_GameObjectFactory();
  var TWEEN_CONST = require_const5();
  var MATH_CONST = require_const4();
  var Tween = new Class({
    Extends: EventEmitter,
    initialize: function Tween2(parent, data, targets) {
      EventEmitter.call(this);
      this.parent = parent;
      this.parentIsTimeline = parent.hasOwnProperty("isTimeline");
      this.data = data;
      this.totalData = data.length;
      this.targets = targets;
      this.totalTargets = targets.length;
      this.useFrames = false;
      this.timeScale = 1;
      this.loop = 0;
      this.loopDelay = 0;
      this.loopCounter = 0;
      this.startDelay = 0;
      this.hasStarted = false;
      this.isSeeking = false;
      this.completeDelay = 0;
      this.countdown = 0;
      this.offset = 0;
      this.calculatedOffset = 0;
      this.state = TWEEN_CONST.PENDING_ADD;
      this._pausedState = TWEEN_CONST.INIT;
      this.paused = false;
      this.elapsed = 0;
      this.totalElapsed = 0;
      this.duration = 0;
      this.progress = 0;
      this.totalDuration = 0;
      this.totalProgress = 0;
      this.callbacks = {
        onActive: null,
        onComplete: null,
        onLoop: null,
        onRepeat: null,
        onStart: null,
        onStop: null,
        onUpdate: null,
        onYoyo: null
      };
      this.callbackScope;
    },
    getValue: function(index) {
      if (index === void 0) {
        index = 0;
      }
      return this.data[index].current;
    },
    setTimeScale: function(value) {
      this.timeScale = value;
      return this;
    },
    getTimeScale: function() {
      return this.timeScale;
    },
    isPlaying: function() {
      return this.state === TWEEN_CONST.ACTIVE;
    },
    isPaused: function() {
      return this.state === TWEEN_CONST.PAUSED;
    },
    hasTarget: function(target) {
      return this.targets.indexOf(target) !== -1;
    },
    updateTo: function(key, value, startToCurrent) {
      if (startToCurrent === void 0) {
        startToCurrent = false;
      }
      for (var i = 0; i < this.totalData; i++) {
        var tweenData = this.data[i];
        if (tweenData.key === key) {
          tweenData.end = value;
          if (startToCurrent) {
            tweenData.start = tweenData.current;
          }
        }
      }
      return this;
    },
    restart: function() {
      this.elapsed = 0;
      this.progress = 0;
      this.totalElapsed = 0;
      this.totalProgress = 0;
      if (this.state === TWEEN_CONST.ACTIVE) {
        return this.seek(0);
      } else if (this.state === TWEEN_CONST.REMOVED) {
        this.seek(0);
        this.parent.makeActive(this);
        return this;
      } else if (this.state === TWEEN_CONST.PENDING_ADD) {
        return this;
      } else {
        return this.play();
      }
    },
    calcDuration: function() {
      var maxDuration = 0;
      var minDelay = MATH_CONST.MAX_SAFE_INTEGER;
      var data = this.data;
      for (var i = 0; i < this.totalData; i++) {
        var tweenData = data[i];
        tweenData.t1 = tweenData.duration + tweenData.hold;
        if (tweenData.yoyo) {
          tweenData.t1 += tweenData.duration;
        }
        tweenData.t2 = tweenData.t1 + tweenData.repeatDelay;
        tweenData.totalDuration = tweenData.delay + tweenData.t1;
        if (tweenData.repeat === -1) {
          tweenData.totalDuration += tweenData.t2 * 999999999999;
        } else if (tweenData.repeat > 0) {
          tweenData.totalDuration += tweenData.t2 * tweenData.repeat;
        }
        if (tweenData.totalDuration > maxDuration) {
          maxDuration = tweenData.totalDuration;
        }
        if (tweenData.delay < minDelay) {
          minDelay = tweenData.delay;
        }
      }
      this.duration = Math.max(maxDuration, 1e-3);
      this.loopCounter = this.loop === -1 ? 999999999999 : this.loop;
      if (this.loopCounter > 0) {
        this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter;
      } else {
        this.totalDuration = this.duration + this.completeDelay;
      }
      this.startDelay = minDelay;
    },
    init: function() {
      if (this.paused && !this.parentIsTimeline) {
        this.state = TWEEN_CONST.PENDING_ADD;
        this._pausedState = TWEEN_CONST.INIT;
        return false;
      }
      var data = this.data;
      var totalTargets = this.totalTargets;
      for (var i = 0; i < this.totalData; i++) {
        var tweenData = data[i];
        var target = tweenData.target;
        var gen = tweenData.gen;
        var key = tweenData.key;
        var targetIndex = tweenData.index;
        tweenData.delay = gen.delay(target, key, 0, targetIndex, totalTargets, this);
        tweenData.duration = Math.max(gen.duration(target, key, 0, targetIndex, totalTargets, this), 1e-3);
        tweenData.hold = gen.hold(target, key, 0, targetIndex, totalTargets, this);
        tweenData.repeat = gen.repeat(target, key, 0, targetIndex, totalTargets, this);
        tweenData.repeatDelay = gen.repeatDelay(target, key, 0, targetIndex, totalTargets, this);
      }
      this.calcDuration();
      this.progress = 0;
      this.totalProgress = 0;
      this.elapsed = 0;
      this.totalElapsed = 0;
      this.state = TWEEN_CONST.INIT;
      return true;
    },
    makeActive: function() {
      this.parent.makeActive(this);
      this.dispatchTweenEvent(Events.TWEEN_ACTIVE, this.callbacks.onActive);
    },
    nextState: function() {
      if (this.loopCounter > 0) {
        this.elapsed = 0;
        this.progress = 0;
        this.loopCounter--;
        this.resetTweenData(true);
        if (this.loopDelay > 0) {
          this.countdown = this.loopDelay;
          this.state = TWEEN_CONST.LOOP_DELAY;
        } else {
          this.state = TWEEN_CONST.ACTIVE;
          this.dispatchTweenEvent(Events.TWEEN_LOOP, this.callbacks.onLoop);
        }
      } else if (this.completeDelay > 0) {
        this.state = TWEEN_CONST.COMPLETE_DELAY;
        this.countdown = this.completeDelay;
      } else {
        this.state = TWEEN_CONST.PENDING_REMOVE;
        this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete);
      }
    },
    pause: function() {
      if (this.state === TWEEN_CONST.PAUSED) {
        return this;
      }
      this.paused = true;
      this._pausedState = this.state;
      this.state = TWEEN_CONST.PAUSED;
      return this;
    },
    play: function(resetFromTimeline) {
      if (resetFromTimeline === void 0) {
        resetFromTimeline = false;
      }
      var state = this.state;
      if (state === TWEEN_CONST.INIT && !this.parentIsTimeline) {
        this.resetTweenData(false);
        this.state = TWEEN_CONST.ACTIVE;
        return this;
      } else if (state === TWEEN_CONST.ACTIVE || state === TWEEN_CONST.PENDING_ADD && this._pausedState === TWEEN_CONST.PENDING_ADD) {
        return this;
      } else if (!this.parentIsTimeline && (state === TWEEN_CONST.PENDING_REMOVE || state === TWEEN_CONST.REMOVED)) {
        this.seek(0);
        this.parent.makeActive(this);
        return this;
      }
      if (this.parentIsTimeline) {
        this.resetTweenData(resetFromTimeline);
        if (this.calculatedOffset === 0) {
          this.state = TWEEN_CONST.ACTIVE;
        } else {
          this.countdown = this.calculatedOffset;
          this.state = TWEEN_CONST.OFFSET_DELAY;
        }
      } else if (this.paused) {
        this.paused = false;
        this.makeActive();
      } else {
        this.resetTweenData(resetFromTimeline);
        this.state = TWEEN_CONST.ACTIVE;
        this.makeActive();
      }
      return this;
    },
    resetTweenData: function(resetFromLoop) {
      var data = this.data;
      var total = this.totalData;
      var totalTargets = this.totalTargets;
      for (var i = 0; i < total; i++) {
        var tweenData = data[i];
        var target = tweenData.target;
        var key = tweenData.key;
        var targetIndex = tweenData.index;
        tweenData.progress = 0;
        tweenData.elapsed = 0;
        tweenData.repeatCounter = tweenData.repeat === -1 ? 999999999999 : tweenData.repeat;
        if (resetFromLoop) {
          tweenData.start = tweenData.getStartValue(target, key, tweenData.start, targetIndex, totalTargets, this);
          tweenData.end = tweenData.getEndValue(target, key, tweenData.end, targetIndex, totalTargets, this);
          tweenData.current = tweenData.start;
          tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
        } else {
          tweenData.state = TWEEN_CONST.PENDING_RENDER;
        }
        if (tweenData.delay > 0) {
          tweenData.elapsed = tweenData.delay;
          tweenData.state = TWEEN_CONST.DELAY;
        }
        if (tweenData.getActiveValue) {
          target[key] = tweenData.getActiveValue(tweenData.target, tweenData.key, tweenData.start);
        }
      }
    },
    resume: function() {
      if (this.state === TWEEN_CONST.PAUSED) {
        this.paused = false;
        this.state = this._pausedState;
      } else {
        this.play();
      }
      return this;
    },
    seek: function(toPosition, delta) {
      if (delta === void 0) {
        delta = 16.6;
      }
      if (this.state === TWEEN_CONST.REMOVED) {
        this.makeActive();
      }
      this.elapsed = 0;
      this.progress = 0;
      this.totalElapsed = 0;
      this.totalProgress = 0;
      var data = this.data;
      var totalTargets = this.totalTargets;
      for (var i = 0; i < this.totalData; i++) {
        var tweenData = data[i];
        var target = tweenData.target;
        var gen = tweenData.gen;
        var key = tweenData.key;
        var targetIndex = tweenData.index;
        tweenData.progress = 0;
        tweenData.elapsed = 0;
        tweenData.repeatCounter = tweenData.repeat === -1 ? 999999999999 : tweenData.repeat;
        tweenData.delay = gen.delay(target, key, 0, targetIndex, totalTargets, this);
        tweenData.duration = Math.max(gen.duration(target, key, 0, targetIndex, totalTargets, this), 1e-3);
        tweenData.hold = gen.hold(target, key, 0, targetIndex, totalTargets, this);
        tweenData.repeat = gen.repeat(target, key, 0, targetIndex, totalTargets, this);
        tweenData.repeatDelay = gen.repeatDelay(target, key, 0, targetIndex, totalTargets, this);
        tweenData.current = tweenData.start;
        tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
        this.updateTweenData(this, tweenData, 0, targetIndex, totalTargets);
        if (tweenData.delay > 0) {
          tweenData.elapsed = tweenData.delay;
          tweenData.state = TWEEN_CONST.DELAY;
        }
      }
      this.calcDuration();
      var wasPaused = false;
      if (this.state === TWEEN_CONST.PAUSED) {
        wasPaused = true;
        this.state = TWEEN_CONST.ACTIVE;
      }
      this.isSeeking = true;
      do {
        this.update(0, delta);
      } while (this.totalProgress < toPosition);
      this.isSeeking = false;
      if (wasPaused) {
        this.state = TWEEN_CONST.PAUSED;
      }
      return this;
    },
    setCallback: function(type, callback, params, scope) {
      this.callbacks[type] = {func: callback, scope, params};
      return this;
    },
    complete: function(delay) {
      if (delay === void 0) {
        delay = 0;
      }
      if (delay) {
        this.state = TWEEN_CONST.COMPLETE_DELAY;
        this.countdown = delay;
      } else {
        this.state = TWEEN_CONST.PENDING_REMOVE;
        this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete);
      }
      return this;
    },
    remove: function() {
      this.parent.remove(this);
      return this;
    },
    stop: function(resetTo) {
      if (this.state === TWEEN_CONST.ACTIVE) {
        if (resetTo !== void 0) {
          this.seek(resetTo);
        }
      }
      if (this.state !== TWEEN_CONST.REMOVED) {
        if (this.state === TWEEN_CONST.PAUSED || this.state === TWEEN_CONST.PENDING_ADD) {
          if (this.parentIsTimeline) {
            this.parent.manager._destroy.push(this);
            this.parent.manager._toProcess++;
          } else {
            this.parent._destroy.push(this);
            this.parent._toProcess++;
          }
        }
        this.dispatchTweenEvent(Events.TWEEN_STOP, this.callbacks.onStop);
        this.removeAllListeners();
        this.state = TWEEN_CONST.PENDING_REMOVE;
      }
      return this;
    },
    update: function(timestamp, delta) {
      if (this.state === TWEEN_CONST.PAUSED) {
        return false;
      }
      if (this.useFrames) {
        delta = 1 * this.parent.timeScale;
      }
      delta *= this.timeScale;
      this.elapsed += delta;
      this.progress = Math.min(this.elapsed / this.duration, 1);
      this.totalElapsed += delta;
      this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);
      switch (this.state) {
        case TWEEN_CONST.ACTIVE:
          if (!this.hasStarted && !this.isSeeking) {
            this.startDelay -= delta;
            if (this.startDelay <= 0) {
              this.hasStarted = true;
              this.dispatchTweenEvent(Events.TWEEN_START, this.callbacks.onStart);
            }
          }
          var stillRunning = false;
          for (var i = 0; i < this.totalData; i++) {
            var tweenData = this.data[i];
            if (this.updateTweenData(this, tweenData, delta)) {
              stillRunning = true;
            }
          }
          if (!stillRunning) {
            this.nextState();
          }
          break;
        case TWEEN_CONST.LOOP_DELAY:
          this.countdown -= delta;
          if (this.countdown <= 0) {
            this.state = TWEEN_CONST.ACTIVE;
            this.dispatchTweenEvent(Events.TWEEN_LOOP, this.callbacks.onLoop);
          }
          break;
        case TWEEN_CONST.OFFSET_DELAY:
          this.countdown -= delta;
          if (this.countdown <= 0) {
            this.state = TWEEN_CONST.ACTIVE;
          }
          break;
        case TWEEN_CONST.COMPLETE_DELAY:
          this.countdown -= delta;
          if (this.countdown <= 0) {
            this.state = TWEEN_CONST.PENDING_REMOVE;
            this.dispatchTweenEvent(Events.TWEEN_COMPLETE, this.callbacks.onComplete);
          }
          break;
      }
      return this.state === TWEEN_CONST.PENDING_REMOVE;
    },
    dispatchTweenDataEvent: function(event, callback, tweenData) {
      if (!this.isSeeking) {
        this.emit(event, this, tweenData.key, tweenData.target, tweenData.current, tweenData.previous);
        if (callback) {
          callback.params[1] = tweenData.target;
          callback.func.apply(callback.scope, callback.params);
        }
      }
    },
    dispatchTweenEvent: function(event, callback) {
      if (!this.isSeeking) {
        this.emit(event, this, this.targets);
        if (callback) {
          callback.params[1] = this.targets;
          callback.func.apply(callback.scope, callback.params);
        }
      }
    },
    setStateFromEnd: function(tween, tweenData, diff) {
      if (tweenData.yoyo) {
        tweenData.elapsed = diff;
        tweenData.progress = diff / tweenData.duration;
        if (tweenData.flipX) {
          tweenData.target.toggleFlipX();
        }
        if (tweenData.flipY) {
          tweenData.target.toggleFlipY();
        }
        this.dispatchTweenDataEvent(Events.TWEEN_YOYO, tween.callbacks.onYoyo, tweenData);
        tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
        return TWEEN_CONST.PLAYING_BACKWARD;
      } else if (tweenData.repeatCounter > 0) {
        tweenData.repeatCounter--;
        tweenData.elapsed = diff;
        tweenData.progress = diff / tweenData.duration;
        if (tweenData.flipX) {
          tweenData.target.toggleFlipX();
        }
        if (tweenData.flipY) {
          tweenData.target.toggleFlipY();
        }
        tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
        tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
        if (tweenData.repeatDelay > 0) {
          tweenData.elapsed = tweenData.repeatDelay - diff;
          tweenData.current = tweenData.start;
          tweenData.target[tweenData.key] = tweenData.current;
          return TWEEN_CONST.REPEAT_DELAY;
        } else {
          this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData);
          return TWEEN_CONST.PLAYING_FORWARD;
        }
      }
      return TWEEN_CONST.COMPLETE;
    },
    setStateFromStart: function(tween, tweenData, diff) {
      if (tweenData.repeatCounter > 0) {
        tweenData.repeatCounter--;
        tweenData.elapsed = diff;
        tweenData.progress = diff / tweenData.duration;
        if (tweenData.flipX) {
          tweenData.target.toggleFlipX();
        }
        if (tweenData.flipY) {
          tweenData.target.toggleFlipY();
        }
        tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
        if (tweenData.repeatDelay > 0) {
          tweenData.elapsed = tweenData.repeatDelay - diff;
          tweenData.current = tweenData.start;
          tweenData.target[tweenData.key] = tweenData.current;
          return TWEEN_CONST.REPEAT_DELAY;
        } else {
          this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData);
          return TWEEN_CONST.PLAYING_FORWARD;
        }
      }
      return TWEEN_CONST.COMPLETE;
    },
    updateTweenData: function(tween, tweenData, delta) {
      var target = tweenData.target;
      switch (tweenData.state) {
        case TWEEN_CONST.PLAYING_FORWARD:
        case TWEEN_CONST.PLAYING_BACKWARD:
          if (!target) {
            tweenData.state = TWEEN_CONST.COMPLETE;
            break;
          }
          var elapsed = tweenData.elapsed;
          var duration = tweenData.duration;
          var diff = 0;
          elapsed += delta;
          if (elapsed > duration) {
            diff = elapsed - duration;
            elapsed = duration;
          }
          var forward = tweenData.state === TWEEN_CONST.PLAYING_FORWARD;
          var progress = elapsed / duration;
          tweenData.elapsed = elapsed;
          tweenData.progress = progress;
          tweenData.previous = tweenData.current;
          if (progress === 1) {
            if (forward) {
              tweenData.current = tweenData.end;
              target[tweenData.key] = tweenData.end;
              if (tweenData.hold > 0) {
                tweenData.elapsed = tweenData.hold - diff;
                tweenData.state = TWEEN_CONST.HOLD_DELAY;
              } else {
                tweenData.state = this.setStateFromEnd(tween, tweenData, diff);
              }
            } else {
              tweenData.current = tweenData.start;
              target[tweenData.key] = tweenData.start;
              tweenData.state = this.setStateFromStart(tween, tweenData, diff);
            }
          } else {
            var v = forward ? tweenData.ease(progress) : tweenData.ease(1 - progress);
            tweenData.current = tweenData.start + (tweenData.end - tweenData.start) * v;
            target[tweenData.key] = tweenData.current;
          }
          this.dispatchTweenDataEvent(Events.TWEEN_UPDATE, tween.callbacks.onUpdate, tweenData);
          break;
        case TWEEN_CONST.DELAY:
          tweenData.elapsed -= delta;
          if (tweenData.elapsed <= 0) {
            tweenData.elapsed = Math.abs(tweenData.elapsed);
            tweenData.state = TWEEN_CONST.PENDING_RENDER;
          }
          break;
        case TWEEN_CONST.REPEAT_DELAY:
          tweenData.elapsed -= delta;
          if (tweenData.elapsed <= 0) {
            tweenData.elapsed = Math.abs(tweenData.elapsed);
            tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
            this.dispatchTweenDataEvent(Events.TWEEN_REPEAT, tween.callbacks.onRepeat, tweenData);
          }
          break;
        case TWEEN_CONST.HOLD_DELAY:
          tweenData.elapsed -= delta;
          if (tweenData.elapsed <= 0) {
            tweenData.state = this.setStateFromEnd(tween, tweenData, Math.abs(tweenData.elapsed));
          }
          break;
        case TWEEN_CONST.PENDING_RENDER:
          if (target) {
            tweenData.start = tweenData.getStartValue(target, tweenData.key, target[tweenData.key], tweenData.index, tween.totalTargets, tween);
            tweenData.end = tweenData.getEndValue(target, tweenData.key, tweenData.start, tweenData.index, tween.totalTargets, tween);
            tweenData.current = tweenData.start;
            target[tweenData.key] = tweenData.start;
            tweenData.state = TWEEN_CONST.PLAYING_FORWARD;
          } else {
            tweenData.state = TWEEN_CONST.COMPLETE;
          }
          break;
      }
      return tweenData.state !== TWEEN_CONST.COMPLETE;
    }
  });
  Tween.TYPES = [
    "onActive",
    "onComplete",
    "onLoop",
    "onRepeat",
    "onStart",
    "onStop",
    "onUpdate",
    "onYoyo"
  ];
  GameObjectFactory.register("tween", function(config2) {
    return this.scene.sys.tweens.add(config2);
  });
  GameObjectCreator.register("tween", function(config2) {
    return this.scene.sys.tweens.create(config2);
  });
  module2.exports = Tween;
});

// node_modules/phaser/src/tweens/tween/TweenData.js
var require_TweenData = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var TweenData = function(target, index, key, getEnd, getStart, getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, flipX, flipY) {
    return {
      target,
      index,
      key,
      getActiveValue: getActive,
      getEndValue: getEnd,
      getStartValue: getStart,
      ease,
      duration: 0,
      totalDuration: 0,
      delay: 0,
      yoyo,
      hold: 0,
      repeat: 0,
      repeatDelay: 0,
      flipX,
      flipY,
      progress: 0,
      elapsed: 0,
      repeatCounter: 0,
      start: 0,
      previous: 0,
      current: 0,
      end: 0,
      t1: 0,
      t2: 0,
      gen: {
        delay,
        duration,
        hold,
        repeat,
        repeatDelay
      },
      state: 0
    };
  };
  module2.exports = TweenData;
});

// node_modules/phaser/src/tweens/builders/NumberTweenBuilder.js
var require_NumberTweenBuilder = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Defaults = require_Defaults();
  var GetAdvancedValue = require_GetAdvancedValue();
  var GetBoolean = require_GetBoolean();
  var GetEaseFunction = require_GetEaseFunction();
  var GetNewValue = require_GetNewValue();
  var GetValue = require_GetValue();
  var GetValueOp = require_GetValueOp();
  var Tween = require_Tween();
  var TweenData = require_TweenData();
  var NumberTweenBuilder = function(parent, config2, defaults) {
    if (defaults === void 0) {
      defaults = Defaults;
    }
    var from = GetValue(config2, "from", 0);
    var to = GetValue(config2, "to", 1);
    var targets = [{value: from}];
    var delay = GetNewValue(config2, "delay", defaults.delay);
    var duration = GetNewValue(config2, "duration", defaults.duration);
    var easeParams = GetValue(config2, "easeParams", defaults.easeParams);
    var ease = GetEaseFunction(GetValue(config2, "ease", defaults.ease), easeParams);
    var hold = GetNewValue(config2, "hold", defaults.hold);
    var repeat = GetNewValue(config2, "repeat", defaults.repeat);
    var repeatDelay = GetNewValue(config2, "repeatDelay", defaults.repeatDelay);
    var yoyo = GetBoolean(config2, "yoyo", defaults.yoyo);
    var data = [];
    var ops = GetValueOp("value", to);
    var tweenData = TweenData(targets[0], 0, "value", ops.getEnd, ops.getStart, ops.getActive, ease, delay, duration, yoyo, hold, repeat, repeatDelay, false, false);
    tweenData.start = from;
    tweenData.current = from;
    tweenData.to = to;
    data.push(tweenData);
    var tween = new Tween(parent, data, targets);
    tween.offset = GetAdvancedValue(config2, "offset", null);
    tween.completeDelay = GetAdvancedValue(config2, "completeDelay", 0);
    tween.loop = Math.round(GetAdvancedValue(config2, "loop", 0));
    tween.loopDelay = Math.round(GetAdvancedValue(config2, "loopDelay", 0));
    tween.paused = GetBoolean(config2, "paused", false);
    tween.useFrames = GetBoolean(config2, "useFrames", false);
    var scope = GetValue(config2, "callbackScope", tween);
    var tweenArray = [tween, null];
    var callbacks = Tween.TYPES;
    for (var i = 0; i < callbacks.length; i++) {
      var type = callbacks[i];
      var callback = GetValue(config2, type, false);
      if (callback) {
        var callbackScope = GetValue(config2, type + "Scope", scope);
        var callbackParams = GetValue(config2, type + "Params", []);
        tween.setCallback(type, callback, tweenArray.concat(callbackParams), callbackScope);
      }
    }
    return tween;
  };
  module2.exports = NumberTweenBuilder;
});

// node_modules/phaser/src/tweens/builders/StaggerBuilder.js
var require_StaggerBuilder = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetEaseFunction = require_GetEaseFunction();
  var GetValue = require_GetValue();
  var MATH_CONST = require_const4();
  var StaggerBuilder = function(value, options) {
    if (options === void 0) {
      options = {};
    }
    var result;
    var start = GetValue(options, "start", 0);
    var ease = GetValue(options, "ease", null);
    var grid = GetValue(options, "grid", null);
    var from = GetValue(options, "from", 0);
    var fromFirst = from === "first";
    var fromCenter = from === "center";
    var fromLast = from === "last";
    var fromValue = typeof from === "number";
    var isRange = Array.isArray(value);
    var value1 = isRange ? parseFloat(value[0]) : parseFloat(value);
    var value2 = isRange ? parseFloat(value[1]) : 0;
    var maxValue = Math.max(value1, value2);
    if (isRange) {
      start += value1;
    }
    if (grid) {
      var gridWidth = grid[0];
      var gridHeight = grid[1];
      var fromX = 0;
      var fromY = 0;
      var distanceX = 0;
      var distanceY = 0;
      var gridValues = [];
      if (fromLast) {
        fromX = gridWidth - 1;
        fromY = gridHeight - 1;
      } else if (fromValue) {
        fromX = from % gridWidth;
        fromY = Math.floor(from / gridWidth);
      } else if (fromCenter) {
        fromX = (gridWidth - 1) / 2;
        fromY = (gridHeight - 1) / 2;
      }
      var gridMax = MATH_CONST.MIN_SAFE_INTEGER;
      for (var toY = 0; toY < gridHeight; toY++) {
        gridValues[toY] = [];
        for (var toX = 0; toX < gridWidth; toX++) {
          distanceX = fromX - toX;
          distanceY = fromY - toY;
          var dist = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
          if (dist > gridMax) {
            gridMax = dist;
          }
          gridValues[toY][toX] = dist;
        }
      }
    }
    var easeFunction = ease ? GetEaseFunction(ease) : null;
    if (grid) {
      result = function(target, key, value3, index) {
        var gridSpace = 0;
        var toX2 = index % gridWidth;
        var toY2 = Math.floor(index / gridWidth);
        if (toX2 >= 0 && toX2 < gridWidth && toY2 >= 0 && toY2 < gridHeight) {
          gridSpace = gridValues[toY2][toX2];
        }
        var output;
        if (isRange) {
          var diff = value2 - value1;
          if (easeFunction) {
            output = gridSpace / gridMax * diff * easeFunction(gridSpace / gridMax);
          } else {
            output = gridSpace / gridMax * diff;
          }
        } else if (easeFunction) {
          output = gridSpace * value1 * easeFunction(gridSpace / gridMax);
        } else {
          output = gridSpace * value1;
        }
        return output + start;
      };
    } else {
      result = function(target, key, value3, index, total) {
        total--;
        var fromIndex;
        if (fromFirst) {
          fromIndex = index;
        } else if (fromCenter) {
          fromIndex = Math.abs(total / 2 - index);
        } else if (fromLast) {
          fromIndex = total - index;
        } else if (fromValue) {
          fromIndex = Math.abs(from - index);
        }
        var output;
        if (isRange) {
          var spacing;
          if (fromCenter) {
            spacing = (value2 - value1) / total * (fromIndex * 2);
          } else {
            spacing = (value2 - value1) / total * fromIndex;
          }
          if (easeFunction) {
            output = spacing * easeFunction(fromIndex / total);
          } else {
            output = spacing;
          }
        } else if (easeFunction) {
          output = total * maxValue * easeFunction(fromIndex / total);
        } else {
          output = fromIndex * value1;
        }
        return output + start;
      };
    }
    return result;
  };
  module2.exports = StaggerBuilder;
});

// node_modules/phaser/src/tweens/builders/TweenBuilder.js
var require_TweenBuilder = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Defaults = require_Defaults();
  var GetAdvancedValue = require_GetAdvancedValue();
  var GetBoolean = require_GetBoolean();
  var GetEaseFunction = require_GetEaseFunction();
  var GetNewValue = require_GetNewValue();
  var GetProps = require_GetProps();
  var GetTargets = require_GetTargets();
  var GetValue = require_GetValue();
  var GetValueOp = require_GetValueOp();
  var Tween = require_Tween();
  var TweenData = require_TweenData();
  var TweenBuilder = function(parent, config2, defaults) {
    if (defaults === void 0) {
      defaults = Defaults;
    }
    var targets = defaults.targets ? defaults.targets : GetTargets(config2);
    var props = GetProps(config2);
    var delay = GetNewValue(config2, "delay", defaults.delay);
    var duration = GetNewValue(config2, "duration", defaults.duration);
    var easeParams = GetValue(config2, "easeParams", defaults.easeParams);
    var ease = GetEaseFunction(GetValue(config2, "ease", defaults.ease), easeParams);
    var hold = GetNewValue(config2, "hold", defaults.hold);
    var repeat = GetNewValue(config2, "repeat", defaults.repeat);
    var repeatDelay = GetNewValue(config2, "repeatDelay", defaults.repeatDelay);
    var yoyo = GetBoolean(config2, "yoyo", defaults.yoyo);
    var flipX = GetBoolean(config2, "flipX", defaults.flipX);
    var flipY = GetBoolean(config2, "flipY", defaults.flipY);
    var data = [];
    for (var p = 0; p < props.length; p++) {
      var key = props[p].key;
      var value = props[p].value;
      for (var t = 0; t < targets.length; t++) {
        var ops = GetValueOp(key, value);
        var tweenData = TweenData(targets[t], t, key, ops.getEnd, ops.getStart, ops.getActive, GetEaseFunction(GetValue(value, "ease", ease), GetValue(value, "easeParams", easeParams)), GetNewValue(value, "delay", delay), GetNewValue(value, "duration", duration), GetBoolean(value, "yoyo", yoyo), GetNewValue(value, "hold", hold), GetNewValue(value, "repeat", repeat), GetNewValue(value, "repeatDelay", repeatDelay), GetBoolean(value, "flipX", flipX), GetBoolean(value, "flipY", flipY));
        data.push(tweenData);
      }
    }
    var tween = new Tween(parent, data, targets);
    tween.offset = GetAdvancedValue(config2, "offset", null);
    tween.completeDelay = GetAdvancedValue(config2, "completeDelay", 0);
    tween.loop = Math.round(GetAdvancedValue(config2, "loop", 0));
    tween.loopDelay = Math.round(GetAdvancedValue(config2, "loopDelay", 0));
    tween.paused = GetBoolean(config2, "paused", false);
    tween.useFrames = GetBoolean(config2, "useFrames", false);
    var scope = GetValue(config2, "callbackScope", tween);
    var tweenArray = [tween, null];
    var callbacks = Tween.TYPES;
    for (var i = 0; i < callbacks.length; i++) {
      var type = callbacks[i];
      var callback = GetValue(config2, type, false);
      if (callback) {
        var callbackScope = GetValue(config2, type + "Scope", scope);
        var callbackParams = GetValue(config2, type + "Params", []);
        tween.setCallback(type, callback, tweenArray.concat(callbackParams), callbackScope);
      }
    }
    return tween;
  };
  module2.exports = TweenBuilder;
});

// node_modules/phaser/src/tweens/Timeline.js
var require_Timeline = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Class = require_Class();
  var EventEmitter = require_eventemitter3();
  var Events = require_events21();
  var TweenBuilder = require_TweenBuilder();
  var TWEEN_CONST = require_const5();
  var Timeline = new Class({
    Extends: EventEmitter,
    initialize: function Timeline2(manager) {
      EventEmitter.call(this);
      this.manager = manager;
      this.isTimeline = true;
      this.data = [];
      this.totalData = 0;
      this.useFrames = false;
      this.timeScale = 1;
      this.loop = 0;
      this.loopDelay = 0;
      this.loopCounter = 0;
      this.completeDelay = 0;
      this.countdown = 0;
      this.state = TWEEN_CONST.PENDING_ADD;
      this._pausedState = TWEEN_CONST.PENDING_ADD;
      this.paused = false;
      this.elapsed = 0;
      this.totalElapsed = 0;
      this.duration = 0;
      this.progress = 0;
      this.totalDuration = 0;
      this.totalProgress = 0;
      this.callbacks = {
        onComplete: null,
        onLoop: null,
        onStart: null,
        onUpdate: null,
        onYoyo: null
      };
      this.callbackScope;
    },
    dispatchTimelineEvent: function(event, callback) {
      this.emit(event, this);
      if (callback) {
        callback.func.apply(callback.scope, callback.params);
      }
    },
    setTimeScale: function(value) {
      this.timeScale = value;
      return this;
    },
    getTimeScale: function() {
      return this.timeScale;
    },
    isPlaying: function() {
      return this.state === TWEEN_CONST.ACTIVE;
    },
    add: function(config2) {
      return this.queue(TweenBuilder(this, config2));
    },
    queue: function(tween) {
      if (!this.isPlaying()) {
        tween.parent = this;
        tween.parentIsTimeline = true;
        this.data.push(tween);
        this.totalData = this.data.length;
      }
      return this;
    },
    hasOffset: function(tween) {
      return tween.offset !== null;
    },
    isOffsetAbsolute: function(value) {
      return typeof value === "number";
    },
    isOffsetRelative: function(value) {
      var t = typeof value;
      if (t === "string") {
        var op = value[0];
        if (op === "-" || op === "+") {
          return true;
        }
      }
      return false;
    },
    getRelativeOffset: function(value, base) {
      var op = value[0];
      var num = parseFloat(value.substr(2));
      var result = base;
      switch (op) {
        case "+":
          result += num;
          break;
        case "-":
          result -= num;
          break;
      }
      return Math.max(0, result);
    },
    calcDuration: function() {
      var prevEnd = 0;
      var totalDuration = 0;
      var offsetDuration = 0;
      for (var i = 0; i < this.totalData; i++) {
        var tween = this.data[i];
        tween.init();
        if (this.hasOffset(tween)) {
          if (this.isOffsetAbsolute(tween.offset)) {
            tween.calculatedOffset = tween.offset;
            if (tween.offset === 0) {
              offsetDuration = 0;
            }
          } else if (this.isOffsetRelative(tween.offset)) {
            tween.calculatedOffset = this.getRelativeOffset(tween.offset, prevEnd);
          }
        } else {
          tween.calculatedOffset = offsetDuration;
        }
        prevEnd = tween.totalDuration + tween.calculatedOffset;
        totalDuration += tween.totalDuration;
        offsetDuration += tween.totalDuration;
      }
      this.duration = totalDuration;
      this.loopCounter = this.loop === -1 ? 999999999999 : this.loop;
      if (this.loopCounter > 0) {
        this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter;
      } else {
        this.totalDuration = this.duration + this.completeDelay;
      }
    },
    init: function() {
      this.calcDuration();
      this.progress = 0;
      this.totalProgress = 0;
      if (this.paused) {
        this.state = TWEEN_CONST.PAUSED;
        return false;
      } else {
        return true;
      }
    },
    resetTweens: function(resetFromLoop) {
      for (var i = 0; i < this.totalData; i++) {
        var tween = this.data[i];
        tween.play(resetFromLoop);
      }
    },
    setCallback: function(type, callback, params, scope) {
      if (Timeline.TYPES.indexOf(type) !== -1) {
        this.callbacks[type] = {func: callback, scope, params};
      }
      return this;
    },
    makeActive: function(tween) {
      return this.manager.makeActive(tween);
    },
    play: function() {
      if (this.state === TWEEN_CONST.ACTIVE) {
        return;
      }
      if (this.paused) {
        this.paused = false;
        this.manager.makeActive(this);
        return;
      } else {
        this.resetTweens(false);
        this.state = TWEEN_CONST.ACTIVE;
      }
      this.dispatchTimelineEvent(Events.TIMELINE_START, this.callbacks.onStart);
    },
    nextState: function() {
      if (this.loopCounter > 0) {
        this.elapsed = 0;
        this.progress = 0;
        this.loopCounter--;
        this.resetTweens(true);
        if (this.loopDelay > 0) {
          this.countdown = this.loopDelay;
          this.state = TWEEN_CONST.LOOP_DELAY;
        } else {
          this.state = TWEEN_CONST.ACTIVE;
          this.dispatchTimelineEvent(Events.TIMELINE_LOOP, this.callbacks.onLoop);
        }
      } else if (this.completeDelay > 0) {
        this.state = TWEEN_CONST.COMPLETE_DELAY;
        this.countdown = this.completeDelay;
      } else {
        this.state = TWEEN_CONST.PENDING_REMOVE;
        this.dispatchTimelineEvent(Events.TIMELINE_COMPLETE, this.callbacks.onComplete);
      }
    },
    update: function(timestamp, delta) {
      if (this.state === TWEEN_CONST.PAUSED) {
        return;
      }
      if (this.useFrames) {
        delta = 1 * this.manager.timeScale;
      }
      delta *= this.timeScale;
      this.elapsed += delta;
      this.progress = Math.min(this.elapsed / this.duration, 1);
      this.totalElapsed += delta;
      this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);
      switch (this.state) {
        case TWEEN_CONST.ACTIVE:
          var stillRunning = this.totalData;
          for (var i = 0; i < this.totalData; i++) {
            var tween = this.data[i];
            if (tween.update(timestamp, delta)) {
              stillRunning--;
            }
          }
          this.dispatchTimelineEvent(Events.TIMELINE_UPDATE, this.callbacks.onUpdate);
          if (stillRunning === 0) {
            this.nextState();
          }
          break;
        case TWEEN_CONST.LOOP_DELAY:
          this.countdown -= delta;
          if (this.countdown <= 0) {
            this.state = TWEEN_CONST.ACTIVE;
            this.dispatchTimelineEvent(Events.TIMELINE_LOOP, this.callbacks.onLoop);
          }
          break;
        case TWEEN_CONST.COMPLETE_DELAY:
          this.countdown -= delta;
          if (this.countdown <= 0) {
            this.state = TWEEN_CONST.PENDING_REMOVE;
            this.dispatchTimelineEvent(Events.TIMELINE_COMPLETE, this.callbacks.onComplete);
          }
          break;
      }
      return this.state === TWEEN_CONST.PENDING_REMOVE;
    },
    stop: function() {
      this.state = TWEEN_CONST.PENDING_REMOVE;
    },
    pause: function() {
      if (this.state === TWEEN_CONST.PAUSED) {
        return;
      }
      this.paused = true;
      this._pausedState = this.state;
      this.state = TWEEN_CONST.PAUSED;
      this.emit(Events.TIMELINE_PAUSE, this);
      return this;
    },
    resume: function() {
      if (this.state === TWEEN_CONST.PAUSED) {
        this.paused = false;
        this.state = this._pausedState;
        this.emit(Events.TIMELINE_RESUME, this);
      }
      return this;
    },
    hasTarget: function(target) {
      for (var i = 0; i < this.data.length; i++) {
        if (this.data[i].hasTarget(target)) {
          return true;
        }
      }
      return false;
    },
    destroy: function() {
      for (var i = 0; i < this.data.length; i++) {
        this.data[i].stop();
      }
    }
  });
  Timeline.TYPES = ["onStart", "onUpdate", "onLoop", "onComplete", "onYoyo"];
  module2.exports = Timeline;
});

// node_modules/phaser/src/tweens/builders/TimelineBuilder.js
var require_TimelineBuilder = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clone = require_Clone();
  var Defaults = require_Defaults();
  var GetAdvancedValue = require_GetAdvancedValue();
  var GetBoolean = require_GetBoolean();
  var GetEaseFunction = require_GetEaseFunction();
  var GetNewValue = require_GetNewValue();
  var GetTargets = require_GetTargets();
  var GetTweens = require_GetTweens();
  var GetValue = require_GetValue();
  var Timeline = require_Timeline();
  var TweenBuilder = require_TweenBuilder();
  var TimelineBuilder = function(manager, config2) {
    var timeline = new Timeline(manager);
    timeline.completeDelay = GetAdvancedValue(config2, "completeDelay", 0);
    timeline.loop = Math.round(GetAdvancedValue(config2, "loop", 0));
    timeline.loopDelay = Math.round(GetAdvancedValue(config2, "loopDelay", 0));
    timeline.paused = GetBoolean(config2, "paused", false);
    timeline.useFrames = GetBoolean(config2, "useFrames", false);
    var scope = GetValue(config2, "callbackScope", timeline);
    var timelineArray = [timeline];
    var onStart = GetValue(config2, "onStart", false);
    if (onStart) {
      var onStartScope = GetValue(config2, "onStartScope", scope);
      var onStartParams = GetValue(config2, "onStartParams", []);
      timeline.setCallback("onStart", onStart, timelineArray.concat(onStartParams), onStartScope);
    }
    var onUpdate = GetValue(config2, "onUpdate", false);
    if (onUpdate) {
      var onUpdateScope = GetValue(config2, "onUpdateScope", scope);
      var onUpdateParams = GetValue(config2, "onUpdateParams", []);
      timeline.setCallback("onUpdate", onUpdate, timelineArray.concat(onUpdateParams), onUpdateScope);
    }
    var onLoop = GetValue(config2, "onLoop", false);
    if (onLoop) {
      var onLoopScope = GetValue(config2, "onLoopScope", scope);
      var onLoopParams = GetValue(config2, "onLoopParams", []);
      timeline.setCallback("onLoop", onLoop, timelineArray.concat(onLoopParams), onLoopScope);
    }
    var onYoyo = GetValue(config2, "onYoyo", false);
    if (onYoyo) {
      var onYoyoScope = GetValue(config2, "onYoyoScope", scope);
      var onYoyoParams = GetValue(config2, "onYoyoParams", []);
      timeline.setCallback("onYoyo", onYoyo, timelineArray.concat(null, onYoyoParams), onYoyoScope);
    }
    var onComplete = GetValue(config2, "onComplete", false);
    if (onComplete) {
      var onCompleteScope = GetValue(config2, "onCompleteScope", scope);
      var onCompleteParams = GetValue(config2, "onCompleteParams", []);
      timeline.setCallback("onComplete", onComplete, timelineArray.concat(onCompleteParams), onCompleteScope);
    }
    var tweens = GetTweens(config2);
    if (tweens.length === 0) {
      timeline.paused = true;
      return timeline;
    }
    var defaults = Clone(Defaults);
    defaults.targets = GetTargets(config2);
    var totalDuration = GetAdvancedValue(config2, "totalDuration", 0);
    if (totalDuration > 0) {
      defaults.duration = Math.floor(totalDuration / tweens.length);
    } else {
      defaults.duration = GetNewValue(config2, "duration", defaults.duration);
    }
    defaults.delay = GetNewValue(config2, "delay", defaults.delay);
    defaults.easeParams = GetValue(config2, "easeParams", defaults.easeParams);
    defaults.ease = GetEaseFunction(GetValue(config2, "ease", defaults.ease), defaults.easeParams);
    defaults.hold = GetNewValue(config2, "hold", defaults.hold);
    defaults.repeat = GetNewValue(config2, "repeat", defaults.repeat);
    defaults.repeatDelay = GetNewValue(config2, "repeatDelay", defaults.repeatDelay);
    defaults.yoyo = GetBoolean(config2, "yoyo", defaults.yoyo);
    defaults.flipX = GetBoolean(config2, "flipX", defaults.flipX);
    defaults.flipY = GetBoolean(config2, "flipY", defaults.flipY);
    for (var i = 0; i < tweens.length; i++) {
      timeline.queue(TweenBuilder(timeline, tweens[i], defaults));
    }
    return timeline;
  };
  module2.exports = TimelineBuilder;
});

// node_modules/phaser/src/tweens/builders/index.js
var require_builders = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    GetBoolean: require_GetBoolean(),
    GetEaseFunction: require_GetEaseFunction(),
    GetNewValue: require_GetNewValue(),
    GetProps: require_GetProps(),
    GetTargets: require_GetTargets(),
    GetTweens: require_GetTweens(),
    GetValueOp: require_GetValueOp(),
    NumberTweenBuilder: require_NumberTweenBuilder(),
    StaggerBuilder: require_StaggerBuilder(),
    TimelineBuilder: require_TimelineBuilder(),
    TweenBuilder: require_TweenBuilder()
  };
});

// node_modules/phaser/src/tweens/TweenManager.js
var require_TweenManager = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var ArrayRemove = require_Remove();
  var Class = require_Class();
  var NumberTweenBuilder = require_NumberTweenBuilder();
  var PluginCache = require_PluginCache();
  var SceneEvents = require_events5();
  var StaggerBuilder = require_StaggerBuilder();
  var TimelineBuilder = require_TimelineBuilder();
  var TWEEN_CONST = require_const5();
  var TweenBuilder = require_TweenBuilder();
  var TweenManager = new Class({
    initialize: function TweenManager2(scene) {
      this.scene = scene;
      this.systems = scene.sys;
      this.timeScale = 1;
      this._add = [];
      this._pending = [];
      this._active = [];
      this._destroy = [];
      this._toProcess = 0;
      scene.sys.events.once(SceneEvents.BOOT, this.boot, this);
      scene.sys.events.on(SceneEvents.START, this.start, this);
    },
    boot: function() {
      this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);
    },
    start: function() {
      var eventEmitter = this.systems.events;
      eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);
      eventEmitter.on(SceneEvents.UPDATE, this.update, this);
      eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);
      this.timeScale = 1;
    },
    createTimeline: function(config2) {
      return TimelineBuilder(this, config2);
    },
    timeline: function(config2) {
      var timeline = TimelineBuilder(this, config2);
      if (!timeline.paused) {
        this._add.push(timeline);
        this._toProcess++;
      }
      return timeline;
    },
    create: function(config2) {
      return TweenBuilder(this, config2);
    },
    add: function(config2) {
      var tween = TweenBuilder(this, config2);
      this._add.push(tween);
      this._toProcess++;
      return tween;
    },
    existing: function(tween) {
      this._add.push(tween);
      this._toProcess++;
      return this;
    },
    addCounter: function(config2) {
      var tween = NumberTweenBuilder(this, config2);
      this._add.push(tween);
      this._toProcess++;
      return tween;
    },
    stagger: function(value, options) {
      return StaggerBuilder(value, options);
    },
    preUpdate: function() {
      if (this._toProcess === 0) {
        return;
      }
      var list = this._destroy;
      var active = this._active;
      var pending = this._pending;
      var i;
      var tween;
      for (i = 0; i < list.length; i++) {
        tween = list[i];
        var idx = active.indexOf(tween);
        if (idx === -1) {
          idx = pending.indexOf(tween);
          if (idx > -1) {
            tween.state = TWEEN_CONST.REMOVED;
            pending.splice(idx, 1);
          }
        } else {
          tween.state = TWEEN_CONST.REMOVED;
          active.splice(idx, 1);
        }
      }
      list.length = 0;
      list = this._add;
      for (i = 0; i < list.length; i++) {
        tween = list[i];
        if (tween.state === TWEEN_CONST.PENDING_ADD) {
          if (tween.init()) {
            tween.play();
            this._active.push(tween);
          } else {
            this._pending.push(tween);
          }
        }
      }
      list.length = 0;
      this._toProcess = 0;
    },
    update: function(timestamp, delta) {
      var list = this._active;
      var tween;
      delta *= this.timeScale;
      for (var i = 0; i < list.length; i++) {
        tween = list[i];
        if (tween.update(timestamp, delta)) {
          this._destroy.push(tween);
          this._toProcess++;
        }
      }
    },
    remove: function(tween) {
      ArrayRemove(this._add, tween);
      ArrayRemove(this._pending, tween);
      ArrayRemove(this._active, tween);
      ArrayRemove(this._destroy, tween);
      tween.state = TWEEN_CONST.REMOVED;
      return this;
    },
    makeActive: function(tween) {
      if (this._add.indexOf(tween) !== -1 || this._active.indexOf(tween) !== -1) {
        return this;
      }
      var idx = this._pending.indexOf(tween);
      if (idx !== -1) {
        this._pending.splice(idx, 1);
      }
      this._add.push(tween);
      tween.state = TWEEN_CONST.PENDING_ADD;
      this._toProcess++;
      return this;
    },
    each: function(callback, scope) {
      var args = [null];
      for (var i = 1; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      for (var texture in this.list) {
        args[0] = this.list[texture];
        callback.apply(scope, args);
      }
    },
    getAllTweens: function() {
      var list = this._active;
      var output = [];
      for (var i = 0; i < list.length; i++) {
        output.push(list[i]);
      }
      return output;
    },
    getGlobalTimeScale: function() {
      return this.timeScale;
    },
    getTweensOf: function(target, includePending) {
      if (includePending === void 0) {
        includePending = false;
      }
      var list = this._active;
      var tween;
      var output = [];
      var i;
      var t;
      if (!Array.isArray(target)) {
        target = [target];
      }
      for (i = 0; i < list.length; i++) {
        tween = list[i];
        for (t = 0; t < target.length; t++) {
          if (tween.hasTarget(target[t])) {
            output.push(tween);
          }
        }
      }
      if (includePending) {
        list = this._pending;
        for (i = 0; i < list.length; i++) {
          tween = list[i];
          for (t = 0; t < target.length; t++) {
            if (tween.hasTarget(target[t])) {
              output.push(tween);
            }
          }
        }
      }
      return output;
    },
    isTweening: function(target) {
      var list = this._active;
      var tween;
      for (var i = 0; i < list.length; i++) {
        tween = list[i];
        if (tween.hasTarget(target) && tween.isPlaying()) {
          return true;
        }
      }
      return false;
    },
    killAll: function() {
      var tweens = this.getAllTweens();
      for (var i = 0; i < tweens.length; i++) {
        tweens[i].stop();
      }
      return this;
    },
    killTweensOf: function(target) {
      var tweens = this.getTweensOf(target);
      for (var i = 0; i < tweens.length; i++) {
        tweens[i].stop();
      }
      return this;
    },
    pauseAll: function() {
      var list = this._active;
      for (var i = 0; i < list.length; i++) {
        list[i].pause();
      }
      return this;
    },
    resumeAll: function() {
      var list = this._active;
      for (var i = 0; i < list.length; i++) {
        list[i].resume();
      }
      return this;
    },
    setGlobalTimeScale: function(value) {
      this.timeScale = value;
      return this;
    },
    shutdown: function() {
      this.killAll();
      this._add = [];
      this._pending = [];
      this._active = [];
      this._destroy = [];
      this._toProcess = 0;
      var eventEmitter = this.systems.events;
      eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);
      eventEmitter.off(SceneEvents.UPDATE, this.update, this);
      eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);
    },
    destroy: function() {
      this.shutdown();
      this.scene.sys.events.off(SceneEvents.START, this.start, this);
      this.scene = null;
      this.systems = null;
    }
  });
  PluginCache.register("TweenManager", TweenManager, "tweens");
  module2.exports = TweenManager;
});

// node_modules/phaser/src/tweens/index.js
var require_tweens = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const5();
  var Extend = require_Extend();
  var Tweens = {
    Builders: require_builders(),
    Events: require_events21(),
    TweenManager: require_TweenManager(),
    Tween: require_Tween(),
    TweenData: require_TweenData(),
    Timeline: require_Timeline()
  };
  Tweens = Extend(false, Tweens, CONST);
  module2.exports = Tweens;
});

// node_modules/phaser/src/utils/base64/ArrayBufferToBase64.js
var require_ArrayBufferToBase64 = __commonJS((exports2, module2) => {
  /**
   * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var ArrayBufferToBase64 = function(arrayBuffer, mediaType) {
    var bytes = new Uint8Array(arrayBuffer);
    var len = bytes.length;
    var base64 = mediaType ? "data:" + mediaType + ";base64," : "";
    for (var i = 0; i < len; i += 3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
      base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
      base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }
    return base64;
  };
  module2.exports = ArrayBufferToBase64;
});

// node_modules/phaser/src/utils/base64/index.js
var require_base64 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    ArrayBufferToBase64: require_ArrayBufferToBase64(),
    Base64ToArrayBuffer: require_Base64ToArrayBuffer()
  };
});

// node_modules/phaser/src/utils/object/GetMinMaxValue.js
var require_GetMinMaxValue = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var GetValue = require_GetValue();
  var Clamp = require_Clamp();
  var GetMinMaxValue = function(source, key, min, max, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = min;
    }
    var value = GetValue(source, key, defaultValue);
    return Clamp(value, min, max);
  };
  module2.exports = GetMinMaxValue;
});

// node_modules/phaser/src/utils/object/HasAll.js
var require_HasAll = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var HasAll = function(source, keys) {
    for (var i = 0; i < keys.length; i++) {
      if (!source.hasOwnProperty(keys[i])) {
        return false;
      }
    }
    return true;
  };
  module2.exports = HasAll;
});

// node_modules/phaser/src/utils/object/MergeRight.js
var require_MergeRight = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Clone = require_Clone();
  var MergeRight = function(obj1, obj2) {
    var clone = Clone(obj1);
    for (var key in obj2) {
      if (clone.hasOwnProperty(key)) {
        clone[key] = obj2[key];
      }
    }
    return clone;
  };
  module2.exports = MergeRight;
});

// node_modules/phaser/src/utils/object/index.js
var require_object = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Clone: require_Clone(),
    DeepCopy: require_DeepCopy(),
    Extend: require_Extend(),
    GetAdvancedValue: require_GetAdvancedValue(),
    GetFastValue: require_GetFastValue(),
    GetMinMaxValue: require_GetMinMaxValue(),
    GetValue: require_GetValue(),
    HasAll: require_HasAll(),
    HasAny: require_HasAny(),
    HasValue: require_HasValue(),
    IsPlainObject: require_IsPlainObject(),
    Merge: require_Merge(),
    MergeRight: require_MergeRight(),
    Pick: require_Pick(),
    SetValue: require_SetValue()
  };
});

// node_modules/phaser/src/utils/string/Format.js
var require_Format = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Format = function(string, values) {
    return string.replace(/%([0-9]+)/g, function(s, n) {
      return values[Number(n) - 1];
    });
  };
  module2.exports = Format;
});

// node_modules/phaser/src/utils/string/RemoveAt.js
var require_RemoveAt2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var RemoveAt = function(string, index) {
    if (index === 0) {
      return string.slice(1);
    } else {
      return string.slice(0, index - 1) + string.slice(index);
    }
  };
  module2.exports = RemoveAt;
});

// node_modules/phaser/src/utils/string/Reverse.js
var require_Reverse3 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var Reverse = function(string) {
    return string.split("").reverse().join("");
  };
  module2.exports = Reverse;
});

// node_modules/phaser/src/utils/string/index.js
var require_string = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Format: require_Format(),
    Pad: require_Pad(),
    RemoveAt: require_RemoveAt2(),
    Reverse: require_Reverse3(),
    UppercaseFirst: require_UppercaseFirst(),
    UUID: require_UUID()
  };
});

// node_modules/phaser/src/utils/index.js
var require_utils = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    Array: require_array(),
    Base64: require_base64(),
    Objects: require_object(),
    String: require_string(),
    NOOP: require_NOOP()
  };
});

// node_modules/phaser/src/sound/index.js
var require_sound = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  module2.exports = {
    SoundManagerCreator: require_SoundManagerCreator(),
    Events: require_events15(),
    BaseSound: require_BaseSound(),
    BaseSoundManager: require_BaseSoundManager(),
    WebAudioSound: require_WebAudioSound(),
    WebAudioSoundManager: require_WebAudioSoundManager(),
    HTML5AudioSound: require_HTML5AudioSound(),
    HTML5AudioSoundManager: require_HTML5AudioSoundManager(),
    NoAudioSound: require_NoAudioSound(),
    NoAudioSoundManager: require_NoAudioSoundManager()
  };
});

// node_modules/phaser/plugins/camera3d/src/sprite3d/Sprite3D.js
var require_Sprite3D = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var Class = require_Class();
  var GameObject = require_GameObject();
  var Sprite = require_Sprite();
  var Vector2 = require_Vector2();
  var Vector4 = require_Vector4();
  var Sprite3D = new Class({
    Extends: GameObject,
    initialize: function Sprite3D2(scene, x, y, z, texture, frame) {
      GameObject.call(this, scene, "Sprite3D");
      this.gameObject = new Sprite(scene, 0, 0, texture, frame);
      this.position = new Vector4(x, y, z);
      this.size = new Vector2(this.gameObject.width, this.gameObject.height);
      this.scale = new Vector2(1, 1);
      this.adjustScaleX = true;
      this.adjustScaleY = true;
      this._visible = true;
    },
    project: function(camera) {
      var pos = this.position;
      var gameObject = this.gameObject;
      camera.project(pos, gameObject);
      camera.getPointSize(pos, this.size, this.scale);
      if (this.scale.x <= 0 || this.scale.y <= 0) {
        gameObject.setVisible(false);
      } else {
        if (!gameObject.visible) {
          gameObject.setVisible(true);
        }
        if (this.adjustScaleX) {
          gameObject.scaleX = this.scale.x;
        }
        if (this.adjustScaleY) {
          gameObject.scaleY = this.scale.y;
        }
        gameObject.setDepth(gameObject.z * -1);
      }
    },
    setVisible: function(value) {
      this.visible = value;
      return this;
    },
    visible: {
      get: function() {
        return this._visible;
      },
      set: function(value) {
        this._visible = value;
        this.gameObject.visible = value;
      }
    },
    x: {
      get: function() {
        return this.position.x;
      },
      set: function(value) {
        this.position.x = value;
      }
    },
    y: {
      get: function() {
        return this.position.y;
      },
      set: function(value) {
        this.position.y = value;
      }
    },
    z: {
      get: function() {
        return this.position.z;
      },
      set: function(value) {
        this.position.z = value;
      }
    }
  });
  module2.exports = Sprite3D;
});

// node_modules/phaser/plugins/camera3d/src/Camera.js
var require_Camera2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var Class = require_Class();
  var Matrix4 = require_Matrix4();
  var RandomXYZ = require_RandomXYZ();
  var RandomXYZW = require_RandomXYZW();
  var RotateVec3 = require_RotateVec3();
  var Set = require_Set();
  var Sprite3D = require_Sprite3D();
  var Vector2 = require_Vector2();
  var Vector3 = require_Vector3();
  var Vector4 = require_Vector4();
  var tmpVec3 = new Vector3();
  var tmpVec4 = new Vector4();
  var dirvec = new Vector3();
  var rightvec = new Vector3();
  var billboardMatrix = new Matrix4();
  var Camera = new Class({
    initialize: function Camera2(scene) {
      this.scene = scene;
      this.displayList = scene.sys.displayList;
      this.updateList = scene.sys.updateList;
      this.name = "";
      this.direction = new Vector3(0, 0, -1);
      this.up = new Vector3(0, 1, 0);
      this.position = new Vector3();
      this.pixelScale = 128;
      this.projection = new Matrix4();
      this.view = new Matrix4();
      this.combined = new Matrix4();
      this.invProjectionView = new Matrix4();
      this.near = 1;
      this.far = 100;
      this.ray = {
        origin: new Vector3(),
        direction: new Vector3()
      };
      this.viewportWidth = 0;
      this.viewportHeight = 0;
      this.billboardMatrixDirty = true;
      this.children = new Set();
    },
    setPosition: function(x, y, z) {
      this.position.set(x, y, z);
      return this.update();
    },
    setScene: function(scene) {
      this.scene = scene;
      return this;
    },
    setPixelScale: function(value) {
      this.pixelScale = value;
      return this.update();
    },
    add: function(sprite3D) {
      this.children.set(sprite3D);
      this.displayList.add(sprite3D.gameObject);
      this.updateList.add(sprite3D.gameObject);
      this.updateChildren();
      return sprite3D;
    },
    remove: function(child) {
      this.displayList.remove(child.gameObject);
      this.updateList.remove(child.gameObject);
      this.children.delete(child);
      return this;
    },
    clear: function() {
      var children = this.getChildren();
      for (var i = 0; i < children.length; i++) {
        this.remove(children[i]);
      }
      return this;
    },
    getChildren: function() {
      return this.children.entries;
    },
    create: function(x, y, z, key, frame, visible) {
      if (visible === void 0) {
        visible = true;
      }
      var child = new Sprite3D(this.scene, x, y, z, key, frame);
      this.displayList.add(child.gameObject);
      this.updateList.add(child.gameObject);
      child.visible = visible;
      this.children.set(child);
      this.updateChildren();
      return child;
    },
    createMultiple: function(quantity, key, frame, visible) {
      if (visible === void 0) {
        visible = true;
      }
      var output = [];
      for (var i = 0; i < quantity; i++) {
        var child = new Sprite3D(this.scene, 0, 0, 0, key, frame);
        this.displayList.add(child.gameObject);
        this.updateList.add(child.gameObject);
        child.visible = visible;
        this.children.set(child);
        output.push(child);
      }
      return output;
    },
    createRect: function(size, spacing, key, frame) {
      if (typeof size === "number") {
        size = {x: size, y: size, z: size};
      }
      if (typeof spacing === "number") {
        spacing = {x: spacing, y: spacing, z: spacing};
      }
      var quantity = size.x * size.y * size.z;
      var sprites = this.createMultiple(quantity, key, frame);
      var i = 0;
      for (var z = 0.5 - size.z / 2; z < size.z / 2; z++) {
        for (var y = 0.5 - size.y / 2; y < size.y / 2; y++) {
          for (var x = 0.5 - size.x / 2; x < size.x / 2; x++) {
            var bx = x * spacing.x;
            var by = y * spacing.y;
            var bz = z * spacing.z;
            sprites[i].position.set(bx, by, bz);
            i++;
          }
        }
      }
      this.update();
      return sprites;
    },
    randomSphere: function(radius, sprites) {
      if (sprites === void 0) {
        sprites = this.getChildren();
      }
      for (var i = 0; i < sprites.length; i++) {
        RandomXYZ(sprites[i].position, radius);
      }
      return this.update();
    },
    randomCube: function(scale, sprites) {
      if (sprites === void 0) {
        sprites = this.getChildren();
      }
      for (var i = 0; i < sprites.length; i++) {
        RandomXYZW(sprites[i].position, scale);
      }
      return this.update();
    },
    translateChildren: function(vec3, sprites) {
      if (sprites === void 0) {
        sprites = this.getChildren();
      }
      for (var i = 0; i < sprites.length; i++) {
        sprites[i].position.add(vec3);
      }
      return this.update();
    },
    transformChildren: function(mat4, sprites) {
      if (sprites === void 0) {
        sprites = this.getChildren();
      }
      for (var i = 0; i < sprites.length; i++) {
        sprites[i].position.transformMat4(mat4);
      }
      return this.update();
    },
    setViewport: function(width, height) {
      this.viewportWidth = width;
      this.viewportHeight = height;
      return this.update();
    },
    translate: function(x, y, z) {
      if (typeof x === "object") {
        this.position.x += x.x || 0;
        this.position.y += x.y || 0;
        this.position.z += x.z || 0;
      } else {
        this.position.x += x || 0;
        this.position.y += y || 0;
        this.position.z += z || 0;
      }
      return this.update();
    },
    lookAt: function(x, y, z) {
      var dir = this.direction;
      var up = this.up;
      if (typeof x === "object") {
        dir.copy(x);
      } else {
        dir.set(x, y, z);
      }
      dir.subtract(this.position).normalize();
      tmpVec3.copy(dir).cross(up).normalize();
      up.copy(tmpVec3).cross(dir).normalize();
      return this.update();
    },
    rotate: function(radians, axis) {
      RotateVec3(this.direction, axis, radians);
      RotateVec3(this.up, axis, radians);
      return this.update();
    },
    rotateAround: function(point, radians, axis) {
      tmpVec3.copy(point).subtract(this.position);
      this.translate(tmpVec3);
      this.rotate(radians, axis);
      this.translate(tmpVec3.negate());
      return this.update();
    },
    project: function(vec, out) {
      if (out === void 0) {
        out = new Vector4();
      }
      var viewportWidth = this.viewportWidth;
      var viewportHeight = this.viewportHeight;
      var n = Camera.NEAR_RANGE;
      var f = Camera.FAR_RANGE;
      tmpVec4.set(vec.x, vec.y, vec.z, 1);
      tmpVec4.transformMat4(this.combined);
      if (tmpVec4.w === 0) {
        tmpVec4.w = 1;
      }
      tmpVec4.x = tmpVec4.x / tmpVec4.w;
      tmpVec4.y = tmpVec4.y / tmpVec4.w;
      tmpVec4.z = tmpVec4.z / tmpVec4.w;
      out.x = viewportWidth / 2 * tmpVec4.x + (0 + viewportWidth / 2);
      out.y = viewportHeight / 2 * tmpVec4.y + (0 + viewportHeight / 2);
      out.z = (f - n) / 2 * tmpVec4.z + (f + n) / 2;
      if (out.w === 0 || out.w) {
        out.w = 1 / tmpVec4.w;
      }
      return out;
    },
    unproject: function(vec, out) {
      if (out === void 0) {
        out = new Vector3();
      }
      var viewport = tmpVec4.set(0, 0, this.viewportWidth, this.viewportHeight);
      return out.copy(vec).unproject(viewport, this.invProjectionView);
    },
    getPickRay: function(x, y) {
      var origin = this.ray.origin.set(x, y, 0);
      var direction = this.ray.direction.set(x, y, 1);
      var viewport = tmpVec4.set(0, 0, this.viewportWidth, this.viewportHeight);
      var mtx = this.invProjectionView;
      origin.unproject(viewport, mtx);
      direction.unproject(viewport, mtx);
      direction.subtract(origin).normalize();
      return this.ray;
    },
    updateChildren: function() {
      var children = this.children.entries;
      for (var i = 0; i < children.length; i++) {
        children[i].project(this);
      }
      return this;
    },
    update: function() {
      return this.updateChildren();
    },
    updateBillboardMatrix: function() {
      var dir = dirvec.set(this.direction).negate();
      var right = rightvec.set(this.up).cross(dir).normalize();
      var up = tmpVec3.set(dir).cross(right).normalize();
      var out = billboardMatrix.val;
      out[0] = right.x;
      out[1] = right.y;
      out[2] = right.z;
      out[3] = 0;
      out[4] = up.x;
      out[5] = up.y;
      out[6] = up.z;
      out[7] = 0;
      out[8] = dir.x;
      out[9] = dir.y;
      out[10] = dir.z;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      this.billboardMatrixDirty = false;
    },
    getPointSize: function(vec, size, out) {
      if (out === void 0) {
        out = new Vector2();
      }
      if (this.billboardMatrixDirty) {
        this.updateBillboardMatrix();
      }
      var tmp = tmpVec3;
      var dx = size.x / this.pixelScale / 2;
      var dy = size.y / this.pixelScale / 2;
      tmp.set(-dx, -dy, 0).transformMat4(billboardMatrix).add(vec);
      this.project(tmp, tmp);
      var tlx = tmp.x;
      var tly = tmp.y;
      tmp.set(dx, dy, 0).transformMat4(billboardMatrix).add(vec);
      this.project(tmp, tmp);
      var brx = tmp.x;
      var bry = tmp.y;
      var w = brx - tlx;
      var h = bry - tly;
      return out.set(w, h);
    },
    destroy: function() {
      this.children.clear();
      this.scene = void 0;
      this.children = void 0;
    },
    setX: function(value) {
      this.position.x = value;
      return this.update();
    },
    setY: function(value) {
      this.position.y = value;
      return this.update();
    },
    setZ: function(value) {
      this.position.z = value;
      return this.update();
    },
    x: {
      get: function() {
        return this.position.x;
      },
      set: function(value) {
        this.position.x = value;
        this.update();
      }
    },
    y: {
      get: function() {
        return this.position.y;
      },
      set: function(value) {
        this.position.y = value;
        this.update();
      }
    },
    z: {
      get: function() {
        return this.position.z;
      },
      set: function(value) {
        this.position.z = value;
        this.update();
      }
    }
  });
  Camera.FAR_RANGE = 1;
  Camera.NEAR_RANGE = 0;
  module2.exports = Camera;
});

// node_modules/phaser/plugins/camera3d/src/OrthographicCamera.js
var require_OrthographicCamera = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var Camera = require_Camera2();
  var Class = require_Class();
  var Vector3 = require_Vector3();
  var tmpVec3 = new Vector3();
  var OrthographicCamera = new Class({
    Extends: Camera,
    initialize: function OrthographicCamera2(scene, viewportWidth, viewportHeight) {
      if (viewportWidth === void 0) {
        viewportWidth = 0;
      }
      if (viewportHeight === void 0) {
        viewportHeight = 0;
      }
      Camera.call(this, scene);
      this.viewportWidth = viewportWidth;
      this.viewportHeight = viewportHeight;
      this._zoom = 1;
      this.near = 0;
      this.update();
    },
    setToOrtho: function(yDown, viewportWidth, viewportHeight) {
      if (viewportWidth === void 0) {
        viewportWidth = this.viewportWidth;
      }
      if (viewportHeight === void 0) {
        viewportHeight = this.viewportHeight;
      }
      var zoom = this.zoom;
      this.up.set(0, yDown ? -1 : 1, 0);
      this.direction.set(0, 0, yDown ? 1 : -1);
      this.position.set(zoom * viewportWidth / 2, zoom * viewportHeight / 2, 0);
      this.viewportWidth = viewportWidth;
      this.viewportHeight = viewportHeight;
      return this.update();
    },
    update: function() {
      var w = this.viewportWidth;
      var h = this.viewportHeight;
      var near = Math.abs(this.near);
      var far = Math.abs(this.far);
      var zoom = this.zoom;
      if (w === 0 || h === 0) {
        return this;
      }
      this.projection.ortho(zoom * -w / 2, zoom * w / 2, zoom * -h / 2, zoom * h / 2, near, far);
      tmpVec3.copy(this.position).add(this.direction);
      this.view.lookAt(this.position, tmpVec3, this.up);
      this.combined.copy(this.projection).multiply(this.view);
      this.invProjectionView.copy(this.combined).invert();
      this.billboardMatrixDirty = true;
      this.updateChildren();
      return this;
    },
    zoom: {
      get: function() {
        return this._zoom;
      },
      set: function(value) {
        this._zoom = value;
        this.update();
      }
    }
  });
  module2.exports = OrthographicCamera;
});

// node_modules/phaser/plugins/camera3d/src/PerspectiveCamera.js
var require_PerspectiveCamera = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var Camera = require_Camera2();
  var Class = require_Class();
  var Vector3 = require_Vector3();
  var tmpVec3 = new Vector3();
  var PerspectiveCamera = new Class({
    Extends: Camera,
    initialize: function PerspectiveCamera2(scene, fieldOfView, viewportWidth, viewportHeight) {
      if (fieldOfView === void 0) {
        fieldOfView = 80;
      }
      if (viewportWidth === void 0) {
        viewportWidth = 0;
      }
      if (viewportHeight === void 0) {
        viewportHeight = 0;
      }
      Camera.call(this, scene);
      this.viewportWidth = viewportWidth;
      this.viewportHeight = viewportHeight;
      this.fieldOfView = fieldOfView * Math.PI / 180;
      this.update();
    },
    setFOV: function(value) {
      this.fieldOfView = value * Math.PI / 180;
      return this;
    },
    update: function() {
      var aspect = this.viewportWidth / this.viewportHeight;
      this.projection.perspective(this.fieldOfView, aspect, Math.abs(this.near), Math.abs(this.far));
      tmpVec3.copy(this.position).add(this.direction);
      this.view.lookAt(this.position, tmpVec3, this.up);
      this.combined.copy(this.projection).multiply(this.view);
      this.invProjectionView.copy(this.combined).invert();
      this.billboardMatrixDirty = true;
      this.updateChildren();
      return this;
    }
  });
  module2.exports = PerspectiveCamera;
});

// node_modules/phaser/plugins/camera3d/src/CameraManager.js
var require_CameraManager2 = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var Class = require_Class();
  var OrthographicCamera = require_OrthographicCamera();
  var PerspectiveCamera = require_PerspectiveCamera();
  var PluginCache = require_PluginCache();
  var CameraManager = new Class({
    initialize: function CameraManager2(scene) {
      this.scene = scene;
      this.systems = scene.sys;
      this.cameras = [];
      scene.sys.events.once("boot", this.boot, this);
      scene.sys.events.on("start", this.start, this);
    },
    boot: function() {
      this.systems.events.once("destroy", this.destroy, this);
    },
    start: function() {
      var eventEmitter = this.systems.events;
      eventEmitter.on("update", this.update, this);
      eventEmitter.once("shutdown", this.shutdown, this);
    },
    add: function(fieldOfView, width, height) {
      return this.addPerspectiveCamera(fieldOfView, width, height);
    },
    addOrthographicCamera: function(width, height) {
      var config2 = this.scene.sys.game.config;
      if (width === void 0) {
        width = config2.width;
      }
      if (height === void 0) {
        height = config2.height;
      }
      var camera = new OrthographicCamera(this.scene, width, height);
      this.cameras.push(camera);
      return camera;
    },
    addPerspectiveCamera: function(fieldOfView, width, height) {
      var config2 = this.scene.sys.game.config;
      if (fieldOfView === void 0) {
        fieldOfView = 80;
      }
      if (width === void 0) {
        width = config2.width;
      }
      if (height === void 0) {
        height = config2.height;
      }
      var camera = new PerspectiveCamera(this.scene, fieldOfView, width, height);
      this.cameras.push(camera);
      return camera;
    },
    getCamera: function(name) {
      for (var i = 0; i < this.cameras.length; i++) {
        if (this.cameras[i].name === name) {
          return this.cameras[i];
        }
      }
      return null;
    },
    removeCamera: function(camera) {
      var cameraIndex = this.cameras.indexOf(camera);
      if (cameraIndex !== -1) {
        this.cameras.splice(cameraIndex, 1);
      }
    },
    removeAll: function() {
      while (this.cameras.length > 0) {
        var camera = this.cameras.pop();
        camera.destroy();
      }
      return this.main;
    },
    update: function(timestep, delta) {
      for (var i = 0, l = this.cameras.length; i < l; ++i) {
        this.cameras[i].update(timestep, delta);
      }
    },
    shutdown: function() {
      var eventEmitter = this.systems.events;
      eventEmitter.off("update", this.update, this);
      eventEmitter.off("shutdown", this.shutdown, this);
      this.removeAll();
    },
    destroy: function() {
      this.shutdown();
      this.scene.sys.events.off("start", this.start, this);
      this.scene = null;
      this.systems = null;
    }
  });
  PluginCache.register("CameraManager3D", CameraManager, "cameras3d");
  module2.exports = CameraManager;
});

// node_modules/phaser/plugins/camera3d/src/index.js
var require_src = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  module2.exports = {
    Camera: require_Camera2(),
    CameraManager: require_CameraManager2(),
    OrthographicCamera: require_OrthographicCamera(),
    PerspectiveCamera: require_PerspectiveCamera()
  };
});

// node_modules/phaser/plugins/camera3d/src/sprite3d/Sprite3DFactory.js
var require_Sprite3DFactory = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var Sprite3D = require_Sprite3D();
  var GameObjectFactory = require_GameObjectFactory();
  GameObjectFactory.register("sprite3D", function(x, y, z, key, frame) {
    var sprite = new Sprite3D(this.scene, x, y, z, key, frame);
    this.displayList.add(sprite.gameObject);
    this.updateList.add(sprite.gameObject);
    return sprite;
  });
});

// node_modules/phaser/plugins/camera3d/src/sprite3d/Sprite3DCreator.js
var require_Sprite3DCreator = __commonJS(() => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var BuildGameObject = require_BuildGameObject();
  var BuildGameObjectAnimation = require_BuildGameObjectAnimation();
  var GameObjectCreator = require_GameObjectCreator();
  var GetAdvancedValue = require_GetAdvancedValue();
  var Sprite3D = require_Sprite3D();
  GameObjectCreator.register("sprite3D", function(config2, addToScene) {
    if (config2 === void 0) {
      config2 = {};
    }
    var key = GetAdvancedValue(config2, "key", null);
    var frame = GetAdvancedValue(config2, "frame", null);
    var sprite = new Sprite3D(this.scene, 0, 0, key, frame);
    if (addToScene !== void 0) {
      config2.add = addToScene;
    }
    BuildGameObject(this.scene, sprite, config2);
    BuildGameObjectAnimation(sprite, config2);
    return sprite;
  });
});

// node_modules/phaser/src/phaser.js
var require_phaser = __commonJS((exports2, module2) => {
  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2020 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   */
  var CONST = require_const();
  var Extend = require_Extend();
  var Phaser6 = {
    Actions: require_actions(),
    Animations: require_animations(),
    BlendModes: require_BlendModes(),
    Cache: require_cache(),
    Cameras: require_cameras(),
    Core: require_core(),
    Class: require_Class(),
    Create: require_create(),
    Curves: require_curves(),
    Data: require_data(),
    Display: require_display(),
    DOM: require_dom(),
    Events: require_events12(),
    Game: require_Game(),
    GameObjects: require_gameobjects(),
    Geom: require_geom(),
    Input: require_input(),
    Loader: require_loader(),
    Math: require_math(),
    Physics: require_physics(),
    Plugins: require_plugins(),
    Renderer: require_renderer(),
    Scale: require_scale(),
    ScaleModes: require_ScaleModes(),
    Scene: require_Scene(),
    Scenes: require_scene(),
    Structs: require_structs(),
    Textures: require_textures(),
    Tilemaps: require_tilemaps(),
    Time: require_time(),
    Tweens: require_tweens(),
    Utils: require_utils()
  };
  if (typeof FEATURE_SOUND) {
    Phaser6.Sound = require_sound();
  }
  if (typeof PLUGIN_CAMERA3D) {
    Phaser6.Cameras.Sprite3D = require_src();
    Phaser6.GameObjects.Sprite3D = require_Sprite3D();
    Phaser6.GameObjects.Factories.Sprite3D = require_Sprite3DFactory();
    Phaser6.GameObjects.Creators.Sprite3D = require_Sprite3DCreator();
  }
  if (typeof PLUGIN_FBINSTANT) {
    Phaser6.FacebookInstantGamesPlugin = require_FacebookInstantGamesPlugin();
  }
  Phaser6 = Extend(false, Phaser6, CONST);
  module2.exports = Phaser6;
  window.Phaser = Phaser6;
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS((exports2, module2) => {
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  (function() {
    var undefined2;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof window == "object" && window && window.Object === Object && window;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined2 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined2 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined2) {
          result = result === undefined2 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined2 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined2, symIterator = Symbol ? Symbol.iterator : undefined2, symToStringTag = Symbol ? Symbol.toStringTag : undefined2;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap && new WeakMap();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
      var symbolProto = Symbol ? Symbol.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined2;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined2;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined2 : result2;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined2 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash(),
          map: new (Map || ListCache)(),
          string: new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined2;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined2 : get(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined2) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined2) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined2) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined2 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined2 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined2, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined2 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined2;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined2 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined2 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined2;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return {criteria, index: ++index, value};
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
            if (newValue === undefined2) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined2;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined2 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
          if (newValue === undefined2) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined2 && other === undefined2) {
            return defaultValue;
          }
          if (value !== undefined2) {
            result2 = value;
          }
          if (other !== undefined2) {
            if (result2 === undefined2) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined2 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined2;
          }
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined2, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined2;
        }
        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined2 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined2;
        }
        var data = isBindKey ? undefined2 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined2, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined2 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined2, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined2;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined2;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return {start, end};
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined2, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined2 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined2;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined2;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined2;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined2 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return array && array.length ? baseUniq(array, undefined2, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined2, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined2
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined2);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined2) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
        return {done, value};
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined2;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined2
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined2 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined2 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined2;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined2;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined2;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined2;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined2) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined2;
        }
        function flush() {
          return timerId === undefined2 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined2) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined2) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined2 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        var result2 = customizer ? customizer(value, other) : undefined2;
        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined2;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined2;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined2, customDefaultsMerge);
        return apply(mergeWith, undefined2, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined2 : baseGet(object, path);
        return result2 === undefined2 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined2;
        }
        while (++index < length) {
          var value = object == null ? undefined2 : object[toKey(path[index])];
          if (value === undefined2) {
            index = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined2) {
          upper = lower;
          lower = undefined2;
        }
        if (upper !== undefined2) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined2) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined2) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined2;
        }
        if (floating === undefined2) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined2;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined2;
          }
        }
        if (lower === undefined2 && upper === undefined2) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined2) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string), n);
      }
      function replace() {
        var args = arguments, string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined2;
        }
        limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined2;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined2) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined2 : pattern;
        if (pattern === undefined2) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined2, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({func, args: arguments, thisArg: object});
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined2 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext2;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), {chain: false});
      lodash.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined2) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({func: thru, args: [interceptor], thisArg: undefined2});
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({name: methodName, func: lodashFunc});
        }
      });
      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined2
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _2 = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _2;
      define(function() {
        return _2;
      });
    } else if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(exports2);
});

// src/main.ts
var import_phaser5 = __toModule(require_phaser());

// src/scenes/SampleScene.js
var import_phaser4 = __toModule(require_phaser());

// src/gameObjects/pixel.js
var import_phaser = __toModule(require_phaser());
var Pixel = class extends import_phaser.default.GameObjects.Rectangle {
  constructor(scene, x, y, width, height, fillColor) {
    super(scene, x, y, width, height, fillColor);
    scene.physics.add.existing(this, true);
    this.body.collideWorldBounds = true;
    scene.add.existing(this);
  }
};
var pixel_default = Pixel;

// src/gameObjects/platform.js
var import_phaser2 = __toModule(require_phaser());
var Platform = class extends import_phaser2.default.GameObjects.Rectangle {
  constructor(scene, x, y, width, height, fillColor) {
    super(scene, x, y, width, height, fillColor);
    scene.physics.add.existing(this, true);
    this.body.collideWorldBounds = true;
    scene.add.existing(this);
  }
};
var platform_default = Platform;

// src/gameObjects/player.js
var import_phaser3 = __toModule(require_phaser());
var Player = class extends import_phaser3.default.GameObjects.Rectangle {
  constructor(scene, x, y, width, height, fillColor) {
    super(scene, x, y, width, height, fillColor);
    scene.physics.add.existing(this);
    this.body.collideWorldBounds = true;
    this.body.onWorldBounds = true;
    this.body.setBounce(0.85);
    scene.add.existing(this);
  }
};
var player_default = Player;

// src/scenes/SampleScene.js
var import_lodash = __toModule(require_lodash());
var SampleScene = class extends import_phaser4.default.Scene {
  platform;
  player;
  cursors;
  pixels = [];
  pixelSize;
  constructor() {
    super("hello-world");
  }
  init() {
    this.cursors = this.input.keyboard.createCursorKeys();
  }
  create() {
    this.add.text(this.centerX, this.height * 0.9, "Use '<' and '>' to move player").setOrigin(0.5);
    this.player = new player_default(this, this.centerX, 50, 20, 20, 16761182);
    this.createPixels();
    let forceDir = new import_phaser4.default.Math.Vector2();
    forceDir.set(import_phaser4.default.Math.Between(100, 200), import_phaser4.default.Math.Between(-100, -500));
    this.physics.add.collider(this.pixels, this.player, function(pixel, player) {
      if (player) {
        if (pixel.y - player.y <= player.displayWidth) {
          if (player.x > pixel.x)
            player.body.setAcceleration(forceDir.x, forceDir.y);
          else
            player.body.setAcceleration(-forceDir.x, forceDir.y);
          setTimeout(() => player.body.setAcceleration(0, 0), 250);
          setTimeout(() => player.body.setVelocityX(0), 1e3);
        }
        pixel.destroy();
      }
    });
    this.physics.world.on("worldbounds", this.onWorldBounds);
  }
  update() {
    if (this.cursors.left.isDown) {
      this.player.body.setVelocityX(-50);
    } else if (this.cursors.right.isDown) {
      this.player.body.setVelocityX(50);
    }
  }
  onWorldBounds() {
    this.player.body.setVelocity(0);
    this.player.body.setBounce(0);
  }
  createPixels() {
    const green = 65280;
    const red = 16711680;
    const black = 0;
    const watermelon = [
      "GRRRBRG",
      "GRBRRRG",
      "-GRRRG-",
      "--GGG--"
    ];
    this.pixelSize = this.width * 0.6 / watermelon[0].length;
    const startX = this.width * 0.2;
    for (let i = 0; i < watermelon.length; i++) {
      for (let j = 0; j < watermelon[i].length; j++) {
        if (watermelon[i][j] === "-")
          continue;
        let color;
        if (watermelon[i][j] === "G")
          color = green;
        if (watermelon[i][j] === "R")
          color = red;
        if (watermelon[i][j] === "B")
          color = black;
        const pixel = new pixel_default(this, startX + j * this.pixelSize, this.centerY + i * this.pixelSize, this.pixelSize, this.pixelSize, color);
        this.pixels.push(pixel);
      }
    }
  }
  get centerX() {
    return this.width / 2;
  }
  get centerY() {
    return this.height / 2;
  }
  get height() {
    return this.sys.game.canvas.height;
  }
  get width() {
    return this.sys.game.canvas.width;
  }
};
var SampleScene_default = SampleScene;

// src/main.ts
var Demo = class extends import_phaser5.default.Scene {
  constructor() {
    super("demo");
  }
  create() {
    this.add.text(200, 150, "Hello World!", {
      font: "40px Times New Roman",
      color: "#000000"
    });
  }
};
var config = {
  type: import_phaser5.default.AUTO,
  width: 400,
  height: 400,
  backgroundColor: 6668684,
  physics: {
    default: "arcade",
    arcade: {
      gravity: {y: 300}
    }
  },
  scene: SampleScene_default
};
var game = new import_phaser5.default.Game(config);
